<html>

<head>
<title>Tentative PicoBSD FAQ</title>

<META name="description" content="Tentative PicoBSD FAQ" >
<META name="keywords" content="PicoBSD" >
</head>



<body>

<p>&nbsp;</p>




<center>
<h2><hr>A PicoBSD User and Starter FAQ<hr></h2>
</center>


<p>
This page contains a PicoBSD user/starter FAQ
aimed primarily at first-time PicoBSD users
who intend to experiment with embedded systems.
PicoBSD is a version of FreeBSD built
in such a way that it
can be useful when you need
a ``real'' BSD and TCP/IP stack in a complete
system small
enough to fit on a floppy. 
Once booted, PicoBSD runs out of RAM-disk.
PicoBSD need not boot from a 
floppy; it can be used to boot from
flash devices, to create a single ``self-contained''
and ``self-extracting'' 
netbootable file , etc..
PicoBSD is suitable for many PC-based embedded OS
projects.
</p>

<p>
The primary purpose of this FAQ is to
describe
the PicoBSD build process 
under FreeBSD 4.3 Stable sufficiently
for a new user to build and use PicoBSD
for experimental embedded systems.
Under different versions of FreeBSD
these procedures may differ.
</p>

<br><br>

<center>

<b>Please bring errors and omissions to
my attention, thanks (see page bottom). 
You are welcome to copy this
document.</b><br><br>

</center>



<!================================================>
<hr>

<p>&sect;&nbsp;Operational tech notes</p>

<blockquote>
<a href="#intro">What is PicoBSD?</a><br><br>
Building PicoBSD:<br>
&nbsp;&nbsp;<a href="#quick_std">Quick! How do I build one of the standard PicoBSD systems?</a><br>
&nbsp;&nbsp;<a href="#quick">Quick! How do I build my own version of PicoBSD?</a><br>
&nbsp;&nbsp;<a href="#errors">What are some common errors and how do I deal with them?</a><br>
&nbsp;&nbsp;<a href="#clean">How do I clean-up after a PicoBSD build?</a><br>
&nbsp;&nbsp;<a href="#pwd">What is the default PicoBSD <code>root</code> password?</a><br>
</blockquote>

<p>&nbsp;</p>

<blockquote>
The <code>picobsd</code> build script:<br>
&nbsp;&nbsp;<a href="#cmd_line">What is the most current description of the <code>picobsd</code> script command?</a><br>
&nbsp;&nbsp;<a href="#syntax">What is the syntax of the <code>picobsd</code> script command?</a><br>
&nbsp;&nbsp;<a href="#menu">What can I do with the script's main interactive dialog menu?</a><br>
&nbsp;&nbsp;<a href="#free_vn">What <code>vn</code> device housekeeping should I do?</a><br>
</blockquote>


<p>&nbsp;</p>
<blockquote>
PicoBSD configuration:<br>
&nbsp;&nbsp;<a href="#files">What is in a PicoBSD configuration directory?</a><br>
&nbsp;&nbsp;<a href="#ref">What are the predefined ``reference'' configurations? Which one should I use?</a><br>
</blockquote>

<p>&nbsp;</p>
<blockquote>
Booting PicoBSD and editing boot scripts:<br>
&nbsp;&nbsp;<a href="#boot_scripts">How does the PicoBSD <code>rc</code> boot script work?</a><br>
&nbsp;&nbsp;<a href="#rc">How do I edit PicoBSD <code>/etc</code> scripts?</a><br>
&nbsp;&nbsp;<a href="#image_update">How do I edit or add new files to an existing floppy <em>image</em> file?</a><br>
</blockquote>


<p>&nbsp;</p>
<blockquote>
Using PicoBSD:<br>
&nbsp;&nbsp;<a href="#cmd_diffs">What are some command-line differences between FreeBSD and PicoBSD?</a><br>
&nbsp;&nbsp;<a href="#app">How do I include my own binary application in PicoBSD, that is, include them with the
``crunched'' applications in the <code>kernel</code> file?</a><br>
&nbsp;&nbsp;<a href="#link_static">How do I write a binary application that I can download individually
to PicoBSD without being ``crunched''?</a><br>
&nbsp;&nbsp;<a href="#size">How big is PicoBSD?</a><br>
&nbsp;&nbsp;<a href="#hdisks">Does PicoBSD support hard disks?</a><br>
&nbsp;&nbsp;<a href="#space">How do I see how much space is used in PicoBSD filesystems?</a><br>
</blockquote>


<p>&nbsp;</p>
<p>&sect;&nbsp;Requirements</p>

<blockquote>
<a href="#host">What ``host'' environment do I need to do embedded PicoBSD development?</a><br>
<a href="#versions">What versions of FreeBSD does <code>picobsd</code> run under?</a><br>
<a href="#get">How do I get PicoBSD (FreeBSD)?</a><br>
</blockquote>


<p>&nbsp;</p>
<p>&sect;&nbsp;Internals and customization</p>

<blockquote>
<a href="#script">How does the ``<code>picobsd</code>'' script work (how does all this happen)?</a><br>
<a href="#tinyware">What is <code>tinyware</code>?</a><br>
<a href="#oinit">What is <code>oinit</code>?</a><br>
<a href="#boot">Where do the PicoBSD boot files on the floppy come from?</a><br>
<a href="#makefile">What makefile invokes the actual PicoBSD kernel compile?</a><br>
<a href="#related">How can I build a number of related PicoBSD systems?</a><br>
<a href="#make_floppy">How do I make a floppy from an existing PicoBSD floppy image file?</a><br><br>

<a href="#comparing">How do I compare FreeBSD and PicoBSD kernel images?</a><br>
<a href="#find_str">How do I find a string in an ELF kernel section?</a><br>
</blockquote>


<p>&nbsp;</p>
<p>&sect;&nbsp;Older/historical/related tech notes</p>

<blockquote>
<a href="#older">What's an older way to build PicoBSD?</a><br>
<a href="#download">Can I download a bootable PicoBSD image?</a><br>
<a href="#small">Are there other ways to make small FreeBSD systems?</a><br>
</blockquote>



<p>&nbsp;</p>
<p>&sect;&nbsp;History and some non-tech notes</p>

<blockquote>
<a href="#maint">Who maintains PicoBSD?</a><br>
<a href="#developed">Who developed PicoBSD?</a><br>
<a href="#license">What type of license is PicoBSD under?</a><br>
<a href="#industrial">What should I know about industrial and embedded PCs?</a><br>
<a href="#academic">What are some university and academic groups using PicoBSD?</a><br><br>

<a href="#disadvantages">What are some disadvantages of PicoBSD?</a><br>
<a href="#advantages">What are some advantages of PicoBSD?</a><br>
</blockquote>

<p>&nbsp;</p>
<p>&sect;&nbsp;Documentation and Web resources</p>

<blockquote>
<a href="#man">What <code>man</code> pages should I read?</a><br>
<a href="#doc">Where is the PicoBSD documentation?</a><br>
<a href="#subscribe">How do I subscribe to the <code>freebsd-small@freebsd.org</code> mailing list?</a><br>
<a href="#small_archives">How do I browse the <code>freebsd-small@freebsd.org</code> mailing list archives?</a><br>
<a href="#web">What PicoBSD-related web resources are available?</a><br>
<a href="#web_app_doc">What are some academic references and web sites that describe research using PicoBSD?</a><br>
</blockquote>

<p>&nbsp;</p>

<p>
&nbsp;&sect;&nbsp;&nbsp;A few useful embedded PicoBSD procedures (most will also work on FreeBSD)
</p>

<blockquote>
<a href="#headless">How do I make PicoBSD on a PC run ``headless'' (without monitor and keyboard)?</a><br>
<a href="#server">How do I use PicoBSD to make a cheap diskless web server?</a><br>
<a href="#instrument">How do I use PicoBSD to make a cheap Internet-enabled instrument?</a><br>
<a href="#io">How do I directly access I/O devices from an application program
(use <code>in</code> and <code>out</code> instructions)?</a><br>

<a href="#msys">How do I put PicoBSD on a flash disk?</a><br>
<a href="#hdisk">How do I put PicoBSD on a hard disk?</a><br>
<a href="#poll_serial">How can I debug kernel code using polled serial I/O?</a><br>
</blockquote>

<p>&nbsp;</p>



<!================================================>
<a name="intro">
<hr>
<h1>What is PicoBSD?</h1>

<p>
PicoBSD is primarily just FreeBSD running from RAM-disk,
with all needed executable programs packed into a single executable 
ELF file in the RAM-disk. 
An entire PicoBSD system consists of a single bootable
kernel file, by default named <code>kernel</code>.
The initial contents of the RAM-disk, 
which include the entire root filesystem,
are stored inside
the <code>kernel</code> file. 
Because a PicoBSD system is usually compiled with 
a ``minimal'' FreeBSD configuration that only
includes needed features,
and because there is only a single
ELF application file, 
the <code>kernel</code> file can fit on a single floppy.
Additionally,
the <code>kernel</code> file is typically compressed 
and is then uncompressed on boot.
</p>

PicoBSD is useful when you need 
a single bootable file that is a complete 
``self-extracting'', preconfigured,
diskless FreeBSD system.
Example PicoBSD uses include 
single-floppy install systems, 
floppy-based ``rescue'' systems, 
netbootable systems, embedded systems that
boot from ROM or flashdisk, 
diskless routers/firewalls, diskless cluster nodes,
and the like.
PicoBSD is a great way to make cheap lab
systems out of old PC hardware.
</p>

<p>
PicoBSD is not <em>another</em> operating
system. PicoBSD is built from the same
sources as FreeBSD. 
PicoBSD is built entirely using standard tools
and utilities available under FreeBSD.
The normal FreeBSD procedure to compile a
kernel is wrapped by a <code>picobsd</code>
script which builds a so-called <em>crunched</em>
application binary that contains all required 
executable application programs.
The <code>picobsd</code> script builds
a root file system image that includes the crunched
applications and all required startup
scripts and configuration files.
It then inserts the file system image
into the <code>kernel</code> file itself.
</p>

<p>
A PicoBSD <em>build</em> is driven by a 
private configuration directory which contains a 
slightly embellished FreeBSD kernel configuration
file named <code>PICOBSD</code>.
A number of other
files in the configuration directory specify device
node names, desired filesystem directory structure,
script files, and the executable files to be included in
the <code>kernel</code>. The build itself 
is driven by the 
<a href="file:/usr/src/release/picobsd/build/picobsd"><code>picobsd</code></a> master script.
The <code>picobsd</code> script copies the
<code>PICOBSD</code> configuration file to the 
configuration directory
normally used for FreeBSD x86 kernel <a href="file:/usr/src/sys/compile">compiles</a>,
namely 
<a href="file:/usr/src/sys/i386/conf">
<code>/usr/src/sys/i386/conf</code></a>.
(This document assumes the FreeBSD source tree has
been installed in <code>/usr</code>, if yours is
located elsewhere, adjust accordingly.)
</p>

<p>
The <code>picobsd</code> script is effectively the
definition of PicoBSD. It is located at:
</p>

<p>
<a href="file:/usr/src/release/picobsd/build/picobsd"><code>/usr/src/release/picobsd/build/picobsd</code></a>
</p>

<p>
The FreeBSD 
<a href="http://www.FreeBSD.org/cgi/man.cgi?query=crunchgen&sektion=1"><code>crunchgen</code></a>
program does the  ``crunch'' of all application object files;
it essentially relabels the <code>main()</code>
entry points in all the application's object files
and creates a 
single application <code>main()</code> that dispatches
to the required program based on the name by which
the program is invoked. All object files are 
linked together to produce a single ELF executable file.
</p>

<p>
Virtual filesystems are created using the FreeBSD <code>vn</code>
(Virtual Node)
driver.
The <code>vn</code> driver
enables a file to be treated as a device (you can then
<code>mount</code> a suitable initialized file).
The filesystem created by the <code>picobsd</code> script
contains a root directory tree and files
as specified by an <code>mtree</code> configuration
file and a directory
tree rooted in the user's private configuration directory. This
virtual filesystem image is
copied into a reserved space in the <code>kernel</code>
image file.
</p>

<p>
After the <code>kernel</code> file is created, a <em>second</em> filesystem
is created
on a virtual device file
named ``<code>picobsd.bin</code>''. 
This file corresponds to a floppy device image. The <code>kernel</code>
file is compressed and placed in this filesystem, 
bootblocks are copied to the floppy image, and the entire
floppy image is then physically copied to a floppy.
</p>

<p>
The FreeBSD boot program (which is really a very
small operating system in it's own right) simply scans the root
directory of the device it boots from searching for
a file named <code>kernel</code> (or a file of another
name, if so indicated by the user entering a filename
in response to the boot prompt's ``count-down''). This
is the file that is loaded (and uncompressed, if necessary).
This process is entirely driven by the kernel's filename (there are
no hard-coded ``magic pointers'' to the code of
the kernel to be
loaded and started, although there are hard-coded pointers
to the boot system's code).
</p>

<p>
A number of predefined ``private'' PicoBSD configuration
directories are provided which build <em>standard</em>
configurations of PicoBSD and serve as examples, templates,
and starting points. In this document, these are called
<em>reference</em> configurations and <em>reference</em> 
directories. These directories
are used
for <em>reference</em> builds, and produce
<em>reference</em> PicoBSD systems.
</p>


<p>
In practice, PicoBSD is often used as a starting point
for forking your own custom embedded system
projects. That is, rather
than simply deploying the predefined standard reference
configurations, it may well be that
most serious users of PicoBSD historically
have been software engineers who have a valid
reason to fork their own unique embedded system
code-base.
This can be a very reasonable thing to do 
because commercial embedded systems often have very 
long product lifecycles (decades) while
potentially requiring maintenance at any level during
the entire deployment of the product.
The entire PicoBSD environment is flavored in many ways
by this expectation. 
</p>

<p>
There have been numerous
custom variations of PicoBSD, and variations on this entire
scheme. For instance, you could have more than one file of
crunched applications, putting each such file on a
seperate floppy image 
and distributing your system on multiple floppies.
</p>



<p>&nbsp;</p>
<!================================================>
<a name="quick_std">
<hr>
<h1>Quick! How do I build one of the standard PicoBSD systems?</h1>

<p>&nbsp;</p>

<p>
The PicoBSD sources in 
<a href="file:/usr/src/release/picobsd">/usr/src/release/picobsd</a>
contain a number
of ``preconfigured'' PicoBSD configurations.
These configurations
each correspond to an existing  reference configuration directory.
The current reference directories are 
<a href="file:/usr/src/release/picobsd/bridge"><code>bridge</code></a>,
<a href="file:/usr/src/release/picobsd/custom"><code>custom</code></a>, 
<a href="file:/usr/src/release/picobsd/net"><code>net</code></a>, 
<a href="file:/usr/src/release/picobsd/dial"><code>dial</code></a>, 
<a href="file:/usr/src/release/picobsd/install"><code>install</code></a>, 
<a href="file:/usr/src/release/picobsd/isp"><code>isp</code></a>, 
and
<a href="file:/usr/src/release/picobsd/router"><code>router</code></a>. 
These may not work ``as-is'', so treat them
as starter kits (these reference configurations are, however,
maintained, so notify the 
``<code><a href="mailto:freebsd-small@freebsd.org">freebsd-small@freebsd.org</a></code>''
mailing list if you encounter a problem).
</p>

<p>&nbsp;</p>
<p>
&nbsp;*&nbsp;&nbsp;  Assure you are running 
a version of FreeBSD 4.3 Stable
that includes the
<code>vn</code> device. Check the
current system's kernel configuration file for:
</p>

<blockquote>
<p>
<code>
pseudo-device vn
</code>
</p>


<p>
You may have to recompile the FreeBSD kernel
and possibly rebuild the ``<code>/dev/vn*</code>'' device
nodes (Use <code>MAKEDEV</code>. This is normally not required.)
</p>
</blockquote>

<p>
&nbsp;*&nbsp;&nbsp;  Verify that you have a free <code>vn</code> device
using:
</p>

<blockquote>
<blockquote>
<code>
#mount 
</code>
</blockquote>

<p>
If you see a mounted filesystem of the form
``<code>/dev/vn0c on /tmp/picobsd.c2OlSJv7sk</code>'', it
is likely that a previous build of <code>picobsd</code>
has failed. See the
<a href="#free_vn"> section on freeing  a <code>vn</code> device 
that has been left in an in-use state</a>.
</p>

</blockquote>

<p>
&nbsp;*&nbsp;&nbsp;  You will need a formatted blank floppy for a standard PicoBSD build.
Insert the floppy in the drive, but do not mount the floppy.
</p>

<p>
&nbsp;*&nbsp;&nbsp; Select which configuration you want to build.
The attributes of the various configurations are explained
in more detail in the 
<a href="#ref">
section that discusses the predefined reference configurations</a>.
</p>



<p>
&nbsp;*&nbsp;&nbsp; Copy the PicoBSD build script
<a href="file:/usr/src/release/picobsd/build/picobsd">
<code>/usr/src/release/picobsd/build/picobsd</code>
</a>
into your path, for instance, into
<code>/usr/bin</code> or <code>/usr/local/bin</code>:
</p>

<blockquote>
<p>
<code><pre>
#su
#cp /usr/src/release/picobsd/build/picobsd /usr/local/sbin
#rehash
</pre>
</code>
</p>

<p>Obviously, you only need to do this step once.</p>


</blockquote><br>




<p>
&nbsp;*&nbsp;&nbsp; Build your selected configuration. 
For instance, to build the 
PicoBSD <code>router</code> reference system
located in 
<a href="file:/usr/src/release/picobsd/router">/usr/src/release/picobsd/router</a>, 
do the following in the directory that you want to become
the ``root'' of your PicoBSD work:
</p>

<blockquote>
<p>
<code>
#su<br>
#picobsd router<br>
</code>
</p>
</blockquote><br>

<blockquote>
<p>
You have to be root to run the <code>picobsd</code>
script.
At the start of the script's execution, you will
be prompted by a dialog menu. Hit return to continue.
A FreeBSD kernel-build will then occur, followed
by object file crunching. Finally a second menu
will appear.
Assure the floppy is physically inserted and hit return to write the
floppy with a bootable image. 
</p>
</blockquote>

<p>
&nbsp;*&nbsp;&nbsp; Take the floppy to
the system on which you want to run PicoBSD, and
boot the floppy (or reboot the running system,
if you want to simply bring up a sample PicoBSD).
You do not have to <code>umount</code> the floppy.
Be sure to check the machine's
BIOS settings and assure that it is
set to boot from the floppy.
</p>

<p>&nbsp;</p>
<p>
That's it...
After a successful PicoBSD build, in addition
to putting a bootable image on the floppy, there
will be a bootable file named 
<code>kernel</code> in the build directory
located in the directory in which the <code>picobsd</code>
script was run.
For instance, if a <code>router</code>
configuration build was done, 
the directory  
<code>build_dir-router</code> will exist
in the
directory from which you ran <code>picobsd</code>.
A binary image of the bootable floppy, named ``<code>picobsd.bin</code>'',
 will also exist in this <code>build_dir-router</code>
directory. The complete directory name
depends on the name of your configuration 
(in this case, <code>router</code>).
If you <code>[Cancel]</code> from the last menu (use <code>Tab</code>
to select the <code>[Cancel]</code> button and then press <code>Enter</code>),
the <code>kernel</code> and ``<code>picobsd.bin</code>''  files will both
be created but the floppy will not be written.
</p>



<p>&nbsp;</p>
<!================================================>
<a name="quick">
<hr>
<h1>Quick! How do I build my own version of PicoBSD?</h1>

<p>&nbsp;</p>

<p>
&nbsp;&sect;&nbsp;&nbsp; <b>Host Requirements.</b>
</p>

<p>
&nbsp;*&nbsp;&nbsp; Assure you are running 
a version of FreeBSD 4.3 Stable
that includes the
<code>vn</code> device. Check the
current system's kernel configuration file for:
</p>

<blockquote>
<p>
<code>
pseudo-device vn
</code>
</p>

<p>
You may have to recompile the FreeBSD kernel
and possibly rebuild the ``<code>/dev/vn*</code>'' device
nodes (Use <code>MAKEDEV</code>. This is normally not required.)
</p>
</blockquote>


<p>
&nbsp;*&nbsp;&nbsp;  Verify that you have a free <code>vn</code> device
using:
</p>

<blockquote>
<blockquote>
<code>
#mount 
</code>
</blockquote>

<p>
If you see a mounted filesystem of the form
``<code>/dev/vn0c on /tmp/picobsd.c2OlSJv7sk</code>'', it
is likely that a previous build of <code>picobsd</code>
has failed. See the
<a href="#free_vn"> section on freeing  a <code>vn</code> device 
that has been left in an in-use state</a>.
</p>

</blockquote>


<p>&nbsp;</p>
<p>
&nbsp;&sect;&nbsp;&nbsp; <b>Assure the <code>picobsd</code> script is in your path.</b>
</p>


<p>
Copy the PicoBSD build script
<a href="file:/usr/src/release/picobsd/build/picobsd">
<code>/usr/src/release/picobsd/build/picobsd</code>
</a>
into your path, for instance, into
<code>/usr/bin</code> or <code>/usr/local/bin</code>:
</p>

<blockquote>
<p>
<code>
#su<br>
#cp /usr/src/release/picobsd/build/picobsd /usr/local/sbin<br>
#rehash<br>
</code>
</p>
</blockquote>



<p>&nbsp;</p>
<p>
&nbsp;&sect;&nbsp;&nbsp; <b>Create your own PicoBSD configuration directory.</b>
</p>

<p>
To work with your own configuration of 
PicoBSD, you need your own private configuration directory.
Using FreeBSD 4.3 and later versions, this ``config'' directory
can be anywhere. In previous versions, you created this directory
as root in 
<a href="file:/usr/src/release/picobsd">/usr/src/release/picobsd</a>.
You can still use this older style.
The remainder of this section assumes a post-4.3 build. See the
<a href="#older">following section</a> for pre-4.3 instructions.
</p>


<p>
Create your new configuration directory somewhere with the
name you want to give your custom PicoBSD configuration.
It is useful to base the initial contents of 
this configuration directory on one of the
standard reference directories.
For instance, to create a configuration directory named 
<code>mysys</code>, based on the
<code>bridge</code> reference configuration,
use:
</p>

<blockquote>
<p>
<code>
#cp -R /usr/src/release/picobsd/bridge mysys
</code>
</p>
</blockquote>


<p>
The reference configurations are directories
located in 
<a href="file:/usr/src/release/picobsd">
<code>/usr/src/release/picobsd</code></a>.
The current reference configurations are 
<a href="file:/usr/src/release/picobsd/bridge"><code>bridge</code></a>,
<a href="file:/usr/src/release/picobsd/custom"><code>custom</code></a>, 
<a href="file:/usr/src/release/picobsd/net"><code>net</code></a>, 
<a href="file:/usr/src/release/picobsd/dial"><code>dial</code></a>, 
<a href="file:/usr/src/release/picobsd/install"><code>install</code></a>, 
<a href="file:/usr/src/release/picobsd/isp"><code>isp</code></a>, 
and
<a href="file:/usr/src/release/picobsd/router"><code>router</code></a>. 
These may not work ``as-is'', so treat them
as starter kits (these reference configurations are, however,
maintained, so notify the 
``<code><a href="mailto:freebsd-small@freebsd.org">freebsd-small@freebsd.org</a></code>''
mailing list if you encounter a problem).
</p>


<p>&nbsp;</p>
<p>
&nbsp;&sect;&nbsp;&nbsp; <b>Build PicoBSD using the <code>picobsd</code> script.</b>
</p>

<p>
Before modifying your initial configuration, you may want
to do a test-build with it as-is.
</p>

<p>
To do a complete PicoBSD build, you need a formatted
and verified floppy. Assure that the floppy device (<code>/dev/fd0c</code>)
is <em>not</em> mounted, as  the script writes ``raw'' to
the floppy using <code>dd</code>. 
You have to be root to run the <code>picobsd</code>
script.
</p>

<p>
Assume you have created a work directory that you want to make the
``root'' of your PicoBSD work. In this directory you have created
a directory called <code>mysys</code> that contains a copy of one
of the standard PicoBSD configurations. To build your <code>mysys</code>
configuration, <code>cd</code> to the work directory and
do the following:
</p>

<blockquote>
<p>
<code>
<pre>
#su
#picobsd mysys
</pre>
</code>
</p>
</blockquote>

<p>
At the start of the script's execution, you will
be prompted by a dialog menu. Hit return to continue.
A FreeBSD kernel-build will then occur, followed
by object file crunching. Finally a second menu
will appear.
Insert a floppy and hit return to write the
floppy with a bootable image. Take the floppy to
the system on which you want to run PicoBSD, and
boot the floppy (or reboot the running system).
Be sure to check the machine's
BIOS settings and assure that it is
set to boot from the floppy.
</p>




<p>
After the PicoBSD script completes,
the floppy contains a mountable and bootable filesystem.
You might want to mount it for verification.
Once PicoBSD has booted from the floppy on the
target machine and completed
its <code>rc</code> boot script, the floppy will
<em>not</em> be mounted. On 
the reference systems, you can interactively mount the
floppy when PicoBSD is running on the target.
</p>



<p>
Results of the example build are left in the 
``<code>./build_dir-mysys</code>''
directory automatically created in the directory in which
you ran <code>picobsd</code>.
After a successful PicoBSD build, in addition
to putting a bootable image on the floppy, there
will be a bootable file named 
<code>kernel</code> in this build directory.
A binary image of the bootable floppy, named ``<code>picobsd.bin</code>'',
 will also exist in this build
directory. The complete name of the build directory 
depends on the name of your configuration directory
(in this case, <code>mysys</code>).
If you <code>[Cancel]</code> from the last menu (use <code>Tab</code>
to select the <code>[Cancel]</code> button and then press <code>Enter</code>),
the <code>kernel</code> and ``<code>picobsd.bin</code>''  files will both
be created but the floppy will not be written.
</p>

<p>
The <code>picobsd</code> script puts all executables and an image of a
RAM-based root filesystem into the single <code>kernel</code>
file. The <code>kernel</code> file in the <em>floppy image</em>
is compressed (the kernel will be
uncompressed at boot-time).
The <code>kernel</code> file in the <code>build_dir</code>
directory is <em>not</em> compressed.
You can explicitly compress the <code>kernel</code>
file using the 
<a href="http://www.FreeBSD.org/cgi/man.cgi?query=kgzip&sektion=8"><code>kgzip</code></a> utility.
</p>


<p>
The <code>picobsd</code> script looks for a configuration directory
with a name that matches its argument.
It first looks in the current directory.
It then looks for a directory with matching name in
``<code>$PICO_TREE</code>''.
If undefined, <code>$PICO_TREE</code>'' defaults to 
``<code>/usr/src/release/picobsd/</code>''.
For example, ``<code>picobsd mysys</code>'' would first look
for ``<code>./mysys</code>'', then for 
``<code>/usr/src/release/picobsd/mysys</code>''.
Once a directory is found, it is assumed to be a PicoBSD
configuration directory if a <code>PICOBSD</code> configuration file 
is present.
</p>



<p>&nbsp;</p>
<p>
&sect; <b>Customize your PicoBSD configuration.</b>
</p>

<p>
In your private configuration directory:
</p>

<p>
 &nbsp;*&nbsp;&nbsp; Edit the <code>PICOBSD</code> kernel configuration
 file to contain
your desired FreeBSD kernel options and device
support.
</p>

<p>
 &nbsp;*&nbsp;&nbsp;  In
file <code>config</code>, add your desired 
<code>/dev</code> device nodes.
</p>

<p>
 &nbsp;*&nbsp;&nbsp; In file ``<code>crunch.conf</code>'' specify
the executables and libraries that you
want to include, and the ``link names'' that you want
to assign your executables.
You also need to specify the directories containing your
binary program <code>Makefile</code>s.
</p>

<p>
 &nbsp;*&nbsp;&nbsp; Put the script files to include in  your system
in a
directory tree named
``<code>floppy.tree</code>''
rooted in your configuration directory.
You may have to create this directory.
You can also put in your configuration directory
a file called ``<code>floppy.tree.exclude</code>'' 
which specifies what files are to
be eliminated
from the default in
``<a href="file:/usr/src/release/picobsd/floppy.tree">
/usr/src/release/picobsd/floppy.tree</a>''.
</p>


<a name="in_mfs">
<p><b>NOTE:</b> The script files 
typically included in the 
``<a href="file:/usr/src/release/picobsd/floppy.tree"><code>floppy.tree</code></a>''
have traditionally been those files that you might want to edit
after your system is operational. If
you want to edit all these files on the floppy, you do <em>not</em>
want these files built into the single <code>kernel</code> file,
but rather want to put them in a <code>/etc</code>
directory tree on the floppy. The files inside the compressed
kernel image on the floppy cannot readily be accessed directly 
by standard tools (a copy of these file
 <em>can</em> be edited on the RAM-disk
when the system is running, which means you can then copy them
to a directory on the floppy).
The current default behavior of the
<code>picobsd</code> script is <em>not</em> to put the
``<code>floppy.tree</code>'' on the floppy, but
rather to put all the contents of the ``<code>floppy.tree</code>''
into the <code>kernel</code> file, and then
use a PicoBSD <code>rc</code> boot script that copies, prior
to most boot script processing,
any files in <code>/etc</code> on the floppy over the files
in <code>/etc</code> in the memory filesystem. 
In this scheme there initially 
is no <code>/etc</code> directory on the floppy. To change
this default behavior and put the ``<code>floppy.tree</code>'' on the floppy,
edit the <code>picobsd</code> script and, near the top, change
the first line in <code>init_vars()</code> from:
</p>

<p>
<code>
    INCLUDE_FLOPPY_IN_MFS="yes"
</code>
</p>

<p>
 To:
</p>

<p>
<code>
    INCLUDE_FLOPPY_IN_MFS="no"
</code>
</p>

<p>
The default ``<code>floppy.tree</code>'' is located in the
``<a href="file:/usr/src/release/picobsd/floppy.tree">
<code>/usr/src/release/picobsd/floppy.tree</code></a>'' directory.
This tree forms the ``base'' floppy script collection. Files that
you define in the ``<code>floppy.tree</code>'' directory within your private
configuration directory will override or extend the base collection.
You do not need a private ``<code>floppy.tree</code>'' directory.
You can exclude files in the base collection using a
file in your configuration directory named ``<code>floppy.tree.exclude</code>''.
</p>


<p>
 &nbsp;*&nbsp;&nbsp; The files included in the  
<a href="file:/usr/src/release/picobsd/mfs_tree">
<code>/usr/src/release/picobsd/mfs_tree</code>
</a>
directory tree
are the initial files included in the root file system built into the
<code>kernel</code> file. Note that if the ``<code>floppy.tree</code>''
is included in the MFS, as described above, floppy files
will override files with the same name in <code>mfs_tree</code>.
</p>

<p>
You can specify a complete directory tree structure for the
root file system using a
``<code>mfs.mtree</code>'' file in your configuration directory
This is optional, and 
can be used to create empty directories in addition
to those populated by <code>mfs_tree</code> and
``<code>floppy.tree</code>'' files.
</p>

<p>
After customization, rebuild your PicoBSD system
as described in the previous section on building
PicoBSD using the <code>picobsd</code> script.
</p>















<p>&nbsp;</p>
<!================================================>
<a name="errors">
<hr>
<h1>What are some common errors and how do I deal with them?</h1>

<p>
After most errors that abort the <code>picobsd</code> script,
it is usually worth completely cleaning up the build
that was aborted as described in the section
``<a href="#clean">How do I clean-up after a PicoBSD build?</a>''.
Also, use <code>mount</code> to check if any <code>vn</code>
pseudo-devices are still mounted and configured.
</p>

<p>
Some common errors are:
</p>


<!---------------------------------------->
<p>&nbsp;</p>
<hr>
<p>
&nbsp;&sect;&nbsp;&nbsp;  After a kernel link in the <code>picobsd</code> script,
 an error of the following form
appears:
</p>

<blockquote>
<b>
<p>
<code>
disklabel: /dev/vn1: No such file or directory<br>
---> fail: Error <4> error code <mfs_disklabel><br>
</code>
</p>
</b>
</blockquote>

</p>
If the host FreeBSD system contains the <code>vn</code> pseudo-device,
this typically means that the prior execution of <code>picobsd</code>
failed, leaving the <code>vn0</code> device in a mounted state.
</p>

<p>
<a name="free_vn">
<b><code>vn</code> device house-cleaning:</b>
</p>

<p>
Check the mount-status of the <code>vn</code> device(s)
using <code>mount</code>.
If a <code>vn</code> device has been left
in a mounted (and configured) state, 
you will see something similar to:
</p>

<blockquote>
<code>
/dev/vn0c on /var/vartmp/picobsd.c2OlSJv7sk (ufs, local)
</code>
</blockquote>

<p>
Manually dismount and unconfigure the
offending <code>vn</code> device:
</p>

<blockquote>
<p>
<code>
#mount<br>
#umount /dev/vn0c<br>
#vnconfig -u vn0
</code>
</p>
</blockquote>

<p>
It is a good idea to 
<a href="#clean">clean up the remains</a>
of the PicoBSD build that died before 
attempting another <code>picobsd</code> build. 
When is starts, the <code>picobsd</code>
script tries to locate an unused <code>vn</code> device,
which is why in the above example error it complains about <code>vn1</code> even
though it was <code>vn0</code> that was not properly
unmounted and unconfigured (the system on which this error
occurred only had a single <code>vn</code> device
configured).
</p>

<p>
You should check the <code>vn</code> devices in this manner
whenever the <code>picobsd</code> script fails for any reason.

</p>


<!---------------------------------------->
<p>&nbsp;</p>
<p>&nbsp;</p>
<hr>
<p>
&nbsp;&sect;&nbsp;&nbsp; If an error message such as the following occurs
that involves a binary included in
PicoBSD, the pathname in the relevant ``<code>crunch.conf</code>''
referencing the binary file  
is probably inconsistent
with the real directory structure:
</p>

<blockquote>
<b>
<p>
<code>
  `../../tinyware' is not a directory, skipping it
</code>
</p>
</b>
</blockquote>

<p>
 Perhaps things
have moved. Perhaps the ``<code>crunch.conf</code>'' file
assumes it is in the <code>/usr/src/release/picobsd</code>
tree. The fix is to set the path
correctly. An absolute path for your current
development system should work.
</p>



<!---------------------------------------->
<p>&nbsp;</p>
<p>&nbsp;</p>
<hr>
<p>
&nbsp;&sect;&nbsp;&nbsp; The build displays the
following error toward the end of the script's execution:
</p>

<blockquote>
<b>
<p>
<code>
MFS filesystem signature not found in kernel
</code>
</p>
</b>
</blockquote>

<p>
The MFS filesystem image is too big to fit into the kernel.
The size of the MFS is specified either
interactively via the main dialog or as the first argument to the
<code>#PICOBSD</code> comment in the relevant <code>PICOBSD</code> 
kernel configuration file.
The comment above the argument line 
in the <code>#PIOCBSD</code> file indicates
that this argument is named 
``<code>dev_sz</code>''.
When this argument changes, you need to also change the 
kernel <code>MD_ROOT_SIZE</code>
option in the 
<code>PICOBSD</code> file to have the same value. Indeed, a mismatch
between these values may be the cause of the error. A typical 
option line is:
</p>

<blockquote>
<p>
<code>
options MD_ROOT_SIZE=2200      # same as def_sz
</code>
</p>
</blockquote>

<p>
This error may also indicate a missing
``<code>options MD_ROOT_SIZE</code>'' statement or a
<code>MD_ROOT_SIZE</code> parse
error, resulting in no MFS space at all being 
configured into the kernel.
</p>

<!---------------------------------------->
<p>&nbsp;</p>
<p>&nbsp;</p>
<hr>
<p>
&nbsp;&sect;&nbsp;&nbsp; An error message is displayed on
the console at boot-time (or spotted later by <code>dmesg</code>) with
the form:

<blockquote>
<b>
<p>
<code>
 pid 8 (cp), uid 0 on /: out of inodes
</code>
</p>
</b>
</blockquote>

There are not enough inodes in the RAM-based MFS. Files are
likely being copied from various <code>/etc</code> override
directories into the MFS. Since each file requires an inode
(Information Node) from the fixed-sized inode space, 
when you are out of inodes you cannot create more files
(even if space still exists on the device).
</p>

<p>
Unless you are trying to include way to many files, you can often fix this
by increasing the size of the static inode array in the MFS. 
This
will <em>decrease</em> the amount of available free space that 
remains in the MFS for file data. 
</p>

<p>
You can increase the number of inodes
either interactively, via the first <code>picobsd</code>
menu, or by editing the <code>PICOBSD</code> file in the
relevant configuration directory and changing the third argument
in the <code>#PicoBSD</code> line (the comment on the previous line
of the <code>PICOBSD</code> file
indicates this is named the ``<code>MFS_inodes</code>'' argument).
The fraction of space dedicated 
in a filesystem to inodes instead of data is ultimately specified as an argument
to <code>newfs</code>, the utility that creates a new filesystem.
The form of this argument is not a direct specifier, but rather indicates
the number of bytes per inode, which is roughly the average file size
you expect in the file system. Thus, to increase the number of 
inodes, you should <em>decrease</em> the existing <code>MFS_inodes</code>
value. 
</p>

<p>
 The layout of the MFS filesystem is reported by <code>picobsd</code>
near the end of the script before the second menu. It has an appearance
such as the following:
</p>

<p>
<code>
<pre>
Filesystem  1K-blocks     Used    Avail Capacity iused   ifree  %iused  Mounted on
/dev/vn0c        2103     1600      503    76%     308     202    60%   /var/vartmp/picobsd.9QsMbDpD3K
</pre>
</code>
</p>

<p>
This indicates that 308 inodes are in use and 202 are free, so
<code>newfs</code> calculated that it should allocate 510 inodes. Again,
you only indirectly control this allocation, but a little experimentation
will result in your ability to partition the filesystem as you desire.
</p>




<!---------------------------------------->
<p>&nbsp;</p>
<p>&nbsp;</p>
<hr>
<p>
&nbsp;&sect;&nbsp;&nbsp; You <code>ftp</code> a binary program to a PicoBSD system,
try to run it, and get the error message:
</p>

<blockquote>
<b>
<pre>
ELF interpreter /usr/libexec/ld-elf.so.1 not found
Abort trap
</pre>
</b>
</blockquote>

<p>&nbsp;</p>

<p>
The program was linked assuming that it could link to
a loaded library at run-time using dynamic linking, 
but the specified library (<code>ld-elf.so.1</code>) was not found. 
See the section on 
<a href="#link_static">writing a statically-linked application for
PicoBSD</a>.
</p>




<!---------------------------------------->
<p>&nbsp;</p>
<p>&nbsp;</p>
<hr>
<p>
&nbsp;&sect;&nbsp;&nbsp; The first thing PicoBSD prints
when it boots is:
</p>

<blockquote>
<b>
<p>
<code>
 No /boot/loader
</code>
</p>
</b>
</blockquote>

<p>
Is this an error? No. This indicates that the interactive
FICL loader is not present (by design). 
The bootstrap will procede to directly
boot the <code>/kernel</code> PicoBSD file.
</p>



<!---------------------------------------->
<p>&nbsp;</p>
<p>&nbsp;</p>
<hr>
<p>
&nbsp;&sect;&nbsp;&nbsp; Attempting to <code>mount</code> a PicoBSD floppy 
on PicoBSD or FreeBSD always produces an 
error (on any machine) similar to:
</p>

<blockquote>
<b>
<p>
<code>
 mount: /dev/fd0c: Operation not permitted
</code>
</p>
</b>
</blockquote>

<p>
If this message occurs with a PicoBSD floppy whenever you attempt 
to <code>mount</code> the floppy,
the floppy has likely, at some point, either (1) been mounted when
it was physically removed from a drive 
without a <code>umount</code> being performed,
or (2) it was mounted when the
power was turned off. Use the <code>dmesg</code> command
to display the system error log and search for a message
such as the following (the <code>/mnt</code> will correspond to
whatever directory you tried to use as a mount-point for the floppy):
</p>


<blockquote>
<b>
<p>
<code>
WARNING: R/W mount of /mnt denied.  Filesystem is not clean - run fsck
</code>
</p>
</b>
</blockquote>

 
<p>
Either run <code>fsck</code> against the floppy (``<code>fsck /dev/fd0</code>'')
or, if you are
absolutely certain of the machine from which you just ``popped'' it out
without unmounting, put the floppy back in the drive and <code>umount</code>
it before physically removing it again.
</p>


<p>
This is not a PicoBSD error per se, but can easily occur
when you are working with a PicoBSD floppy, for instance,
editing scripts or copying static applications.
Note that a FreeBSD-formatted *ix floppy ``knows'' if,
after being mounted,
it has been cleanly unmounted via a <code>umount</code>. 
</p>

<p>
Under PicoBSD, the boot floppy can be in this unmountable state, that is,
it may not be possible to mount the boot floppy if it was explicitly
mounted when
a power-off occured (or it was popped out and moved). 
This does not interfere with the ability
to boot the floppy, only the ability to mount it. Because
not all configurations include <code>fsck</code>, it may be necessary
to take the floppy to another FreeBSD or PicoBSD machine to run
<code>fsck</code>. The <code>router</code> and <code>net</code>
reference configurations <b>do not include <code>fsck</code></b>.
</p>



<p>&nbsp;</p>





<p>&nbsp;</p>
<!================================================>
<a name="clean">
<hr>
<h1>How do I clean-up after a PicoBSD build?</h1>
 
<p>
To completely clean up a PicoBSD build, for example,
after a reference build using ``<code>picobsd net</code>'',
do the following:
</p>

<blockquote>
<p>
 &nbsp;*&nbsp;&nbsp; <code>#cd /usr/src/sys/compile</code><br>
   and delete the <code>PICOBSD-net</code> kernel build directory.
</p>

<p>
  &nbsp;*&nbsp;&nbsp;   <code>#cd /usr/src/sys/i386/conf</code><br>
   and delete the <code>PICOBSD-net</code> kernel configuration file.
</p>

<p>
  &nbsp;*&nbsp;&nbsp;   <code>#cd /usr</code><br>
   and delete the <code>obj-pico</code>  directory.
</p>

<p>
  &nbsp;*&nbsp;&nbsp;  Go
to the directory containing your
<code>build_dir</code> directory,<br>
(for instance,
``<code>cd /usr/src/release/picobsd/build</code>'')<br>
   and delete the <code>build_dir-net</code> directory.
</p>

<p>
  &nbsp;*&nbsp;&nbsp;   <code>#cd /tmp</code><br>
   and delete any <code>picobsd.XXXXXXXXXX</code> (temporary
      name) directories.
   Also delete any <code>reply.XXXXXXXXXX</code> temporary file(s).
</p>

</blockquote>

<p>&nbsp;</p>


<p>
Note that only one <code>obj-pico</code> directory is created,
that is, versions are not created based on the
name of your configuration.
</p>



<p>&nbsp;</p><p>&nbsp;</p>
<!================================================>
<a name="pwd">
<hr>
<h1>What is the default PicoBSD <code>root</code> password?</h1>

<p>&nbsp;</p>
<p>
The default root password is ``<code>setup</code>''.
You should change this before you do a PicoBSD build.
</p>

<p>
Specify your accounts and passwords by directly editing
the relevant ``<code>etc/master.passwd</code>'' file.
Depending on your PicoBSD configuration tree, this
file could be in 
``<a href="file:/usr/src/release/picobsd/floppy.tree/etc/master.passwd">
<code>/usr/src/release/picobsd/floppy.tree/etc/master.passwd</code></a>'',
a ``<code>floppy.tree/etc/master.passwd</code>'' in your configuration
directory, or, also in your configuration directory,
a ``<code>floppy.tree.$SITE_NAME/etc/master.passwd</code>''
subconfiguration directory 
corresponding to your subconfiguration <code>$SITE_NAME</code>
(which is specified as the optional second argument to <code>picobsd</code>,
see the 
<a href="#syntax">section on the syntax of the <code>picobsd</code> command</a>).
</p>

<p>
You can change a password on a PicoBSD floppy using
the procedures described to
<a href="#rc">edit PicoBSD <code>/etc</code> scripts</a> or
to
<a href="#image_update">edit or add a file to 
an existing floppy image</a>.
</p>

<p>&nbsp;</p>




<p>&nbsp;</p>
<!================================================>
<a name="cmd_line">
<hr>
<h1>What is the most current description of the <code>picobsd</code> script command?</h1>

<p>&nbsp;</p>
<p>
The comments at the head of the <code>picobsd</code> script contain
the following:
</p>

<p>
<code>
<pre>
# picobsd [options] floppy_type site_name
#
# Where floppy_type is a directory where the picobsd config info
# is held, and ${floppy_type}/floppy.tree.${site_name} contains
# optional site-specific configuration.
#
# For Options, see the bottom of the file where the processing is
# done... so
#
# This script depends on the following files:
#
# in ${PICO_TREE} :
#   Makefile.conf       Makefile used to build the kernel
#   config              shell variables, sourced here.
#   mfs.mtree           mtree config file
#
#   floppy.tree/        files which go on the floppy
#   mfs_tree/           files which go onto the mfs
#
# in ${MY_TREE} :
#   PICOBSD             kernel config file
#   config              shell variables, sourced here.
#   crunch.conf         crunchgen configuration
#   floppy.tree.exclude files from floppy.tree/ which we do not need here.
#   floppy.tree/        local additions to the floppy.tree
#   floppy.tree.${site}/ same as above, site specific.
</pre>
</code>
</p>

<p>&nbsp;</p>
<p>
In the above, <code>${PICO_TREE}</code> is the root of your
PicoBSD source tree, for instance,
<a href="file:/usr/src/release/picobsd">
<code>/usr/src/release/picobsd</code></a>.
The <code>${MY_TREE}</code> directory is usually 
either one of the
reference configuration directories, such as
<a href="file:/usr/src/release/picobsd/router">
<code>/usr/src/release/picobsd/router</code></a>,
or your own private configuration directory, which
can be located anywhere. You do not explictly
set <code>${MY_TREE}</code>. The <code>picobsd</code>
script first looks for a directory with the same
name as it's <code>floppy_type</code> argument in
the directory from which you ran the script,
and then looks for a subdirectory with that
name in <code>${PICO_TREE}</code>, which defaults
to  ``<code>/usr/src/release/picobsd</code>''.
</p>




<p>&nbsp;</p>
<!================================================>
<a name="syntax">
<hr>
<h1>What is the syntax of the <code>picobsd</code> script command?</h1>

<p>&nbsp;</p>
<p>
The command syntax of the <code>picobsd</code> script is:
</p>

<blockquote>
<p>
<code>
 #picobsd [options] floppy_type [site_name]
</code>
</p>
</blockquote>

<p>
The <code>floppy_type</code> argument specifies
the name of an existing PicoBSD configuration directory.
The <code>picobsd</code> script will look for a directory with this name first in the current
directory and then in the directory
specified by the <code>$PICO_TREE</code> environment variable.
If you have not set this variable, it defaults to 
``<a href="file:/usr/src/release/picobsd/"><code>/usr/src/release/picobsd/</code></a>''.
</p>

<p>
The optional <code>site_name</code> argument specifies the name
of a ``subconfiguration'' within the configuration directory specified by
<code>floppy_type</code>. The subconfiguration will itself be a 
directory, with a name of the form ``<code>floppy.tree.$site_name</code>''.
This subconfiguration directory should contain a <code>/etc</code> directory
containing scripts and files which you want to replace those with
the same names in
the ``<code>floppy.tree/etc</code>'' directory in the same
configuration directory (that is, the directory corresponding
to <code>floppy_type</code>).
</p>

<p>
Thus, the command ``<code>picobsd my_486 old_isa_486</code>''
would first try to use the configuration directory ``<code>./my_486</code>''
and subconfiguration scripts in 
``<code>./my_486/floppy.tree.old_isa_486/etc</code>''.
If no ``<code>./my_486</code>'' configuration directory was found,
<code>picobsd</code> would try to use
<code>/usr/src/release/picobsd/my_486/</code> and
``<code>/usr/src/release/picobsd/my_486/floppy.tree.old_isa_486/etc</code>''.


<p>&nbsp;</p>
<p>
The command options are:
</p>

<blockquote>
<p>&nbsp;</p>
<p>
<b><code>--floppy_type n</code></b><br>
The size of the bootable floppy image is set to
``n'' KBytes. The default is 1440,
the size of  a standard 3.5 inch floppy.
</p>

<p>&nbsp;</p>
<p>
<b><code>-n</code></b><br>
Do <b>not</b> display the first interactive menu. 

The final interactive dialog, which prompts for permission
to write to the floppy <em>will</em> occur,
so this switch does not allow complete ``batch'' mode execution.
</p>

<p>&nbsp;</p>
<p>
<b><code>-clean</code></b><br>
Delete the <code>build_dir</code> directory before 
starting. This directory
will have a name of the form <code>build_dir-mysys</code>,
where <code>mysys</code> is the name of your PicoBSD configuration
directory, as specified by argument <code>floppy_type</code>.
</p>

<p>&nbsp;</p>
<p>
<b><code>-verbose</code></b><br>
This option makes the script enter a semi-interactive
trace mode. It produces various output displays as it
runs and
stops after each display until user confirmation is recieved.
This provides insight into the action taken by
the script at each major step.
</p>
</blockquote>


<p>&nbsp;</p>
Environment Variables are:

<p>&nbsp;</p>

<blockquote>
<p>
<b><code>$INCLUDE_FLOPPY_IN_MFS</b></code><br>
In addition to the command-line arguments, there is
an important environment variable set at the start of
the <code>picobsd</code> script.
This variable, ``<code>INCLUDE_FLOPPY_IN_MFS</code>'',
should be set to ``yes'' if you want the contents of your
``<code>floppy.tree</code>'' to be placed, gzipped, into the
<code>/fd</code> directory in the MFS filesystem (the RAM-filesystem)
built into the kernel. The files will be uncompressed and
copied to your RAM-based <code>/etc</code> directory at boot, that is,
they will be copied over the files originating in the 
<code>/usr/src/release/picobsd/mfs_tree/etc</code> directory.
If <code>INCLUDE_FLOPPY_IN_MFS</code> is not ``yes'', the
files in your floppy tree will be placed on the floppy
in <code>/etc</code>. From here they will also be copied
over the memory-resident <code>/etc</code>. Note that
even if you specify <code>INCLUDE_FLOPPY_IN_MFS="yes"</code>,
you can later create a <code>/etc</code> on your floppy
and put updated startup script files on the floppy. These
files will be copied into <code>/etc</code> before other
boot-time script processing occurs.
</p>

<p>
The default is <code>INCLUDE_FLOPPY_IN_MFS="yes"</code>.
</p>

<p>
<b><code>$SRC</code></b><br>
The location of your FreeBSD source tree.
</p>

<p>
<b><code>$OBJ</code></b><br>
The location of the object tree. This is
normally ``<a href="file:/usr/obj-pico"><code>/usr/obj-pico</code></a>''.
</p>

<p>
<b><code>$PICO_TREE</code></b><br>
The directory containing the <code>picobsd</code>
source tree. This includes the reference directory 
configurations, and the <code>build</code> directory
that contains the <code>picobsd</code> script.
This defaults to 
``<a href="file:/usr/src/release/picobsd"><code>/usr/src/release/picobsd</code></a>''.
</p>


<p>
<b><code>$FLOPPY_SIZE</b></code><br>
The size of the floppy image file in Kbytes.
This size should match the size of the device you
intend to write.
The <code>$FLOPPY_SIZE</code>
environment variable defaults
to 1440 Kbytes, the size of the most common 3.5 inch floppy.
The current <code>picobsd</code> script 
writes to a ``floppy device'' using a 
device node of ``<code>dev/rfd0.${FLOPPY_SIZE}</code>''.
</p>


</blockquote>


<p>&nbsp;</p>
<p>
Results:
</p>

<blockquote>
<p>
The principal outputs of the <code>picobsd</code> script are
(1) a bootable floppy, (2) an image of the floppy saved in file
``<code>picobsd.bin</code>'', and (3) a 
bootable <code>kernel</code> file. 
The two files are in the <code>build_dir-$floppy_type</code>
directory (which itself will be located in the directory
in which you executed the <code>picobsd</code> command).
</p>

<p>
Unless you change the <code>INCLUDE_FLOPPY_IN_MFS</code>
default, the floppy
and floppy image will only contain the bootable kernel file.
</p>

<p>If you <code>[Cancel]</code> out of the last menu dialog in
the <code>picobsd</code> script, the two files will be created,
but the ``<code>picobsd.bin</code>'' file will not be written to
the floppy, which is useful if you are booting the kernel over
a network, from flash, etc..
</p>
 
</blockquote>



<p>&nbsp;</p>
<!================================================>
<a name="menu">
<hr>
<h1>What can I do with the script's main interactive dialog menu?</h1>


<p>&nbsp;</p>
<p>
&nbsp;&sect;&nbsp;&nbsp; The initial dialog menu gives you the opportunity
to edit the relevant <code>PICOBSD</code> kernel configuration file
and the ``<code>crunch.conf</code>'' file that specifies the
binary executables to link into your kernel.
You can also configure the layout of the two 
filesystems constructed on virtual devices and select the
program you use as the ``init'' process (the process
ultimately responsible for activating all other
processes on the system).
</p>

<p>
The appearance of the menu (with typical defaults) is as follows:
</p>


<p>
<code>
<pre>
N  --> READY, build it <---
T  Type: my_486 name my_486
K  edit Kernel config file
E  Edit crunch.conf file
S  MFS Size: 2200kB
I  Init type: init
F  Floppy size: 1440kB
M  MFS bytes per inode: 5000
U  UFS bytes per inode: 32768
$  Site-info:
Q  Quit

[  OK  ]       Cancel 
</pre>   
</code>
</p>

<p>
You can highlight a line of the menu by using the
keyboard up-and-down arrows, or by pressing the
indicated letter (case insensitive). Invoke the
selected option by pressing Enter.
</p>

<p>
&nbsp;*&nbsp;&nbsp; If you select ``<code>N  --> READY, build it <---</code>'',
the build will proceed.
</p>

<p>
&nbsp;*&nbsp;&nbsp; If you select ``<code>T  Type: my_486 name my_486</code>'',
you will be presented with another dialog containing all
the configuration directories that the <code>picobsd</code>
script can find. Scroll through this dialog with the
up-and-down arrows to select the configuration you want
to build (or edit with the other menu options).
</p>

<p>
&nbsp;*&nbsp;&nbsp;Select ``<code>K  edit Kernel config file</code>''
to edit the <code>PICOBSD</code> kernel configruation file in 
the selected configuration directory.
</p>

<p>
&nbsp;*&nbsp;&nbsp;Select ``<code>E  Edit crunch.conf file</code>''
to edit the file that specifies the pathnames of the
executable program files you want to crunch into
your kernel, link names for these programs, required libraries, and the 
directories containing the program's <code>Makefile</code>s.
</p>

<p>
&nbsp;*&nbsp;&nbsp;Select ``<code>S  MFS Size: 2200kB</code>''
to specify the size of the MFS RAM-file system built into your kernel.
This has to be established by experience and should be as small
as possible. The dialog notes that typical ranges are
between 820 and 2500 KBytes.
Specifying this too large will result in the error message:
``<code>MFS filesystem signature not found in kernel</code>''.
This should be changed in conjunction with the
<code>MD_ROOT_SIZE</code> option in the <code>PICOBSD</code>
kernel config file.
</p>

<p>
&nbsp;*&nbsp;&nbsp;Select ``<code>I  Init type: init</code>''
to select the program to run as your ``init'' program (Process 1).
A dialog will appear which allows you to select the normal
FreeBSD <code>init</code> program, or the PicoBSD <code>oinit</code>
program in the 
<a href="file:/usr/src/release/picobsd/tinyware">
<code>/usr/src/release/picobsd/tinyware</code></a> collection.
The <code>oinit</code> program contains a small built-in shell
that can only handle simple command lines, not
the normal <code>sh</code> syntax. If <code>oinit</code> 
is used the
<a href="#rc">
technique of updating files 
in <code>/etc</code></a> <b>cannot be used</b>,
unless you write your own simple <code>etc/rc</code>
or ``<code>etc/oinit.rc</code>'' to do so (see the section
on <a href="#oinit">oinit</a>).
</p>

<p>
&nbsp;*&nbsp;&nbsp;Select ``<code>F  Floppy size: 1440kB</code>''
to select the size of the ``<code>picobsd.bin</code>'' image that
is produced. A dialog will appear with 4 standard sizes that
correspond to various devices (the largest is 4 Mbytes).
Typically this is the image that you would write to a floppy
boot disk, but at the end of the script if you cancel from the
floppy-write menu, the output file image will be left in the
<code>build_dir-$floppy_type</code> directory of the configuration
directory. 
</p>


<p>
&nbsp;*&nbsp;&nbsp;Select ``<code>M  MFS bytes per inode: 5000</code>''
to specify the fraction of the MFS (the in-kernel RAM-filesystem)
you want to devote to inodes. This is the average file size
you expect in the ``fully-loaded'' MFS, with some pad. 
Set this with respect to the ``<code>MFS Size</code>'' option
that was previously set. To <em>increase</em> the number of inodes
(that is, the number of files that can exist),
you need to <em>decrease</em> this value.
</p>


<p>
&nbsp;*&nbsp;&nbsp;Select ``<code>U  UFS bytes per inode: 32768</code>''
to specify the fraction of the floppy filesystem you want to devote to inodes.
Actually, the ``floppy'' need not be a floppy, and so you want to select
this size in conjunction with the ``<code>Floppy size</code>'' option.
Again, this is the average file size you expect when the floppy is fully
loaded. The <code>newfs</code> utility will figure out how many inodes
this requires. To <em>increase</em> the number of inodes,
you need to <em>decrease</em> this value.
</p>

<p>
After the <code>picobsd</code> script has finished, a new boot floppy
will only have two used inodes - the root directory and the <code>/kernel</code>
file (assuming the MFS is in the kernel).
</p>



<p>&nbsp;</p>
<p>
&nbsp;&sect;&nbsp;&nbsp; Unlike some toolsets,
you are not required to go through the menu to edit the
files in your configuration directory.
There is no reason why you cannot edit the files in your
configuration directory directly using any editor of your
choice. If you are in a repetitive developmnet and debugging
cycle, it is often easiest to simply leave all relevant files open
in an editor and skip the use of the menus.
</p>

<p>
There is no way from the menu to edit the
<code>config</code> file, which specifies your desired
device nodes. You have
to do this directly.
</p>





<p>&nbsp;</p>
<!================================================>
<a name="files">
<hr>
<h1>What is in a PicoBSD configuration directory?</h1>

<p>
As the <code>picobsd</code> script header documentation
indicates, each
PicoBSD configuration directory contains
a number of standard files:
</p>

<p>&nbsp;</p>
<p>
&nbsp;&sect;&nbsp;&nbsp;  <code>PICOBSD</code>
</p>

<blockquote>

<p>
The <code>PICOBSD</code> file is a normal FreeBSD kernel configuration
file with the addition of a comment line that starts
with ``<code>#PicoBSD</code>''. 
This comment line  supplies arguments
to the <code>picobsd</code> script.
</p>

<p>
Edit the <code>PICOBSD</code> file
to include your desired FreeBSD kernel options. In particular,
you often will want to specify drivers (devices).
</p>

<p>
Edit the <code>#PIOCBSD</code> comment/argument line 
to change the size of MFS RAM-disk,
the number of inodes in either the MFS or on
the floppy, or the ``init'' program.
An example of the <code>#PIOCBSD</code> comment/argument line 
(from 
<a href="file:/usr/src/release/picobsd/router/PICOBSD">
<code>/usr/src/release/picobsd/router/PICOBSD</code></a>) is:
</p>

<p>
<blockquote>
<code>
<pre>
#Line starting with #PicoBSD contains PicoBSD build parameters
#marker        def_sz  init    MFS_inodes      floppy_inodes
#PicoBSD       1200     oinit   3072            32768
options MD_ROOT_SIZE=1200
</pre>
</code>
</blockquote>
</p>

<p>
&nbsp;*&nbsp;&nbsp; The first argument in the ``<code>#PicoBSD</code>'' comment
indicates the size in 1Kbyte blocks
of the MFS filesystem (this argument is passed as the ``<code>count=</code>''
argument to the <code>dd</code> command that creates the file backing
the MFS image, using <code>bs=1k</code>).
</p>

<p>
&nbsp;*&nbsp;&nbsp; The second argument 
specifies the program to be run as the <code>init</code> process, that is,
Process 1. This program is  ultimately responsible for activating
all other processes, so changing this argument can totally change
the nature of the system you build. The <code>oinit</code> program in
the above example is a tiny  ``template starter'' alternate to the
traditional FreeBSD <code>init</code> program. See the
<a href="#oinit">section on <code>oinit</code></a>.
</p>

<p>
&nbsp;*&nbsp;&nbsp; The third argument is the ``<code>-i <em>avg_bytes_per_file</em></code>'' value
passed to the 
<a href="http://www.FreeBSD.org/cgi/man.cgi?query=newfs&sektion=8"><code>newfs</code></a>
 invocation that creates the filesystem on
the MFS. This indirectly specifies the number of inodes, that is, the maximum number of files that
you expect to fit on the filesystem of size ``<code>def_sz</code>''.
</p>

<p>
&nbsp;*&nbsp;&nbsp; The fourth argument is the ``<code>-i <em>avg_bytes_per_file</em></code>'' value
passed to the 
<a href="http://www.FreeBSD.org/cgi/man.cgi?query=newfs&sektion=8"><code>newfs</code></a>
 invocation that creates the floppy image filesystem.
This indirectly specifies the number of inodes, that is, the number of files that
you expect to fit on a filesystem of <code>$FLOPPY_SIZE</code>. The <code>$FLOPPY_SIZE</code>
environment variable defaults
to 1440 Kbytes, the size of the most common 3.5 inch floppy.
</p>


</blockquote>



<p>&nbsp;</p>
<p>
&nbsp;&sect;&nbsp;&nbsp; <code>config</code>
</p>

<blockquote>

<p>
The <code>config</code> file
lists all the device nodes
that are to be created in ``<code>/dev</code>''. 
Edit this file and add any device node names you
need to the <code>MY_DEVS</code> string. There is only
a single line in the typical <code>config</code> file.
An example of this line (from the 
<a href="file:/usr/src/release/picobsd/bridge"><code>bridge</code></a>
configuration) is:
</p>

<blockquote>
<p>
<code>
MY_DEVS="std tun2 vty10 fd0 ad0 pty0 cuaa0 cuaa1 bpf0 bpf1 bpf2"
</code>
</p>
</blockquote>

<p>
Any number of environment variables that you decided to
use could be defined in your <code>config</code> file.
</p>

</blockquote>

<p>&nbsp;</p>
<p>
&nbsp;&sect;&nbsp;&nbsp;  <code>crunch.conf</code>
</p>

<blockquote>
<p>
The ``<code>crunch.conf</code>'' file controls the application
<a href="http://www.FreeBSD.org/cgi/man.cgi?query=crunchgen&sektion=1"><code>crunchgen</code></a>,
that is, it
indicates which executables
to link into the single executable
<a href="http://www.FreeBSD.org/cgi/man.cgi?query=elf&sektion=5">ELF</a> file. 
</p>

<p>
Edit ``<code>crunch.conf</code>'' and add
<code>srcdirs</code>, <code>progs</code>, and 
<code>libs</code> statements as needed. 
The <code>progs</code>
statements specify the pathnames of the
executables that you
require. The <code>srcdirs</code> 
specify the pathnames of the directories
containing the 
<code>Makefile</code>s that correspond
to the executables. Note that <code>crunchgen</code>
requires a special ``makefile format'' (a FreeBSD 
standard), but you can easily 
<a href="#app">create a pseudo-makefile</a>
with this format if required.
</p>

<p>
The <a href="http://www.FreeBSD.org/cgi/man.cgi?query=crunchgen&sektion=1"><code>crunchgen</code></a>
 program, in effect, renames
all program <code>main()</code> routines and creates a single
<code>main()</code> with a little stub code that dispatches 
to the real entry-point based on the <code>arg0</code> 
command-line
name. Because of this, ``links'' are important in
the PicoBSD file tree (so as to provide desired
names). You specify your desired link names
in the ``<code>crunch.conf</code>'' file
using the <code>ln</code> command.
</p>

<p>
See ``<a href="http://www.FreeBSD.org/cgi/man.cgi?query=crunchgen&sektion=1"><code>man crunchgen</code></a>'' 
for the syntax of
the statements in the ``<code>crunch.conf</code>'' file.
Also see the comments included in the 
``<code>crunch.conf</code>'' files in the 
<a href="#ref">reference directories</a>.
</p>

</blockquote>

<p>&nbsp;</p>

<p>
&nbsp;&sect;&nbsp;&nbsp;  <code>floppy.tree</code> (optional)
</p>

<blockquote>

<p>
Each configuration directory can root its own ``<code>floppy.tree</code>''
directory tree. If it exists, the ``<code>floppy.tree</code>'' directory
normally contains a <code>/etc</code> directory which includes
the <code>/etc/rc</code> script and other scripts
that you want to build into the kernel,
such as ``<code>/etc/rc.firewall</code>''. 
Create and edit files, directories, scripts and
configuration files in the
``<code>floppy.tree</code>'' directory tree as required.
</p>

<p>
The files in the floppy tree are typically the files
that you might want (potentially) to edit on the floppy.
The default behavior of the current PicoBSD is <em>not</em> to
put these files on the floppy outside the <code>kernel</code>
file, but to include them directly in a <code>/fd</code> directory
in the MFS RAM-disk built into the kernel 
(see the section on 
<a href="#in_mfs">INCLUDE_FLOPPY_IN_MFS</a>
to change this behavior).
</p>


<p>
The directory 
``<a href="file:/usr/src/release/picobsd/floppy.tree">
<code>/usr/src/release/picobsd/floppy.tree</code></a>''
contains a ``base collection'' of scripts and other <code>/etc</code> files
that will be
included in PicoBSD.
In the kernel you build, the version of these files in
your ``<code>floppy.tree</code>'' is copied over 
the files in this tree.
</p>

</blockquote>

<p>&nbsp;</p>
<p>
&nbsp;&sect;&nbsp;&nbsp;  <code>floppy.tree.exclude</code> (optional)
</p>

<blockquote>

<p>
Each configuration directory can optionally
contain a ``<code>floppy.tree.exclude</code>''
file.  Each line in this file
contains the pathname of a file
in the ``base collection''
in 
``<a href="file:/usr/src/release/picobsd/floppy.tree"><code>/usr/src/release/picobsd/floppy.tree</code></a>''
that is <em>not</em> to be included in the PicoBSD system
that you build. An example exclude file, from the
bridge collection, is 
``<a href="file:/usr/src/release/picobsd/bridge/floppy.tree.exclude">
<code>/usr/src/release/picobsd/bridge/floppy.tree.exclude</code></a>''.
</p>

</blockquote>

<p>&nbsp;</p>
<b>Note:</b> a
single 
<a href="file:/usr/src/release/picobsd/mfs_tree"><code>/usr/src/release/picobsd/mfs_tree</code></a>
contains the files that are always built into the root MFS RAM-based
filesystem included in every kernel image
built under a particular <code>$PICO_TREE</code> (usually, this means that
whatever is in <code>mfs_tree</code> will end up in every PicoBSD system
that you build).
</p>


<p>&nbsp;</p>
<p>
&nbsp;&sect;&nbsp;&nbsp;  <code>mfs.mtree</code> (optional)
</p>

<blockquote>

<p>
Each configuration directory can
contain a ``<code>mfs.mtree</code>'' file
which specifies, in the format
used by the 
<a href="http://www.FreeBSD.org/cgi/man.cgi?query=mtree&sektion=8"><code>mtree</code></a> utility,
a map of the directory
structure you want to create in the RAM-based
file system. You do not need to define a
``<code>mfs.mtree</code>'' directory structure if
you do not need any directories other than those
included in  
<a href="file:/usr/src/release/picobsd/mfs_tree">
<code>/usr/src/release/picobsd/mfs_tree</code></a>.
</p>

<p>
See <a href="file:/etc/mtree">/etc/mtree</a> for
examples of <code>mtree</code> specification files.
</p>

</blockquote>




<p>&nbsp;</p>
<!================================================>
<a name="ref">
<hr>
<h1>What are the predefined ``reference'' configurations? Which one should I use?</h1>


<p>&nbsp;</p>
<p>
The current reference configuration directories are located in
directory 
``<a href="file:/usr/src/release/picobsd/"><code>/usr/src/release/picobsd</code></a>''. 
Start with the system closest to your needs and adapt
it to your circumstances.
The following
briefly describes these reference configurations:

<p>&nbsp;</p>

<p>
&nbsp;&sect;&nbsp;&nbsp; <code>bridge</code>&nbsp;&nbsp;
(<a href="file:/usr/src/release/picobsd/bridge">
<code>/usr/src/release/picobsd/bridge</code></a>)<br>
This PicoBSD system includes the 
<a href="http://www.FreeBSD.org/cgi/man.cgi?query=ipfw&sektion=8"><code>ipfw</code></a> firewall,
<a href="http://www.FreeBSD.org/cgi/man.cgi?query=dummynet&sektion=4"><code>dummynet</code></a>, and 
<a href="http://www.FreeBSD.org/cgi/man.cgi?query=dummynet&sektion=4"><code>bridge</code></a>.
Dummynet is software that enhances the <code>ipfw</code> firewall code
with the ability to do bandwidth limiting and a wide variety of other
features of interest to network researchers and technical ISPs
(traffic shaping and generation). 
The 
<a href="http://www.FreeBSD.org/cgi/man.cgi?query=dummynet&sektion=4"><code>bridge</code></a>
facility permits a PC to operate as a software ``bridge'', where
``bridge'' is used in the hardware sense, that is, as a repeater-style
connection that allows two Ethernet cables to appear to be a single
Ethernet cable. The FreeBSD <code>maxusers</code> kernel-sizing estimate
is set to 20.
See ``<a href="http://www.FreeBSD.org/cgi/man.cgi?query=dummynet&sektion=4"><code>man dummynet</code></a>'' and 
``<a href="http://www.FreeBSD.org/cgi/man.cgi?query=bridge&sektion=4"><code>man bridge</code></a>''.
</p>

<p>
&nbsp;&sect;&nbsp;&nbsp; <code>custom</code>&nbsp;&nbsp;
(<a href="file:/usr/src/release/picobsd/custom">
<code>/usr/src/release/picobsd/custom</code></a>)<br>
Although this directory at one time apparently supported
custom builds, currently it apparently
contains an (older) experimental <code>Makefile</code>
that was intended to replace the <code>picobsd</code> script.
This was apparently written at a time when a PicoBSD system required two floppies.
</p>

<p>
&nbsp;&sect;&nbsp;&nbsp; <code>dial</code>&nbsp;&nbsp;
(<a href="file:/usr/src/release/picobsd/dial">
<code>/usr/src/release/picobsd/dial</code></a>)<br>
This is basically a minimal end-user system that could be used
on a low-end PC to connect to an ISP using 
<a href="http://www.FreeBSD.org/cgi/man.cgi?query=ppp&sektion=8"><code>ppp</code></a>
over a dial-in connection.
It does <em>not</em> contain any firewall code.
The FreeBSD <code>maxusers</code> kernel-sizing estimate
is set to 3.
</p>

<p>
&nbsp;&sect;&nbsp;&nbsp; <code>install</code>&nbsp;&nbsp;
(<a href="file:/usr/src/release/picobsd/install">
<code>/usr/src/release/picobsd/install</code></a>)<br>
This appears to be a simple PicoBSD-based install system. This PicoBSD
system contains a script, ``<code>floppy.tree/etc/doinstall</code>'',
that does a network fetch to install a FreeBSD system. 
What is the status of this kit?
</p>

<p>
&nbsp;&sect;&nbsp;&nbsp; <code>isp</code>&nbsp;&nbsp;
(<a href="file:/usr/src/release/picobsd/isp">
<code>/usr/src/release/picobsd/isp</code></a>)<br>
This system is intended to be operated as an ISP
modem-server supporting 8 serial 
<a href="http://www.FreeBSD.org/cgi/man.cgi?query=pppd&sektion=8"><code>ppp</code></a>
connections. It includes the 
<a href="http://www.FreeBSD.org/cgi/man.cgi?query=ipfw&sektion=8"><code>ipfw</code></a> firewall
and 
<a href="http://www.FreeBSD.org/cgi/man.cgi?query=dummynet&sektion=4">Dummynet</a> code.
This system defines no scripts or configuration
files of its own, and thus is entirely dependent on the
scripts in the 
``base collection'' in the
<a href="file:/usr/src/release/picobsd"><code>/usr/src/release/picobsd</code></a>
 directory (
<a href="file:/usr/src/release/picobsd/mfs_tree">mfs_tree</a> 
and 
<a href="file:/usr/src/release/picobsd/mfs_tree">floppy_tree</a>).
The FreeBSD <code>maxusers</code> kernel-sizing estimate
is set to 20.
</p>

<p>
&nbsp;&sect;&nbsp;&nbsp; <code>net</code>&nbsp;&nbsp;
(<a href="file:/usr/src/release/picobsd/net">
<code>/usr/src/release/picobsd/net</code></a>)<br>
This is a generic network ``end node''.
It does not include Dummynet, but does support 
<a href="http://www.FreeBSD.org/cgi/man.cgi?query=ipfw&sektion=8"><code>ipfw</code></a>
and 
<a href="http://www.FreeBSD.org/cgi/man.cgi?query=ppp&sektion=8"><code>ppp</code></a>.
The FreeBSD <code>maxusers</code> kernel-sizing estimate
is set to 10.
</p>

<p>
&nbsp;&sect;&nbsp;&nbsp; <code>router</code>&nbsp;&nbsp;
(<a href="file:/usr/src/release/picobsd/router">
<code>/usr/src/release/picobsd/router</code></a>)<br>
This system is similar to the <code>ISP</code> system but
it does not support any special serial devices or <code>ppp</code>,
it does not include Dummynet, and it contains no special applications. Basically
this system is intended to be a running TCP/IP
stack in an Ethernet networked environment.
It includes 
<a href="http://www.FreeBSD.org/cgi/man.cgi?query=ipfw&sektion=8"><code>ipfw</code></a>
firewall support.
This system defines no scripts or configuration
files of its own, and thus is entirely dependent on the
scripts in the 
``base collection'' in the
<a href="file:/usr/src/release/picobsd"><code>/usr/src/release/picobsd</code></a> directory
(
<a href="file:/usr/src/release/picobsd/mfs_tree">mfs_tree</a> 
and 
<a href="file:/usr/src/release/picobsd/mfs_tree">floppy_tree</a>).
The FreeBSD <code>maxusers</code> kernel-sizing estimate
is set to 10.
</p>

<p>
An important operational characteristic of the  <code>router</code>
system is that it runs the minimal <code>oinit</code> version
of the Process 1 
<a href="http://www.FreeBSD.org/cgi/man.cgi?query=init&sektion=8"><code>init</code></a>
 program. Presumably a system
that is being used as a dedicated network router/firewall does not
want to waste memory on a user shell.
The source to this program is in
``<a href="file:/usr/src/release/picobsd/tinyware/oinit"><code>/usr/src/release/picobsd/tinyware/oinit/</code></a>''.
An important implication of this is that <b>the scheme
for overwriting and updating the files in  <code>/etc</code>
is not supported</b> by the router configuration. It runs a  
<a href="file:/usr/src/release/picobsd/router/floppy.tree/etc/rc">minimal <code>rc</code> script</a>
consisting only of simple command lines.
</p>

<p>
Because of the aformentioned use of <code>oinit</code>, for a typical
PicoBSD router-style deployment, the ``full-blown'' <code>bridge</code>
configuration is probably recommended.
</p>






<p>&nbsp;</p>
<!================================================>
<a name="boot_scripts">
<hr>
<h1>How does the PicoBSD <code>rc</code> boot script work?</h1>


<p>
The PicoBSD <code>/etc/rc</code> boot script 
is different than that used in FreeBSD.
The 
<a href="http://www.FreeBSD.org/cgi/man.cgi?query=rc&sektion=8">FreeBSD ``<code>/etc/rc.conf</code>'' scheme</a>,
in which the
boot sequence is controlled by overriding default shell 
variables,
is not used in PicoBSD due to size.
PicoBSD does, however, use a
``<a href="file:/usr/src/release/picobsd/floppy.tree/etc/rc.conf"><code>/etc/rc.conf</code></a>'' file
in which shell variables are set.
In addition, PicoBSD uses a somewhat subtle initial
<code>rc</code> scheme that involves uncompressing
and merging multiple <code>/etc</code>
directories and which always overwrites
the initial <code>rc</code> script,
<a href="file:/usr/src/release/picobsd/mfs_tree/etc/rc"><code>/usr/src/release/picobsd/mfs_tree/etc/rc</code></a>,
while it executes.
</p>


<p>
When the floppy tree is built into the kernel, the floppy <code>/etc</code>
files are put in MFS filesystem directory
``<code>/fd/etc</code>''. <em>All files in  <code>/fd/etc</code> are compressed</em>
(gzipped, that is, are ``<code>.gz</code>'' files).
</p>

<p>
The files that you want to statically include in the 
MFS RAM-filesystem are
located at
<a href="file:/usr/src/release/picobsd/mfs_tree"><code>/usr/src/release/picobsd/mfs_tree</code></a>
in the source directory tree.
This directory, in the running system, will be rooted at ``<code>/</code>''.
These statically included files are primarily small versions of
script files that rarely change, such as 
<code>disktab</code>, <code>protocols</code>, 
<code>services</code>, <code>shells</code>,
and <code>termcap</code>. 
</p>

<p>
The <code>mfs_tree</code> contains
a very simple 
<a href="file:/usr/src/release/picobsd/mfs_tree/etc/rc"><code>/etc/rc</code></a> script
(located in
<a href="file:/usr/src/release/picobsd/mfs_tree/etc"><code>/usr/src/release/picobsd/mfs_tree/etc</code></a>).
This is the initial script executed upon boot.
It:

<blockquote>

<p>
&nbsp;*&nbsp;&nbsp; Enters the <code>/fd</code> directory
and recursively copies the <code>/fd/etc/</code> tree
to <code>/etc</code>. This merges  <code>etc</code> files
defined in <code>mfs_tree/etc</code> with any gzipped
files from  ``<code>floppy.tree/etc</code>''
included in the kernel due to 
<code>INCLUDE_FLOPPY_IN_MFS="yes"</code>.
</p>

<p>
&nbsp;*&nbsp;&nbsp; The <code>rc</code> script then returns to
``<code>/</code>'', and mounts the floppy disk (<code>/dev/fd0c</code>)
on <code>/fd</code>. 
</p>

<p>
&nbsp;*&nbsp;&nbsp; It then repeats the process of copying all files
from <code>/fd/etc</code> into <code>/etc</code> and then dismounts the floppy.
This will copy any files into <code>/etc</code>
that were put on the floppy using
``<code>floppy.tree</code>'' and <code>INCLUDE_FLOPPY_IN_MFS="no"</code>,
or which you have manually edited on the floppy (perhaps using a host
machine or PicoBSD). At build time, the original ``<code>floppy.tree</code>'' sources
may be located either in a private  ``<code>floppy.tree/etc</code>'' configuration directory,
 or in the base
``<a href="file:/usr/src/release/picobsd/floppy.tree/etc"><code>/usr/src/release/picobsd/floppy.tree/etc</code></a>''.
</p>

<p>
&nbsp;*&nbsp;&nbsp; The <code>rc</code> script then enters
<code>/etc</code> and scans the directory for all files for which
a gzipped version also exists, and it deletes the non-gzipped files
(that is, for all files where <code>foo.gz</code> exists, <code>foo</code> is deleted).
This means that if you want to overwrite a file that exists in a
floppy tree built into the kernel image (that is, in <code>/fd</code>) 
with a new file that is actually located on the
floppy, <b>the new file must be gzipped</b>.
</p>

<p>
&nbsp;*&nbsp;&nbsp; All gzipped files in <code>/etc</code> are unzipped.
</p>

<p>
&nbsp;*&nbsp;&nbsp; The 
<a href="http://www.FreeBSD.org/cgi/man.cgi?query=pwd_mkdb&sektion=8"><code>pwd_mkdb</code></a>
 utility processes the ``<code>master.passwd</code>'' file
to create a valid binary password ``database''.
</p>

<p>
&nbsp;*&nbsp;&nbsp; Finally, the initial <code>/etc/rc</code> script
executes the script <code>/etc/rc</code>, that is, <em>itself</em>.
However, the previous steps assure that the <code>/etc/rc</code>
file <em>will have been
overwritten</em>. The source to the new
<code>/etc/rc</code> can come from a number of original locations.
It may have come from the default ``base'' 
<a href="file:/usr/src/release/picobsd/floppy.tree/etc/rc"><code>rc</code></a>
script defined in the
``<a href="file:/usr/src/release/picobsd/floppy.tree/etc"><code>/usr/src/release/picobsd/floppy.tree/etc</code></a>''.
It may be a script defined in the ``<code>floppy.tree/etc</code>'' directory of a
PicoBSD configuration directory, if such a file exists.
Finally, it will be the gzipped script located in
``<code>/etc/rc.gz</code>'' on the boot floppy, if such a file exists.
</p>

</blockquote>



<p>&nbsp;<p>

<p>
Because of its self-modifying behavior, it is important that the
initial 
<a href="file:/usr/src/release/picobsd/mfs_tree/etc/rc"><code>mfs_tree/etc/rc</code></a> script remain less than 1K.
</p>



<p>
Note that the gzipped <code>/fd/etc</code> files
are not by default deleted from the RAM-disk,
which typically uses up some 20K of memory.
</p>


<p>&nbsp;</p>
<!================================================>
<a name="rc">
<hr>
<h1>How do I edit PicoBSD <code>/etc</code> scripts?</h1>


<p>&nbsp;</p>
<p>
Once the system boots, the RAM-filesystem is volatile
and files can be edited, etc... Such modifications
will be lost, of course, upon reboot. 
There is no easy way to permanently edit a file
included in the kernel image, however,
the process described in the
<a href="#boot_scripts">previous section on the boot 
<code>rc</code> script</a> explains
how a file to be updated can be 
overwritten at boot time by new files placed
on the floppy.  To create a new <code>/etc</code>
file,
the floppy can
be mounted as a normal filesystem (either from a host
or from PicoBSD after PicoBSD boots). 
</p>

<p>
The procedure to update a <code>/etc</code> script is:
(1) edit copies of the script files you want to update, 
(2) <code>gzip</code> the files,
(3) mount the PicoBSD floppy,
(4) create a <code>/etc</code> directory, if it does not exist, 
on the PicoBSD floppy, and 
(5) put the updated and
gzipped
script files in <code>/etc</code> on the floppy.
The new files 
will then overwrite the original files at
boot time. 
</p>

<p>
For instance, to change the <code>motd</code>
``message of the day'' login file using a PicoBSD system
built with <code>ed</code> and
<code>gzip</code>:
</p>

<p>
<code>
<pre>
 #mount /dev/fd0 /mnt
 #cd /mnt
 #mkdir etc
 #cd etc
 #ed motd
  H
  P
  a
  *** Hello there, world!!!!***
  .
  wq
 #cat motd
 #gzip motd
 #ls
 #
 #cd
 #umount /mnt
 #reboot
 #
</pre>
</code>
</p>


<p>
 In the above, a ``<code>mount /dev/fd0c /mnt</code>''
should work as well. Note that a floppy ``knows'' if,
after being mounted,
it has been cleanly unmounted via a <code>umount</code>. 
If you get persistent
``<code>mount: /dev/fd0c: Operation not permitted</code>''
errors
while attempting to mount a floppy, check with <code>dmesg</code>
for ``run <code>fsck</code>'' warnings - the floppy was likely
``popped'' out without a manual <code>umount</code>.
</p>


<p>
The procedure described in this section enables
persistent (re)editing of startup scripts (put 
<a href="http://www.FreeBSD.org/cgi/man.cgi?query=ed&sektion=1"><code>ed</code></a>
in your ``<code>crunch.conf</code>'' if you are a minimalist,
or try 
<a href="http://www.FreeBSD.org/cgi/man.cgi?query=ee&sektion=1"><code>ee</code></a>). 
The script 
<a href="file:/usr/src/release/picobsd/mfs_tree/stand/update">
<code>/usr/src/release/picobsd/mfs_tree/stand/update</code></a>
automates this process, including saving an updated password file.
</p>


<p>&nbsp;</p>
<p>
Beware that the procedure described here <b>does not work</b> for the 
<code>router</code> configuration because it uses
<a href="#oinit"><code>oinit</code></a>, which 
requires either a 
<a href="file:/usr/src/release/picobsd/router/floppy.tree/etc/rc">
minimal commands-only rc file</a>,
or (depending on a <code>#define</code>),
its own ``<code>etc/oinit.rc</code>'' file.
If ``<code>oinit.rc</code>'' is used, all its
lines must either be comments
that start with a <code>#</code>, or valid executable command-lines.
</p>



<p>&nbsp;</p>
<!================================================>
<a name="image_update">
<hr>
<h1>How do I edit or add new files to an existing floppy <em>image</em> file?</h1>

<p>
Suppose you want to edit a new version of a <code>/etc</code>
script file. You can mount the floppy (``<code>mount /dev/fd0 /mnt</code>'')
and put the gzipped file in the
<code>/etc</code> directory on the floppy,
as described in the 
<a href="#rc">section on updating a script file</a>.
 Alternatively, you can
mount the ``<code>picobsd.bin</code>'' floppy image file,
and put the new gzipped file in the <code>/etc</code> directory
in the image file. You can then create as many floppies as
you like that include your new file by using <code>dd</code>
to copy the ``<code>picobsd.bin</code>'' image file to a real
floppy.
For example, to add a new  <code>rc</code> file to a floppy image named
``<code>my_old_picobsd.bin</code>'' in the current
directory:
</p>

<p>
<code>
<pre>
 #su
 #mount
 #vnconfig -c -s labels vn0 my_old_picobsd.bin
 #mount /dev/vn0c /mnt
 #mount
 #cd /mnt
 #
 #echo Create a new etc, or gunzip and edit existing files...
 #
 #mkdir etc
 #cd etc
 #cp /tmp/my_new_rc rc
 #
 #gzip rc
 #
 #cd
 #umount /mnt
 #vnconfig -u vn0
</pre>
</code>
</p>

<p>
Now you can <a href="#make_floppy">write the image file to a boot floppy</a>.
</p>

<p>
The first 
<a href="http://www.FreeBSD.org/cgi/man.cgi?query=vnconfig&sektion=8"><code>vnconfig</code></a>
 configures (``<code>-c</code>'') the <code>/dev/vn0</code>
device and sets a flag to 
use the diskslice label  on the device (``<code>-s labels</code>'')
This means the existing ``disk'' label, which contains the *ix partition information,
is respected.
After this command, the device <code>/dev/vn0</code> is accessible. The bytes of the
device are the bytes contained in file ``<code>my_old_picobsd.bin</code>''. At this point
the <code>/dev/vn0</code> device can be mounted and unmounted as if it were any block
device. The final <code>vnconfig</code> command unconfigures (``<code>-u</code>'') device
<code>/dev/vn0</code>. Be sure to do this, as the <code>picobsd</code> script needs
a free <code>vn</code> device. After the unconfigure, the mapping between the device and
file no longer exists; <code>/dev/vn0</code> can no longer be accessed as a device.
</p>

<p>
Note that <b>the gzip step is not optional</b> if the configuration has
previously used a ``<code>floppy.tree/etc/rc</code>'' script!
This is because
the ``first-level'' <code>rc</code> script (source in
``<a href="file:/usr/src/release/picobsd/mfs_tree/etc/rc">
<code>/usr/src/release/picobsd/mfs_tree/etc/rc</code></a>'')
deletes all the files in <code>/etc</code> that have a corresponding gzipped version.
If the new file 
is not gzipped, this will delete your new version of the <code>rc</code> file that came
from the floppy, leaving the old gzipped <code>rc</code> from <code>/fd/etc/rc</code> to
become the executing <code>rc</code>.
</p>


<p>
An advantage of this style is that you can
edit startup scripts on a large host with your favorite visual editor
at normal I/O speed (not floppy-speed!).
</p>


<p>
Often, it is almost just as fast to do a rebuild of
PicoBSD. However, this procedure may be useful if
you can no longer build PicoBSD, for instance, you
no longer have the FreeBSD source installed.
</p>




<p>&nbsp;</p>
<!================================================>
<a name="cmd_diffs">
<hr>
<h1>What are some command-line differences between FreeBSD and PicoBSD?</h1>

<p>
The <code>netstat</code> utility
in FreeBSD 
is a stripped-down version named 
<a href="file:/usr/src/release/picobsd/tinyware/ns"><code>ns</code></a>.
A link exists with the name
<code>netstat</code>.
Not all changes are simple ``throw-outs'', 
for instance, PicoBSD's
``<code>netstat -w 1</code>'' assumes a CRT.
</p>



<p>
Instead of using <code>dmesg</code> to redisplay console messages
(such as the driver boot probe messages), PicoBSD uses 
the 
<a href="file:/usr/src/release/picobsd/tinyware/msg"><code>msg</code></a>
utility (also linked to the
<code>dmesg</code> name).
</p>

<p>
PicoBSD uses a stripped-down version of <code>vmstat</code> called 
<a href="file:/usr/src/release/picobsd/tinyware/vm"><code>vm</code></a>.
It automatically enters
a loop with a display
in the ``<code>-w 5</code>'' style.

<p>
If 
<a href="file:/usr/src/release/picobsd/tinyware/oinit"><code>oinit</code></a>
is used (currently it is only used
for the <code>router</code> reference configuration), the user's
``shell environment'' is quite different than for the
other systems, which use <code>sh</code> as the shell.
Because <code>oinit</code> does not parse command
lines it is used with either a 
<a href="file:/usr/src/release/picobsd/router/floppy.tree/etc/rc">
minimal line-at-a-time
<code>rc</code> file</a> or it's own 
``<code>etc/oinit.rc</code>''
file. The default <code>rc</code> file in this case
do not support the scheme for
<a href="#rc">updating <code>/etc</code> files</a>
by replacing them with 
updated versions from the floppy.
</p>

<p>
Some versions of PicoBSD may use
stripped-down versions of <code>ps</code>
(the source is in <code>picobsd/tinyware</code>).
</p>

<p>
None of the standard PicoBSD builds include any version of
<code>more</code>, probably due to its size (<code>more</code>
is really a complete old-fashioned text-browser).
</p>

<p>
PicoBSD <em>does</em> support virtual consoles, which
can be accessed using <code>&LT;alt&GT;-F1</code>, <code>&LT;alt&GT;-F2</code>,
 ..., <code>&LT;alt&GT;-F8</code>.
</p>

<p>
When running X-windows on FreeBSD, 
you cannot reboot 
by pressing
<code>&LT;ctl&GT;-&LT;alt&GT;-&LT;del&GT;</code> 
(which otherwise works on both).
The standard  PicoBSD reference 
configurations do not include <code>shutdown</code>.
They do include
<code>reboot</code>.
</p>



<p>&nbsp;</p>
<!================================================>
<a name="app">
<hr>
<h1>How do I include my own binary application in PicoBSD, that is, include them with the
``crunched'' applications in the <code>kernel</code> file?</h1>


<p>
Many FreeBSD executable applications are linked assuming they can 
dynamically link to loadable libraries. Attempting to run such a
binary on a PicoBSD system will fail because the shared library will
not be found. To get around this problem, either statically link
the application as described in the 
<a href="#link_static">section on static linking</a>,
or ``crunch'' your application using 
<a href="http://www.FreeBSD.org/cgi/man.cgi?query=crunchgen&sektion=1">
<code>crunchgen</code></a> into the binary file included 
in the filesystem contained in
the system image. 
Using <code>crunchgen</code> requires 
some commands in the ``<code>crunch.conf</code>'' file and
at least a minimal <code>Makefile</code> in your application
directory. The <code>crunchgen</code>  utility requires
a standard FreeBSD Makefile. From ``<code>man crunchgen</code>'':
</p>

<blockquote>
"...the Makefile
must contain the target <b>depend</b>, and it must define all object files..."
</blockquote>

Suppose for some reason you do not use makefiles (perhaps
you have your own development tools). In this case, to use
PicoBSD, you still need to put a simple <code>Makefile</code>
in your ``development directory'' that defines the object files
to be processed. Suppose you write a program called <code>my_serv</code>
which consists of two C files, ``<code>my_serv.c</code>'' and
``<code>my_lib.c</code>''.
A <code>Makefile</code> sufficient to keep <code>crunchgen</code>
happy would only require:

<p>&nbsp;</p>
<blockquote>

<code>
<p>
#<br>
# <br>
# Makefile for picobsd crunchgen<br>
#<br>
PROG=my_serv<br>
SRCS=   my_serv.c my_lib.c<br>
OBJS=   my_serv.o my_lib.o<br>
NOMAN=yes<br>
<br>
.include &lt;bsd.prog.mk&gt;<br>
</p>
</code>
</blockquote>

<p>&nbsp;</p>


<p>
Assuming the above <code>Makefile</code> and C code is in
directory <code>/usr/my/demo/code</code>,
in your PicoBSD configuration directory, edit the ``<code>crunch.conf</code>''
file to contain the lines:
</p>

<p>&nbsp;</p>
<blockquote>
<code>
<p>
srcdirs /usr/my/demo/code<br>
<br>
progs my_serv<br>
special my_serv objvar OBJS<br>
special my_serv srcdir /usr/my/demo/code<br>
special my_serv objdir /usr/my/demo/code<br>
</p>
</code>
</blockquote>
<p>&nbsp;</p>


<p>
When using this pseudo-Makefile, 
the ``<code>.o</code>'' files will need
to exist in
``<code>/usr/my/demo/code</code>''
before the <code>picobsd</code> script executes.
If you are compiling files by hand, you can generate
the ``<code>.o</code>'' files for <code>my_serv</code>
using:
</p>

<blockquote>
<p>
<code>
<pre>
#gcc -c my_serv.c
#gcc -c my_lib.c
</pre>
</code>
</p>
</blockquote>
<p>&nbsp;</p>


<p>
Rebuild your version of PicoBSD, and test your application.
</p>




<p>&nbsp;</p>
<!================================================>
<a name="link_static">
<hr>
<h1>How do I write a binary application that I can download individually
and run on PicoBSD without requiring it to be 
``crunched'' into the <code>kernel</code> file?</h1>

<p>
FreeBSD executables use dynamic link libraries
by default. Dynamic linking is
typically used on modern systems to increase code sharing
and reduce the size of
executable programs (which often link to very large graphics
libraries). Arbitrary executables built under FreeBSD will
often require dynamic libraries not included in the PicoBSD system.
</p>

<p>
One way to avoid this problem is to
relink the application ``statically'' under FreeBSD.
The application's executable image will then
include all needed library
routines. For instance, to compile and statically link 
``<code>hello.c</code>'',
producing output ``<code>a.out</code>'':
</p>

<blockquote>
<code>
<pre>
 #cc -static hello.c
</pre>
</code>
</blockquote>


<p>
To find out if a binary program, for instance ``<code>a.out</code>'',
has been linked statically
or dynamically (and, if dynamic, which libraries it uses),
do a:
</p>

<blockquote>
<code>
<pre>
 #file a.out
 #ldd a.out
</pre>
</code>
</blockquote>

<p>
It is also good practice to ``strip'' a binary that is
to be downloaded individually to run on PicoBSD, that is, remove
unnecessary symbols:
</p>

<blockquote>
<code>
<pre>
 #strip a.out
</pre>
</code>
</blockquote>




<p>&nbsp;</p>
<!================================================>
<a name="size">
<hr>
<h1>How big is PicoBSD?</h1>


<p>
The size of the typical uncompressed PicoBSD <code>kernel</code> file for
the standard reference configurations is
somewhere between 3 and 4 Mbytes. This usually compresses
to around 1 Mbyte.
</p>

<p>
The PicoBSD <code>kernel</code> file
does not necessarily have to fit on a floppy.
You can make it
any size you want, if you have a suitable boot 
mechanism.
</p>

<p>
The run-time footprint will, of course, depend on the 
applications you run. Although I have run PicoBSD in 4 Mbytes
in the past, current lore has it that around 8 Mbytes
is a typical minimum.
</p>




<p>&nbsp;</p>
<!================================================>
<a name="hdisks">
<hr>
<h1>Does PicoBSD support hard disks?</h1>

<p>
Yes, PicoBSD can support hard disks.
Other than perhaps building your PicoBSD system to contain any
needed disk initialization utilities, the use of hard disks
in PicoBSD does
not differ from normal FreeBSD practice. To support a
hard disk:
</p> 

<p>
&nbsp;*&nbsp;&nbsp; Add an
entry in your <code>PICOBSD</code> configuration file for
the driver you need.
</p>

<p>
&nbsp;*&nbsp;&nbsp;  Add the device node names
you will be using to your <code>config</code> file.
If you need slices and partitions, be sure to add
device nodes for them. You do not need an MBR (Microsoft
Boot Record, defining Microsoft partitions) and disk
slices (the FreeBSD name for Microsoft partitions)
on a hard disk if you only use the disk for data. If you intend
to boot PicoBSD from the disk, it should have an
MBR.
</p>


<p>
&nbsp;*&nbsp;&nbsp;  You will have to mount the hard disk, perhaps using
a mount command at the bottom of the <code>/etc/rc</code>
file you include in your ``<code>floppy.tree</code>''
(that is, in the
``<code>./floppy.tree/etc/rc</code>'' file in your
configuration directory).
</p>

<p>
Depending on your environment, you may need to include
such utilities as 
<a href="http://www.FreeBSD.org/cgi/man.cgi?query=fdisk&sektion=8"><code>fdisk</code></a> and
<a href="http://www.FreeBSD.org/cgi/man.cgi?query=disklabel&sektion=8"><code>disklabel</code></a>
in your PicoBSD configuration.
</p>




<p>&nbsp;</p>
<!================================================>
<a name="space">
<hr>
<p>&nbsp;</p>

<h1>How do I see how much space is used in the filesystems?</h1>

<p>
There are two virtual filesystems relevent to the standard PicoBSD
build: (1) the MFS RAM-based filesystem built into the kernel, and (2) the
filesystem placed in file ``<code>picobsd.bin</code>'', the floppy image.
</p>


<p>&nbsp;</p>
<p>
&nbsp;&sect;&nbsp;&nbsp; At the end of the executable code-crunch phase of the <code>picobsd</code>
script, a ``<code>df -i</code>'' report, similar to the following, appears:
<p>

<code>
<pre>
Filesystem  1K-blocks     Used    Avail Capacity iused   ifree  %iused  Mounted on
/dev/vn0c        2103     1600      503    76%     308     202    60%   /var/vartmp/picobsd.ObsQn6JZW8
</pre>
</code>

<blockquote>
<p>
If you want to study this at your leisure,
run <code>picobsd</code> with the ``<code>-v</code>'' option (``<code>picobsd -v my_sys</code>'').
After the ``<code>---> Labeling MFS image</code>'' trace step, you will see a display such as
the following:
</p>

<p>
<code>
<pre>
Filesystem  1K-blocks     Used    Avail Capacity  Mounted on
/dev/vn0c        2103        1     2102     0%    /var/vartmp/picobsd.QYgf0heGbl
</pre>
</code>
</p>

<p>
After the ``<code>---> Copy generic MFS tree...</code>'' and ``<code>
---> Copy generic floppy_tree into MFS...</code>'' steps, you will see the <code>df</code>
display of the final MFS filesystem (resembling the first display above).
</p>

</blockquote>

<p>&nbsp;</p>
<p>
&nbsp;&sect;&nbsp;&nbsp; At the end of the <code>picobsd</code> script,
a dialog menu appears. This dialog includes output similar to the following:
</p>

<p>
<code>
<pre>
 The build process was completed successfuly.
 Filesystem  1K-blocks     Used    Avail Capacity iused   ifree  %iuse
 /dev/vn0c        1403     1268      135    90%       2      60     3%
</pre>
</code>
</p>

<p>
This is a ``<code>df -i</code>'' style display of your populated floppy
filesystem. The <code>Capacity</code> field tells you how much space
is used (and left) on the floppy filesystem. For a default build,
there will only be two inodes used on the floppy, one for the root directory
and the other for ``<code>/kernel</code>''.
</p>



<p>&nbsp;</p>
&nbsp;&sect;&nbsp;&nbsp; To see the status of filesystems in a running 
PicoBSD system, use ``<code>df -Hi</code>''. This will produce a display
in ``human-readable'' format.

<p>&nbsp;</p>
&nbsp;&sect;&nbsp;&nbsp; 
To alter the amount of space reserved for inodes,
see the 
<a href="#files">section on the PICOBSD configuration file</a>.








<p>&nbsp;</p>
<!================================================>
<a name="host">
<hr>
<h1>What ``host'' environment do I need to do embedded PicoBSD development?</h1>

<p>
Well, FreeBSD, naturally, since 
FreeBSD and PicoBSD are really the same thing.
The most up-to-date PicoBSD development environment as of this
date (June-2001) is FreeBSD 4.3 Stable. 
PicoBSD may not build under FreeBSD Current
(this may change by the time you read this).
Beware that PicoBSD
procedures (such as those described in this document) can
change significantly between FreeBSD versions, so check
the 
<a href="#small_archives">
freebsd-small@freebsd.org e-mail list archives</a>.
</p>



<p>&nbsp;</p>
<!================================================>
<a name="versions">
<hr>
<h1>What versions of FreeBSD does <code>picobsd</code> run under?</h1>

<p>
Some form of the <code>picobsd</code> script
  should run under all recent FreeBSD versions
except FreeBSD 5.0 Current (and maybe that too, by the
time you read this). 
Currently (June 2001), FreeBSD 4.3 Stable is the 
most solid version of PicoBSD. The 4.3 Stable version
of PicoBSD
generates systems that easily fit on a single floppy,
unlike some earlier versions which required two floppies.
</p>



<p>&nbsp;</p>
<!================================================>
<a name="get">
<hr>
<h1>How do I get PicoBSD (FreeBSD)?</h1>

<p>
To get PicoBSD, obtain FreeBSD with sources.
Once FreeBSD is installed, assuming the
sources are in the default <code>/usr/src</code>
directory, the PicoBSD
sources are in 
``<a href="file:/usr/src/release/picobsd"><code>/usr/src/release/picobsd</code></a>''.
</p>


<p>
There are a number of ways to get FreeBSD with sources
and keep it up-to-date.
You can subscribe to one of the commercial services that
ship FreeBSD on CD-ROM or DVD. You can download 
FreeBSD CD-ROM images over the Internet and burn a
bootable CD. You can <code>ftp</code> the sources from one
of the FreeBSD source mirror sites. You can use
<code>cvs</code> or <code>cvsup</code> to obtain
sources from a FreeBSD CVS repository. You can use
<code>ctm</code> to get sources and source diffs via e-mail.
</p>

<p>
The CVS system is used by the FreeBSD project to
manage the source code tree.
In practice, once you have installed a source kit
(perhaps from a CD-ROM image), most FreeBSD developers
seem to use <code>cvsup</code>. The <code>cvsup</code>
system runs on top of CVS and, in effect, only updates
files in your source tree from the repository that a
hash indicates have changed.
</p>

See ``<a href="http://www.freebsd.org">www.freebsd.org</a>''.


<p>&nbsp;</p>
<!================================================>
<a name="script">
<hr>
<p>&nbsp;</p>

<h1>What is the <code>picobsd</code> script (how does all this happen)?</h1>

<p>
The 
<a href="file:/usr/src/release/picobsd/build/picobsd">
<code>/usr/src/release/picobsd/build/picobsd</code>
</a>
script
<em>is</em> PicoBSD. Read this script file for the
``real'' documentation. The header of the <code>picobsd</code>
script file contains 
usage notes. This script is, among
other things, a wrapper for a FreeBSD kernel build.
It creates a ``virtual disk device'' using a file and
makes this (file) a bootable FreeBSD (PicoBSD) disk image
by putting in the disk image: (1) a root file system, 
(2) boot blocks, and (3) a bootable
<code>kernel</code> in the ``<conf>/</conf>'' directory. Startup scripts
are included in the memory-based filesystem included
internal to the <code>kernel</code> file itself.
</p>

<p>
You have to be root to run the <code>picobsd</code> script because
it needs to mount the virtual devices
and write raw to
the floppy.
</p>

<p>
In earlier versions of PicoBSD, the <code>picobsd</code> script
was named <code>build</code>.
</p>

<p>
The PicoBSD build cycle builds the floppy ``disk image''
file and then at the very end does a block-block
copy of this image to floppy, using 
<a href="http://www.FreeBSD.org/cgi/man.cgi?query=dd&sektion=1">
<code>dd</code> (Device Dup)</a>.
You do not need to build or use the floppy image.
You can just netboot the <code>kernel</code> file, boot
it from flash, etc..
</p>

<p>

In the typical development
cycle in which you are editing source code files,
after the first PicoBSD build 
following builds will go much faster (only the files you
have changed will be recompiled).
</p>

<p>&nbsp;</p>
<p>
The overall steps performed by the <code>picobsd</code> script are
now outlined, using a sort-of shell-command pseudo-code
and noting the names of relevant shell script routines.

<p>&nbsp;</p>
<p>
&nbsp;&sect;&nbsp;&nbsp; Setup variables and do 
the initial setup menu dialog (<code>init_vars()</code>,
<code>main_dialog()</code>).
</p>

<p>&nbsp;</p>
<p>
&nbsp;&sect;&nbsp;&nbsp; Build the <code>kernel</code>
(<code>build_image()</code>).
The <code>build_image()</code> routine is the main driver for building
the <code>kernel</code>file and putting the MFS and floppy tree inside
it. The steps performed by <code>build_image()</code> are now
described.
</p>

<blockquote>

<p>&nbsp;</p>
<p>
&nbsp;&sect;&nbsp;&nbsp; Read in the <code>config</code> file
(<code>init_stage1()</code>).
</p>

<p>&nbsp;</p>
<p>
&nbsp;&sect;&nbsp;&nbsp; Build the initial
<code>kernel</code> file and copy it to a work directory
(<code>do_kernel()</code>).
The actual kernel compile is driven by <code>make</code>
using<br>
``<a href="file:/usr/src/release/picobsd/build/Makefile.conf">
<code>/usr/src/release/picobsd/build/Makefile.conf</code></a>''.
</p>
<blockquote>
<p>
<code>
#make<br>
#cp<br>
#<a href="http://www.FreeBSD.org/cgi/man.cgi?query=strip&sektion=1">strip</a><br>
</code>
</p>
</blockquote>


<p>&nbsp;</p>
<p>
&nbsp;&sect;&nbsp;&nbsp; Create the floppy filesystem
in a work directory
(<code>populate_floppy_fs()</code>).
This is done before creating the memory filesystem so
that the floppy filesystem can be copied into the
memory filesystem, if desired.
</p>

<blockquote>
<p>
<code>
 #tar<br>
 #gzip etc/*<br>
</code>
</p>
</blockquote>

<p>&nbsp;</p>
<p>
&nbsp;&sect;&nbsp;&nbsp; Create the memory filesystem (MFS)
(<code>create_mfs(), init_fs_image()</code>).
</p>

<p>
<blockquote>
<a href="http://www.FreeBSD.org/cgi/man.cgi?query=dd&sektion=1"><code>#dd</code></a>
 an image of the size specified in the <code>PICOBSD</code> file.<br>
<code>#dd</code> <code>boot1</code> to make it bootable.<br>
<a href="http://www.FreeBSD.org/cgi/man.cgi?query=vnconfig&sektion=8"><code>#vnconfig</code></a>
 the image (make it accessible as a device).<br>
<a href="http://www.FreeBSD.org/cgi/man.cgi?query=disklabel&sektion=8"><code>#disklabel</code></a>
 to create a *ix disk partition table (disk label).<br>
<a href="http://www.FreeBSD.org/cgi/man.cgi?query=newfs&sektion=8"><code>#newfs</code></a>
 to create the filesystem.<br>
<a href="http://www.FreeBSD.org/cgi/man.cgi?query=mount&sektion=8"><code>#mount</code></a>
 to make it accessible for normal utilities.<br>
</code>
</p>
</blockquote>

<p>&nbsp;</p>
<p>
&nbsp;&sect;&nbsp;&nbsp; Populate the MFS file system
(<code>populate_mfs()</code>).
</p>

<p>
<blockquote>
<code>#cd</code> into the configuration directory.<br>
<a href="http://www.FreeBSD.org/cgi/man.cgi?query=mtree&sektion=8"><code>#mtree</code></a>
 to create the MFS directory structure.<br>
<code>#ln</code><br>
<a href="http://new.omc.net/cgi-bin/man.cgi?section=8&topic=MAKEDEV"><code>#MAKEDEV</code></a>
 to create device nodes.<br>
<a href="http://www.FreeBSD.org/cgi/man.cgi?query=crunchgen&sektion=1"><code>#crunchgen crunch.mk</code></a>
 to preprocess the applications to crunch.<br>
<code>#make crunch.mk</code> to crunch the onjects into <code>crunch1</code>.<br>
<code>#mv</code> to put <code>crunch1</code> in <code>/stand/crunch</code> in the MFS filesystem.<br>
<code>#tar</code> to copy <code>mfs_tree</code> files from configuration directories to the MFS filesystem.<br>
<code>#cp -R floppy.tree</code> into <code>/fd</code> in the MFS if <code>INCLUDE_FLOPPY_IN_MFS="yes"</code>.<br>
<code>#umount</code> virtual MFS device.<br>
<code>#fsck</code><br>
<code>#vnconfig -u</code>, which returns the file to ``normal'' (not a device).<br>
</p>
</blockquote>

<p>
All binary executable files are actually in a single 
file, <code>/stand/crunch</code>. The <code>/stand</code> directory
contains links which refer to all binaries, and directories
such as <code>/bin</code> and <code>/sbin</code> are simply
links to <code>/stand</code>.
</p> 


<p>&nbsp;</p>
<p>
&nbsp;&sect;&nbsp;&nbsp; Create ``<code>picobsd.bin</code>'', the floppy disk image
(<code>fill_floppy_image()</code>  (Part I)).
</p>

<blockquote>
<p>
<code>#dd</code> a file to floppy size.<br>
<code>#dd</code> boot1 to make the file bootable.<br>
<code>#vnconfig</code> to make the file accessible as a device.<br>
<code>#disklabel</code> to write boot records (and create a single partition disk).<br>
<code>#newfs</code> to create a filesystem in the file.<br>
<code>#mount</code> to make the filesystem accessible.<br>
<p>
</blockquote>

<p>
&nbsp;&sect;&nbsp;&nbsp; Copy the MFS to the kernel, compress the kernel,
and copy it to the floppy image.
(<code>fill_floppy_image()</code>  (Part II)).
</p>

<blockquote>
<p>
<code>#cc write_mfs_in_kernel.c</code><br>
<code>#write_mfs_in_kernel</code> to actually put the MFS in the kernel.<br>
<a href="http://www.FreeBSD.org/cgi/man.cgi?query=kgzip&sektion=8"><code>#kgzip</code></a>
 the kernel.<br>
<code>#cp</code> the kernel to <code>/kernel</code> in the floppy tree.<br>
</p>
</blockquote>

<p>
The file 
``<a href="file:/usr/src/release/write_mfs_in_kernel.c"><code>/usr/src/release/write_mfs_in_kernel.c</code></a>''
is a little program compiled every execution of 
the <code>picobsd</code> script.
It
``zaps'' the MFS filesystem image into the kernel image at a location
it finds by scanning the <code>kernel</code> file
for a byte string literal
``<code>MFS Filesystem goes here</code>''. 
Note ``<code>write_mfs_in_kernel.c</code>''
is not in the PicoBSD tree (it has other uses as well).
If your MFS filesystem becomes too large to fit in the kernel,
the error ``<code>MFS Filesystem signature not found</code>''
will likely occur. Increase the <code>MD_ROOT_SIZE</code> specified
via the second argument in your <code>PICOBSD</code> configuration
file. This may result in a <code>kernel</code> too large to fit
on the floppy.
</p>

<p>
&nbsp;&sect;&nbsp;&nbsp; Put the ``<code>floppy.tree</code>'' in the floppy image, if needed
(<code>fill_floppy_image()</code>  (Part III)).
</p>
<blockquote>
<p>
<code>#cp</code> the ``<code>floppy.tree</code>'' into the floppy image if it was not already copied into the MFS
(that is, if it is not already inside the compressed <code>kernel</code> file).<br>
</p>
</blockquote>

<p>&nbsp;</p><p>&nbsp;</p>
<p>
&nbsp;&sect;&nbsp;&nbsp;  This completes the <code>build_image()</code> routine.
</p>

</blockquote>

<p>&nbsp;</p>
<p>
&nbsp;&sect;&nbsp;&nbsp; Write the floppy image to the floppy disk
(<code>do_install()</code>).

<blockquote>
<p>
<a href="http://www.FreeBSD.org/cgi/man.cgi?query=dialog&sektion=1"><code>#dialog</code></a>
 to display the confirmation dialog.<br>
<code>#dd picobsd.bin  -> /dev/rfd0</code> to write the floppy.<br>
</p>
</blockquote>



<p>&nbsp;</p>
<!================================================>
<a name="tinyware">
<hr>
<h1>What is <code>tinyware</code>?</h1>


The <code>tinyware</code> homepage, which is quite dated,
is at:

<blockquote>
<p>
<code>
<a href="http://people.freebsd.org/~picobsd/tinyware">http://people.freebsd.org/~picobsd/tinyware</a>
</code>
</p>
</blockquote>

<p>
The <code>tinyware</em> directory in 
<a href="file:/usr/src/release/picobsd/tinyware">
<code>/usr/src/release/picobsd/tinyware</code>
</a>
contains small versions of a few standard
system utilities, in particular <code>vmstat</code>
and <code>netstat</code>. These are smaller
than their FreeBSD counterparts and are the
versions typically used with PicoBSD.
</p>

<p>
There is occasional discussion in the PicoBSD
world of developing a ``complete'' set of ``tiny''
utilities, perhaps based on those for such systems
as Minix. Lately, it appears this idea has
fallen out of favor as a general strategy, on
the grounds that it introduces yet another
standard for things such as script syntax.
As is, the 
<a href="http://www.FreeBSD.org/cgi/man.cgi?query=sh&sektion=1">
<code>sh</code></a>
 shell works fine
with PicoBSD. 
Conversly, 
<a href="#oinit"><code>oinit</code></a> acts as it's
own minimal shell.
Of course, for your special application
you can engineer exactly whatever you need.
</p>

<p>See also the PicoBSD FAQs


<p>
See the following section for some information on
the tinyware utilities.
</p>




<p>&nbsp;</p>
<!================================================>
<a name="oinit">
<hr>
<h1>What is <code>oinit</code>?</h1>

<p>&nbsp;</p>
<p>
&nbsp;&sect;&nbsp;&nbsp; The second process created by a 
<a href="http://www.FreeBSD.org/cgi/man.cgi?query=boot&sektion=8">booting *ix system</a>
typically runs the program
<a href="http://www.FreeBSD.org/cgi/man.cgi?query=init&sektion=8"><code>/sbin/init</code></a>.
A FreeBSD ``<code>ps -ax</code>''
will show this <code>init</code> program with a
Process ID of 1. Process 0 is considered
the <code>swapper</code>, 
which (irrespective of virtual memory)
provides a means to make main memory available by
swapping programs to the <em>swap device</em>
(PicoBSD usually does not have a swap device).
</p>

<p>
It is <code>init</code> that forks itself for each
interactive terminal which the system is to support,
resulting in other forks which issue login prompts, 
create shells, and such. The <code>init</code>
process thus becomes the uppermost ``parent'' of all the
processes in the system.
</p>

<p>
In many embedded PicoBSD scenarios, the full-blown
<code>init</code> program is inappropriate.
In this case, the <code>oinit</code> program
provides a simple 
alternative. 
The <code>oinit</code> program acts as it's own
minimal shell, that is, it does not run another shell
program.
You can treat this program as a
starting point for developing your own embedded
environment very different from traditional *ix.
</p>

<p>&nbsp;</p>
<p>
&nbsp;&sect;&nbsp;&nbsp;  The code for the <code>oinit</code> program is 
located in directory:
</p>

<p>
<a href="file:/usr/src/release/picobsd/tinyware/oinit">
<code>
/usr/src/release/picobsd/tinyware/oinit 
</code>
</a>
</p>

<p>&nbsp;</p>
<p>
&nbsp;&sect;&nbsp;&nbsp; Specify that you want to use <code>oinit</code> instead
of <code>init</code> by changing the 
<a href="file:/usr/src/release/picobsd/router/PICOBSD">second argument
of the <code>#PicoBSD</code> line</a> in your
<code>PICOBSD</code> configuration file.
</p>



<p>&nbsp;</p>
<p>
&nbsp;&sect;&nbsp;&nbsp; 
The PicoBSD <code>router</code> reference system
uses <code>oinit</code>. A 
compile-time ``<code>#ifdef OINIT_RC</code>'' controls
whether the <code>oinit</code> program
process a 
<a href="file:/usr/src/release/picobsd/router/floppy.tree/etc/rc">
minimal line-at-a-time
<code>rc</code> file</a>, 
or uses its own ``<code>etc/oinit.rc</code>'' file.
Because <code>oinit</code> does no real parsing,
the lines in either of these files
must either be comments
that start with a <code>#</code>, or valid executable command-lines.
Thus,
the default scripts for the
router configuration <b>do not support the scheme for
<a href="#rc">updating <code>/etc</code> files</a></b>
by replacing them with 
updated versions from the floppy.
You could modify these to do so, if need be.
</p>




<p>&nbsp;</p>
<!================================================>
<a name="boot">
<hr>
<h1>Where do the PicoBSD boot files on the floppy come from?</h1>

<p>
The 
<a href="http://www.FreeBSD.org/cgi/man.cgi?query=boot&sektion=8">boot blocks</a>
written to the floppy image 
are obtained from the host
FreeBSD machine's 
<a href="file:/boot"><code>/boot</code></a> directory</a>.
</p>

<p>
If you intend to write boot blocks to a device
from a running PicoBSD system (perhaps to make a
bootable hard-disk or flash device), 
put the boot files that you need in 
``<a href="file:/usr/src/release/picobsd/mfs_tree/boot"><code>/usr/src/release/picobsd/mfs_tree/boot</code></a>''.
</p>


<p>&nbsp;</p>
<!================================================>
<a name="makefile">
<hr>
<h1>What makefile invokes the actual kernel compile?</h1>

<p>
The 
<a href="file:/usr/src/release/picobsd/build/Makefile.conf"><code>Makefile.conf</code></a> file in
``<a href="file:/usr/src/release/picobsd/build"><code>/usr/src/release/picobsd/build</code></a>''.
</p>





<p>&nbsp;</p>
<!================================================>
<a name="related">
<hr>
<p>&nbsp;</p>

<h1>How can I build a number of related PicoBSD systems?</h1>

<p>
&nbsp;&sect;&nbsp;&nbsp;PicoBSD has a tree-structured configuration scheme with respect
to boot-time script files.
Each ``leaf-node'' of the configuration tree defines
a single system. Three levels of ``factored
commonality'' potentially exist above each leaf. The layering is:
</p>

<code>
<pre>
      /usr/src/release/picobsd/mfs_tree/etc    (top, base-class, super-class)
      /usr/src/release/picobsd/floppy.tree/etc
      $CONF_DIR/floppy.tree/etc
      $CONF_DIR/floppy.tree.$SITE_NAME/etc
</pre>
</code>

<p>
In the above, <code>$CONF_DIR</code> specifies your configuration
directory, and <code>$SITE_NAME</code> is the optional
site as specified in the <code>picobsd</code> command
(see <a href="#syntax">the section on command syntax</a>).
The <code>$CONF_DIR</code> above corresponds to the <code>floppy_type</code>
argument passed to the <code>picobsd</code> command.
You do not need to have either of the <code>$CONF_DIR/floppy.tree</code>
directories. 
</p>

<p>
Your <code>/etc</code> files are, in effect,
``inherited'' using the above four ``classes''.
</p>

<p>&nbsp;</p>
<p>
&nbsp;&sect;&nbsp;&nbsp;In addition, you can have multiple PicoBSD source trees
by specifying the root using the <code>$PICO_TREE</code>
variable.
</p>


<p>&nbsp;</p>
<p>
&nbsp;&sect;&nbsp;&nbsp;See also the section <em>Cloning the Sample Client</em>
toward the end of the article
<em>Setting Up a FreeBSD Lab</em>, by Oscar Bonilla,
at 
<a href="http://www.daemonnews.org/199911/fbsdlab.html">www.daemonnews.org/199911/fbsdlab.html</a>.
This article describes replicated PicoBSD installation.
</p>







<p>&nbsp;</p>
<!================================================>
<a name="make_floppy">
<hr>
<h1>How do I make a floppy from an existing PicoBSD floppy image file?</h1>

<p>
Easy! Suppose you keep a collection of pre-built PicoBSD floppy
systems, that is, a collection of ``<code>picobsd.bin</code>'' files.
To write bootable image file ``<code>my_old_picobsd.bin</code>''
to a standard 3.5 inch floppy,
use 
<a href="http://www.FreeBSD.org/cgi/man.cgi?query=dd&sektion=1"><code>dd</code> (Device Dup)</a>:
</p>

<p>
<code>
#su<br>
#dd if=my_old_picobsd.bin of=/dev/rfd0.1440</br>
</code>
</p>





<p>&nbsp;</p>
<!================================================>
<a name="comparing">
<hr>
<h2>How do I compare FreeBSD and PicoBSD kernel images?</h2>

<p>
A FreeBSD or PicoBSD kernel is an ELF (Executable and Linking Format) file.
One way to compare a FreeBSD kernel with a PicoBSD kernel is to
use <code>objdump</code>. Assuming a PicoBSD configuration named
<code>mysys</code>:
</p>

<blockquote>
<code>
<pre>
#cd /usr/src/release/picobsd/build/build-mysys
#objdump -f -h -p /kernel
#objdump -f -h -p kernel
</pre>
</code>
</blockquote>

<p>
The first <code>objdump</code> command displays information
from the running FreeBSD system, and the second from the
PicoBSD system generated from the same sources.
These <code>objdump</code> commands display the
ELF file header (<code>-f</code>), the section
headers (<code>-h</code>), and the program
headers (<code>-p</code>).

<p>
An ELF file always contains an ELF header.
If the file is an object file it contains
a section table. If the file is an executable file it
contains a program table. A shared library file
contains both a section and a program table.
A kernel file contains both section and program tables.
</p>

<p>
The section table describes
named memory sections with particular attributes 
(<code>text</code>, <code>data</code>).
The program table describes ``segments'', which in ELF
terminology contain contiguous memory ready
to be loaded into an address range in virtual memory.
</p>

For example, a PicoBSD kernel shows:

<blockquote>
<code>
<pre>
...

Program Header:

...
    LOAD off    0x00000000 vaddr 0xc0100000 paddr 0xc0100000 align 2**12
         filesz 0x000f7c79 memsz 0x000f7c79 flags r-x

    LOAD off    0x000f7c80 vaddr 0xc01f8c80 paddr 0xc01f8c80 align 2**12
         filesz 0x000188c8 memsz 0x0002f910 flags rw-

...

Sections:
Idx Name          Size      VMA       LMA       File off  Algn

...

  4 .text         000c46b8  c0118d00  c0118d00  00018d00  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE

  5 .rodata       0001a8b9  c01dd3c0  c01dd3c0  000dd3c0  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, DATA

  6 .data         00017bbc  c01f8c80  c01f8c80  000f7c80  2**5
                  CONTENTS, ALLOC, LOAD, DATA

...
 18 .bss          00017030  c0211560  c0211560  00110560  2**5
                  ALLOC
...
</pre>
</code>
</blockquote>



A FreeBSD kernel built from the same sources shows:

<blockquote>
<code>
<pre>

...

Program Header:
...
    LOAD off    0x00000000 vaddr 0xc0100000 paddr 0xc0100000 align 2**12
         filesz 0x0028111f memsz 0x0028111f flags r-x

    LOAD off    0x00281120 vaddr 0xc0382120 paddr 0xc0382120 align 2**12
         filesz 0x00032de0 memsz 0x000545d8 flags rw-
...

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
...
  4 .text         002073a8  c0126a80  c0126a80  00026a80  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE

  5 .rodata       000532df  c032de40  c032de40  0022de40  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, DATA

  6 .data         00031ba0  c0382120  c0382120  00281120  2**5
                  CONTENTS, ALLOC, LOAD, DATA
...
 19 .bss          000217f8  c03b4f00  c03b4f00  002b3f00  2**5
                  ALLOC
</pre>
</code>
</blockquote>


<p>
Both kernels always have two <code>LOAD</code> segments.
The two program <code>LOAD</code> segements are the read-only executable
<em>text</em> segment and the read/write <em>data</em> segement.
When FreeBSD boots, the text size is displayed, along
with a ``<code>data=</code>'' display that shows the size of the data segment
plus the size of the <em>.bss section</em>. The <code>.bss</code> section corresponds to 
space that can simply be zeroed, which is why it is marked
<code>ALLOC</code> but not <code>LOAD</code>.
</p>

<p>
Initial footprint of the PicoBSD kernel is thus text=1,014,905 (0xF7C79)
and data=[100,552+94,256] (0x188C8+0x17030), or 1,209,713 bytes.
The FreeBSD kernel is text=2,625,823 (0x28111f)
and data=[208,352+137,208] (0x32de0+0x217f8), or 2,971,383 bytes.
</p>



<p>&nbsp;</p>
<!================================================>
<a name="find_str">
<hr>
<h2>How do I find a string in an ELF kernel section?</h2>

<p>
You can dump a given section using <code>objdump</code>. To get a
hexdump of the 
``<code>.rodata</code>'' section:
</p>

<blockquote>
<code>
<pre>
#objdump -s -j .rodata kernel | more
</pre>
</code>
</blockquote>

<p>
To find a string in the kernel (for instance, the MFS
in the 
``<code>MFS Filesystem goes here</code>'' string), first find the
section containing the string:
</p>

<blockquote>
<code>
<pre>
#hd kernel | egrep MFS
 000fabe0  4d 46 53 20 46 69 6c 65  73 79 73 74 65 6d 20 67  |MFS Filesystem g|
</pre>
</code>
</blockquote>

<p>
Use the file offset (in this case <code>000fabe0</code>) to locate
the section. Examine the ``<code>File off</code>'' fields 
produced by:
</p>

<blockquote>
<code>
<pre>
#objdump -f -s -p kernel
</pre>
</code>
</blockquote>

<p>
In this case, the string is in the ``<code>.data</code>'' section.
Now, find the offset of the start of the string in the section:
</p>

<blockquote>
<code>
<pre>
#objdump -s -h .data kernel | egrep MFS
 c01fbbe0 4d465320 46696c65 73797374 656d2067  MFS Filesystem g
</pre>
</code>
</blockquote>

<p>
The string starts at <code>c01fbbe0</code>, so dump the section starting
from that location:
</p>

<blockquote>
<code>
<pre>
#objdump -s -j .data --start-address=0xc01fbbe0 kernel | more
</pre>
</code>
</blockquote>





<p>&nbsp;</p>
<!================================================>
<a name="older">
<hr>
<h1>What's an older way to build PicoBSD?</h1>

<p>
Over time there have been a number of ways to build PicoBSD,
including <code>Makefile</code>-based techniques
(at least for some
build directories). Also, there was 
a prior technique
based on a script called <code>build</code>.
It is very common to start with one of the existing
approaches and develop your own system, specific
to your development requirements.
</p>

<p>
Prior to FreeBSD 4.3, the <code>picobsd</code> script
had to be used with private
configuration directories created in 
``<code>/usr/src/release/picobsd</code>''.
This meant that the developer had to work in the
FreeBSD source tree. The use of the
<code>picobsd</code> script in this fashion is described
in this section.
</p>


<p>
&nbsp;*&nbsp;&nbsp;  Unless you simply want to perform a reference build,
create a new configuration directory
as root in ``<code>/usr/src/release/picobsd</code>''.
Give this new
directory the name
that you want to give your custom PicoBSD configuration. Copy one of the 
standard reference directories into your configuration directory.
For instance, to create a configuration directory named <code>mysys</code>
based on the PicoBSD
<code>bridge</code> reference configuration:
</p>

<blockquote>
<p>
<code>
#su<br>
#cd /usr/src/release/picobsd<br>
#cp -R bridge mysys<br>
</code>
</p>
</blockquote>

<p>
&nbsp;*&nbsp;&nbsp; After modifying the PicoBSD configuration files in
the <code>mysys</code> directory, to build your system
you would:

<blockquote>
<p>
<code>
<pre>
#su
#cd /usr/src/release/picobsd/build
#./picobsd mysys
</pre>
</code>
</p>
</blockquote>

<p>
The build results will be left in the
<code>/usr/src/release/picobsd/build/build_dir-mysys</code>
directory. These results would include the uncompressed
<code>kernel</code> file and the <code>``picobsd.bin''</code> file,
which contains the floppy image (and which includes the compressed
kernel file).
</p>


<p>
&nbsp;*&nbsp;&nbsp; To build one of the standard reference systems,
for instance <code>router</code>,
you would:
</p>

<blockquote>
<p>
<code>
<pre>
#su
#cd /usr/src/release/picobsd/build
#./picobsd router
</pre>
</code>
</p>
</blockquote>

<p>
The build results will be left in the
<code>/usr/src/release/picobsd/build/build_dir-router</code>
directory.
</p>

<p>
There is no need to copy the <code>picobsd</code> script
into a location in your path when using the method of
building PicoBSD described in this section.
</p>


<p>
A potential disadvantage of this style of development is
that it conflicts with using <code>cvsup</code> to incrementally
synchronize your source-code tree to the evolving FreeBSD
source. Because any files you have modified and the files in the source
tree will have different hashes, modified files will be replaced.
</p>



<p>&nbsp;</p>
<!================================================>
<a name="download">
<hr>
<h1>Can I download a bootable PicoBSD image?</h1>

<p>
At one time it was apparently common to keep downloadable
versions of the standard ``reference'' systems available.
This practice appears to have become de-emphasized, due
to the proliferation of devices and the need to keep
PicoBSD as small as possible (thus only including support
for those hardware devices you have in your specific target machine).
It is also no longer as necessary, since every FreeBSD installation
that includes source can readily build the standard PicoBSD configurations.
</p>





<p>&nbsp;</p>
<!================================================>
<a name="small">
<hr>
<h1>Are there other ways to make small FreeBSD systems?</h1>

<p>
Sure. Don't overlook what can be done just by building a
FreeBSD system with a minimal configuration file.
Today, many embedded systems support large flash disks
(64M, 128M, 256M). On devices of this size, people often
simply run FreeBSD.
</p>

<p>
If you have done a full FreeBSD  install
that included the documentation,
the 
<a href="file:/usr/share/doc/handbook/index.html">FreeBSD Handbook</a> in the 
<a href="file:/usr/share/doc">
<code>/usr/share/doc</code></a>
 directory
contains an example of such a minimal config file, called <code>MINI</code>.
Following a full installation, the <code>doc</code> directory
contains three versions of the handbook,<br>
a single web page
(<a href="file:/usr/share/doc/handbook/book.html"><code>/usr/share/doc/handbook/book.html</code></a>),<br>
a text file (<a href="file:/usr/share/doc/handbook/book.txt"><code>/usr/share/doc/handbook/book.txt</code></a>),<br>
and a collection of web pages 
(<a href="file:/usr/share/doc/handbook/index.html"><code>/usr/share/doc/handbook/index.html</code></a>).<br>
</p>

<p>
The config file is included in a
script that puts the generated <code>kernel</code>
on a bootable floppy as a backup ``save disk''. 
The script (and config file) can be found at the bottom of 
web page:
</p>

<p>
<a href="file:/usr/share/doc/en_US.ISO_8859-1/books/handbook/backup-programs.html">
<code>
/usr/share/doc/en_US.ISO_8859-1/books/handbook/backup-programs.html
</code>
</a>
</p>

<p>
Near the middle of the web page,
<em>Section 11.3.8</em>, <em>Emergency Restore Procedure</em>, contains:
</p>

<blockquote><em>
`An example script for creating a bootable floppy:'
</em>
</blockquote>

<p>
If this example script does not find an existing <code>MINI</code>
FreeBSD configuration,
it echos the <code>MINI</code> sample configuration file it contains
to the console.
</p>



<p>&nbsp;</p>
<p>
(You can read the handbook by doing a
``<code>cd /usr/share/doc/handbook</code>'' followed by a
``<code>netscape index.html &amp;</code>'').
</p>
</small>

<p>
This web page is also at<br>
<a href="http://www.freebsd.org/doc/en_US.ISO8859-1/books/handbook/backup-programs.html">
<code>
http://www.freebsd.org/doc/en_US.ISO8859-1/books/handbook/backup-programs.html
</code>
</a><br>
and the handbook
at<br>
<a href="http://www.freebsd.org/doc/en_US.ISO8859-1/books/handbook/index.html">
<code>
http://www.freebsd.org/doc/en_US.ISO8859-1/books/handbook
</code>
</a>.







<p>&nbsp;</p>
<!================================================>
<a name="maint">
<hr>
<h1>Who maintains PicoBSD?</h1>

<p>
Again, PicoBSD is really just FreeBSD, so the actual
code is the work of the huge team of people that
participate in FreeBSD development.
</p>

<p>
Currently, 
<a href="http://info.iet.unipi.it/~luigi/">Dr. Luigi Rizzo</a>
 of the University of Pisa
is the lead maintainer and committer of the 
<code>picobsd</code> script.
Many FreeBSD committers appear to work on occcasion on
the files in the PicoBSD source.
Many, many people have apparently contributed over the years
to PicoBSD and the utilities that it requires. 
Although it is difficult
to attribute all involved, 
some of the more frequent names encountered
in PicoBSD related files and utilities are
<a href="http://people.freebsd.org/~abial/">Andrzej Bialecki</a> (who wrote the
first version of the build script
and many of the <code>tinyware</code> tools), 
<a href="http://people.freebsd.org/~picobsd/picobsd225/">Dinesh Nair</a> (who maintained 
version 2.2.5 of
PicoBSD),  Mike Smith, Poul-Henning Kamp,
Josef Karthauser, Doug White,
James da Silva of the University of Maryland, 
Greg Lehey, Joe Greco,
and various programmers at the University of Utah.
I have no doubt missed many key people, for which
I apologize.
</p> 

<p>
You can scan the CVS source tree yourself and see who is working
on what. The CVS tree is at:
<a href="http://www.FreeBSD.org/cgi/cvsweb.cgi/src/release/picobsd">
<code>http://www.FreeBSD.org/cgi/cvsweb.cgi/src/release/picobsd</code></a>.
</p>


<!================================================>
<a name="developed">
<hr>
<h1>Who developed PicoBSD?</h1>

<p>
PicoBSD was originally developed by 
<a href="http://www.picobsd.pbg.pl/about.html">Andrzej Bialecki</a>
(<a href="http://people.FreeBSD.org/~abial">http://people.FreeBSD.org/~abial</a>)
while at what was then Poland's national ISP,
the 
<a href="http://www.nask.pl/english/">Research and Academic Network in Poland (NASK)</a>.
Andrzej credits the
<a href="http://www.cs.arizona.edu/xkernel/">
Xkernel</a>
as an antecedent inspiration.
The orignal Xkernel was apparently based on
a stripped-down version of SunOS (itself a BSD derivative).
</p>

<p>
Similar engineering problems often engender similar solutions,
and there has always been a need for PicoBSD-style systems.
For instance, I still find myself sometimes momentarily
confusing PicoBSD and 
<a href="http://www.mentec.com/mentecinc/SPDs/RSX11S.htm">
RSX-11S</a>
&nbsp;<a href="http://nucwww.chem.sunysb.edu/HTBIN/BOOK/DY4YAA56.DECW$BOOK/78">[1]</a>,
although I know I shouldn't...
I'm leaving in these links because there still might be an idea or two there...
</p>





<!================================================>
<a name="license">
<hr>
<h1>What type of license is PicoBSD under?</h1>

<p>
Again, PicoBSD is just FreeBSD, so it is under the
same BSD license as FreeBSD. The short version
of what the ``new BSD'' license means is that you
can use the code for any purpose, including your
own commercial products, but you cannot sue the
developers or make any claims in their name. Nobody
but you has liability for what you do with the code.
You do not have to give any code you write back to
anyone or make your code open source.
</p>









<p>&nbsp;</p>
<!================================================>
<a name="industrial">
<hr>
<h1>What should I know about industrial and embedded PCs?</h1>


<p>
This has become a huge industry. Industrial PC's are often intended
to be rack-mounted or mounted in small ``shoe-box'' enclosures.
Many industrial systems will cost considerably more than a stock
retail PC, as they are designed to operate reliably in
electrically noisy
environments.
</p>

<p>
Standard industrial motherboard form-factors today include <em>biscuit</em>
PC's that are the same size as a floppy drive, and <em>mini biscuits</em>,
which are about half the size of a biscuit. 
Also popular are <em>POS</em> motherboards, which stands for Point of Sale (which
means cash register). POS PCs often include a number of interesting 
I/O devices for interfacing scales, bar-code readers, 
drawer locks, and such.
</p>

<p>
Many of these boards are highly
integrated with many of the device controllers
directly on the motherboard. All but the <em>mini biscuits</em>
often support the 
<a href="http://www.pc104.org">
PC/104</a> bus. This is an embedded version of
the ISA bus with a smaller form-factor. It supports small boards
about 3.5 inches square which stack vertically on top of one another.
A new form-factor is the ``<em>half-biscuit</em>'', which is
a small motherboard about half the size of a conventional ATX motherboard
(not half the size of a biscuit).
These are popular for set-top boxes, home firewall applications, and such.
Integrated PC CPU chipsets are reaching the point where it is fairly
easy to build custom single-board PCs. Such <em>single-board computers</em>
are often called SBCs.
</p>

<p>
With most PCs, it is often not worth trying to get much smaller than the
biscuit form-factor, as the size of the connectors does not shrink
and comes to dominate the system. Power supplies also often
dominate system size.
</p>

<p>
In industrial environments in which size if not that important 
but custom boards or flexible hardware configurations are to be deployed
and reliability and maintenance is important,
<em>passive backplane</em> systems
are often used. These systems are not built around a traditional
PC motherboard,
but rather around a simple backplane containing a number of 
slots (typically
6 to 8). The CPU is mounted on a card inserted into one of
these slots. 
Passive backplanes are typically more reliable then a conventional
motherboard, which is large and is flexed when cards are inserted.
The use of passive backplanes tends to result in systems 
in which boards can rapidly be replaced and upgraded in the field,
resulting in reduced downtime.
These systems are highly configurable, 
usually well shielded from electrical noise, can often
support multiple CPU cards, and
resemble many ``old-fashioned'' computers.
Passive backplane versions of x86 PCs are common.
These systems appear largely indistinguishable from
any other PC as far as software is concerned, although
they often have a few additional ``standard'' devices,
such as a watchdog timer.
</p>




<p>&nbsp;</p>
<!================================================>
<a name="academic">
<p>&nbsp;</p>
<hr>
<h1>What are some university and academic groups using PicoBSD?</h1>

<p>&nbsp;</p>
<p>
The following are academic-related groups that use PicoBSD in research:
</p>

<p>&nbsp;</p>

<blockquote>
<p>
<a href="http://www.iet.unipi.it/~luigi/">Dr. Luigi Rizzo</a> of the 
<a href="http://www.iet.unipi.it/">Dipartimento di Ingegneria dell'Informazione</a> at the
<a href="http://www.unipi.it/princ.html">Universita di Pisa</a>
uses PicoBSD as a platform for network protocol research.
Contact: <a href="luigi@iet.unipi.it">luigi@iet.unipi.it</a>
</p>
<p>&nbsp;</p>



The 
<a href="http://turtle.ee.ncku.edu.tw/">Distributed System Lab</a> of the E.E. department at
<a href="http://www.ncku.edu.tw/english/index.html">National Cheng Kung University in Taiwan</a> is 
working on 
<a href="http://turtle.ee.ncku.edu.tw/sgcluster">fault-tolerant PicoBSD clusters</a>, 
primarily applied to routing and firewalls.
Contact: 
<a href="mailto:tung@turtle.ee.ncku.edu.tw">tung@turtle.ee.ncku.edu.tw</a>
</p>
<p>&nbsp;</p>


<p>
The 
<a href="http://www.telepresence.strath.ac.uk">Transparent Telepresence Research Group</a>
of the 
<a href="http://www.dmem.strath.ac.uk/Research/rsrch.htm">
Design, Manufacture and Engineering Management Department</a>
of the 
<a href="http://www.strath.ac.uk">
University of Strathclyde in Glasgow</a>
uses PicoBSD in Telepresense research.
Contacts: 
<a href="mailto:jen@vulture.dmem.strath.ac.uk">jen@vulture.dmem.strath.ac.uk</a>,
<a href="mailto:roger@cs.strath.ac.uk">roger@cs.strath.ac.uk</a>
</p>

</blockquote>





<p>&nbsp;</p>
<!================================================>
<a name="disadvantages">
<hr>
<h1>What are some disadvantages of PicoBSD?</h1>


<p>&nbsp;</p>
<p>
 &nbsp;&sect;&nbsp;&nbsp;  <b>Static ``linked-single-image'' flavor.</b>
</p>


<p>
 &nbsp;*&nbsp;&nbsp;  You can't copy or download an
arbitrary FreeBSD binary 
executable to the system and expect it to run, because
such a binary will usually dynamically
link to loadable libraries that are not present. You have to 
either explicitly build 
all executables into the ``crunched'' application image(s) or
statically link the downloadable 
application image so that it includes all needed library
routines (which will typically make the application much larger).
</p>

<p>
 &nbsp;*&nbsp;&nbsp; You have to decide in advance what overall functionality
you require (this is true, however, of many embedded systems).
</p>

<p>
 &nbsp;*&nbsp;&nbsp; Because all libraries are linked together,
there may be irreconcilable library dependencies that preclude
some combinations of libraries (and thus the executables that
depend on the libraries).
</p>

<p>
This is not just a ``theoretical'' problem. It can
occur is if you need a number of applications that all link
to the same library, and the library 
``assumes'' it is linked to a single application and 
keeps ``dirty'' global data. Libraries that reference
other libraries, or global data in other libraries, may have similar
problems. Library conflict problems can also arise from collision
on common names, for instance, <code>debug</code>.
Examples of these problems occur in the use of <code>ssh</code>
and NTP ``<code>libntp.a</code>'' libraries. The 
<a href="http://www.FreeBSD.org/cgi/cvsweb.cgi/ports/picobsd/ssh-picobsd/">PicoBSD <code>ssh</code> port</a>
was created to eliminate such problems with <code>ssh</code>,
but the general problem must be solved on a case-by-case basis.
</p>




<p>&nbsp;</p>
<p>
 &nbsp;&sect;&nbsp;&nbsp; <b>Not all FreeBSD features.</b>
</p>


<p>
 &nbsp;*&nbsp;&nbsp; There is no support for loadable kernel modules.
</p>

<p>
 &nbsp;*&nbsp;&nbsp; No X11. Depending on your needs, you may be able to use the
<a href="http://www.FreeBSD.org/cgi/man.cgi?query=vga&sektion=4"><code>vga</code></a>
 driver and 
<a href="http://www.FreeBSD.org/cgi/man.cgi?query=vgl&sektion=3"><code>vgl</code></a>.
</p>


<p>
 &nbsp;*&nbsp;&nbsp; The current version of PicoBSD provides no boot-phase
configuration. There is no 
<a href="http://www.FreeBSD.org/cgi/man.cgi?query=loader&sektion=8">
interactive FICL boot loader</a>, and there is no
kernel configuration utility. This means that you cannot simply include a
lot of drivers and then decide, during boot, what drivers to disable.
You should build in exactly what you need. This also may restrict
the utility of keeping ``standard'' system images.
</p>

<p>&nbsp;</p>
<p>
 &nbsp;&sect;&nbsp;&nbsp; <b>Running without a swap device can be dangerous.</b>
</p>

<p>
Because PicoBSD runs diskless, by default it
has no swap device. FreeBSD can become unhappy if it runs
out of memory and cannot swap.
</p>


<p>&nbsp;</p>
<p>
 &nbsp;*&nbsp;&nbsp; <b>Size.</b>
</p>
<p>
Because PicoBSD runs using a RAM-based
root file system, it may have a larger RAM footprint than
alternatives that do not use RAM-disk.
</p>



<p>&nbsp;</p>
<p>
 &nbsp;&sect;&nbsp;&nbsp; <b>Embedded development cycle.</b>
</p>

<p>
 &nbsp;*&nbsp;&nbsp; The application development cycle,
typical of embedded cross-development,
may be more complex than when the host and target system
are the same.
</p>


<p>
 &nbsp;*&nbsp;&nbsp; Not all the debugging and diagnostic programs that one is accustomed
to using are likely included in a PicoBSD
configuration. Thus, PicoBSD is rarely used as an
application development platform. (Consider it more for
the embedded deployment of a stable application).
</p>

<p>
 &nbsp;*&nbsp;&nbsp; It may be difficult (if not impossible)
to make persistent changes
to files across boots if you have not planned for the particular
update.
</p>

<p>
 &nbsp;*&nbsp;&nbsp; You must have the FreeBSD source tree installed
to develop for PicoBSD.
You need to have a FreeBSD system installed somewhere with
enough disk space to keep the FreeBSD source tree.
You need to be able to install and maintain FreeBSD, and have some
mechanism for tracking changes in the FreeBSD code base.
</p>



<p>&nbsp;</p>
<p>
 &nbsp;&sect;&nbsp;&nbsp; <b>No true cross-compilation.</b>
</p>

<p>
PicoBSD does not support a true cross-compilation
development cycle, that is, compiling on a machine such as an Alpha
and producing a system for a low-end PC. Typically, PicoBSD is compiled
on a large host-PC that can target a smaller embedded PC using the <em>same 
source code
tree</em> that compiled the host kernel
(albeit perhaps with a different kernel configuration file <code>cpu</code>
setting, and similar changes). 
</p>

<p>
Because PicoBSD is compiled directly from the installed FreeBSD source, this
cross-compilation incompatibility holds even between versions of FreeBSD.
That is, you cannot compile a version of PicoBSD based on the
FreeBSD 3.2 source under
FreeBSD 4.3, or compile 
a version of PicoBSD based on the FreeBSD 4.3 source
under FreeBSD 5.0, and so on.
</p>

<p>
This is an area receiving current development attention.
</p>



<p>&nbsp;</p>
<p>
 &nbsp;&sect;&nbsp;&nbsp; <b>Not hard real-time.</b>
</p>


<p>
Neither FreeBSD nor PicoBSD are particularly
good for true real-time applications (which is true of *ix
in general). If you need to control
an aileron using a hard real-time
system with predictable performance guarantees, PicoBSD is
probably not for you. Most PC hardware is not that great for
true real-time tasks either. 
However, that being said, many
actual embedded applications really
have relatively modest soft real-time requirements.
In addition, 
you can shovel many real-time programming tasks into drivers,
which by necessity are real-time.
Tracking a mouse on the screen, for instance, is a 
canonical real-time task.
Also, see 
``<a href="http://www.FreeBSD.org/cgi/man.cgi?query=kqueue&sektion=2"><code>man kqueue</code></a>''.
</p>

<p>
 PicoBSD is not a system that has been
expressly designed for embedded systems or for soft--real-time.
PicoBSD is just what it is, namely a version of FreeBSD that
has been built so as to run diskless and minimize the boot image
sufficient to fit on a floppy.
</p>


<p>&nbsp;</p>
<!================================================>
<a name="advantages">
<hr>
<h1>What are some advantages of PicoBSD?</h1>



<p>&nbsp;</p>
<p>
 &nbsp;&sect;&nbsp;&nbsp; <b>Affinity</b>
</p>

<p>
The PicoBSD code base <em>is</em>
FreeBSD, which includes the classic TCP/IP reference implementation. 
If you are familiar with FreeBSD (or any *ix),
you can use PicoBSD in
many embedded application scenarios without needing
to learn how to cross-develop for a
special-purpose embedded OS that has its own
tool-chain. The natural development environment for PicoBSD is 
classic, vanilla C. Your familiarity
with FreeBSD is directly useful in the embedded project.
If you install FreeBSD with sources, you have,
in PicoBSD, an entire embedded system development package 
with a complete tool-chain.
</p>

<p>&nbsp;</p>
<p>
 &nbsp;&sect;&nbsp;&nbsp; <b>Minimal feature-set</b>
</p>

<p>
Unlike the normal FreeBSD system,
in which many features default to being <em>in</em>
and you then decide what to throw out,
PicoBSD defaults to almost everything being <em>out</em>,
and you have to explicitly decide what to include.
This is an advantage is some types of engineering projects.
</p>




<p>&nbsp;</p>
<p>
 &nbsp;&sect;&nbsp;&nbsp; <b>Diskless</b>
</p>

<p>
PicoBSD runs everything 
out of RAM-disk,
which may provide a <b>performance benefit</b> for some 
applications. 
</p>

<p>
PicoBSD can boot from a
read-only device (for instance, a CD-ROM).
In this case, 
since files
are built into the filesystem inside the
kernel image, they cannot be permanently
edited.
This can be somewhat of a security benefit. 
</p>

<p>
A booted PicoBSD system does
not <em>require</em> a disk device (or any secondary storage
device).
</p>


<p>&nbsp;</p>
<p>
 &nbsp;&sect;&nbsp;&nbsp; <b>Enhanced fault-tolerance</b>
</p>

<p>
A default PicoBSD system can 
be 
<b>powered
off at anytime</b> 
without danger of corrupting any disks or 
requiring a lengthy <code>fsck</code> execution during the next boot.
(Naturally, this will not be true if you explicitly mount
hard-disks or similar devices).
Indeed, the default PicoBSD configurations do not contain the
<code>halt</code> or <code>shutdown</code> commands
(<code>reboot</code> is included).
</p>



<p>&nbsp;</p>
<p>
 &nbsp;&sect;&nbsp;&nbsp; <b>Controlled ``embedded-style'' configuration of the complete system</b>
</p>
<p>
You can't copy or download an
arbitrary FreeBSD binary 
executable to the system and expect it to work, because it likely
depends on loadable libraries that are not present. In some commercial,
production, and embedded environments in which all components
of a system are to be tested as a single package, this is
a ``release engineering'' advantage.
</p>

<p>
PicoBSD, as of FreeBSD 4.3,
does not use the standard FreeBSD 
<a href="http://www.FreeBSD.org/cgi/man.cgi?query=loader&sektion=8">
boot-Forth environment (FICL)</a>. 
PicoBSD simply ``boots-direct''.
Forth is very good for poking around in the hardware
from the console, booting alternative kernels,
and such. In an embedded scenario, you may not want 
to enable the 
computer ``operator'' to interact with the system boot
process in this fashion.
</p>

<p>
Because all executables are linked into a single image that itself is
included in the kernel file, multiple PicoBSD versions can
be stored in single bootable files
with each such file including all required applications and data files. Systems that have been
built with different application and configuration support will automatically load
with the correct applications, application support features, and required files.
</p>


<p>
PicoBSD is built from a single script
(<a href="file:/usr/src/release/picobsd/build/picobsd"><code>picobsd</code></a>). This script
contains two simple
menus. You can easily modify this script to run in batch mode,
and can also readily modify it to build a large number of systems,
similar or not (for
instance, all the elements of a cluster).
</p>


<p>&nbsp;</p>
<p>
 &nbsp;&sect;&nbsp;&nbsp; <b>Small self-contained system with no post-boot installation</b>
</p>

<p>
PicoBSD typically consists of
a single small <code>kernel</code> file
that can be compressed; 
this small kernel file is the only file
that needs to be transported or downloaded to boot a running
system.
</p>




<p>
PicoBSD is self-contained. 
Everything is in a single self-extracting file. 
In default PicoBSD, you
do not need to format and layout disk devices after
you initially boot the system. For the required root directory tree,
you specify the size and layout <em>before</em> you build the system.
</p>

<p>
PicoBSD naturally creates floppy
images that are easy to e-mail as attachments.
The entire bootable floppy system (the single ``<code>picobsd.bin</code>'' file), 
including the root file system
and all utilities needed to run, is small enough to be e-mailed
without undo trouble. This can be quite useful when
debugging a kernel, driver, or hardware specific feature in a 
world-wide programming group -- just mail your entire system
to a coworker to test/verify.
</p>

<p>
For some types of development, because of the
small system size, the development cycle is particularly fast.
This is especially true if you are booting via Ethernet (either
netbooting, or copying over the LAN to flash and then booting from 
flash).
</p>

<p>
PicoBSD is small enough that two versions of
PicoBSD can be kept on a small flash device. For instance, both
a ``current''
version and an ``old-good'' version of a PicoBSD can
be kept on a small 8Mbyte M-Systems DOC device.
</p>


<p>&nbsp;</p>
<p>
 &nbsp;&sect;&nbsp;&nbsp; <b>Supports easy generation of many related variants</b>
</p>

<p>
Because of the scheme in which a ``base collection'' of scripts is 
extended by scripts in private configuration directories, many related systems
can be generated at the same time with relative ease. This is a natural
way to generate systems for a slightly heterogenous cluster.
</p>

<p>&nbsp;</p>
<p>
 &nbsp;&sect;&nbsp;&nbsp; <b>Supports large host development for small targets</b>
</p>

<p>
Because the PicoBSD development cycle is essentially a cross-development 
cycle, it is naturally the case that one normally develops on as large
an interactive host machine as possible, while often targeting the smallest
PCs obtainable. This is usually the desired way to develop for small,
low-end machines.
</p>


<p>&nbsp;</p>
<p>
 &nbsp;&sect;&nbsp;&nbsp; <b>Enables student research projects</b>
</p>
<p>

<p>
Because PicoBSD is a cross-development system that 
rapidly makes a bootable floppy, 
PicoBSD provides a means for every student in a class
to build their own real system and experiment with their own system,
without the encumberances associated with the need for multiple
dedicated hard-disks. Students do, however, need to have root
access on the machine that  runs the <code>picobsd</code> script.
</p>

<p>
For certain types of student projects, it is desirable for
students to have a view of ``everything''. PicoBSD is 
good for this sort of project. For instance, the startup scripts are 
much smaller than for full-blown FreeBSD and many other
systems.
</p>

<p>
Because PicoBSD boots from floppy and runs diskless, you can use it to rapidly
experiment with different system software without performing
any system installation work. For instance, in a PC research
lab, a prototype
cluster could be constructed in minutes by booting all machines
from preconfigured PicoBSD floppies. 
After the experiemnt/evaluation is over, the PCs can be rebooted
to run their normal system.
</p>


<p>&nbsp;</p>
<p>
 &nbsp;&sect;&nbsp;&nbsp; <b>Cheap</b>
</p>
<p>
If you need a lot of systems
(a compute cluster)
but can implement your application on PicoBSD,
you can save a lot of money because you <b>do not need
to buy any hard disks</b>. Unlike many clustering scenarios,
in which NFS or some other distributed file system is
used, <b>no networked filesystem I/O is required</b>.
No file servers are required. 
</p>

<p>
 PicoBSD is a good way to turn an old legacy PC into a 
very low-cost router, firewall, homebrew platform, instrument controller,
or low-cost student lab machine. The cost is right.
</p>






<p>&nbsp;</p>
<!================================================>
<a name="man">
<hr>
<h1>What FreeBSD <code>man</code> pages should I read?</h1>

<p>&nbsp;</p>
<blockquote>
<p>
<code>
<a href="http://www.FreeBSD.org/cgi/man.cgi?query=picobsd&sektion=8">picobsd</a><br>
<a href="http://www.FreeBSD.org/cgi/man.cgi?query=crunchgen&sektion=1">crunchgen</a><br>
<a href="http://www.FreeBSD.org/cgi/man.cgi?query=crunchide&sektion=1">crunchide</a><br>
<a href="http://www.FreeBSD.org/cgi/man.cgi?query=mtree&sektion=8">mtree</a><br>
<a href="http://www.FreeBSD.org/cgi/man.cgi?query=vnconfig&sektion=8">vnconfig</a><br>
<a href="http://www.FreeBSD.org/cgi/man.cgi?query=vn&sektion=4">vn</a><br>
<a href="http://www.FreeBSD.org/cgi/man.cgi?query=ld&sektion=1">ld</a><br>
<a href="http://www.FreeBSD.org/cgi/man.cgi?query=dd&sektion=1">dd</a><br>
<a href="http://www.FreeBSD.org/cgi/man.cgi?query=disklabel&sektion=8">disklabel</a><br>
<a href="http://www.FreeBSD.org/cgi/man.cgi?query=disklabel&sektion=5">disklabel (5)</a><br>
<a href="http://www.FreeBSD.org/cgi/man.cgi?query=disktab&sektion=5">disktab</a><br>

<br>

<a href="http://www.FreeBSD.org/cgi/man.cgi?query=objdump&sektion=1">objdump</a><br>
<a href="http://www.FreeBSD.org/cgi/man.cgi?query=elf&sektion=5">elf</a><br>
<a href="http://www.FreeBSD.org/cgi/man.cgi?query=ldd&sektion=1">ldd</a><br>
<a href="http://www.FreeBSD.org/cgi/man.cgi?query=boot&sektion=8">boot</a><br>
<a href="http://www.FreeBSD.org/cgi/man.cgi?query=pxeboot&sektion=8">pxeboot</a><br>

<br>

<a href="http://www.FreeBSD.org/cgi/man.cgi?query=kqueue&sektion=2">kqueue</a><br>
<a href="http://www.FreeBSD.org/cgi/man.cgi?query=vga&sektion=4">vga</a><br>
<a href="http://www.FreeBSD.org/cgi/man.cgi?query=vgl&sektion=3">vgl</a><br>

<a href="http://www.gsp.com/cgi-bin/man.cgi?section=4&topic=io">io</a>
<a href="http://www.sinbad.wantabe.com/cgi-bin/bsdi-man?proto=1.0&query=io(4)&section=4&apropos=0">
&nbsp;[1]</a><br>

<br>

<a href="http://www.FreeBSD.org/cgi/man.cgi?query=bridge&sektion=4">bridge</a><br>
<a href="http://www.FreeBSD.org/cgi/man.cgi?query=dummynet&sektion=4">dummynet</a><br>
</code>
</p>
</blockquote>

<p>
See the file 
<a href="file:/usr/src/sys/i386/conf/LINT">
<code>/usr/src/sys/i386/conf/LINT</code></a>
for FreeBSD configuration file (<code>PICOBSD</code>) kernel options.
</p>

<p>&nbsp;</p>
<!================================================>
<hr>
<a name="doc">
<h1>Where is the PicoBSD documentation?</h1>

<p>&nbsp;</p>
<p>
See:
</p>

<p>
<a href="http://people.freebsd.org/~picobsd/">http://people.freebsd.org/~picobsd</a><br>
<a href="http://people.freebsd.org/~picobsd/small-tips.html">http://people.freebsd.org/~picobsd/small-tips.html</a><br>
</p>


<p>&nbsp;</p>

<p>
 &nbsp;&sect;&nbsp;&nbsp; Much of the available PicoBSD documentation is
somewhat dated. This is not necessarily a bad
thing, as it provides a history of
the project and its objectives.
PicoBSD originally existed independently
of the FreeBSD CVS source tree. It was folded into the
standard FreeBSD CVS source tree in 1999.
The best way to learn about PicoBSD is to
browse the PicoBSD sources in
<a href="file:/usr/src/release/picobsd">
<code>/usr/src/release/picobsd</code></a>
(if your source is not installed in <code>/usr/src</code>
you will need to manually enter the appropriate URL).
</p>

<p>&nbsp;</p>
<p>
 &nbsp;&sect;&nbsp;&nbsp;  The primary (old) documentation is 
``<a href="http://www.FreeBSD.org/cgi/man.cgi?query=picobsd&sektion=8"><code>man picobsd</code></a>''
and even older documentation (primarily ``<code>.htm</code>'' files)
is included in 
<a href="file:/usr/src/release/picobsd/doc/src">
<code>/usr/src/release/picobsd/doc/src</code></a>.
</p>

<blockquote>

<p>
There is a slightly dated
PicoBSD FAQ in
<a href="file:/usr/src/release/picobsd/doc/src/faq.html">
<code>/usr/src/release/picobsd/doc/src/faq.html</code></a>.
This FAQ primarily describes
FreeBSD 2.2.5-RELEASE and FreeBSD 3.2-RELEASE versions.
</p>

<p>
There is another slightly dated
PicoBSD FAQ in
<a href="file:/usr/src/release/picobsd/doc/src/intro.html">
<code>/usr/src/release/picobsd/doc/src/intro.html</code></a>,
which primarily describes FreeBSD 3.0 versions.
Note that the <code>man</code> page build instructions
are no longer accurate.
</p>

</blockquote>

<p>
See also the <code>README</code> files in
the 
<a href="file:/usr/src/release/picobsd/tinyware">
<code>/usr/src/release/picobsd/tinyware</code></a>
 subdirectories,
and the documentation at the top of the
<a href="file:/usr/src/release/picobsd/build/picobsd">
<code>/usr/src/release/picobsd/build/picobsd</code></a>
 script.
</p>

<p>
The <code>tinyware</code> README files are:
</p>

<p>
<blockquote>
<a href="file:/usr/src/release/picobsd/tinyware/msg/README">msg</a> 
 &nbsp;(alt. to <a href="http://www.FreeBSD.org/cgi/man.cgi?query=dmesg&sektion=8">dmesg</a>)<br>

<a href="file:/usr/src/release/picobsd/tinyware/ns/README">ns</a> 
 &nbsp;(alt. to <a href="http://www.FreeBSD.org/cgi/man.cgi?query=netstat&sektion=1">netstat</a>)<br>

<a href="file:/usr/src/release/picobsd/tinyware/oinit/README">oinit</a> 
 &nbsp;(alt. to <a href="http://www.FreeBSD.org/cgi/man.cgi?query=init&sektion=8">init</a> 
 and <a href="http://www.FreeBSD.org/cgi/man.cgi?query=sh&sektion=1">sh</a>)<br>

<a href="file:/usr/src/release/picobsd/tinyware/simple_httpd/README">simple_httpd</a> 
  &nbsp;(alt. to <a href="http://www.apache.org">httpd web server</a>)<br>

<a href="file:/usr/src/release/picobsd/tinyware/vm/README">vm</a> 
 &nbsp;(alt. to <a href="http://www.FreeBSD.org/cgi/man.cgi?query=vmstat&sektion=8">vmstat</a>)<br>

<br>(the following appear depricated)</br>
<a href="file:/usr/src/release/picobsd/tinyware/aps/README">aps</a><br>
<a href="file:/usr/src/release/picobsd/tinyware/sps/README">sps</a><br>
<a href="file:/usr/src/release/picobsd/tinyware/help/README">help</a><br>
<a href="file:/usr/src/release/picobsd/tinyware/view/README">view</a><br>
</blockquote>
</p>



<p>
It may be useful to examine the somewhat dated documentation
in 
<a href="file:/usr/src/release/picobsd/help">
<code>/usr/src/release/picobsd/help/</code></a>.
</p>



<p>&nbsp;</p>
<p>
 &nbsp;&sect;&nbsp;&nbsp; Academic citations, research literature,
and research web sites
related to PicoBSD are listed in the
section on
<a href="#web_app_doc">
Academic references</a>.
</p>





<p>&nbsp;</p>
<!================================================>
<a name="subscribe">
<hr>
<h1>How do I subscribe to the <code>freebsd-small@freebsd.org</code> mailing list?</h1>


<p>
See:
</p>

<blockquote>
<p>
<a href="http://www.freebsd.org/doc/en_US.ISO8859-1/books/handbook/eresources.html">
www.freebsd.org/doc/en_US.ISO8859-1/books/handbook/eresources.html</a>
</p>
</blockquote>


<p>&nbsp;</p>
<p>
<b>To subscribe</b>, send mail to ``<code>majordomo@freebsd.org</code>''. This mail will not
be read by a human; the body of the message should contain only:
</p>

<blockquote>
<p>
<code>
subscribe freebsd-small@freebsd.org
</code>
</p>
</blockquote>

<p>
You will get back a mail message containing an authorization code string.
Assuming this string is ``<code>foo</code>'', you then send a mail message back
to ``<code>majordomo@freebsd.org</code>'' with a message body 
 containing only:
</p>

<blockquote>
<p>
<code>
auth foo
</code>
</p>
</blockquote>


<p>&nbsp;</p>
<p>
<b>To unsubscribe</b>, send a mail message to ``<code>majordomo@freebsd.org</code>''
with the body:
</p>

<blockquote>
<p>
<code>
unsubscribe freebsd-small@freebsd.org
</code>
</p>
</blockquote>

<p>
You will also have to make an authorization reply.
</p>



<p>&nbsp;</p>
<!================================================>
<a name="small_archives">
<hr>
<h1>How do I browse the <code>freebsd-small@freebsd.org</code> mailing list archives?</h1>


<p>&nbsp;</p>

<p>
Browse the ``<code>freebsd-small@freebsd.org</code>'' mailing list at
``<code><a href="http://docs.freebsd.org/mail">http://docs.freebsd.org/mail</a></code>''.
Select a time-period and then select
``<code>freebsd-small.html</code>''.
To browse the current mail messages, select ``this week'' from the bottom
of the time-period list.
</p>

<p>&nbsp;</p>

To directly browse the <code>freebsd-small</code> archives for past years,
use the following:

<blockquote>

<a href="http://docs.freebsd.org/mail/archive/1998/freebsd-small">http://docs.freebsd.org/mail/archive/1998/freebsd-small</a><br>
<a href="http://docs.freebsd.org/mail/archive/1999/freebsd-small">http://docs.freebsd.org/mail/archive/1999/freebsd-small</a><br>
<a href="http://docs.freebsd.org/mail/archive/2000/freebsd-small">http://docs.freebsd.org/mail/archive/2000/freebsd-small</a><br>
<a href="http://docs.freebsd.org/mail/archive/2001/freebsd-small">http://docs.freebsd.org/mail/archive/2001/freebsd-small</a><br>

</blockquote>





<p>&nbsp;</p>
<!================================================>
<a name="web">
<hr>
<h1>What other PicoBSD-related web resources are available?</h1>




<p>&nbsp;</p>
<p>
&nbsp;&sect;&nbsp;&nbsp;The source.
</p>
<blockquote>
<p>
The PicoBSD CVSed source is browsable (with changelogs) on the web at
<a href="http://www.FreeBSD.org/cgi/cvsweb.cgi/src/release/picobsd">www.FreeBSD.org/cgi/cvsweb.cgi/src/release/picobsd</a>.
</p>
</blockquote>
<p>&nbsp;</p>


<p>&nbsp;</p>
<p>
&nbsp;&sect;&nbsp;&nbsp;FreeBSD Pico pages.
</p>
<blockquote>

<p>
<a href="http://www.freebsd.org/ports/picobsd.html">www.freebsd.org/ports/picobsd.html</a><br>
This page contains ports (applications) 
in the FreeBSD port tree
which are specific to PicoBSD. Currently a version of 
<a href="http://www.gsp.com/cgi-bin/man.cgi?section=1&topic=ssh"><code>ssh</code></a> intended to be
crunched into PicoBSD is the only port. See also
<a href="http://freshports.org/port-description.php3?port=5418">
http://freshports.org/port-description.php3?port=5418</a>.
</p>
<p>&nbsp;</p>

<p>
See the Small FreeBSD Home Page at
<a href="http://people.FreeBSD.org/~picobsd">http://people.FreeBSD.org/~picobsd</a>
and the
PicoBSD home page
at
<a href="http://people.FreeBSD.org/~picobsd/picobsd.html">http://people.FreeBSD.org/~picobsd/picobsd.html</a>.
</p>
<p>&nbsp;</p>





<p>
<a href="http://www.picobsd.pbg.pl">www.picobsd.pbg.pl</a><br>
A mirror of one of the early PicoBSD pages. This now 
appears primarily of historical interest.
<p>&nbsp;</p>


<a href="http://www.freebsd.org">www.freebsd.org</a><br>
This is the home of the FreeBSD project.

</blockquote>


<p>&nbsp;</p>
<p>
&nbsp;&sect;&nbsp;&nbsp;Miscellaneous pages.
</p>
<blockquote>
<p>&nbsp;</p>

<a href="http://www.freebsd.org/doc/en_US.ISO8859-1/articles/solid-state/index.html">
www.freebsd.org/doc/en_US.ISO8859-1/articles/solid-state/index.html</a><br>
The article <em>FreeBSD and Solid State Devices</em>,
by John Kozubik.
</p>
<p>&nbsp;</p>

<a href="http://www.munts.com/diskless/netboot.pdf">www.munts.com/diskless/netboot.pdf</a><br>
The paper, <em>Network Booting i386 Unix Variants</em>,
by Philip Munts.
<p>&nbsp;</p>


<a href="http://matt.simerson.net/computing/freebsd.netboot.shtml">
http://matt.simerson.net/computing/freebsd.netboot.shtml</a><br>
The web-paper <em>Booting FreeBSD with PXE</em>.
<p>&nbsp;</p>

<a href="http://www.cse.ucsc.edu/~brucem/fbsd_links.htm">www.cse.ucsc.edu/~brucem/fbsd_links.htm</a><br>
This is a page I maintain with academic-oriented (grad student) FreeBSD links.
<p>&nbsp;</p>



</blockquote>


<p>&nbsp;</p>
<p>
&nbsp;&sect;&nbsp;&nbsp;Similar Systems.
</p>
<blockquote>
<p>&nbsp;</p>

<a href="http://www.embsd.org">www.embsd.org</a><br>
<b>emBSD</em> is a stripped down version of OpenBSD primarily used
for routers and firewalls.

<p>&nbsp;</p>


<a href="http://www.gnatbox.com">www.gnatbox.com</a><br>
The folks at GTA note that their Gnat box product was the
``inspiration'' for PicoBSD...
Their 
<a href="http://www.gnatbox.com/Pages/faq.html">FAQ</a>
has some interesting information and ideas...

<p>&nbsp;</p>

<a href="http://busybox.lineo.com">http://busybox.lineo.com</a><br>
The Busybox is essentially Linux PicoBSD-ized...
It grew out of Debian boot disk technology.
See also 
<a href="http://www.linuxdevices.com/articles/AT4802795572.html">
www.linuxdevices.com/articles/AT4802795572.html</a><br>
<a href="http://www.trinux.org">Trinux</a>
is based on Busybox,
see 
<a href="http://trinux.sourceforge.net">http://trinux.sourceforge.net</a>.

<p>&nbsp;</p>
<a href="http://www.linuxrouter.org">www.linuxrouter.org</a><br>
The Linux Router Project (LRP).

<p>&nbsp;</p>
<a href="http://learn.western.tec.wi.us/aev/linux/router_freesco_v026.htm">
http://learn.western.tec.wi.us/aev/linux/router_freesco_v026.htm</a><br>
Freesco is a single-floppy Linux router.

<p>&nbsp;</p>
<a href="http://sourceforge.net/projects/mobsd">http://sourceforge.net/projects/mobsd</a><br>
The <em>Micro OpenBSD</em> project.
This project appears attempting to create a floppy-based
version of OpenBSD ``<em>...inspired by emBSD, PicoBSD and Trinux.</em>''


<p>&nbsp;</p>
<a href="http://www.embedded-linux.org">www.embedded-linux.org</a><br>
The Embedded Linux Consortium.

<p>&nbsp;</p>
<a href="http://bengross.com/smallunix.html">http://bengross.com/smallunix.html</a><br>
A portal with links to small/embedded *ix systems and projects.


<p>&nbsp;</p>
<a href="http://www.cotse.com/miniunix.htm">www.cotse.com/miniunix.htm</a><br>
Another portal with links to small/embedded *ix systems and projects.



</blockquote>


<p>&nbsp;</p>
<p>
&nbsp;&sect;&nbsp;&nbsp;A Few PC Bit-twiddling pages...
</p>
<blockquote>

<p>&nbsp;</p>
<a href="http://et.nmsu.edu/~etti/fall96/computer/printer/printer.html">
http://et.nmsu.edu/~etti/fall96/computer/printer/printer.html</a><br>
<em>Use of a PC Printer Port for Control and Data Acquisition</em>,
by Peter H. Anderson.


<p>&nbsp;</p>
<a href="http://www.beyondlogic.org/spp/parallel.htm">www.beyondlogic.org/spp/parallel.htm</a><br>
<em>Interfacing the Standard Parallel Port</em>, by Craig Peacock.


<p>&nbsp;</p>
<a href="http://www.beyondlogic.org/epp/epp.htm">www.beyondlogic.org/epp/epp.htm</a><br>
<em>Interfacing the Enhanced Parallel Port</em>, by Craig Peacock.


<p>&nbsp;</p>
<a href="http://www.beyondlogic.org/serial/serial.htm">www.beyondlogic.org/serial/serial.htm</a><br>
<em>Interfacing the Serial / RS232 Port</em> (part 1),  by Craig Peacock.<br>
Also,
<a href="http://www.beyondlogic.org/serial/serial1.htm">www.beyondlogic.org/serial/serial1.htm</a>
(part II).


<p>&nbsp;</p>
<a href="http://www.beyondlogic.org/keyboard/keybrd.htm">www.beyondlogic.org/keyboard/keybrd.htm</a><br>
<em>The PC's keyboard</em>, by Craig Peacock.


<p>&nbsp;</p>
<a href="http://www.beyondlogic.org/interrupts/interupt.htm">www.beyondlogic.org/interrupts/interupt.htm</a><br>
<em>Using Interrupts</em>, by Craig Peacock.

</blockquote>




<p>&nbsp;</p>








<p>&nbsp;</p>
<!================================================>
<a name="web_app_doc">
<p>&nbsp;</p>
<hr>
<h1>What are some academic references and web sites that describe research using PicoBSD?</h1>


<p>&nbsp;</p>
<p>
<a href="http://www.iet.unipi.it/~luigi/COST264/mcm990207/#rizzo">
www.iet.unipi.it/~luigi/COST264/mcm990207/#rizzo</a><br>
This is the abstract for the paper, 
<em>Some FreeBSD-based tools to support networking research and experimentation</em>,
COST264, 8 Feb 1999, from the COST264 workshop on 
<em>Enabling Networked Multimedia Group Communication</em>.
The slides for this talk are online at:
<a href="http://www.iet.unipi.it/~luigi/COST264/mcm990207/rizzo">
www.iet.unipi.it/~luigi/COST264/mcm990207/rizzo</a>.

<p>&nbsp;</p>
<p>
The only published <b>academic reference</b> of which I am aware that is
directly concerned with PicoBSD is
``<a href="http://www.math.utah.edu:8080/pub/tex/bib/idx/sigplan2000/35/8/15-17.html">
<em>Forth and the  FreeBSD Bootloader</em></a>'', Paul Frenger,
<em>ACM SIGPLAN Notices</em>, August 2000, v.35, n.8, pp.15-17.
Despite the title, about half of this small 3-page paper is 
devoted to PicoBSD, in its capacity as a ``single-floppy''
means to run Forth. The interactive FreeBSD FICL bootloader
is a portable implementation of Forth.
To minimize size, the FICL boot loader is no longer built into PicoBSD.
</p>

<p>&nbsp;</p>
<p>
<a href="http://turtle.ee.ncku.edu.tw/sgcluster">turtle.ee.ncku.edu.tw/sgcluster</a><br>
This web-site describes the SG cluster system, which
clusters PicoBSD for load balancing and high availability in NAT and VPN
type applications.
</p>

<p>&nbsp;</p>
<p>
<a href="http://www.prevelakis.net/Usenix/secnet.html">www.prevelakis.net/Usenix/secnet.html</a><br>
This paper, <em>A Secure Station for Network Monitoring and Control</em>, 
describes the ``PicoBSD-ization'' and deployment of a custom system
based on OpenBSD. The system appears to have
evolved from PicoBSD scripts and
was developed to implement network management and security nodes
at the University of Piraeus in Greece. Despite being based on OpenBSD, 
this paper and those cited immediately below all contain a clear page-long high-level
summary of PicoBSD.<br>
&nbsp;*&nbsp;&nbsp;See also
``<a href="http://www.usenix.org/events/sec99/full_papers/prevelakis/prevelakis.pdf">
www.usenix.org/events/sec99/full_papers/prevelakis/prevelakis.pdf</a>''.<br>
&nbsp;*&nbsp;&nbsp;See also
``<a href="http://www.cis.upenn.edu/~vassilip/TechRep-MS-CS-00-21.pdf">
www.cis.upenn.edu/~vassilip/TechRep-MS-CS-00-21.pdf</a>'',
 <em>The Shrink-Wrapped VPN Node</em>,
by Vassilis Prevelakis and Angelos Keromytis,
Technical Report MS-CIS-00-21,
Digital Systems Laboratory,
Department of Computer and Information Science,
University of Pennsylvania.<br>
&nbsp;*&nbsp;&nbsp;See also
``<a href="http://csweb.rau.ac.za/ifip/workgroup/docs1999/07_sec1999.pdf">
http://csweb.rau.ac.za/ifip/workgroup/docs1999/07_sec1999.pdf</a>'',
<em>A Secure Station for Network Monitoring and Control</em>,
by Vassilis Prevelakis.
</p>








<p>&nbsp;</p>
<!================================================>
<a name="headless">
<hr>
<h1>How do I make PicoBSD on a PC run ``headless'' (without monitor and keyboard)?</h1>

<p>
A normal PC with a default BIOS setup cannot run without a keyboard.
It will produce an error message such as ``<code>Press F1 to Resume</code>''.
Many older systems will not run without a video card; the system will
enter a ``beep loop'' sending out a beep sequence that indicates a
fatal video controller initialization error.
</p>

<p>
There are a number of ways to make a PC run headless. This is particularly
useful when you want to turn an old PC into an
Internet router in a box, an Internet-enabled embedded
instrument manager, or part of a home-brew cluster.
</p>

<p>
&nbsp;&sect;&nbsp;&nbsp; Many new PC BIOSes can simply be told to ignore errors encountered
when trying to initialize the video card and keyboard
at BIOS boot-time. With a monitor and
keyboard attached, enter the BIOS setup program and search for a setting
such as ``<code>Errors:</code>'', ``<code>Halt on:</code>'', or ``<code>Ignore</code>''.
Often you can set this field to ``<code>Any, but keyboard and video</code>'',
or even ``<code>none</code>''.
</p>

<p>
&nbsp;&sect;&nbsp;If the BIOS requires a video card, find a used card with a standard
VGA chipset (like Trident). It will not need a connected monitor.
This is a great use for those cards from a
$5 all-used-cards barrel, no
refunds. Most will work sufficiently to enable booting.
</p>

<p>
&nbsp;&sect;&nbsp;&nbsp;If your BIOS requires a keyboard, get an old keyboard, take it apart,
and connect the small ``keyboard motherboard'' to the motherboard's
keyboard connector. The ``keyboard motherboard'' is typically a small
printed-circuit board about 1 inch by 9.5 inches. It usually contains only
a single IC. One end of the keyboard cable will be connected to
the ``keyboard motherboard''. You may want to reduce the length of the connector
cable. There is no cheap, easy way to wire something to the PC keyboard
connector that will ``fake'' the keyboard
(available devices that do this cost as much as 5 times a used keyboard).
The keyboard is actually a small embedded real-time computer (originally
an Intel 8048). It communicates
with the PC using a simple protocol based on 11-bit ``serial data units''
(SDUs).
</p>

<p>
To take a keyboard apart, find 5 or 6 slots 
that will be located on one of the edges,
insert a flat-head screwdriver, and flex and wiggle. The keyboard
clamshell will pop open. Another dozen or so small latches will 
hold the
key-mount board to the clamshell bottom. Use a needle-nose or
screwdriver to 
unlatch a few of these, then grab one end of the key-mount board and separate
from the clamshell bottom (this may take some force but the key-mount
board with all the keys will come off cleanly). You should now
be able to remove the "keyboard motherboard', being careful to
work loose the attached keyboard connector cable (it is usually not fastened
but just twisted into a holder). Attached to the "keyboard
motherboard" will be a large 1.5 foot by .5 foot poly-flex circuit
(mylar sheet). This mylar sheet is attached to the "keyboard
motherboard" by a 35-pin conductive snap that clamps the mylar
to the small motherboard. Work the mylar out of the snap and work
the snap loose at the same time. <b>Be sure to remove the snap
completely from the ``keyboard motherboard''</b>. 
If the mylar is removed and the snap left in place,
when the keyboard controller is connected and power to your PC
turned on,
all keyboard circuits are shorted, which will result in a large power-draw
and typically smoke will then emerge from the vicinity of your keyboard connector
on the PC's motherboard. 
</p>

<p>
You should not swap (plug or unplug) a keyboard connector
with the motherboard powered up.
</p>

<p>
&nbsp;&sect;&nbsp;&nbsp; If you are collecting old PCs to use as routers
or cluster test-beds, you may have to deal with lost BIOS passwords.
Most BIOSes have the ability to save some sort of password in the
real-time clock CMOS. If set, by the time you get the machine
and want to run it headless,
the password will have been long forgotten. The security provided by these passwords is of the
``irritation'' variety. A quick web search will typically provide dozens
of programs, most of which are DOS ``<code>.exes</code>'', that will decode
and display the passwords.
</p>

<p>
If your junk PC has an AMI BIOS (American
Megatrends), and you are in a hurry or don't have DOS,
you can do the following (it's not pretty).
</p>

<p>&nbsp;</p>
<small>
<blockquote>
<p>
&nbsp;&sect;&nbsp;&nbsp; Modify
kernel source file 
``<code>/usr/src/sys/kern/tty.c</code>'' in your PicoBSD kit and
change the code at the top of <code>ttyinput()</code>
to be similar to the following (this is for FreeBSD 4.3;
adjust for other versions if need be). Insert the code
fragments between the ``<code>AMIBIOS PWD DECODE</code>'' comments:
</p>

<small>
<code>
<pre>
/*
 * Process input of a single character received on a tty.
 */
int
ttyinput(c, tp)
	register int c;
	register struct tty *tp;
{
	register tcflag_t iflag, lflag;
	register cc_t *cc;
	int i, err;
/* AMIBIOS PWD DECODE (start) */
int ioadr,val;
unsigned char  pswd[10];
unsigned char  ch,cl,dh,dl;
/* AMIBIOS PWD DECODE (end) */
	/*
	 * If input is pending take it first.
	 */
	lflag = tp->t_lflag;
	if (ISSET(lflag, PENDIN))
		ttypend(tp);
	/*
	 * Gather stats.
	 */
	if (ISSET(lflag, ICANON)) {
		++tk_cancc;
		++tp->t_cancc;
	} else {
		++tk_rawcc;
		++tp->t_rawcc;
	}
	++tk_nin;

	/*
	 * Block further input iff:
	 * current input > threshold AND input is available to user program
	 * AND input flow control is enabled and not yet invoked.
	 * The 3 is slop for PARMRK.
	 */
	iflag = tp->t_iflag;
	if (tp->t_rawq.c_cc + tp->t_canq.c_cc > tp->t_ihiwat - 3 &&
	    (!ISSET(lflag, ICANON) || tp->t_canq.c_cc != 0) &&
	    (ISSET(tp->t_cflag, CRTS_IFLOW) || ISSET(iflag, IXOFF)) &&
	    !ISSET(tp->t_state, TS_TBLOCK))
		ttyblock(tp);

/* AMIBIOS PWD DECODE (start) */

 if( c == '.' ) {
   printf( "\n------ CMOS Contents---\n" );
   
   /* ioadr = 0x0E; */
   ioadr = 0xB7;
   for(i=0;i<7;i++,ioadr++) {
       outb( 0x70, ioadr );
       val = inb( 0x71 );
       printf( "\n cmos of=%x adr=%x v=%x ", i, ioadr, val );

       pswd[i] = val;
   }
   printf( "\n----\n\n" );

   pswd[0] &= 0xF0;

   for(i=1;i<8;i++) {
      if( 0 == pswd[i] ) break;

      cl = 0;
      ch = pswd[i-1];

      for(;;) {
         cl++;
         dh = dl = 0;

         if( ch & 0x80 ) dh++;
         if( ch & 0x40 ) dh++;
         if( ch & 0x02 ) dh++;
         if( ch & 0x01 ) dh++;

         while( dl < dh ) dl += 2;

         dl -= dh;
         ch >>= 1;
         if( 1 == dl ) {
             ch += 0x80;
         }
         if( ch == pswd[i] ) break;

      } /* End decrypt loop. */

      printf( " decr=%x (%c) ", cl, cl );
   } /* End for input chars */

 }

/* AMIBIOS PWD DECODE (end) */

</code>
</pre>
</small>

<p>
&nbsp;&sect;&nbsp;&nbsp; Build PicoBSD, and boot the PicoBSD
floppy. At the prompt, whenever you press ``<code>.</code>'',
the BIOS password should be displayed (consisting of the characters
between the ``<code>()</code>''s). Use this password to
enter the BIOS and change the password. Entering a null password
will usually disable BIOS password protection.
</p>

</blockquote>
</small>

<p>
 If you have equivalent code of other BIOSes, please let me know.
Decoding these from an existing ASM takes about 2 hours.
</p>

<p>
&nbsp;&sect;&nbsp;&nbsp; All you need to run stock PicoBSD with TCP/IP is an Ethernet controller,
a floppy controller, and (perhaps) a video controller. Many new
motherboards include all these controllers directly on the motherboard.
The remanents of
many old junk PC's contain these components in completely working form.
</p>

<p>
When using PicoBSD on a headless system with an Ethernet controller,
you will need to modify the 
``<code>./floppy.tree/etc/rc.conf</code>'' script in your config directory.
The default ``<code>rc.conf</code>'' behavior is to prompt at 
PicoBSD boot time to
``<code>Please enter a hostname and IP address for your system</code>''.
Depending on your circumstances, you may want to hardcode the 
hostname and IP address by recoding routine <code>read_address()</code>
in ``<code>rc.conf</code>'' to contain lines such as the following:
</p> 

<blockquote>
<p>
<code>
hostname=slowsys<br>
the_ip=192.168.0.30<br>
</code>
</p>
</blockquote>


<p>
&nbsp;&sect;&nbsp;&nbsp; It is easy to operate PicoBSD using just a motherboard, power supply,
and floppy drive. You do not even need to use a PC case, which is
useful for applications such as home-brew clustering. Be careful to
avoid shorting the board and assure reasonable air-flow. 
Most hardware stores carry 8-32 nylon bolts of various lengths.
These fit the mounting holes on typical motherboards (even biscuits),
and can be used to make custom mounts.
</p>

<p>
When resurecting an old computer, it is worth taking the
whole system apart and going over everything at close range with a normal household
vacuum cleaner, making sure all the empty slots and chip pins
are free from dust. Beware any loose jumper straps... 
If the system has been in a chemically ``dirty'' environment for
a long time, you may want to take the boards out and clean
the gold contact pins. Use a rubber eraser to remove
any ``scum-film'' build-up from gold surfaces.
Without the hard-disk, many old systems will run fine.
</p>

<p>
As compact
flash and M-systems flash devices become cheaper and common, it will
be increasingly easy to replace the floppy. Alternatively, if the
Ethernet controller supports PXE (the <em>Preboot Execution Environment</em>
standard), you can boot the PicoBSD <code>kernel</code>
file directly over the network, that is, use the LAN controller as your boot
device.
</p>









<p>&nbsp;</p>
<!================================================>
<a name="server">
<hr>
<h1>How do I use PicoBSD to make a cheap diskless web server?</h1>

<p>&nbsp;</p>


<p>
&nbsp;&sect;&nbsp;&nbsp; A simple web-server is very easy to write, and running
a web-server on a RAM-disk has its advantages. A small
sample web-server suitable for including in PicoBSD is located at:
</p>

<p>
<a href="file:/usr/src/release/picobsd/tinyware/simple_httpd">
<code>
/usr/src/release/picobsd/tinyware/simple_httpd
</code>
</a>
</p>

<p>
The <code>simple_httpd</code> server
is only around 500 lines-of-code and 25 Kbytes when compiled.
To add it to your PicoBSD system,
assure that the following lines are in your
``<code>crunch.conf</code>'' file and rebuild your PicoBSD configuration:
</p>

<p>
<blockquote>
<code>
srcdirs /usr/src/release/picobsd/tinyware<br>
progs simple_httpd<br>
</code>
</blockquote>
</p>


<p>
Once the PicoBSD system boots, do the following on the PicoBSD system,
or put the equivalent commands in the startup scripts:

<p>
<blockquote>
<code>
#cd /<br>
#mkdir httphome<br>
#cp /etc/motd /httphome/index.html   # (or somesuch)<br>
#simple_httpd -d /httphome -l /dev/null &<br>
</code>
</blockquote>
</p>

<p>
This makes <code>/httphome</code>, which is the
default, the root directory of your web-pages
and discards the server log.
The <code>cp</code> command in this example
simply creates a home-page for your web-site;
in practice this will be a custom file of
yours instead of the <code>motd</code> file.
</p>

<p>&nbsp;</p>
<p>
Now you can use a
browser, such as Netscape,  from another system to
access your PicoBSD web-server. For instance,
if you are in a lab environment
and your PicoBSD system has a private
IP address of 172.16.0.5, you could issue a
command such as:
</p>

<blockquote>
<p>
<code>
#netscape 172.16.0.5 &
</code>
</p>
</blockquote>



<p>&nbsp;</p>
<p>
&nbsp;&sect;&nbsp;&nbsp; You might want to run the web-server in 
visual logging mode
on the PicoBSD console (or on an
alternate virtual console) using
the ``<code>-D</code>'' switch, which indicates that the program is to run
in the foreground and not to ``daemonize''. On PicoBSD this is
an easy way to
see current log activity without bothering to store the log anywhere:
</p>

<blockquote>
<p>
<code>
#simple_httpd -d /httphome -D 
</code>
</p>
</blockquote>




<p>&nbsp;</p>
<p>
&nbsp;&sect;&nbsp;&nbsp; You can operate the web-server
as a dedicated <code>fetch</code> server.
See the <code>README</code> documentation in the 
<a href="file:/usr/src/release/picobsd/tinyware/simple_httpd">
<code>tinyware/simple_httpd</code>
</a>
directory. 
</p>


<p>&nbsp;</p>
<p>
&nbsp;&sect;&nbsp;&nbsp; The <code>simple_httpd</code> server will only
use port 80 (the HTTP port) if it is run as root (otherwise
it uses port 1080).
</p>

<p>
&nbsp;&sect;&nbsp;&nbsp; Because the ``<code>simple_httpd.c</code>'' server is only 480 lines of code,
it can easily be modified...
</p>




<p>&nbsp;</p>
<!================================================>
<a name="instrument">
<hr>
<h1>How do I use PicoBSD to make a cheap Internet-enabled instrument?</h1>

<p>&nbsp;</p>


<p>
One easy way to start might be to simply create web pages
on-the-fly for the <code>simple_httpd</code> server 
described in the previous section. Of course, you can
enhance the server to any degree or 
write your own socket-based Internet 
data acquisition system of almost any
complexity...
</p>


<p>&nbsp;</p>
<!================================================>
<a name="io">
<hr>
<h1>How do I directly access I/O devices from an application program
(use <code>in</code> and <code>out</code> instructions)?</h1>

<p>&nbsp;</p>

<p>
For quick-and-dirty embedded hardware work it is often useful
to directly read and write device registers in I/O space from 
within an application program.
This can be much easier than developing a complete driver, and is
appropriate when you need to do an ``experiment'' with only a few minutes
of overhead.
 Many old DOS C compilers (such as Borland's Turbo C) had very
good support for such operations, including interrupt support.
</p>

<p>
In PicoBSD (or FreeBSD), open ``<code>/dev/io</code>''. Until you close
the handle you obtained from <code>open()</code>, you can read and
write I/O space using calls such as <code>inb()</code>, <code>outb()</code>,
<code>inl()</code>, and <code>outw()</code>.
Hold the handle for as short a period as possible.
</p>

<p>
The following example program 
``turns-on'' a 16550 UART output pin in the COM1 serial port (pin DTR, Data Terminal Ready).
This is done by setting a bit (bit 1) in the 
COM1 modem control register.
The COM1 modem control register is almost always, on a PC,
at I/O space address 0x3fc:
</p>

<blockquote>
<code>
<pre>
// turn_on.c

#include &lt;stdio.h>
#include &lt;fcntl.h>

// Get inb()/outb() macros.
#include &lt;/usr/src/sys/i386/include/cpufunc.h>

main() {
int ios;

   printf( "\n *** ON!\n" );

  /*----- Gain access to I/O space. */
  ios = <b>open( "/dev/io",</b> O_RDONLY );
  if (0 > ios ) {
     close( ios );
     perror("unable to open /dev/io");
     exit(1);
  }

  <b>outb( 0x3fc, 0x01 );</b>  // Set DTR (bit 1) in Modem Ctrl reg of COM1.

  <b>close( ios );</b>
  /*----- Release I/O space. */

}
</pre>
</code>
</blockquote>

<p>
See the file 
``<a href="file:/usr/src/sys/i386/include/cpufunc.h"><code>/usr/src/sys/i386/include/cpufunc.h</code></a>''
for the other calls that you can use. Build this
program as described in the 
<a href="#app">
section on building
your own application</a>.
</p.

<p>
A program to turn DTR off would be:
</p>


<blockquote>
<small>
<code>
<pre>

// turn_off.c

#include &lt;stdio.h>
#include &lt;fcntl.h>

// Get inb()/outb() macros.
#include &lt;/usr/src/sys/i386/include/cpufunc.h>


main() {
int ios,reg_val;

   printf( "\n *** OFF!\n" );

  /*----- Gain access to I/O space. */
  ios = <b>open( "/dev/io",</b> O_RDONLY );
  if (0 > ios ) {
     close( ios );
     perror("unable to open /dev/io");
     exit(1);
  }

  reg_val  = <b>inb( 0x3fc );</b>
  reg_val &= ~0x01;
  <b>outb( 0x3fc, reg_val );</b> // Clear DTR on Modem Ctrl reg of COM1.

  <b>close( ios );</b>
  /*----- Release I/O space. */

}
</pre>
</code>
</small>
</blockquote>



<p>
Electronics suppliers sell
small, cheap devices that can display the state of the
serial-line pins. The more complex devices are often
called ``break-out boxes'' and allow you to strap
pins in various ways. At the low end, LEDs display the
state of the pins.
Radio Shack sells a <em>RS232
Mini-Tester</em> for around $10. This is
the size of a null modem and contains a 
state LED for the 7 most commonly used serial-line pins.
It can easily be used with the above two programs to
verify that your program is performing I/O operations.
Some URLs listing such devices:<br>
<small>
<a href="http://www.scancat.com/minitstr.html">www.scancat.com/minitstr.html</a><br>
<a href="http://www.rpelectronics.com/English/Content/Items/TG-339.asp">
www.rpelectronics.com/English/Content/Items/TG-339.asp</a><br>
</small>

<p>
Three serial-line pins that can easily be used as
LED status toggles (or for other purposes) are:
</p>


<center>
<table  frame=box border=2 >
<tr><td>Pin</td><td>COM1 I/O Register Address</td><td>Register Bit</td>
<tbody>
<tr><td>DTR</td><td>34c</td><td>0x01</td></tr>
<tr><td>RTS</td><td>34c</td><td>0x02</tr>
<tr><td>BREAK</td><td>34b</td><td>0x40</tr>
</tbody>
</table>
</center>
<p>&nbsp;</p>

<p>
See also:
<a href="http://www.daemonnews.org/200107/dasblinkenlights.html">
www.daemonnews.org/200107/dasblinkenlights.html</a>.
</p>










<p>&nbsp;</p>
<!================================================>
<a name="msys">
<hr>
<h1>How do I put PicoBSD on a flash disk?</h1>


<p>&nbsp;</p>
<p>
&nbsp;&sect;&nbsp;&nbsp; There are currently two major types of flash disks in use
on small x86 PC-based embedded systems. 
</p>

<p>
The so-called <em>Compact Flash</em>,
or <em>CF</em>, devices appear exactly to the system
as an IDE hard disk, that is, they contain a complete
IDE drive controller. These devices are very easy to
use (there is no new software required). These
devices are typically about half the size of a 
PCMCIA card.
</p>

<p>
The <em>M-systems DiskOnChip</em> flash devices (often called a
<em>DOC</em>) are useful when a small on-board flash disk
is required. Looking at a motherboard,
these physically resemble a typical BIOS
ROM. These devices require a special driver to enable them
to be accessed as a native disk device. Most motherboards
that include an M-Systems DOC support a BIOS that can boot
from the DOC. Currently DOCs come in 2M, 8M, and 256M sizes.
</p>


<p>&nbsp;</p>
<p>
&nbsp;&sect;&nbsp;&nbsp; FreeBSD (and PicoBSD) make use of the M-Systems DOC
devices via the <code>fla</code> driver.
The <code>fla</code> driver source is located in a slightly
unusual location in the FreeBSD source tree,
<a href="file:/usr/src/sys/contrib/dev/fla">
<code>/usr/src/sys/contrib/dev/fla</code></a>.
This location is used because 
FreeBSD <code>fla</code> driver development was funded
by M-Systems 
(<a href="http://www.m-sys.com">www.m-sys.com</a>) and is under an M-Systems
license instead of the
standard BSD license. The license appears to be a
typical commercial open source license that takes
pains to make it clear that you can't sue M-Systems.
</p>

<p>
The important steps described in this section are:
</p>

<p>
&nbsp;*&nbsp;&nbsp; Add the <code>fla</code> driver to the kernel.<br>

&nbsp;*&nbsp;&nbsp; Put a FreeBSD disk label on the DOC and create a 
FreeBSD filesystem.<br>

&nbsp;*&nbsp;&nbsp; Put a bootable kernel on the DOC.<br>
</p>

<p>
 The following section 
assumes a PicoBSD configuration
directory named <code>mysys</code>.


<p>&nbsp;</p>
<p>
&nbsp;&sect;&nbsp;&nbsp; <b>Add the <code>fla</code> driver to the kernel.</b><br>
</p>


<p>
Compile in the <code>fla</code> device driver.
In your <code>PICOBSD</code> configuration file add the device lines:
</p>

<p>
<code>
device          fla0    at isa?
</code>
</p>

<p>
Next, 
create the <code>fla</code> device node. Edit your
<code>config</code> file and add
to it a device named ``<code>fla0</code>''. A typical
<code>config</code> file might appear as:
</p>

<p>
<code>
MY_DEVS="std tun2 vty10 fd0 fla0 pty0 cuaa0 cuaa1 bpf0 bpf1 bpf2"
</code>
</p>

<p>
Add the utilities needed to initialize a FreeBSD
file-system to the PicoBSD build. Edit 
your ``<code>crunch.conf</code>'' file and
in the <code>progs</code> section
add the following lines if they do not already
exist. PicoBSD configuration files can vary greatly,
so check
the file contents.

<p>
<code>
 progs disklabel<br>
 progs newfs<br>
 progs dd<br>
</code>
</p>

<p>&nbsp;</p>
<p>
&nbsp;&sect;&nbsp;&nbsp; <b>Put a disk label on the DOC.</b><br>
</p>

<p>
For the DOC to be used as a ``normal'' FreeBSD (PicoBSD) disk,
the DOC must have a valid disk label. 
This disk label describes the disk geometry,
among other things. 
The <code>disklabel</code> program is used to create such labels,
in conjunction with the <code>/etc/disktab</code> file,
which contains a 
configuration ``database''.
</p>

<p>
A typical FreeBSD PC hard-disk has an MS-DOS MBR (Master Boot Record)
in the block at the start of the disk.  
The MS-DOS MBR, among other things, controls how the disk is
divided into partitions (called <em>slices</em> in FreeBSD
terminology to distinguish them from *ix partitions).
It is usually not desirable to partition a device as small
as the 8Mb DOC. Somewhat awkwardly, the <code>disklabel</code>
program considers disks that do <em>not</em> contain a MBR 
<code>removable</code>
devices, since floppy disks are probably the most common
disks that are not usually partitioned.
</p>

<p>
The <code>disklabel</code> program works by locating a named
configuration section in the <code>/etc/disktab</code> file,
converts the ASCII text in the section to a binary block,
and writes the block to the location at which the system
expects to find the label block(s).
</p>

<p>
To create the DOC label, edit the file
``<code>/usr/src/release/picobsd/mfs_tree/etc/disktab</code>''.
Note that this file will be included in all
PicoBSD builds.
Add the following label section to the end of
<code>disktab</code>:

<p>
<code>
doct:ty=removable:dt=DOC2K:se#512:nt#1:rm#300:\<br>
        :ns#15920:nc#1:\<br>
        :pa#15920:oa#0:ba#4096:fa#512:\<br>
        :pc#15920:oc#0:bc#4096:fc#512:<br>
</code>
</p>

<p>
 This defines a label for a device type named
<code>doct</code>, with controller type (<code>dt</code>)
of <code>DOC2K</code>. Note that the disk is considered
<code>removable</code> so as not to have MS-DOS partitions
and a MBR. The device consists of 
<code>15920</code> sectors of <code>512</code> bytes each.
The <code>pa</code> and <code>pc</code> lines define the 
*ix A and C partitions. The C partition, by old *ix
convention, always spans the entire device.
Partition A is the first partition (and the default boot partition).
On the DOC, in this definition, partition A also spans the 
device.
</p>

<p>
To write the label defined by <code>doct</code> to
the DOC, once you have booted a PicoBSD 
system containing the <code>fla</code> driver,
issue the following commands:

<p>
<code>
 #dd if=/dev/zero of=/dev/fla0c count=100<br>
 #dd if=/dev/zero of=/dev/fla0c count=100<br>
 #disklabel -w -r /dev/fla0c doct<br>
</code>
</p>

<p>
 The <code>dd</code> commands overwrite the first 100
blocks with zeros. This is effectively a required
idiom that keeps the new label from overwriting
only part of a disk's boot-sector and label information,
which could then confuse some utilities (such as 
<code>disklabel</code>).
The ``Input File'' is <code>/dev/zero</code>, a pseudo-device
that generates zero-filled blocks. The output
device is the entire DOC flash device, ``<code>dev/fla0c</code>''.
</p>

<p>
 The <code>dd</code> command is issued twice as sometimes
the first execution will produce warning messages.
</p>

<p>
 The ``<code>disklabel -w -r</code>'' command ``Writes'' a label
to device <code>/dev/fla0c</code>. 
The disk is written ``R''aw, that is, bypassing
any information that the running system is maintaining about
the device and forcing the label to use <em>only</em> the
data specified in the <code>disktab</code> file's <code>doct</code>
section. 
Note that ``<code>-w -r</code>'' is <em>NOT</em> the same as
``<code>-r -w</code>'' for <code>disklabel</code>!
The label is written to device <code>/dev/fla0c</code>
and is formed using the section in the <code>disktab</code>
file named <code>doct</code>. Note that the device name
is <em>not</em> specified as a ``raw device''. 
</p>


<p>&nbsp;</p>
<p>
&nbsp;&sect;&nbsp;&nbsp; <b>Put a filesystem on the DOC.</b><br>
</p>

<p>
Once a label has been written to the DOC,
a filesystem can be written using the command:
</p>

<blockquote>
<p>
<code>
 #newfs /dev/fla0c
</code>
</p>
</blockquote>


<p>
At this point the device can be mounted and
used as a regular disk device. For instance,
to mount and unmount the DOC on the standard PicoBSD
<code>/mnt</code> mount-point:

<blockquote>
<p>
<code>
<pre>
 #mount /dev/fla0c /mnt
 #umount /mnt
</pre>
</code>
</p>
</blockquote>




<p>&nbsp;</p>
<p>
&nbsp;&sect;&nbsp;&nbsp; <b>Booting from the DOC.</b><br>
</p>

<p>
It can be useful to boot PicoBSD systems from
the DOC. All this requires is copying a PicoBSD
kernel to the DOC, and then writing the bootstrap
blocks to the DOC. For the purposes of this discussion,
the PicoBSD bootstrap can be considered to consist of
two programs that are put at the start of the disk
following the disk label. The first of these programs
is the single-block <code>boot1</code> program, and the
second the multi-block <code>boot2</code> program.
</p>

<p>
It is the secondary bootstrap that actually locates the
kernel, loads it, and starts it. The secondary bootstrap
is smart enough to locate the file <code>/kernel</code>
by looking for its name in the FreeBSD file-system directory.
Note that there are no hard-coded disk addresses in the
boot blocks that point directly to the kernel to be booted.
</p>

<p>
The secondary bootstrap can boot any file
on the DOC by name (it helps, of course, if the file
contains a bootable system!).
To boot a PicoBSD system named ``<code>kernel.old</code>'',
at the ``<code>boot:</code>'' count-down prompt, simply type the
name of the file you wish to boot, the press
Enter. When you type, the boot
count-down will pause.
</p>

<p>
Often the easiest way to get a kernel on the DOC is simply
to copy a kernel from the boot floppy, for instance:
</p>

<blockquote>
<p>
<code>
<pre>
 #mount /dev/fla0c /mnt
 #mount /dev/fd0c  /mnt1
 #cp /mnt1/kernel /mnt
 #umount /mnt
 #umount /mnt1
 #disklabel -r -B -b /boot/boot1 -s /boot/boot2 /dev/fla0c
</pre>
</code>
</p>
</blockquote>


<p>
 The DOC is mounted on <code>/mnt</code>, the floppy on
<code>/mnt2</code>, and the compressed PicoBSD <code>kernel</code> file copied.
Once the kernel has been copied, 
the <code>disklabel</code> program is used to write
``R''aw (<code>-r</code>) bootblocks (<code>-B</code>) to the DOC
device (<code>/dev/fla0c</code>).
File <code>/boot/boot1</code> contains the primary bootstrap
(<code>-b</code>), and <code>/boot/boot2</code> the secondary
bootstrap (<code>-s</code>).
</p>

<p>
Be sure that the boot files that you intend to write
<em>from</em> the running PicoBSD system are located in 
``<a href="file:/usr/src/release/picobsd/mfs_tree/boot"><code>/usr/src/release/picobsd/mfs_tree/boot</code></a>''.
These are not necessarily the same as the boot files
written to the floppy, which are obtained from the host
FreeBSD machine's 
<a href="/boot"><code>/boot</code></a> directory.
</p>

<p>
The DOC can now be unmounted and the kernel rebooted, either by cycling
the power or using <code>reboot</code>. Note that if
the DOC is mounted and power is cycled without 
doing a <code>umount</code>, the contents of the DOC
will not be accessible until an <code>fsck</code> is
performed on the DOC. 
</p>


<p>&nbsp;</p>
<p>
&nbsp;&sect;&nbsp;&nbsp; <b>Script to move PicoBSD from floppy to DOC.</b><br>
</p>

<p>
For example,
to create a script named <code>kcp</code>
that automates the process for initializing a DOC and
copying a bootable kernel to it,
create a file in one of the locations from which
the <code>picobsd</code> script builds the memory-based file-system internal
to the kernel image. For instance, using <code>mysys</code> in
the source tree as
your PicoBSD configuration directory, one of the
following would be valid:
</p>

<p>
<code>
 /usr/src/release/picobsd/mfs_tree/etc/kcp<br>
 /usr/src/release/picobsd/mysys/floppy.tree/etc/kcp<br>
</code>
</p>

<p>
 In the <code>kcp</code> file, an example file could be:
</p>

<p>
<code>
<pre>
echo
echo "Script to wipe out DiskOnChip and copy kernel"
echo "from floppy to DiskOnChip".
echo
set -e
dd if=/dev/zero of=/dev/fla0c count=100
dd if=/dev/zero of=/dev/fla0c count=100
disklabel -w -r /dev/fla0c doct
newfs /dev/fla0c
mount /dev/fla0c /mnt
mount /dev/fd0c  /mnt1
cp /mnt1/kernel /mnt
umount /mnt
umount /mnt1
disklabel -r -B -b /boot/boot1 -s /boot/boot2 /dev/fla0c
echo
echo "Now remove the floppy and reboot".
echo
</pre>
</code>
</p>

<p>
Since this requires the definition of the
<code>doct</code>  label in file <code>/etc/disktab</code>,
be sure this exists.
</p>


<p>&nbsp;</p>
<p>
&nbsp;&sect;&nbsp;&nbsp; <b>Kernel development with the DOC.</b><br>
</p>

<p>
You can use the DOC, of course, without putting
a kernel on it. However, it is very convenient
to use the DOC as your boot device, thus providing
a ``diskless'' system without moving parts.
The bootstrap can boot either compressed (gzipped) or uncompressed
<code>kernel</code> files. 
If you copy the <code>/kernel</code> file from
the boot floppy to the DOC, the kernel file
will be compressed.
</p>

<p>
I've found it useful on the 8M
DOC to keep a backup (perhaps compressed) ``<code>kernel.old</code>''
and my 
development PicoBSD kernel.
The development kernel is copied over the net from a
large host system on which it is compiled.
The <code>picobsd</code> build script need not
write a boot floppy on the host development
machine.
If you skip both writing the boot floppy and booting from
the floppy, the PicoBSD development cycle can
be reasonably
fast. To skip writing the floppy, when the
last menu is displayed by the <code>picobsd</code> script,
hit tab twice to position the cursor on <code>[Cancel]</code>,
and press Enter. Then, using the existing 
PicoBSD kernel on the DOC,
copy the new kernel file over the
net to the DOC, and then issue <code>reboot</code> on the
DOC. A set of commands to do this from PicoBSD,
assuming a <code>mysys</code> PicoBSD development configuration,
would be similar to:
</p>

<blockquote>
<p>
<code>
<pre>
 #mount /dev/fla0c /mnt
 #cd /mnt
 #rm kernel
 #ftp <host>
  ftp> binary
  ftp> get /usr/src/release/picobsd/build/build_dir-mysys/kernel
  ftp> quit
 #cd /
 #umount /mnt
 #reboot
</pre>
</code>
</p>
</blockquote>

<p>
This requires that <code>ftp</code> be included
in the PicoBSD kernels (included in the ``<code>crunch.conf</code>'').
</p>




<p>&nbsp;</p>
<!================================================>
<a name="hdisk">
<hr>
<h1>How do I put PicoBSD on a hard disk?</h1>





<p>
Putting a bootable PicoBSD <code>kernel</code> on a hard-disk is easy;
there are no special procedures that would not apply to
the normal FreeBSD. See:
</p>

<p>
<a href="http://people.freebsd.org/~imp/diskprep">http://people.freebsd.org/~imp/diskprep</a>
</p>










<p>&nbsp;</p>
<!================================================>
<a name="poll_serial">
<hr>
<h1>How can I kernel debug using polled serial I/O?</h1>




<p>
Sometimes, after a kernel has crashed, it is useful
to be able to do complex I/O from the ``carcass'' of the dead
kernel (for instance, from a fatal trap handler).
By this time, the operating system can no longer be
used to do interrupt driven I/O. There are other times
when it may be desirable for a driver to do complex
I/O without effecting interrupts.
</p>

<p>
In both these cases, the solution is to use polled
serial I/O over one of the 
serial ports (UARTs). This requires connecting the serial port
to a terminal, datascope, or another computer (a
``datascope'' is a network line-analyzer).
</p>

<p>
The code for polled serial I/O is small and
can easily be included in driver and kernel
routines. This small chunk of code will  
operate even after the operating system has
crashed and when interrupts are (perhaps accidentally)
disabled.
</p>

<p>
The code for polled serial UART I/O on a PC
is:
</p>



<small>
<code>
<pre>
#if 0
#define   DATA_REG      0x3f8
#define   LSB           0x3f8
#define   MSB           0x3f9
#define   INT_ENAB      0x3fa
#define   LINE_CONTROL  0x3fb
#define   MODEM_CNTRL   0x3fc
#define   LINE_STATUS   0x3fd
#define   MODEM_CSR     0x3fe
#endif

/*---------------------------------------------------------------------------*/
/* Debug serial driver routines */
/*---------------------------------------------------------------------------*/
void fsdz_init() {
 outb( /*LINE_CONTROL*/ 0x3fb, 0x80 );       /* Set baud */
 outb( /*MSB*/          0x3f9,    0 );       /* MSB of baud divisor */
 outb( /*LSB*/          0x3f8,   12 );       /* LSB of baud divisor */
 outb( /*LINE_CONTROL*/ 0x3fb,    0 );       /* Zero */
 outb( /*LINE_CONTROL*/ 0x3fb, 0x0b );       /* 8-bit, odd parity enabled */
 outb( /*INT_ENAB*/     0x3fa,    0 );       /* Disable interupts. */    
}

/*---------------------------------------------------------------------------*/
void fsdz_put( ochar )
char ochar;
{
char  status,c;
 
 status = inb( /*LINE_STATUS*/ 0x3fd );    /* Check if rcv buffer is full */
 if (status & 1) {
   c  = inb( /*DATA_REG*/ 0x3f8 );         /* Get the char */
   c &= 0x7f;                              /* Ignore parity */
   if (c == 19) { 

      do {
         do {
            status = inb( /*LINE_STATUS*/ 0x3fd );
         } while ( 1 != (status & 1) );

         c  = inb( /*DATA_REG*/ 0x3f8 );
         c &= 0x7f;
      } while (c != 17);
   } 

 }

#if 0                                      /* Set modem control. */
 outb( /*MODEM_CNTRL*/ 0x3fc, 0x03 );      /* DTR and RTS */

 do {
    status = inportb( /*MODEM_CSR*/ 0x3fe);   /* Wait for DSR and CTS */
 while (status != 0x30);
#endif

 for(;;) {
    status = inb( /*LINE_STATUS*/ 0x3fd);  /* Wait for TRANS READY */
    if (status & 0x20) break;
 }

 outb( /*DATA_REG*/ 0x3f8, ochar );        /* Output the data byte,.. */ 
}

</code>
</pre>
</small>



<p>
This is
very old code. Minor variations of this code
have been used on PCs for nearly two decades.
</p>

<p>
Note the preceeding code
does not
use the ``<code>#define</code>'' statements;
they are primarily left in as documentation.
You often do not need to use modem control
on the serial line. However, if you need to
do explicit modem-style flow-control on the serial
line, alter the section of code that has been
``<code>#defined</code>'' out.


<p>
The polling serial I/O code is used in the following manner:
</p>

<blockquote>
<code>
<pre>
 fsdz_init();
 fsdz_put( 'U' );
 fsdz_put( 'p' );
</code>
</pre>
</blockquote>

<p>
 The previous code would initialize the 16550 UART
and write the characters "Up" over the serial port.
A typical debug idiom using this code would be:
</p>

<blockquote>
<code>
<pre>
char brm_dbuf[80];
int  len,i;

 fsdz_init();
 fsdz_put( 'C' ); fsdz_put( 'R' ); fsdz_put( 'A' ); fsdz_put( '!' );
 
 len = sprintf( brm_dbuf, "f=%x t=%x cnt=%d.", from, to, count );
 for(i=0; i&lt;len; i++) fsdz_put( brm_dbuf[i] );
</code>
</pre>
</blockquote>


<p>
 The baud rate used can be
altered by changing the divisor written to registers
<code>MSB</code> and <code>LSB</code>  in ``<code>fzdz_init()</code>''. The formula for
these values is ``<code>divisor = 1.8432Mhz /( 16 * baud rate)</code>''.
Some common values are:
</p>
<p>&nbsp;</p>

<center>
<table frame=box border=2 >
Baud Rate Divisors (MSB and LSB in Hex)<br>
<tbody>
<tr><td>Baud Rate</td><td>MSB</td><td>LSB</td></tr>
<tr><td>1200</td><td>00</td><td>0x60</td></tr>
<tr><td>9600</td><td>00</td><td>0x0c</td></tr>
<tr><td>19200</td><td>00</td><td>0x06</td></tr>
<tr><td>56000</td><td>00</td><td>0x02</td></tr>
<tbody>

</table>
</center>
<p>&nbsp;</p>


<p>
A ``classic'' book describing PC serial communications is
<a href="http://www.amazon.com/exec/obidos/ISBN%3D0672302861/103-0545919-2275865">
<em>C Programmer's Guide to Serial Communications</em></a>
<a href="http://hallwebtools.com/languages_tools/742.shtml">
&nbsp;[1]&nbsp;</a>
<a href="http://vig.prenhall.com/catalog/professional/product/1,4096,0672302861,00.html">
&nbsp;[2]&nbsp;</a>,
<a href="http://citeseer.nj.nec.com/context/551346/0">
&nbsp;[3]&nbsp;</a>,
by Joe Campbell, 1987, Howard Sams and Company.
</p>










<hr>
<!================================================>
<p>&nbsp;</p>
<h2>My Contact Info</h2>

<p>
Many people have contributed to this FAQ.
Draft 20-Jul-2001 of this document written by:
</p>

<a href="http://www.cse.ucsc.edu/~brucem">Bruce R. Montague</a>
(<a href="http://www.cse.ucsc.edu/~brucem">www.cse.ucsc.edu/~brucem</a>)<br>
<a href="mailto:brucem@mail.cruzio.com">brucem@mail.cruzio.com</a><br>
brucem@mail.got.net<br>
<a href="mailto:brucem@cse.ucsc.edu">brucem@cse.ucsc.edu</a><br>

</body>












