  <HTML>
  <HEAD>
  
  <TITLE>MySQL Reference Manual for version 5.0.3-alpha - 3  MySQL Tutorial</TITLE>
   <style> code {color:purple} tt {color:green} samp {color:navy} pre {color:maroon} </style>
  </HEAD>
  <BODY BGCOLOR=silver TEXT=#000000 LINK=#101090 VLINK=#7030B0>
Go to the <A HREF="manual_Introduction.html">first</A>, <A HREF="manual_Installing.html">previous</A>, <A HREF="manual_Using_MySQL_Programs.html">next</A>, <A HREF="manual_Concept_Index.html">last</A> section, <A HREF="manual_toc.html">table of contents</A>.
<P><HR><P>


<H1><A NAME="Tutorial" HREF="manual_toc.html#Tutorial">3  MySQL Tutorial</A></H1>

<P>
<A NAME="IDX337"></A>
<A NAME="IDX338"></A>
<A NAME="IDX339"></A>
<A NAME="IDX340"></A>

</P>

<P>
This chapter provides a tutorial introduction to MySQL by showing
how to use the <code>mysql</code> client program to create and use a simple
database.  <code>mysql</code> (sometimes referred to as the ``terminal monitor'' or
just ``monitor'') is an interactive program that allows you to connect to a
MySQL server, run queries, and view the results.  <code>mysql</code> may
also be used in batch mode: you place your queries in a file beforehand, then
tell <code>mysql</code> to execute the contents of the file.  Both ways of using
<code>mysql</code> are covered here.

</P>
<P>
To see a list of options provided by <code>mysql</code>, invoke it with
the <code>--help</code> option:

</P>

<PRE>
shell&#62; mysql --help
</PRE>

<P>
This chapter assumes that <code>mysql</code> is installed on your machine and that
a MySQL server is available to which you can connect.  If this is
not true, contact your MySQL administrator.  (If <strong>you</strong> are the
administrator, you will need to consult other sections of this manual.)

</P>
<P>
This chapter describes the entire process of setting up and using a
database.  If you are interested only in accessing an already-existing
database, you may want to skip over the sections that describe how to
create the database and the tables it contains.

</P>
<P>
Because this chapter is tutorial in nature, many details are necessarily
omitted.  Consult the relevant sections of the manual for more
information on the topics covered here.

</P>



<H2><A NAME="Connecting-disconnecting" HREF="manual_toc.html#Connecting-disconnecting">3.1  Connecting to and Disconnecting from the Server</A></H2>

<P>
<A NAME="IDX341"></A>
<A NAME="IDX342"></A>
<A NAME="IDX343"></A>
<A NAME="IDX344"></A>

</P>
<P>
To connect to the server, you'll usually need to provide a MySQL
username when you invoke <code>mysql</code> and, most likely, a password.  If the
server runs on a machine other than the one where you log in, you'll also
need to specify a hostname.  Contact your administrator to find out what
connection parameters you should use to connect (that is, what host, username,
and password to use).  Once you know the proper parameters, you should be
able to connect like this:

</P>

<PRE>
shell&#62; mysql -h <var>host</var> -u <var>user</var> -p
Enter password: ********
</PRE>

<P>
<code>host</code> and <code>user</code> represent the hostname where your MySQL server is
running and the username of your MySQL account.  Substitute appropriate values
for your setup.
The <code>********</code> represents your password; enter it when <code>mysql</code>
displays the <code>Enter password:</code> prompt.

</P>
<P>
If that works, you should see some introductory information followed by a
<code>mysql&#62;</code> prompt:

</P>


<PRE>
shell&#62; mysql -h <var>host</var> -u <var>user</var> -p
Enter password: ********
Welcome to the MySQL monitor.  Commands end with ; or \g.
Your MySQL connection id is 25338 to server version: 4.0.14-log

Type 'help;' or '\h' for help. Type '\c' to clear the buffer.

mysql&#62;
</PRE>

<P>
The prompt tells you that <code>mysql</code> is ready for you to enter commands.

</P>
<P>
Some MySQL installations allow users to connect as the anonymous
(unnamed) user to the server running on the local host.  If this is the case
on your machine, you should be able to connect to that server by invoking
<code>mysql</code> without any options:

</P>

<PRE>
shell&#62; mysql
</PRE>

<P>
After you have connected successfully, you can disconnect any time by typing
<code>QUIT</code> (or <code>\q</code>) at the <code>mysql&#62;</code> prompt:

</P>

<PRE>
mysql&#62; QUIT
Bye
</PRE>

<P>
On Unix, you can also disconnect by pressing Control-D.

</P>
<P>
Most examples in the following sections assume that you are connected to the
server.  They indicate this by the <code>mysql&#62;</code> prompt.

</P>



<H2><A NAME="Entering_queries" HREF="manual_toc.html#Entering_queries">3.2  Entering Queries</A></H2>

<P>
<A NAME="IDX345"></A>
<A NAME="IDX346"></A>
<A NAME="IDX347"></A>

</P>
<P>
Make sure that you are connected to the server, as discussed in the previous
section.  Doing so will not in itself select any database to work with, but
that's okay.  At this point, it's more important to find out a little about
how to issue queries than to jump right in creating tables, loading data
into them, and retrieving data from them.  This section describes the basic
principles of entering commands, using several queries you can try out to
familiarize yourself with how <code>mysql</code> works.

</P>
<P>
Here's a simple command that asks the server to tell you its version number
and the current date.  Type it in as shown here following the <code>mysql&#62;</code>
prompt and press Enter:

</P>

<PRE>
mysql&#62; SELECT VERSION(), CURRENT_DATE;
+--------------+--------------+
| VERSION()    | CURRENT_DATE |
+--------------+--------------+
| 3.22.20a-log | 1999-03-19   |
+--------------+--------------+
1 row in set (0.01 sec)
mysql&#62;
</PRE>

<P>
This query illustrates several things about <code>mysql</code>:

</P>

<UL>
<LI>

A command normally consists of an SQL statement followed by a semicolon.
(There are some exceptions where a semicolon may be omitted.  <code>QUIT</code>,
mentioned earlier, is one of them.  We'll get to others later.)

<LI>

When you issue a command, <code>mysql</code> sends it to the server for execution
and displays the results, then prints another <code>mysql&#62;</code> prompt to indicate
that it is ready for another command.

<LI>

<code>mysql</code> displays query output in tabular form (rows and columns).  The
first row contains labels for the columns.  The rows following are the query
results.  Normally, column labels are the names of the columns you fetch from
database tables.  If you're retrieving the value of an expression rather than
a table column (as in the example just shown), <code>mysql</code> labels the column
using the expression itself.

<LI>

<code>mysql</code> shows how many rows were returned and how long the query took
to execute, which gives you a rough idea of server performance.  These values
are imprecise because they represent wall clock time (not CPU or machine
time), and because they are affected by factors such as server load and
network latency.  (For brevity, the ``rows in set'' line is not shown in
the remaining examples in this chapter.)
</UL>

<P>
Keywords may be entered in any lettercase.  The following queries are
equivalent:

</P>

<PRE>
mysql&#62; SELECT VERSION(), CURRENT_DATE;
mysql&#62; select version(), current_date;
mysql&#62; SeLeCt vErSiOn(), current_DATE;
</PRE>

<P>
Here's another query.  It demonstrates that you can use <code>mysql</code> as a
simple calculator:

</P>

<PRE>
mysql&#62; SELECT SIN(PI()/4), (4+1)*5;
+-------------+---------+
| SIN(PI()/4) | (4+1)*5 |
+-------------+---------+
|    0.707107 |      25 |
+-------------+---------+
</PRE>

<P>
The queries shown thus far have been relatively short, single-line
statements.  You can even enter multiple statements on a single line.
Just end each one with a semicolon:

</P>

<PRE>
mysql&#62; SELECT VERSION(); SELECT NOW();
+--------------+
| VERSION()    |
+--------------+
| 3.22.20a-log |
+--------------+

+---------------------+
| NOW()               |
+---------------------+
| 1999-03-19 00:15:33 |
+---------------------+
</PRE>

<P>
A command need not be given all on a single line, so lengthy commands that
require several lines are not a problem.  <code>mysql</code> determines where your
statement ends by looking for the terminating semicolon, not by looking for
the end of the input line.  (In other words, <code>mysql</code>
accepts free-format input:  it collects input lines but does not execute them
until it sees the semicolon.)

</P>
<P>
Here's a simple multiple-line statement:

</P>

<PRE>
mysql&#62; SELECT
    -&#62; USER()
    -&#62; ,
    -&#62; CURRENT_DATE;
+--------------------+--------------+
| USER()             | CURRENT_DATE |
+--------------------+--------------+
| joesmith@localhost | 1999-03-18   |
+--------------------+--------------+
</PRE>

<P>
In this example, notice how the prompt changes from <code>mysql&#62;</code> to
<code>-&#62;</code> after you enter the first line of a multiple-line query.  This is
how <code>mysql</code> indicates that it hasn't seen a complete statement and is
waiting for the rest.  The prompt is your friend, because it provides
valuable feedback.  If you use that feedback, you will always be aware of
what <code>mysql</code> is waiting for.

</P>
<P>
If you decide you don't want to execute a command that you are in the
process of entering, cancel it by typing <code>\c</code>:

</P>

<PRE>
mysql&#62; SELECT
    -&#62; USER()
    -&#62; \c
mysql&#62;
</PRE>

<P>
Here, too, notice the prompt.  It switches back to <code>mysql&#62;</code> after you
type <code>\c</code>, providing feedback to indicate that <code>mysql</code> is ready
for a new command.

</P>
<P>
The following table shows each of the prompts you may see and summarizes what
they mean about the state that <code>mysql</code> is in:

</P>
<P>
<A NAME="IDX348"></A>
<TABLE BORDER>
<TR><TD><strong>Prompt</strong> </TD><TD> <strong>Meaning</strong>
</TD></TR>
<TR><TD><code>mysql&#62;</code> </TD><TD> Ready for new command.
</TD></TR>
<TR><TD><code>    -&#62;</code> </TD><TD> Waiting for next line of multiple-line command.
</TD></TR>
<TR><TD><code>    '&#62;</code> </TD><TD> Waiting for next line, collecting a string that begins with a single quote (<samp>`''</samp>).
</TD></TR>
<TR><TD><code>    "&#62;</code> </TD><TD> Waiting for next line, collecting a string that begins with a double quote (<samp>`"'</samp>).
</TD></TR>
<TR><TD><code>    `&#62;</code> </TD><TD> Waiting for next line, collecting an identifier that begins with a backtick (<samp>``'</samp>).
</TD></TR>
</TABLE>

</P>
<P>
Multiple-line statements commonly occur by accident when you intend to
issue a command on a single line, but forget the terminating semicolon.  In
this case, <code>mysql</code> waits for more input:

</P>

<PRE>
mysql&#62; SELECT USER()
    -&#62;
</PRE>

<P>
If this happens to you (you think you've entered a statement but the only
response is a <code>-&#62;</code> prompt), most likely <code>mysql</code> is waiting for the
semicolon.  If you don't notice what the prompt is telling you, you might sit
there for a while before realising what you need to do.  Enter a semicolon to
complete the statement, and <code>mysql</code> will execute it:

</P>

<PRE>
mysql&#62; SELECT USER()
    -&#62; ;
+--------------------+
| USER()             |
+--------------------+
| joesmith@localhost |
+--------------------+
</PRE>

<P>
The <code>'&#62;</code> and <code>"&#62;</code> prompts occur during string collection.
In MySQL, you can write strings surrounded by either <samp>`''</samp>
or <samp>`"'</samp> characters (for example, <code>'hello'</code> or <code>"goodbye"</code>),
and <code>mysql</code> lets you enter strings that span multiple lines.  When you
see a <code>'&#62;</code> or <code>"&#62;</code> prompt, it means that you've entered a line
containing a string that begins with a <samp>`''</samp> or <samp>`"'</samp> quote character,
but have not yet entered the matching quote that terminates the string.
That's fine if you really are entering a multiple-line string, but how likely
is that?  Not very.  More often, the <code>'&#62;</code> and <code>"&#62;</code> prompts indicate
that you've inadvertantly left out a quote character.  For example:

</P>

<PRE>
mysql&#62; SELECT * FROM my_table WHERE name = 'Smith AND age &#60; 30;
    '&#62;
</PRE>

<P>
If you enter this <code>SELECT</code> statement, then press Enter and wait for the
result, nothing will happen.  Instead of wondering why this
query takes so long, notice the clue provided by the <code>'&#62;</code> prompt.  It
tells you that <code>mysql</code> expects to see the rest of an unterminated
string.  (Do you see the error in the statement?  The string <code>'Smith</code> is
missing the second quote.)

</P>
<P>
At this point, what do you do?  The simplest thing is to cancel the command.
However, you cannot just type <code>\c</code> in this case, because <code>mysql</code>
interprets it as part of the string that it is collecting!  Instead, enter
the closing quote character (so <code>mysql</code> knows you've finished the
string), then type <code>\c</code>:

</P>

<PRE>
mysql&#62; SELECT * FROM my_table WHERE name = 'Smith AND age &#60; 30;
    '&#62; '\c
mysql&#62;
</PRE>

<P>
The prompt changes back to <code>mysql&#62;</code>, indicating that <code>mysql</code>
is ready for a new command.

</P>
<P>
The <code>`&#62;</code> prompt is similar to th <code>'&#62;</code> and <code>"&#62;</code> prompts,
but indicates that you have begun but not completed a backtick-quoted
identifier.

</P>
<P>
It's important to know what the <code>'&#62;</code>, <code>"&#62;</code>, and <code>`&#62;</code> prompts signify,
because if you mistakenly enter an unterminated string, any further lines you
type will appear to be ignored by <code>mysql</code>---including a line
containing <code>QUIT</code>!  This can be quite confusing, especially if you
don't know that you need to supply the terminating quote before you can
cancel the current command.

</P>



<H2><A NAME="Database_use" HREF="manual_toc.html#Database_use">3.3  Creating and Using a Database</A></H2>

<P>
<A NAME="IDX349"></A>
<A NAME="IDX350"></A>
<A NAME="IDX351"></A>

</P>

<P>
Now that you know how to enter commands, it's time to access a database.

</P>
<P>
Suppose that you have several pets in your home (your menagerie) and you'd
like to keep track of various types of information about them.  You can do so
by creating tables to hold your data and loading them with the desired
information.  Then you can answer different sorts of questions about your
animals by retrieving data from the tables.  This section shows you how to:

</P>

<UL>
<LI>

Create a database
<LI>

Create a table
<LI>

Load data into the table
<LI>

Retrieve data from the table in various ways
<LI>

Use multiple tables
</UL>

<P>
The menagerie database will be simple (deliberately), but it is not difficult
to think of real-world situations in which a similar type of database might
be used.  For example, a database like this could be used by a farmer to keep
track of livestock, or by a veterinarian to keep track of patient records.
A menagerie distribution containing some of the queries and sample data used
in the following sections can be obtained from the MySQL Web site.
It's available in either compressed <code>tar</code> format
(<a HREF="http://www.mysql.com/Downloads/Contrib/Examples/menagerie.tar.gz">http://www.mysql.com/Downloads/Contrib/Examples/menagerie.tar.gz</a>)
or Zip format
(<a HREF="http://www.mysql.com/Downloads/Contrib/Examples/menagerie.zip">http://www.mysql.com/Downloads/Contrib/Examples/menagerie.zip</a>).

</P>
<P>
Use the <code>SHOW</code> statement to find out what databases currently exist
on the server:

</P>

<PRE>
mysql&#62; SHOW DATABASES;
+----------+
| Database |
+----------+
| mysql    |
| test     |
| tmp      |
+----------+
</PRE>

<P>
The list of databases is probably different on your machine, but the
<code>mysql</code> and <code>test</code> databases are likely to be among them.  The
<code>mysql</code> database is required because it describes user access
privileges.  The <code>test</code> database is often provided as a workspace for
users to try things out.

</P>
<P>
Note that you may not see all databases if you don't have the
<code>SHOW DATABASES</code> privilege. See section <A HREF="manual_SQL_Syntax.html#GRANT">13.5.1.2  <code>GRANT</code> and <code>REVOKE</code> Syntax</A>.

</P>
<P>
If the <code>test</code> database exists, try to access it:

</P>

<PRE>
mysql&#62; USE test
Database changed
</PRE>

<P>
Note that <code>USE</code>, like <code>QUIT</code>, does not require a semicolon.  (You
can terminate such statements with a semicolon if you like; it does no harm.)
The <code>USE</code> statement is special in another way, too:  it must be given on
a single line.

</P>
<P>
You can use the <code>test</code> database (if you have access to it) for the
examples that follow, but anything you create in that database can be
removed by anyone else with access to it.  For this reason, you should
probably ask your MySQL administrator for permission to use a
database of your own.  Suppose that you want to call yours <code>menagerie</code>.  The
administrator needs to execute a command like this:

</P>

<PRE>
mysql&#62; GRANT ALL ON menagerie.* TO 'your_mysql_name'@'your_client_host';
</PRE>

<P>
where <code>your_mysql_name</code> is the MySQL username assigned to
you and <code>your_client_host</code> is the host from which you connect to the
server.

</P>



<H3><A NAME="Creating_database" HREF="manual_toc.html#Creating_database">3.3.1  Creating and Selecting a Database</A></H3>

<P>
<A NAME="IDX352"></A>
<A NAME="IDX353"></A>

</P>
<P>
If the administrator creates your database for you when setting up your
permissions, you can begin using it.  Otherwise, you need to create it
yourself:

</P>

<PRE>
mysql&#62; CREATE DATABASE menagerie;
</PRE>

<P>
Under Unix, database names are case sensitive (unlike SQL keywords), so you
must always refer to your database as <code>menagerie</code>, not as
<code>Menagerie</code>, <code>MENAGERIE</code>, or some other variant.  This is also true
for table names.  (Under Windows, this restriction does not apply, although
you must refer to databases and tables using the same lettercase throughout a
given query.)

</P>
<P>
Creating a database does not select it for use; you must do that explicitly.
To make <code>menagerie</code> the current database, use this command:

</P>

<PRE>
mysql&#62; USE menagerie
Database changed
</PRE>

<P>
Your database needs to be created only once, but you must select it for use
each time you begin a <code>mysql</code> session.  You can do this by issuing a
<code>USE</code> statement as shown in the example.  Alternatively, you can select the
database on the command line when you invoke <code>mysql</code>.  Just specify its
name after any connection parameters that you might need to provide.  For
example:

</P>

<PRE>
shell&#62; mysql -h <var>host</var> -u <var>user</var> -p menagerie
Enter password: ********
</PRE>

<P>
Note that <code>menagerie</code> is not your password on the command just shown.
If you want to supply your password on the command line after the <code>-p</code>
option, you must do so with no intervening space (for example, as
<code>-pmypassword</code>, not as <code>-p mypassword</code>).  However, putting your
password on the command line is not recommended, because doing so exposes it
to snooping by other users logged in on your machine.

</P>



<H3><A NAME="Creating_tables" HREF="manual_toc.html#Creating_tables">3.3.2  Creating a Table</A></H3>

<P>
<A NAME="IDX354"></A>
<A NAME="IDX355"></A>

</P>
<P>
Creating the database is the easy part, but at this point it's empty, as
<code>SHOW TABLES</code> will tell you:

</P>

<PRE>
mysql&#62; SHOW TABLES;
Empty set (0.00 sec)
</PRE>

<P>
The harder part is deciding what the structure of your database should be:
what tables you will need and what columns will be in each of them.

</P>
<P>
You'll want a table that contains a record for each of your pets.  This can
be called the <code>pet</code> table, and it should contain, as a bare minimum,
each animal's name.  Because the name by itself is not very interesting, the
table should contain other information.  For example, if more than one person
in your family keeps pets, you might want to list each animal's owner.  You
might also want to record some basic descriptive information such as species
and sex.

</P>
<P>
How about age?  That might be of interest, but it's not a good thing to store
in a database.  Age changes as time passes, which means you'd have to update
your records often.  Instead, it's better to store a fixed value such as
date of birth.  Then, whenever you need age, you can calculate it as the
difference between the current date and the birth date.  MySQL
provides functions for doing date arithmetic, so this is not difficult.
Storing birth date rather than age has other advantages, too:

</P>

<UL>
<LI>

You can use the database for tasks such as generating reminders for upcoming
pet birthdays.  (If you think this type of query is somewhat silly, note that
it is the same question you might ask in the context of a business database
to identify clients to whom you'll soon need to send out birthday greetings,
for that computer-assisted personal touch.)

<LI>

You can calculate age in relation to dates other than the current date.  For
example, if you store death date in the database, you can easily calculate
how old a pet was when it died.
</UL>

<P>
You can probably think of other types of information that would be useful in
the <code>pet</code> table, but the ones identified so far are sufficient for now:
name, owner, species, sex, birth, and death.

</P>
<P>
Use a <code>CREATE TABLE</code> statement to specify the layout of your table:

</P>

<PRE>
mysql&#62; CREATE TABLE pet (name VARCHAR(20), owner VARCHAR(20),
    -&#62; species VARCHAR(20), sex CHAR(1), birth DATE, death DATE);
</PRE>

<P>
<code>VARCHAR</code> is a good choice for the <code>name</code>, <code>owner</code>, and
<code>species</code> columns because the column values will vary in length.  The
lengths of those columns need not all be the same, and need not be
<code>20</code>.  You can pick any length from <code>1</code> to <code>255</code>, whatever
seems most reasonable to you.  (If you make a poor choice and it turns
out later that you need a longer field, MySQL provides an
<code>ALTER TABLE</code> statement.)

</P>
<P>
Several types of values can be chosen to represent sex in animal records,
such as <code>'m'</code>
and <code>'f'</code>, or perhaps <code>'male'</code> and <code>'female'</code>.  It's simplest
to use the single characters <code>'m'</code> and <code>'f'</code>.

</P>
<P>
The use of the <code>DATE</code> data type for the <code>birth</code> and <code>death</code>
columns is a fairly obvious choice.

</P>
<P>
Now that you have created a table, <code>SHOW TABLES</code> should produce some
output:

</P>

<PRE>
mysql&#62; SHOW TABLES;
+---------------------+
| Tables in menagerie |
+---------------------+
| pet                 |
+---------------------+
</PRE>

<P>
To verify that your table was created the way you expected, use
a <code>DESCRIBE</code> statement:

</P>

<PRE>
mysql&#62; DESCRIBE pet;
+---------+-------------+------+-----+---------+-------+
| Field   | Type        | Null | Key | Default | Extra |
+---------+-------------+------+-----+---------+-------+
| name    | varchar(20) | YES  |     | NULL    |       |
| owner   | varchar(20) | YES  |     | NULL    |       |
| species | varchar(20) | YES  |     | NULL    |       |
| sex     | char(1)     | YES  |     | NULL    |       |
| birth   | date        | YES  |     | NULL    |       |
| death   | date        | YES  |     | NULL    |       |
+---------+-------------+------+-----+---------+-------+
</PRE>

<P>
You can use <code>DESCRIBE</code> any time, for example, if you forget the names of
the columns in your table or what types they have.

</P>



<H3><A NAME="Loading_tables" HREF="manual_toc.html#Loading_tables">3.3.3  Loading Data into a Table</A></H3>

<P>
<A NAME="IDX356"></A>
<A NAME="IDX357"></A>
<A NAME="IDX358"></A>

</P>
<P>
After creating your table, you need to populate it.  The <code>LOAD DATA</code> and
<code>INSERT</code> statements are useful for this.

</P>
<P>
Suppose that your pet records can be described as shown here.
(Observe that MySQL expects dates in <code>'YYYY-MM-DD'</code> format;
this may be different from what you are used to.)

</P>
<TABLE BORDER>
<TR><TD><strong>name</strong> </TD><TD> <strong>owner</strong> </TD><TD> <strong>species</strong> </TD><TD> <strong>sex</strong> </TD><TD> <strong>birth</strong> </TD><TD> <strong>death</strong>
</TD></TR>
<TR><TD>Fluffy </TD><TD> Harold </TD><TD> cat </TD><TD> f </TD><TD> 1993-02-04 </TD><TD>
</TD></TR>
<TR><TD>Claws </TD><TD> Gwen </TD><TD> cat </TD><TD> m </TD><TD> 1994-03-17 </TD><TD>
</TD></TR>
<TR><TD>Buffy </TD><TD> Harold </TD><TD> dog </TD><TD> f </TD><TD> 1989-05-13 </TD><TD>
</TD></TR>
<TR><TD>Fang </TD><TD> Benny </TD><TD> dog </TD><TD> m </TD><TD> 1990-08-27 </TD><TD>
</TD></TR>
<TR><TD>Bowser </TD><TD> Diane </TD><TD> dog </TD><TD> m </TD><TD> 1979-08-31 </TD><TD> 1995-07-29
</TD></TR>
<TR><TD>Chirpy </TD><TD> Gwen </TD><TD> bird </TD><TD> f </TD><TD> 1998-09-11 </TD><TD>
</TD></TR>
<TR><TD>Whistler </TD><TD> Gwen </TD><TD> bird </TD><TD> </TD><TD> 1997-12-09 </TD><TD>
</TD></TR>
<TR><TD>Slim </TD><TD> Benny </TD><TD> snake </TD><TD> m </TD><TD> 1996-04-29 </TD><TD>
</TD></TR>
</TABLE>

<P>
Because you are beginning with an empty table, an easy way to populate it is to
create a text file containing a row for each of your animals, then load the
contents of the file into the table with a single statement.

</P>
<P>
You could create a text file <tt>`pet.txt'</tt> containing one record per line,
with values separated by tabs, and given in the order in which the columns
were listed in the <code>CREATE TABLE</code> statement.  For missing values (such
as unknown sexes or death dates for animals that are still living), you can
use <code>NULL</code> values.  To represent these in your text file, use
<code>\N</code> (backslash, capital-N).  For example, the record for Whistler the
bird would look like
this (where the whitespace between values is a single tab character):

</P>
<TABLE BORDER>
<TR><TD><strong>name</strong> </TD><TD> <strong>owner</strong> </TD><TD> <strong>species</strong> </TD><TD> <strong>sex</strong> </TD><TD> <strong>birth</strong> </TD><TD> <strong>death</strong>
</TD></TR>
<TR><TD><code>Whistler</code> </TD><TD> <code>Gwen</code> </TD><TD> <code>bird</code> </TD><TD> <code>\N</code> </TD><TD> <code>1997-12-09</code> </TD><TD> <code>\N</code>
</TD></TR>
</TABLE>

<P>
To load the text file <tt>`pet.txt'</tt> into the <code>pet</code> table, use this
command:

</P>

<PRE>
mysql&#62; LOAD DATA LOCAL INFILE '/path/pet.txt' INTO TABLE pet;
</PRE>

<P>
Note that if you created the file on Windows with an editor that uses
<code>\r\n</code> as a line terminator, you should use:

</P>

<PRE>
mysql&#62; LOAD DATA LOCAL INFILE '/path/pet.txt' INTO TABLE pet
    -&#62; LINES TERMINATED BY '\r\n';
</PRE>

<P>
You can specify the column value separator and end of line marker explicitly
in the <code>LOAD DATA</code> statement if you wish, but the defaults are tab and
linefeed.  These are sufficient for the statement to read the file
<tt>`pet.txt'</tt> properly.

</P>
<P>
If the statement fails, it is likely that your MySQL installation does not
have local file capability enabled by default.  See
section <A HREF="manual_MySQL_Database_Administration.html#LOAD_DATA_LOCAL">5.4.4  Security Issues with <code>LOAD DATA LOCAL</code></A> for information on how to
change this.

</P>
<P>
When you want to add new records one at a time, the <code>INSERT</code> statement
is useful.  In its simplest form, you supply values for each column, in the
order in which the columns were listed in the <code>CREATE TABLE</code> statement.
Suppose that Diane gets a new hamster named Puffball.  You could add a new record
using an <code>INSERT</code> statement like this:

</P>

<PRE>
mysql&#62; INSERT INTO pet
    -&#62; VALUES ('Puffball','Diane','hamster','f','1999-03-30',NULL);
</PRE>

<P>
Note that string and date values are specified as quoted strings here.  Also,
with <code>INSERT</code>, you can insert <code>NULL</code> directly to represent a
missing value.  You do not use <code>\N</code> like you do with <code>LOAD DATA</code>.

</P>
<P>
From this example, you should be able to see that there would be a lot more
typing involved to load
your records initially using several <code>INSERT</code> statements rather
than a single <code>LOAD DATA</code> statement.

</P>



<H3><A NAME="Retrieving_data" HREF="manual_toc.html#Retrieving_data">3.3.4  Retrieving Information from a Table</A></H3>

<P>
<A NAME="IDX359"></A>
<A NAME="IDX360"></A>
<A NAME="IDX361"></A>
<A NAME="IDX362"></A>

</P>

<P>
The <code>SELECT</code> statement is used to pull information from a table.
The general form of the statement is:

</P>

<PRE>
SELECT what_to_select
FROM which_table
WHERE conditions_to_satisfy;
</PRE>

<P>
<code>what_to_select</code> indicates what you want to see.  This can be a list of
columns, or <code>*</code> to indicate ``all columns.'' <code>which_table</code>
indicates the table from which you want to retrieve data.  The <code>WHERE</code>
clause is optional.  If it's present, <code>conditions_to_satisfy</code> specifies
conditions that rows must satisfy to qualify for retrieval.

</P>



<H4><A NAME="Selecting_all" HREF="manual_toc.html#Selecting_all">3.3.4.1  Selecting All Data</A></H4>

<P>
The simplest form of <code>SELECT</code> retrieves everything from a table:

</P>

<PRE>
mysql&#62; SELECT * FROM pet;
+----------+--------+---------+------+------------+------------+
| name     | owner  | species | sex  | birth      | death      |
+----------+--------+---------+------+------------+------------+
| Fluffy   | Harold | cat     | f    | 1993-02-04 | NULL       |
| Claws    | Gwen   | cat     | m    | 1994-03-17 | NULL       |
| Buffy    | Harold | dog     | f    | 1989-05-13 | NULL       |
| Fang     | Benny  | dog     | m    | 1990-08-27 | NULL       |
| Bowser   | Diane  | dog     | m    | 1979-08-31 | 1995-07-29 |
| Chirpy   | Gwen   | bird    | f    | 1998-09-11 | NULL       |
| Whistler | Gwen   | bird    | NULL | 1997-12-09 | NULL       |
| Slim     | Benny  | snake   | m    | 1996-04-29 | NULL       |
| Puffball | Diane  | hamster | f    | 1999-03-30 | NULL       |
+----------+--------+---------+------+------------+------------+
</PRE>

<P>
This form of <code>SELECT</code> is useful if you want to review your entire table,
for example, after you've just loaded it with your initial dataset.  For
example, you may happen to think that the birth date for Bowser doesn't seem
quite right.  Consulting your original pedigree
papers, you find that the correct birth year should be 1989, not 1979.

</P>
<P>
There are least a couple of ways to fix this:

</P>

<UL>
<LI>

Edit the file <tt>`pet.txt'</tt> to correct the error, then empty the table
and reload it using <code>DELETE</code> and <code>LOAD DATA</code>:


<PRE>
mysql&#62; DELETE FROM pet;
mysql&#62; LOAD DATA LOCAL INFILE 'pet.txt' INTO TABLE pet;
</PRE>

However, if you do this, you must also re-enter the record for Puffball.

<LI>

Fix only the erroneous record with an <code>UPDATE</code> statement:


<PRE>
mysql&#62; UPDATE pet SET birth = '1989-08-31' WHERE name = 'Bowser';
</PRE>

The <code>UPDATE</code> changes only the record in question and does not require you
to reload the table.
</UL>



<H4><A NAME="Selecting_rows" HREF="manual_toc.html#Selecting_rows">3.3.4.2  Selecting Particular Rows</A></H4>

<P>
<A NAME="IDX363"></A>
<A NAME="IDX364"></A>

</P>
<P>
As shown in the preceding section, it is easy to retrieve an entire table.
Just omit the <code>WHERE</code> clause from the <code>SELECT</code> statement.
But typically you don't want
to see the entire table, particularly when it becomes large.  Instead,
you're usually more interested in answering a particular question, in which
case you specify some constraints on the information you want.  Let's look at
some selection queries in terms of questions about your pets that they
answer.

</P>
<P>
You can select only particular rows from your table.  For example, if you want
to verify the change that you made to Bowser's birth date, select Bowser's
record like this:

</P>

<PRE>
mysql&#62; SELECT * FROM pet WHERE name = 'Bowser';
+--------+-------+---------+------+------------+------------+
| name   | owner | species | sex  | birth      | death      |
+--------+-------+---------+------+------------+------------+
| Bowser | Diane | dog     | m    | 1989-08-31 | 1995-07-29 |
+--------+-------+---------+------+------------+------------+
</PRE>

<P>
The output confirms that the year is correctly recorded now as 1989, not 1979.

</P>
<P>
String comparisons normally are case-insensitive, so you can specify the
name as <code>'bowser'</code>, <code>'BOWSER'</code>, etc.  The query result will be
the same.

</P>
<P>
You can specify conditions on any column, not just <code>name</code>.  For example,
if you want to know which animals were born after 1998, test the <code>birth</code>
column:

</P>

<PRE>
mysql&#62; SELECT * FROM pet WHERE birth &#62;= '1998-1-1';
+----------+-------+---------+------+------------+-------+
| name     | owner | species | sex  | birth      | death |
+----------+-------+---------+------+------------+-------+
| Chirpy   | Gwen  | bird    | f    | 1998-09-11 | NULL  |
| Puffball | Diane | hamster | f    | 1999-03-30 | NULL  |
+----------+-------+---------+------+------------+-------+
</PRE>

<P>
You can combine conditions, for example, to locate female dogs:

</P>

<PRE>
mysql&#62; SELECT * FROM pet WHERE species = 'dog' AND sex = 'f';
+-------+--------+---------+------+------------+-------+
| name  | owner  | species | sex  | birth      | death |
+-------+--------+---------+------+------------+-------+
| Buffy | Harold | dog     | f    | 1989-05-13 | NULL  |
+-------+--------+---------+------+------------+-------+
</PRE>

<P>
The preceding query uses the <code>AND</code> logical operator.  There is also an
<code>OR</code> operator:

</P>

<PRE>
mysql&#62; SELECT * FROM pet WHERE species = 'snake' OR species = 'bird';
+----------+-------+---------+------+------------+-------+
| name     | owner | species | sex  | birth      | death |
+----------+-------+---------+------+------------+-------+
| Chirpy   | Gwen  | bird    | f    | 1998-09-11 | NULL  |
| Whistler | Gwen  | bird    | NULL | 1997-12-09 | NULL  |
| Slim     | Benny | snake   | m    | 1996-04-29 | NULL  |
+----------+-------+---------+------+------------+-------+
</PRE>

<P>
<code>AND</code> and <code>OR</code> may be intermixed, although <code>AND</code> has higher
precedence than <code>OR</code>.  If you use both operators, it's a good idea
to use parentheses to indicate explicitly how conditions should be grouped:

</P>

<PRE>
mysql&#62; SELECT * FROM pet WHERE (species = 'cat' AND sex = 'm')
    -&#62; OR (species = 'dog' AND sex = 'f');
+-------+--------+---------+------+------------+-------+
| name  | owner  | species | sex  | birth      | death |
+-------+--------+---------+------+------------+-------+
| Claws | Gwen   | cat     | m    | 1994-03-17 | NULL  |
| Buffy | Harold | dog     | f    | 1989-05-13 | NULL  |
+-------+--------+---------+------+------------+-------+
</PRE>



<H4><A NAME="Selecting_columns" HREF="manual_toc.html#Selecting_columns">3.3.4.3  Selecting Particular Columns</A></H4>

<P>
<A NAME="IDX365"></A>
<A NAME="IDX366"></A>

</P>
<P>
If you don't want to see entire rows from your table, just name the columns
in which you're interested, separated by commas.  For example, if you want to
know when your animals were born, select the <code>name</code> and <code>birth</code>
columns:

</P>

<PRE>
mysql&#62; SELECT name, birth FROM pet;
+----------+------------+
| name     | birth      |
+----------+------------+
| Fluffy   | 1993-02-04 |
| Claws    | 1994-03-17 |
| Buffy    | 1989-05-13 |
| Fang     | 1990-08-27 |
| Bowser   | 1989-08-31 |
| Chirpy   | 1998-09-11 |
| Whistler | 1997-12-09 |
| Slim     | 1996-04-29 |
| Puffball | 1999-03-30 |
+----------+------------+
</PRE>

<P>
To find out who owns pets, use this query:

</P>

<PRE>
mysql&#62; SELECT owner FROM pet;
+--------+
| owner  |
+--------+
| Harold |
| Gwen   |
| Harold |
| Benny  |
| Diane  |
| Gwen   |
| Gwen   |
| Benny  |
| Diane  |
+--------+
</PRE>

<P>
<A NAME="IDX367"></A>
However, notice that the query simply retrieves the <code>owner</code> field from
each record, and some of them appear more than once.  To minimize the output,
retrieve each unique output record just once by adding the keyword
<code>DISTINCT</code>:

</P>

<PRE>
mysql&#62; SELECT DISTINCT owner FROM pet;
+--------+
| owner  |
+--------+
| Benny  |
| Diane  |
| Gwen   |
| Harold |
+--------+
</PRE>

<P>
You can use a <code>WHERE</code> clause to combine row selection with column
selection.  For example, to get birth dates for dogs and cats only,
use this query:

</P>

<PRE>
mysql&#62; SELECT name, species, birth FROM pet
    -&#62; WHERE species = 'dog' OR species = 'cat';
+--------+---------+------------+
| name   | species | birth      |
+--------+---------+------------+
| Fluffy | cat     | 1993-02-04 |
| Claws  | cat     | 1994-03-17 |
| Buffy  | dog     | 1989-05-13 |
| Fang   | dog     | 1990-08-27 |
| Bowser | dog     | 1989-08-31 |
+--------+---------+------------+
</PRE>



<H4><A NAME="Sorting_rows" HREF="manual_toc.html#Sorting_rows">3.3.4.4  Sorting Rows</A></H4>

<P>
<A NAME="IDX368"></A>
<A NAME="IDX369"></A>
<A NAME="IDX370"></A>
<A NAME="IDX371"></A>
<A NAME="IDX372"></A>

</P>
<P>
You may have noticed in the preceding examples that the result rows are
displayed in no particular order.  It's often easier to examine
query output when the rows are sorted in some meaningful way.  To sort a
result, use an <code>ORDER BY</code> clause.

</P>
<P>
Here are animal birthdays, sorted by date:

</P>

<PRE>
mysql&#62; SELECT name, birth FROM pet ORDER BY birth;
+----------+------------+
| name     | birth      |
+----------+------------+
| Buffy    | 1989-05-13 |
| Bowser   | 1989-08-31 |
| Fang     | 1990-08-27 |
| Fluffy   | 1993-02-04 |
| Claws    | 1994-03-17 |
| Slim     | 1996-04-29 |
| Whistler | 1997-12-09 |
| Chirpy   | 1998-09-11 |
| Puffball | 1999-03-30 |
+----------+------------+
</PRE>

<P>
On character type columns, sorting--like all other comparison
operations--is normally performed in a case-insensitive fashion.
This means that the order will be undefined for columns that are identical
except for their case. You can force a case-sensitive sort for a column
by using the <code>BINARY</code> cast: <code>ORDER BY BINARY col_name</code>.

</P>
<P>
The default sort order is ascending, with smallest values first.
To sort in reverse (descending) order, add the <code>DESC</code> keyword to the
name of the column you are sorting by:

</P>

<PRE>
mysql&#62; SELECT name, birth FROM pet ORDER BY birth DESC;
+----------+------------+
| name     | birth      |
+----------+------------+
| Puffball | 1999-03-30 |
| Chirpy   | 1998-09-11 |
| Whistler | 1997-12-09 |
| Slim     | 1996-04-29 |
| Claws    | 1994-03-17 |
| Fluffy   | 1993-02-04 |
| Fang     | 1990-08-27 |
| Bowser   | 1989-08-31 |
| Buffy    | 1989-05-13 |
+----------+------------+
</PRE>

<P>
You can sort on multiple columns, and you can sort columns in different
directions.  For example, to sort by type of
animal in ascending order, then by birth date within animal type in descending
order (youngest animals first), use the following query:

</P>

<PRE>
mysql&#62; SELECT name, species, birth FROM pet
    -&#62; ORDER BY species, birth DESC;
+----------+---------+------------+
| name     | species | birth      |
+----------+---------+------------+
| Chirpy   | bird    | 1998-09-11 |
| Whistler | bird    | 1997-12-09 |
| Claws    | cat     | 1994-03-17 |
| Fluffy   | cat     | 1993-02-04 |
| Fang     | dog     | 1990-08-27 |
| Bowser   | dog     | 1989-08-31 |
| Buffy    | dog     | 1989-05-13 |
| Puffball | hamster | 1999-03-30 |
| Slim     | snake   | 1996-04-29 |
+----------+---------+------------+
</PRE>

<P>
Note that the <code>DESC</code> keyword applies only to the column name immediately
preceding it (<code>birth</code>); it does not affect the <code>species</code> column sort
order.

</P>



<H4><A NAME="Date_calculations" HREF="manual_toc.html#Date_calculations">3.3.4.5  Date Calculations</A></H4>

<P>
<A NAME="IDX373"></A>
<A NAME="IDX374"></A>
<A NAME="IDX375"></A>
<A NAME="IDX376"></A>

</P>
<P>
MySQL provides several functions that you can use to perform
calculations on dates, for example, to calculate ages or extract
parts of dates.

</P>
<P>
To determine how many years old each of your pets is, compute the
difference in the year part of the current date and the birth date, then
subtract one if the current date occurs earlier in the calendar year than
the birth date.  The following query shows, for each pet, the birth date,
the current date, and the age in years.

</P>

<PRE>
mysql&#62; SELECT name, birth, CURDATE(),
    -&#62; (YEAR(CURDATE())-YEAR(birth))
    -&#62; - (RIGHT(CURDATE(),5)&#60;RIGHT(birth,5))
    -&#62; AS age
    -&#62; FROM pet;
+----------+------------+------------+------+
| name     | birth      | CURDATE()  | age  |
+----------+------------+------------+------+
| Fluffy   | 1993-02-04 | 2003-08-19 |   10 |
| Claws    | 1994-03-17 | 2003-08-19 |    9 |
| Buffy    | 1989-05-13 | 2003-08-19 |   14 |
| Fang     | 1990-08-27 | 2003-08-19 |   12 |
| Bowser   | 1989-08-31 | 2003-08-19 |   13 |
| Chirpy   | 1998-09-11 | 2003-08-19 |    4 |
| Whistler | 1997-12-09 | 2003-08-19 |    5 |
| Slim     | 1996-04-29 | 2003-08-19 |    7 |
| Puffball | 1999-03-30 | 2003-08-19 |    4 |
+----------+------------+------------+------+
</PRE>

<P>
Here, <code>YEAR()</code> pulls out the year part of a date and <code>RIGHT()</code>
pulls off the rightmost five characters that represent the <code>MM-DD</code>
(calendar year) part of the date.  The part of the expression that
compares the <code>MM-DD</code> values evaluates to 1 or 0, which adjusts the
year difference down a year if <code>CURDATE()</code> occurs earlier in
the year than <code>birth</code>.  The full expression is somewhat ungainly,
so an alias (<code>age</code>) is used to make the output column label more
meaningful.

</P>
<P>
The query works, but the result could be scanned more easily if the rows
were presented in some order.  This can be done by adding an <code>ORDER
BY name</code> clause to sort the output by name:

</P>

<PRE>
mysql&#62; SELECT name, birth, CURDATE(),
    -&#62; (YEAR(CURDATE())-YEAR(birth))
    -&#62; - (RIGHT(CURDATE(),5)&#60;RIGHT(birth,5))
    -&#62; AS age
    -&#62; FROM pet ORDER BY name;
+----------+------------+------------+------+
| name     | birth      | CURDATE()  | age  |
+----------+------------+------------+------+
| Bowser   | 1989-08-31 | 2003-08-19 |   13 |
| Buffy    | 1989-05-13 | 2003-08-19 |   14 |
| Chirpy   | 1998-09-11 | 2003-08-19 |    4 |
| Claws    | 1994-03-17 | 2003-08-19 |    9 |
| Fang     | 1990-08-27 | 2003-08-19 |   12 |
| Fluffy   | 1993-02-04 | 2003-08-19 |   10 |
| Puffball | 1999-03-30 | 2003-08-19 |    4 |
| Slim     | 1996-04-29 | 2003-08-19 |    7 |
| Whistler | 1997-12-09 | 2003-08-19 |    5 |
+----------+------------+------------+------+
</PRE>

<P>
To sort the output by <code>age</code> rather than <code>name</code>, just use a
different <code>ORDER BY</code> clause:

</P>

<PRE>
mysql&#62; SELECT name, birth, CURDATE(),
    -&#62; (YEAR(CURDATE())-YEAR(birth))
    -&#62; - (RIGHT(CURDATE(),5)&#60;RIGHT(birth,5))
    -&#62; AS age
    -&#62; FROM pet ORDER BY age;
+----------+------------+------------+------+
| name     | birth      | CURDATE()  | age  |
+----------+------------+------------+------+
| Chirpy   | 1998-09-11 | 2003-08-19 |    4 |
| Puffball | 1999-03-30 | 2003-08-19 |    4 |
| Whistler | 1997-12-09 | 2003-08-19 |    5 |
| Slim     | 1996-04-29 | 2003-08-19 |    7 |
| Claws    | 1994-03-17 | 2003-08-19 |    9 |
| Fluffy   | 1993-02-04 | 2003-08-19 |   10 |
| Fang     | 1990-08-27 | 2003-08-19 |   12 |
| Bowser   | 1989-08-31 | 2003-08-19 |   13 |
| Buffy    | 1989-05-13 | 2003-08-19 |   14 |
+----------+------------+------------+------+
</PRE>

<P>
A similar query can be used to determine age at death for animals that have
died.  You determine which animals these are by checking whether the
<code>death</code> value is <code>NULL</code>.  Then, for those with non-<code>NULL</code>
values, compute the difference between the <code>death</code> and <code>birth</code>
values:

</P>

<PRE>
mysql&#62; SELECT name, birth, death,
    -&#62; (YEAR(death)-YEAR(birth)) - (RIGHT(death,5)&#60;RIGHT(birth,5))
    -&#62; AS age
    -&#62; FROM pet WHERE death IS NOT NULL ORDER BY age;
+--------+------------+------------+------+
| name   | birth      | death      | age  |
+--------+------------+------------+------+
| Bowser | 1989-08-31 | 1995-07-29 |    5 |
+--------+------------+------------+------+
</PRE>

<P>
The query uses <code>death IS NOT NULL</code> rather than <code>death &#60;&#62; NULL</code>
because <code>NULL</code> is a special value that cannot be compared using the usual
comparison operators.  This is discussed later.
See section <A HREF="manual_Tutorial.html#Working_with_NULL">3.3.4.6  Working with <code>NULL</code> Values</A>.

</P>
<P>
What if you want to know which animals have birthdays next month?  For this
type of calculation, year and day are irrelevant; you simply want to extract
the month part of the <code>birth</code> column.  MySQL provides several
date-part extraction functions, such as <code>YEAR()</code>, <code>MONTH()</code>, and
<code>DAYOFMONTH()</code>.  <code>MONTH()</code> is the appropriate function here.  To
see how it works, run a simple query that displays the value of both
<code>birth</code> and <code>MONTH(birth)</code>:

</P>

<PRE>
mysql&#62; SELECT name, birth, MONTH(birth) FROM pet;
+----------+------------+--------------+
| name     | birth      | MONTH(birth) |
+----------+------------+--------------+
| Fluffy   | 1993-02-04 |            2 |
| Claws    | 1994-03-17 |            3 |
| Buffy    | 1989-05-13 |            5 |
| Fang     | 1990-08-27 |            8 |
| Bowser   | 1989-08-31 |            8 |
| Chirpy   | 1998-09-11 |            9 |
| Whistler | 1997-12-09 |           12 |
| Slim     | 1996-04-29 |            4 |
| Puffball | 1999-03-30 |            3 |
+----------+------------+--------------+
</PRE>

<P>
Finding animals with birthdays in the upcoming month is easy, too.  Suppose
that the current month is April.  Then the month value is <code>4</code> and you look
for animals born in May (month <code>5</code>) like this:

</P>

<PRE>
mysql&#62; SELECT name, birth FROM pet WHERE MONTH(birth) = 5;
+-------+------------+
| name  | birth      |
+-------+------------+
| Buffy | 1989-05-13 |
+-------+------------+
</PRE>

<P>
There is a small complication if the current month is December.
You don't just add one to the month number (<code>12</code>) and look for animals
born in month <code>13</code>, because there is no such month.  Instead, you look for
animals born in January (month <code>1</code>).

</P>
<P>
You can even write the query so that it works no matter what the current
month is.  That way you don't have to use a particular month number
in the query.  <code>DATE_ADD()</code> allows you to add a time interval to a
given date.  If you add a month to the value of <code>CURDATE()</code>, then extract
the month part with <code>MONTH()</code>, the result produces the month in which to
look for birthdays:

</P>

<PRE>
mysql&#62; SELECT name, birth FROM pet
    -&#62; WHERE MONTH(birth) = MONTH(DATE_ADD(CURDATE(),INTERVAL 1 MONTH));
</PRE>

<P>
A different way to accomplish the same task is to add <code>1</code> to get the
next month after the current one (after using the modulo function (<code>MOD</code>)
to wrap around the month value to <code>0</code> if it is currently
<code>12</code>):

</P>

<PRE>
mysql&#62; SELECT name, birth FROM pet
    -&#62; WHERE MONTH(birth) = MOD(MONTH(CURDATE()), 12) + 1;
</PRE>

<P>
Note that <code>MONTH</code> returns a number between <code>1</code> and <code>12</code>. And
<code>MOD(something,12)</code> returns a number between <code>0</code> and <code>11</code>. So the
addition has to be after the <code>MOD()</code>, otherwise we would go from
November (<code>11</code>) to January (<code>1</code>).

</P>



<H4><A NAME="Working_with_NULL" HREF="manual_toc.html#Working_with_NULL">3.3.4.6  Working with <code>NULL</code> Values</A></H4>

<P>
<A NAME="IDX377"></A>
<A NAME="IDX378"></A>

</P>
<P>
The <code>NULL</code> value can be surprising until you get used to it.
Conceptually, <code>NULL</code> means missing value or unknown value and it
is treated somewhat differently than other values.  To test for <code>NULL</code>,
you cannot use the arithmetic comparison operators such as <code>=</code>, <code>&#60;</code>,
or <code>&#60;&#62;</code>.  To demonstrate this for yourself, try the following query:

</P>

<PRE>
mysql&#62; SELECT 1 = NULL, 1 &#60;&#62; NULL, 1 &#60; NULL, 1 &#62; NULL;
+----------+-----------+----------+----------+
| 1 = NULL | 1 &#60;&#62; NULL | 1 &#60; NULL | 1 &#62; NULL |
+----------+-----------+----------+----------+
|     NULL |      NULL |     NULL |     NULL |
+----------+-----------+----------+----------+
</PRE>

<P>
Clearly you get no meaningful results from these comparisons.  Use
the <code>IS NULL</code> and <code>IS NOT NULL</code> operators instead:

</P>

<PRE>
mysql&#62; SELECT 1 IS NULL, 1 IS NOT NULL;
+-----------+---------------+
| 1 IS NULL | 1 IS NOT NULL |
+-----------+---------------+
|         0 |             1 |
+-----------+---------------+
</PRE>

<P>
Note that in MySQL, <code>0</code> or <code>NULL</code> means false and anything else means
true. The default truth value from a boolean operation is <code>1</code>.

</P>
<P>
This special treatment of <code>NULL</code> is why, in the previous section, it
was necessary to determine which animals are no longer alive using
<code>death IS NOT NULL</code> instead of <code>death &#60;&#62; NULL</code>.

</P>
<P>
Two <code>NULL</code> values are regarded as equal in a <code>GROUP BY</code>.

</P>
<P>
When doing an <code>ORDER BY</code>, <code>NULL</code> values are presented first if you
do <code>ORDER BY ... ASC</code> and last if you do <code>ORDER BY ... DESC</code>.

</P>
<P>
Note that MySQL 4.0.2 to 4.0.10 incorrectly always sorts <code>NULL</code> values
first regardless of the sort direction.

</P>



<H4><A NAME="Pattern_matching" HREF="manual_toc.html#Pattern_matching">3.3.4.7  Pattern Matching</A></H4>

<P>
<A NAME="IDX379"></A>
<A NAME="IDX380"></A>
<A NAME="IDX381"></A>

</P>
<P>
MySQL provides standard SQL pattern matching as well as a form of
pattern matching based on extended regular expressions similar to those used
by Unix utilities such as <code>vi</code>, <code>grep</code>, and <code>sed</code>.

</P>
<P>
SQL pattern matching allows you to use <samp>`_'</samp> to match any single
character and <samp>`%'</samp> to match an arbitrary number of characters (including
zero characters).  In MySQL, SQL patterns are case-insensitive by
default.  Some examples are shown here.  Note that you do not use <code>=</code>
or <code>&#60;&#62;</code> when you use SQL patterns; use the <code>LIKE</code> or <code>NOT
LIKE</code> comparison operators instead.

</P>
<P>
To find names beginning with <samp>`b'</samp>:

</P>

<PRE>
mysql&#62; SELECT * FROM pet WHERE name LIKE 'b%';
+--------+--------+---------+------+------------+------------+
| name   | owner  | species | sex  | birth      | death      |
+--------+--------+---------+------+------------+------------+
| Buffy  | Harold | dog     | f    | 1989-05-13 | NULL       |
| Bowser | Diane  | dog     | m    | 1989-08-31 | 1995-07-29 |
+--------+--------+---------+------+------------+------------+
</PRE>

<P>
To find names ending with <samp>`fy'</samp>:

</P>

<PRE>
mysql&#62; SELECT * FROM pet WHERE name LIKE '%fy';
+--------+--------+---------+------+------------+-------+
| name   | owner  | species | sex  | birth      | death |
+--------+--------+---------+------+------------+-------+
| Fluffy | Harold | cat     | f    | 1993-02-04 | NULL  |
| Buffy  | Harold | dog     | f    | 1989-05-13 | NULL  |
+--------+--------+---------+------+------------+-------+
</PRE>

<P>
To find names containing a <samp>`w'</samp>:

</P>

<PRE>
mysql&#62; SELECT * FROM pet WHERE name LIKE '%w%';
+----------+-------+---------+------+------------+------------+
| name     | owner | species | sex  | birth      | death      |
+----------+-------+---------+------+------------+------------+
| Claws    | Gwen  | cat     | m    | 1994-03-17 | NULL       |
| Bowser   | Diane | dog     | m    | 1989-08-31 | 1995-07-29 |
| Whistler | Gwen  | bird    | NULL | 1997-12-09 | NULL       |
+----------+-------+---------+------+------------+------------+
</PRE>

<P>
To find names containing exactly five characters, use five instances of
the <samp>`_'</samp> pattern character:

</P>

<PRE>
mysql&#62; SELECT * FROM pet WHERE name LIKE '_____';
+-------+--------+---------+------+------------+-------+
| name  | owner  | species | sex  | birth      | death |
+-------+--------+---------+------+------------+-------+
| Claws | Gwen   | cat     | m    | 1994-03-17 | NULL  |
| Buffy | Harold | dog     | f    | 1989-05-13 | NULL  |
+-------+--------+---------+------+------------+-------+
</PRE>

<P>
The other type of pattern matching provided by MySQL uses extended
regular expressions.  When you test for a match for this type of pattern, use
the <code>REGEXP</code> and <code>NOT REGEXP</code> operators (or <code>RLIKE</code> and
<code>NOT RLIKE</code>, which are synonyms).

</P>
<P>
Some characteristics of extended regular expressions are:

</P>

<UL>
<LI>

<samp>`.'</samp> matches any single character.

<LI>

A character class <samp>`[...]'</samp> matches any character within the brackets.
For example, <samp>`[abc]'</samp> matches <samp>`a'</samp>, <samp>`b'</samp>, or <samp>`c'</samp>.  To name a
range of characters, use a dash.  <samp>`[a-z]'</samp> matches any letter,
whereas <samp>`[0-9]'</samp> matches any digit.

<LI>

<samp>`*'</samp> matches zero or more instances of the thing preceding it.  For
example, <samp>`x*'</samp> matches any number of <samp>`x'</samp> characters,
<samp>`[0-9]*'</samp> matches any number of digits, and <samp>`.*'</samp> matches any
number of anything.

<LI>

A <code>REGEXP</code> pattern match succeed if
the pattern matches anywhere in the value being tested.
(This differs from a <code>LIKE</code> pattern match, which succeeds only if the
pattern matches the entire value.)

<LI>

To anchor a pattern so that it must match the beginning or end of the value
being tested, use <samp>`^'</samp> at the beginning or <samp>`$'</samp> at the end of the
pattern.
</UL>

<P>
To demonstrate how extended regular expressions work, the <code>LIKE</code> queries
shown previously are rewritten here to use <code>REGEXP</code>.

</P>
<P>
To find names beginning with <samp>`b'</samp>, use <samp>`^'</samp> to match the beginning of
the name:

</P>

<PRE>
mysql&#62; SELECT * FROM pet WHERE name REGEXP '^b';
+--------+--------+---------+------+------------+------------+
| name   | owner  | species | sex  | birth      | death      |
+--------+--------+---------+------+------------+------------+
| Buffy  | Harold | dog     | f    | 1989-05-13 | NULL       |
| Bowser | Diane  | dog     | m    | 1989-08-31 | 1995-07-29 |
+--------+--------+---------+------+------------+------------+
</PRE>

<P>
Prior to MySQL Version 3.23.4, <code>REGEXP</code> is case sensitive,
and the previous query will return no rows. In this case, to match either
lowercase or uppercase <samp>`b'</samp>, use this query instead:

</P>

<PRE>
mysql&#62; SELECT * FROM pet WHERE name REGEXP '^[bB]';
</PRE>

<P>
From MySQL 3.23.4 on, if you really want to force a <code>REGEXP</code> comparison to
be case sensitive, use the <code>BINARY</code> keyword to make one of the
strings a binary string. This query will match only lowercase <samp>`b'</samp>
at the beginning of a name:

</P>

<PRE>
mysql&#62; SELECT * FROM pet WHERE name REGEXP BINARY '^b';
</PRE>

<P>
To find names ending with <samp>`fy'</samp>, use <samp>`$'</samp> to match the end of the
name:

</P>

<PRE>
mysql&#62; SELECT * FROM pet WHERE name REGEXP 'fy$';
+--------+--------+---------+------+------------+-------+
| name   | owner  | species | sex  | birth      | death |
+--------+--------+---------+------+------------+-------+
| Fluffy | Harold | cat     | f    | 1993-02-04 | NULL  |
| Buffy  | Harold | dog     | f    | 1989-05-13 | NULL  |
+--------+--------+---------+------+------------+-------+
</PRE>

<P>
To find names containing a <samp>`w'</samp>, use this query:

</P>

<PRE>
mysql&#62; SELECT * FROM pet WHERE name REGEXP 'w';
+----------+-------+---------+------+------------+------------+
| name     | owner | species | sex  | birth      | death      |
+----------+-------+---------+------+------------+------------+
| Claws    | Gwen  | cat     | m    | 1994-03-17 | NULL       |
| Bowser   | Diane | dog     | m    | 1989-08-31 | 1995-07-29 |
| Whistler | Gwen  | bird    | NULL | 1997-12-09 | NULL       |
+----------+-------+---------+------+------------+------------+
</PRE>

<P>
Because a regular expression pattern matches if it occurs anywhere in the
value, it is not necessary in the previous query to put a wildcard on either
side of the pattern to get it to match the entire value like it would be if
you used an SQL pattern.

</P>
<P>
To find names containing exactly five characters, use <samp>`^'</samp> and <samp>`$'</samp>
to match the beginning and end of the name, and five instances of <samp>`.'</samp>
in between:

</P>

<PRE>
mysql&#62; SELECT * FROM pet WHERE name REGEXP '^.....$';
+-------+--------+---------+------+------------+-------+
| name  | owner  | species | sex  | birth      | death |
+-------+--------+---------+------+------------+-------+
| Claws | Gwen   | cat     | m    | 1994-03-17 | NULL  |
| Buffy | Harold | dog     | f    | 1989-05-13 | NULL  |
+-------+--------+---------+------+------------+-------+
</PRE>

<P>
You could also write the previous query using the <samp>`{n}'</samp>
``repeat-<code>n</code>-times'' operator:

</P>

<PRE>
mysql&#62; SELECT * FROM pet WHERE name REGEXP '^.{5}$';
+-------+--------+---------+------+------------+-------+
| name  | owner  | species | sex  | birth      | death |
+-------+--------+---------+------+------------+-------+
| Claws | Gwen   | cat     | m    | 1994-03-17 | NULL  |
| Buffy | Harold | dog     | f    | 1989-05-13 | NULL  |
+-------+--------+---------+------+------------+-------+
</PRE>



<H4><A NAME="Counting_rows" HREF="manual_toc.html#Counting_rows">3.3.4.8  Counting Rows</A></H4>

<P>
<A NAME="IDX382"></A>
<A NAME="IDX383"></A>
<A NAME="IDX384"></A>

</P>
<P>
Databases are often used to answer the question, ``How often does a certain
type of data occur in a table?''  For example, you might want to know how
many pets you have, or how many pets each owner has, or you might want to
perform various kinds of census operations on your animals.

</P>
<P>
Counting the total number of animals you have is the same question as ``How
many rows are in the <code>pet</code> table?'' because there is one record per pet.
<code>COUNT(*)</code> counts the number of rows, so
the query to count your animals looks like this:

</P>

<PRE>
mysql&#62; SELECT COUNT(*) FROM pet;
+----------+
| COUNT(*) |
+----------+
|        9 |
+----------+
</PRE>

<P>
Earlier, you retrieved the names of the people who owned pets.  You can
use <code>COUNT()</code> if you want to find out how many pets each owner has:

</P>

<PRE>
mysql&#62; SELECT owner, COUNT(*) FROM pet GROUP BY owner;
+--------+----------+
| owner  | COUNT(*) |
+--------+----------+
| Benny  |        2 |
| Diane  |        2 |
| Gwen   |        3 |
| Harold |        2 |
+--------+----------+
</PRE>

<P>
Note the use of <code>GROUP BY</code> to group together all records for each
<code>owner</code>.  Without it, all you get is an error message:

</P>

<PRE>
mysql&#62; SELECT owner, COUNT(*) FROM pet;
ERROR 1140: Mixing of GROUP columns (MIN(),MAX(),COUNT()...)
with no GROUP columns is illegal if there is no GROUP BY clause
</PRE>

<P>
<code>COUNT()</code> and <code>GROUP BY</code> are useful for characterizing your
data in various ways.  The following examples show different ways to
perform animal census operations.

</P>
<P>
Number of animals per species:

</P>

<PRE>
mysql&#62; SELECT species, COUNT(*) FROM pet GROUP BY species;
+---------+----------+
| species | COUNT(*) |
+---------+----------+
| bird    |        2 |
| cat     |        2 |
| dog     |        3 |
| hamster |        1 |
| snake   |        1 |
+---------+----------+
</PRE>

<P>
Number of animals per sex:

</P>

<PRE>
mysql&#62; SELECT sex, COUNT(*) FROM pet GROUP BY sex;
+------+----------+
| sex  | COUNT(*) |
+------+----------+
| NULL |        1 |
| f    |        4 |
| m    |        4 |
+------+----------+
</PRE>

<P>
(In this output, <code>NULL</code> indicates that the sex is unknown.)

</P>
<P>
Number of animals per combination of species and sex:

</P>

<PRE>
mysql&#62; SELECT species, sex, COUNT(*) FROM pet GROUP BY species, sex;
+---------+------+----------+
| species | sex  | COUNT(*) |
+---------+------+----------+
| bird    | NULL |        1 |
| bird    | f    |        1 |
| cat     | f    |        1 |
| cat     | m    |        1 |
| dog     | f    |        1 |
| dog     | m    |        2 |
| hamster | f    |        1 |
| snake   | m    |        1 |
+---------+------+----------+
</PRE>

<P>
You need not retrieve an entire table when you use <code>COUNT()</code>.  For
example, the previous query, when performed just on dogs and cats, looks like
this:

</P>

<PRE>
mysql&#62; SELECT species, sex, COUNT(*) FROM pet
    -&#62; WHERE species = 'dog' OR species = 'cat'
    -&#62; GROUP BY species, sex;
+---------+------+----------+
| species | sex  | COUNT(*) |
+---------+------+----------+
| cat     | f    |        1 |
| cat     | m    |        1 |
| dog     | f    |        1 |
| dog     | m    |        2 |
+---------+------+----------+
</PRE>

<P>
Or, if you wanted the number of animals per sex only for known-sex animals:

</P>

<PRE>
mysql&#62; SELECT species, sex, COUNT(*) FROM pet
    -&#62; WHERE sex IS NOT NULL
    -&#62; GROUP BY species, sex;
+---------+------+----------+
| species | sex  | COUNT(*) |
+---------+------+----------+
| bird    | f    |        1 |
| cat     | f    |        1 |
| cat     | m    |        1 |
| dog     | f    |        1 |
| dog     | m    |        2 |
| hamster | f    |        1 |
| snake   | m    |        1 |
+---------+------+----------+
</PRE>



<H4><A NAME="Multiple_tables" HREF="manual_toc.html#Multiple_tables">3.3.4.9  Using More Than one Table</A></H4>

<P>
<A NAME="IDX385"></A>

</P>
<P>
The <code>pet</code> table keeps track of which pets you have.  If you want to
record other information about them, such as events in their lives like
visits to the vet or when litters are born, you need another table.  What
should this table look like? It needs:

</P>

<UL>
<LI>

To contain the pet name so you know which animal each event pertains
to.

<LI>

A date so you know when the event occurred.

<LI>

A field to describe the event.

<LI>

An event type field, if you want to be able to categorize events.
</UL>

<P>
Given these considerations, the <code>CREATE TABLE</code> statement for the
<code>event</code> table might look like this:

</P>

<PRE>
mysql&#62; CREATE TABLE event (name VARCHAR(20), date DATE,
    -&#62; type VARCHAR(15), remark VARCHAR(255));
</PRE>

<P>
As with the <code>pet</code> table, it's easiest to load the initial records
by creating a tab-delimited text file containing the information:

</P>
<TABLE BORDER>
<TR><TD><strong>name</strong> </TD><TD> <strong>date</strong> </TD><TD> <strong>type</strong> </TD><TD> <strong>remark</strong>
</TD></TR>
<TR><TD>Fluffy </TD><TD> 1995-05-15 </TD><TD> litter </TD><TD> 4 kittens, 3 female, 1 male
</TD></TR>
<TR><TD>Buffy </TD><TD> 1993-06-23 </TD><TD> litter </TD><TD> 5 puppies, 2 female, 3 male
</TD></TR>
<TR><TD>Buffy </TD><TD> 1994-06-19 </TD><TD> litter </TD><TD> 3 puppies, 3 female
</TD></TR>
<TR><TD>Chirpy </TD><TD> 1999-03-21 </TD><TD> vet </TD><TD> needed beak straightened
</TD></TR>
<TR><TD>Slim </TD><TD> 1997-08-03 </TD><TD> vet </TD><TD> broken rib
</TD></TR>
<TR><TD>Bowser </TD><TD> 1991-10-12 </TD><TD> kennel </TD><TD>
</TD></TR>
<TR><TD>Fang </TD><TD> 1991-10-12 </TD><TD> kennel </TD><TD>
</TD></TR>
<TR><TD>Fang </TD><TD> 1998-08-28 </TD><TD> birthday </TD><TD> Gave him a new chew toy
</TD></TR>
<TR><TD>Claws </TD><TD> 1998-03-17 </TD><TD> birthday </TD><TD> Gave him a new flea collar
</TD></TR>
<TR><TD>Whistler </TD><TD> 1998-12-09 </TD><TD> birthday </TD><TD> First birthday
</TD></TR>
</TABLE>

<P>
Load the records like this:

</P>

<PRE>
mysql&#62; LOAD DATA LOCAL INFILE 'event.txt' INTO TABLE event;
</PRE>

<P>
Based on what you've learned from the queries you've run on the <code>pet</code>
table, you should be able to perform retrievals on the records in the
<code>event</code> table; the principles are the same.  But when is the
<code>event</code> table by itself insufficient to answer questions you might ask?

</P>
<P>
Suppose that you want to find out the ages at which each pet had its
litters. We saw earlier how to calculate ages from two dates.
The litter date of the mother is in the
<code>event</code> table, but to calculate her age on that date you need her
birth date, which is stored in the <code>pet</code> table.
This means the query requires both tables:

</P>

<PRE>
mysql&#62; SELECT pet.name,
    -&#62; (YEAR(date)-YEAR(birth)) - (RIGHT(date,5)&#60;RIGHT(birth,5)) AS age,
    -&#62; remark
    -&#62; FROM pet, event
    -&#62; WHERE pet.name = event.name AND type = 'litter';
+--------+------+-----------------------------+
| name   | age  | remark                      |
+--------+------+-----------------------------+
| Fluffy |    2 | 4 kittens, 3 female, 1 male |
| Buffy  |    4 | 5 puppies, 2 female, 3 male |
| Buffy  |    5 | 3 puppies, 3 female         |
+--------+------+-----------------------------+
</PRE>

<P>
There are several things to note about this query:

</P>

<UL>
<LI>

The <code>FROM</code> clause lists two tables because the query needs to pull
information from both of them.

<LI>

When combining (joining) information from multiple tables, you need to
specify how records in one table can be matched to records in the other.
This is easy because they both have a <code>name</code> column.  The query uses
<code>WHERE</code> clause to match up records in the two tables based on the
<code>name</code> values.

<LI>

Because the <code>name</code> column occurs in both tables, you must be specific
about which table you mean when referring to the column.  This is done
by prepending the table name to the column name.
</UL>

<P>
You need not have two different tables to perform a join.  Sometimes it is
useful to join a table to itself, if you want to compare records in a table
to other records in that same table.  For example, to find breeding pairs
among your pets, you can join the <code>pet</code> table with itself to produce
candidate pairs of males and females of like species:

</P>

<PRE>
mysql&#62; SELECT p1.name, p1.sex, p2.name, p2.sex, p1.species
    -&#62; FROM pet AS p1, pet AS p2
    -&#62; WHERE p1.species = p2.species AND p1.sex = 'f' AND p2.sex = 'm';
+--------+------+--------+------+---------+
| name   | sex  | name   | sex  | species |
+--------+------+--------+------+---------+
| Fluffy | f    | Claws  | m    | cat     |
| Buffy  | f    | Fang   | m    | dog     |
| Buffy  | f    | Bowser | m    | dog     |
+--------+------+--------+------+---------+
</PRE>

<P>
In this query, we specify aliases for the table name in order
to refer to the columns and keep straight which instance of the table
each column reference is associated with.

</P>



<H2><A NAME="Getting_information" HREF="manual_toc.html#Getting_information">3.4  Getting Information About Databases and Tables</A></H2>

<P>
<A NAME="IDX386"></A>
<A NAME="IDX387"></A>
<A NAME="IDX388"></A>

</P>
<P>
What if you forget the name of a database or table, or what the structure of
a given table is (for example, what its columns are called)?  MySQL
addresses this problem through several statements that provide information
about the databases and tables it supports.

</P>
<P>
You have already seen <code>SHOW DATABASES</code>, which lists the databases
managed by the server.  To find out which database is currently selected,
use the <code>DATABASE()</code> function:

</P>

<PRE>
mysql&#62; SELECT DATABASE();
+------------+
| DATABASE() |
+------------+
| menagerie  |
+------------+
</PRE>

<P>
If you haven't selected any database yet, the result is <code>NULL</code>
(or the empty string before MySQL 4.1.1).

</P>
<P>
To find out what tables the current database contains (for example, when
you're not sure about the name of a table), use this command:

</P>

<PRE>
mysql&#62; SHOW TABLES;
+---------------------+
| Tables in menagerie |
+---------------------+
| event               |
| pet                 |
+---------------------+
</PRE>

<P>
If you want to find out about the structure of a table, the <code>DESCRIBE</code>
command is useful; it displays information about each of a table's columns:

</P>

<PRE>
mysql&#62; DESCRIBE pet;
+---------+-------------+------+-----+---------+-------+
| Field   | Type        | Null | Key | Default | Extra |
+---------+-------------+------+-----+---------+-------+
| name    | varchar(20) | YES  |     | NULL    |       |
| owner   | varchar(20) | YES  |     | NULL    |       |
| species | varchar(20) | YES  |     | NULL    |       |
| sex     | char(1)     | YES  |     | NULL    |       |
| birth   | date        | YES  |     | NULL    |       |
| death   | date        | YES  |     | NULL    |       |
+---------+-------------+------+-----+---------+-------+
</PRE>

<P>
<code>Field</code> indicates the column name, <code>Type</code> is the data type for
the column, <code>NULL</code> indicates whether the column can contain
<code>NULL</code> values, <code>Key</code> indicates whether the column is
indexed, and <code>Default</code> specifies the column's default value.

</P>
<P>
If you have indexes on a table,
<code>SHOW INDEX FROM <var>tbl_name</var></code> produces information about them.

</P>



<H2><A NAME="Batch_mode" HREF="manual_toc.html#Batch_mode">3.5  Using <code>mysql</code> in Batch Mode</A></H2>

<P>
<A NAME="IDX389"></A>
<A NAME="IDX390"></A>
<A NAME="IDX391"></A>
<A NAME="IDX392"></A>
<A NAME="IDX393"></A>

</P>
<P>
In the previous sections, you used <code>mysql</code> interactively to enter
queries and view the results.  You can also run <code>mysql</code> in batch
mode.  To do this, put the commands you want to run in a file, then
tell <code>mysql</code> to read its input from the file:

</P>

<PRE>
shell&#62; mysql &#60; <var>batch-file</var>
</PRE>

<P>
If you are running <code>mysql</code> under Windows and have some special
characters in the file that cause problems, you can do this:

</P>

<PRE>
C:\&#62; mysql -e "source <var>batch-file</var>"
</PRE>

<P>
If you need to specify connection parameters on the command line, the
command might look like this:

</P>

<PRE>
shell&#62; mysql -h <var>host</var> -u <var>user</var> -p &#60; <var>batch-file</var>
Enter password: ********
</PRE>

<P>
When you use <code>mysql</code> this way, you are creating a script file, then
executing the script.

</P>
<P>
If you want the script to continue even if some of the statements in it
produce errors, you should
use the <code>--force</code> command-line option.

</P>
<P>
Why use a script?  Here are a few reasons:

</P>

<UL>
<LI>

If you run a query repeatedly (say, every day or every week), making it a
script allows you to avoid retyping it each time you execute it.

<LI>

You can generate new queries from existing ones that are similar by copying
and editing script files.

<LI>

Batch mode can also be useful while you're developing a query, particularly
for multiple-line commands or multiple-statement sequences of commands.  If
you make a mistake, you don't have to retype everything.  Just edit your
script to correct the error, then tell <code>mysql</code> to execute it again.

<LI>

If you have a query that produces a lot of output, you can run the output
through a pager rather than watching it scroll off the top of your screen:


<PRE>
shell&#62; mysql &#60; <var>batch-file</var> | more
</PRE>

<LI>

You can catch the output in a file for further processing:


<PRE>
shell&#62; mysql &#60; <var>batch-file</var> &#62; mysql.out
</PRE>

<LI>

You can distribute your script to other people so they can run the commands,
too.

<LI>

Some situations do not allow for interactive use, for example, when you run
a query from a <code>cron</code> job.  In this case, you must use batch mode.
</UL>

<P>
The default output format is different (more concise) when you run
<code>mysql</code> in batch mode than when you use it interactively.  For
example, the output of <code>SELECT DISTINCT species FROM pet</code> looks like
this when <code>mysql</code> is run interactively:

</P>

<PRE>
+---------+
| species |
+---------+
| bird    |
| cat     |
| dog     |
| hamster |
| snake   |
+---------+
</PRE>

<P>
In batch mode, the output looks like this instead:

</P>

<PRE>
species
bird
cat
dog
hamster
snake
</PRE>

<P>
If you want to get the interactive output format in batch mode, use
<code>mysql -t</code>.  To echo to the output the commands that are executed, use
<code>mysql -vvv</code>.

</P>
<P>
You can also use scripts from the <code>mysql</code> prompt by
using the <code>source</code> or <code>\.</code> command:

</P>

<PRE>
mysql&#62; source filename;
mysql&#62; \. filename
</PRE>



<H2><A NAME="Examples" HREF="manual_toc.html#Examples">3.6  Examples of Common Queries</A></H2>

<P>
<A NAME="IDX394"></A>
<A NAME="IDX395"></A>

</P>
<P>
Here are examples of how to solve some common problems with
MySQL.

</P>
<P>
Some of the examples use the table <code>shop</code> to hold the price of each
article (item number) for certain traders (dealers).  Supposing that each
trader has a single fixed price per article, then (<code>article</code>,
<code>dealer</code>) is a primary key for the records.

</P>
<P>
Start the command-line tool <code>mysql</code> and select a database:

</P>

<PRE>
shell&#62; mysql your-database-name
</PRE>

<P>
(In most MySQL installations, you can use the database name <code>test</code>).

</P>
<P>
You can create and populate the example table with these statements:

</P>

<PRE>
mysql&#62; CREATE TABLE shop (
    -&#62; article INT(4) UNSIGNED ZEROFILL DEFAULT '0000' NOT NULL,
    -&#62; dealer  CHAR(20)                 DEFAULT ''     NOT NULL,
    -&#62; price   DOUBLE(16,2)             DEFAULT '0.00' NOT NULL,
    -&#62; PRIMARY KEY(article, dealer));
mysql&#62; INSERT INTO shop VALUES
    -&#62; (1,'A',3.45),(1,'B',3.99),(2,'A',10.99),(3,'B',1.45),
    -&#62; (3,'C',1.69),(3,'D',1.25),(4,'D',19.95);
</PRE>

<P>
After issuing the statements, the table should have the following contents:

</P>

<PRE>
mysql&#62; SELECT * FROM shop;
+---------+--------+-------+
| article | dealer | price |
+---------+--------+-------+
|    0001 | A      |  3.45 |
|    0001 | B      |  3.99 |
|    0002 | A      | 10.99 |
|    0003 | B      |  1.45 |
|    0003 | C      |  1.69 |
|    0003 | D      |  1.25 |
|    0004 | D      | 19.95 |
+---------+--------+-------+
</PRE>



<H3><A NAME="example-Maximum-column" HREF="manual_toc.html#example-Maximum-column">3.6.1  The Maximum Value for a Column</A></H3>

<P>
``What's the highest item number?''

</P>

<PRE>
SELECT MAX(article) AS article FROM shop;

+---------+
| article |
+---------+
|       4 |
+---------+
</PRE>



<H3><A NAME="example-Maximum-row" HREF="manual_toc.html#example-Maximum-row">3.6.2  The Row Holding the Maximum of a Certain Column</A></H3>

<P>
``Find number, dealer, and price of the most expensive article.''

</P>
<P>
In standard SQL (and as of MySQL 4.1), this is easily done with a subquery:

</P>

<PRE>
SELECT article, dealer, price
FROM   shop
WHERE  price=(SELECT MAX(price) FROM shop);
</PRE>

<P>
In MySQL versions prior to 4.1, just do it in two steps:

</P>

<OL>
<LI>

Get the maximum price value from the table with a <code>SELECT</code> statement.

<PRE>
mysql&#62; SELECT MAX(price) FROM shop;
+------------+
| MAX(price) |
+------------+
|      19.95 |
+------------+
</PRE>

<LI>

Using the value 19.95 shown by the previous query to be the maximum
article price, write a query to locate and display the corresponding record:

<PRE>
mysql&#62; SELECT article, dealer, price
    -&#62; FROM   shop
    -&#62; WHERE  price=19.95;
+---------+--------+-------+
| article | dealer | price |
+---------+--------+-------+
|    0004 | D      | 19.95 |
+---------+--------+-------+
</PRE>

</OL>

<P>
Another solution is to sort all rows descending by price and only
get the first row using the MySQL-specific <code>LIMIT</code> clause:

</P>

<PRE>
SELECT article, dealer, price
FROM   shop
ORDER BY price DESC
LIMIT 1;
</PRE>

<P>
Note:  If there were several most expensive articles, each with a
price of 19.95, the <code>LIMIT</code> solution would show only one of them!

</P>



<H3><A NAME="example-Maximum-column-group" HREF="manual_toc.html#example-Maximum-column-group">3.6.3  Maximum of Column per Group</A></H3>

<P>
``What's the highest price per article?''

</P>

<PRE>
SELECT article, MAX(price) AS price
FROM   shop
GROUP BY article

+---------+-------+
| article | price |
+---------+-------+
|    0001 |  3.99 |
|    0002 | 10.99 |
|    0003 |  1.69 |
|    0004 | 19.95 |
+---------+-------+
</PRE>



<H3><A NAME="example-Maximum-column-group-row" HREF="manual_toc.html#example-Maximum-column-group-row">3.6.4  The Rows Holding the Group-wise Maximum of a Certain Field</A></H3>

<P>
``For each article, find the dealer or dealers with the most expensive price.''

</P>
<P>
In standard SQL (and as of MySQL 4.1), the problem can be solved
with a subquery like this:

</P>

<PRE>
SELECT article, dealer, price
FROM   shop s1
WHERE  price=(SELECT MAX(s2.price)
              FROM shop s2
              WHERE s1.article = s2.article);
</PRE>

<P>
In MySQL versions prior to 4.1, it's best do it in several steps:

</P>

<OL>
<LI>

Get the list of (article,maxprice) pairs.
<LI>

For each article, get the corresponding rows that have the stored maximum
price.
</OL>

<P>
This can easily be done with a temporary table and a join:

</P>

<PRE>
CREATE TEMPORARY TABLE tmp (
        article INT(4) UNSIGNED ZEROFILL DEFAULT '0000' NOT NULL,
        price   DOUBLE(16,2)             DEFAULT '0.00' NOT NULL);

LOCK TABLES shop READ;

INSERT INTO tmp SELECT article, MAX(price) FROM shop GROUP BY article;

SELECT shop.article, dealer, shop.price FROM shop, tmp
WHERE shop.article=tmp.article AND shop.price=tmp.price;

UNLOCK TABLES;

DROP TABLE tmp;
</PRE>

<P>
If you don't use a <code>TEMPORARY</code> table, you must also lock the <code>tmp</code>
table.

</P>
<P>
``Can it be done with a single query?''

</P>
<P>
Yes, but only by using a quite inefficient trick called the
``MAX-CONCAT trick'':

</P>

<PRE>
SELECT article,
       SUBSTRING( MAX( CONCAT(LPAD(price,6,'0'),dealer) ), 7) AS dealer,
  0.00+LEFT(      MAX( CONCAT(LPAD(price,6,'0'),dealer) ), 6) AS price
FROM   shop
GROUP BY article;

+---------+--------+-------+
| article | dealer | price |
+---------+--------+-------+
|    0001 | B      |  3.99 |
|    0002 | A      | 10.99 |
|    0003 | C      |  1.69 |
|    0004 | D      | 19.95 |
+---------+--------+-------+
</PRE>

<P>
The last example can be made a bit more efficient by doing the
splitting of the concatenated column in the client.

</P>



<H3><A NAME="example-user-variables" HREF="manual_toc.html#example-user-variables">3.6.5  Using User Variables</A></H3>

<P>
You can use MySQL user variables to remember results without
having to store them in temporary variables in the client.
See section <A HREF="manual_Language_Structure.html#Variables">9.3  User Variables</A>.

</P>
<P>
For example, to find the articles with the highest and lowest price you
can do this:

</P>

<PRE>
mysql&#62; SELECT @min_price:=MIN(price),@max_price:=MAX(price) FROM shop;
mysql&#62; SELECT * FROM shop WHERE price=@min_price OR price=@max_price;
+---------+--------+-------+
| article | dealer | price |
+---------+--------+-------+
|    0003 | D      |  1.25 |
|    0004 | D      | 19.95 |
+---------+--------+-------+
</PRE>



<H3><A NAME="example-Foreign_keys" HREF="manual_toc.html#example-Foreign_keys">3.6.6  Using Foreign Keys</A></H3>

<P>
<A NAME="IDX396"></A>
<A NAME="IDX397"></A>

</P>
<P>
In MySQL 3.23.44 and up, <code>InnoDB</code> tables support checking of
foreign key constraints. See section <A HREF="manual_InnoDB.html#InnoDB">15  The <code>InnoDB</code> Storage Engine</A>.
See also section <A HREF="manual_Introduction.html#ANSI_diff_Foreign_Keys">1.5.5.5  Foreign Keys</A>.

</P>
<P>
You don't actually need foreign keys to join two tables.
For table types other than <code>InnoDB</code>,
the only things MySQL currently doesn't do are 1)
<code>CHECK</code> to make sure that the keys you use
really exist in the table or tables you're referencing and 2)
automatically delete rows from a table with a foreign key
definition. Using your keys to join tables will work just fine:

</P>

<PRE>
CREATE TABLE person (
    id SMALLINT UNSIGNED NOT NULL AUTO_INCREMENT,
    name CHAR(60) NOT NULL,
    PRIMARY KEY (id)
);

CREATE TABLE shirt (
    id SMALLINT UNSIGNED NOT NULL AUTO_INCREMENT,
    style ENUM('t-shirt', 'polo', 'dress') NOT NULL,
    color ENUM('red', 'blue', 'orange', 'white', 'black') NOT NULL,
    owner SMALLINT UNSIGNED NOT NULL REFERENCES person(id),
    PRIMARY KEY (id)
);

INSERT INTO person VALUES (NULL, 'Antonio Paz');

SELECT @last := LAST_INSERT_ID();

INSERT INTO shirt VALUES
(NULL, 'polo', 'blue', @last),
(NULL, 'dress', 'white', @last),
(NULL, 't-shirt', 'blue', @last);

INSERT INTO person VALUES (NULL, 'Lilliana Angelovska');

SELECT @last := LAST_INSERT_ID();

INSERT INTO shirt VALUES
(NULL, 'dress', 'orange', @last),
(NULL, 'polo', 'red', @last),
(NULL, 'dress', 'blue', @last),
(NULL, 't-shirt', 'white', @last);

SELECT * FROM person;
+----+---------------------+
| id | name                |
+----+---------------------+
|  1 | Antonio Paz         |
|  2 | Lilliana Angelovska |
+----+---------------------+

SELECT * FROM shirt;
+----+---------+--------+-------+
| id | style   | color  | owner |
+----+---------+--------+-------+
|  1 | polo    | blue   |     1 |
|  2 | dress   | white  |     1 |
|  3 | t-shirt | blue   |     1 |
|  4 | dress   | orange |     2 |
|  5 | polo    | red    |     2 |
|  6 | dress   | blue   |     2 |
|  7 | t-shirt | white  |     2 |
+----+---------+--------+-------+

SELECT s.* FROM person p, shirt s
 WHERE p.name LIKE 'Lilliana%'
   AND s.owner = p.id
   AND s.color &#60;&#62; 'white';

+----+-------+--------+-------+
| id | style | color  | owner |
+----+-------+--------+-------+
|  4 | dress | orange |     2 |
|  5 | polo  | red    |     2 |
|  6 | dress | blue   |     2 |
+----+-------+--------+-------+
</PRE>



<H3><A NAME="Searching_on_two_keys" HREF="manual_toc.html#Searching_on_two_keys">3.6.7  Searching on Two Keys</A></H3>

<P>
<A NAME="IDX398"></A>
<A NAME="IDX399"></A>
<A NAME="IDX400"></A>
<A NAME="IDX401"></A>

</P>
<P>
An <code>OR</code> using a single key is well optimized, as is the handling
of <code>AND</code>.

</P>
<P>
The one tricky case is that of searching on two different keys
combined with <code>OR</code>:

</P>

<PRE>
SELECT field1_index, field2_index FROM test_table
WHERE field1_index = '1' OR  field2_index = '1'
</PRE>

<P>
This case is optimized from MySQL 5.0.0.
See section <A HREF="manual_MySQL_Optimization.html#Index_Merge_optimization">7.2.6  Index Merge Optimization</A>.

</P>
<P>
In MySQL 4.0 and up, you can also solve the problem efficiently by
using a <code>UNION</code> that combines the output of two separate
<code>SELECT</code> statements.
See section <A HREF="manual_SQL_Syntax.html#UNION">13.1.7.2  <code>UNION</code> Syntax</A>.

</P>
<P>
Each <code>SELECT</code> searches only one key and can be optimized:

</P>

<PRE>
SELECT field1_index, field2_index
    FROM test_table WHERE field1_index = '1'
UNION
SELECT field1_index, field2_index
    FROM test_table WHERE field2_index = '1';
</PRE>

<P>
Prior to MySQL 4.0, you can achieve the same effect by using a
<code>TEMPORARY</code> table and separate <code>SELECT</code> statements.
This type of optimization is also very good if
you are using very complicated queries where the SQL server does the
optimizations in the wrong order.

</P>

<PRE>
CREATE TEMPORARY TABLE tmp
SELECT field1_index, field2_index
    FROM test_table WHERE field1_index = '1';
INSERT INTO tmp
SELECT field1_index, field2_index
    FROM test_table WHERE field2_index = '1';
SELECT * from tmp;
DROP TABLE tmp;
</PRE>

<P>
This method of solving the problem is in effect a <code>UNION</code> of two queries.

</P>


<H3><A NAME="Calculating_days" HREF="manual_toc.html#Calculating_days">3.6.8  Calculating Visits Per Day</A></H3>

<P>
<A NAME="IDX402"></A>
<A NAME="IDX403"></A>
<A NAME="IDX404"></A>
<A NAME="IDX405"></A>

</P>
<P>
The following example shows how you can use the bit group functions
to calculate the number of days per month a user has visited a Web page.

</P>

<PRE>
CREATE TABLE t1 (year YEAR(4), month INT(2) UNSIGNED ZEROFILL,
             day INT(2) UNSIGNED ZEROFILL);
INSERT INTO t1 VALUES(2000,1,1),(2000,1,20),(2000,1,30),(2000,2,2),
            (2000,2,23),(2000,2,23);
</PRE>

<P>
The example table contains year-month-day values representing visits by users
to the page. To determine how many different days in each month these visits
occur, use this query:

</P>

<PRE>
SELECT year,month,BIT_COUNT(BIT_OR(1&#60;&#60;day)) AS days FROM t1
       GROUP BY year,month;
</PRE>

<P>
Which returns:

</P>

<PRE>
+------+-------+------+
| year | month | days |
+------+-------+------+
| 2000 |    01 |    3 |
| 2000 |    02 |    2 |
+------+-------+------+
</PRE>

<P>
The query calculates how many different days appear in the table for each
year/month combination, with automatic removal of duplicate entries.

</P>



<H3><A NAME="example-AUTO_INCREMENT" HREF="manual_toc.html#example-AUTO_INCREMENT">3.6.9  Using <code>AUTO_INCREMENT</code></A></H3>

<P>
<A NAME="IDX406"></A>
<A NAME="IDX407"></A>
<A NAME="IDX408"></A>
The <code>AUTO_INCREMENT</code> attribute can be used to generate a unique
identity for new rows:

</P>

<PRE>
CREATE TABLE animals (
             id MEDIUMINT NOT NULL AUTO_INCREMENT,
             name CHAR(30) NOT NULL,
             PRIMARY KEY (id)
             );
INSERT INTO animals (name) VALUES ('dog'),('cat'),('penguin'),
                                  ('lax'),('whale'),('ostrich');
SELECT * FROM animals;
</PRE>

<P>
Which returns:

</P>

<PRE>
+----+---------+
| id | name    |
+----+---------+
|  1 | dog     |
|  2 | cat     |
|  3 | penguin |
|  4 | lax     |
|  5 | whale   |
|  6 | ostrich |
+----+---------+
</PRE>

<P>
You can retrieve the most recent <code>AUTO_INCREMENT</code> value with the
<code>LAST_INSERT_ID()</code> SQL function or the <code>mysql_insert_id()</code> C API
function. These functions are connection-specific, so their return value
is not affected by another connection also doing inserts.

</P>
<P>
Note: For a multiple-row insert,
<code>LAST_INSERT_ID()</code>/<code>mysql_insert_id()</code> will actually return the
<code>AUTO_INCREMENT</code> key from the <strong>first</strong> of the inserted rows.
This allows multiple-row inserts to be reproduced correctly on other servers
in a replication setup.

</P>
<P>
For <code>MyISAM</code> and <code>BDB</code> tables you can specify <code>AUTO_INCREMENT</code>
on a secondary column in a multiple-column index.  In this case, the generated
value for the <code>AUTO_INCREMENT</code> column is calculated as
<code>MAX(auto_increment_column)+1 WHERE prefix=given-prefix</code>.  This is
useful when you want to put data into ordered groups.

</P>

<PRE>
CREATE TABLE animals (
             grp ENUM('fish','mammal','bird') NOT NULL,
             id MEDIUMINT NOT NULL AUTO_INCREMENT,
             name CHAR(30) NOT NULL,
             PRIMARY KEY (grp,id)
             );
INSERT INTO animals (grp,name) VALUES('mammal','dog'),('mammal','cat'),
                  ('bird','penguin'),('fish','lax'),('mammal','whale'),
                  ('bird','ostrich');
SELECT * FROM animals ORDER BY grp,id;
</PRE>

<P>
Which returns:

</P>

<PRE>
+--------+----+---------+
| grp    | id | name    |
+--------+----+---------+
| fish   |  1 | lax     |
| mammal |  1 | dog     |
| mammal |  2 | cat     |
| mammal |  3 | whale   |
| bird   |  1 | penguin |
| bird   |  2 | ostrich |
+--------+----+---------+
</PRE>

<P>
Note that in this case (when the <code>AUTO_INCREMENT</code> column is part of a
multiple-column index), <code>AUTO_INCREMENT</code> values will be reused if you
delete the row with the biggest <code>AUTO_INCREMENT</code> value in any group.
This happens even for <code>MyISAM</code> tables, for which <code>AUTO_INCREMENT</code>
values normally are not reused.)

</P>


<H2><A NAME="Twin" HREF="manual_toc.html#Twin">3.7  Queries from the Twin Project</A></H2>

<P>
<A NAME="IDX409"></A>
<A NAME="IDX410"></A>

</P>
<P>
At Analytikerna and Lentus, we have been doing the systems and field work
for a big research project. This project is a collaboration between the
Institute of Environmental Medicine at Karolinska Institutet Stockholm
and the Section on Clinical Research in Aging and Psychology at the
University of Southern California.

</P>
<P>
The project involves a screening part where all twins in Sweden older
than 65 years are interviewed by telephone. Twins who meet certain
criteria are passed on to the next stage. In this latter stage, twins who
want to participate are visited by a doctor/nurse team. Some of the
examinations include physical and neuropsychological examination,
laboratory testing, neuroimaging, psychological status assessment, and family
history collection. In addition, data are collected on medical and
environmental risk factors.

</P>
<P>
More information about Twin studies can be found at:
<a HREF="http://www.mep.ki.se/twinreg/index_en.html">http://www.mep.ki.se/twinreg/index_en.html</a>

</P>
<P>
The latter part of the project is administered with a Web interface
written using Perl and MySQL.

</P>
<P>
Each night all data from the interviews is moved into a MySQL
database.

</P>



<H3><A NAME="Twin_pool" HREF="manual_toc.html#Twin_pool">3.7.1  Find All Non-distributed Twins</A></H3>

<P>
The following query is used to determine who goes into the second part of the
project:

</P>

<PRE>
SELECT
    CONCAT(p1.id, p1.tvab) + 0 AS tvid,
    CONCAT(p1.christian_name, ' ', p1.surname) AS Name,
    p1.postal_code AS Code,
    p1.city AS City,
    pg.abrev AS Area,
    IF(td.participation = 'Aborted', 'A', ' ') AS A,
    p1.dead AS dead1,
    l.event AS event1,
    td.suspect AS tsuspect1,
    id.suspect AS isuspect1,
    td.severe AS tsevere1,
    id.severe AS isevere1,
    p2.dead AS dead2,
    l2.event AS event2,
    h2.nurse AS nurse2,
    h2.doctor AS doctor2,
    td2.suspect AS tsuspect2,
    id2.suspect AS isuspect2,
    td2.severe AS tsevere2,
    id2.severe AS isevere2,
    l.finish_date
FROM
    twin_project AS tp
    /* For Twin 1 */
    LEFT JOIN twin_data AS td ON tp.id = td.id
              AND tp.tvab = td.tvab
    LEFT JOIN informant_data AS id ON tp.id = id.id
              AND tp.tvab = id.tvab
    LEFT JOIN harmony AS h ON tp.id = h.id
              AND tp.tvab = h.tvab
    LEFT JOIN lentus AS l ON tp.id = l.id
              AND tp.tvab = l.tvab
    /* For Twin 2 */
    LEFT JOIN twin_data AS td2 ON p2.id = td2.id
              AND p2.tvab = td2.tvab
    LEFT JOIN informant_data AS id2 ON p2.id = id2.id
              AND p2.tvab = id2.tvab
    LEFT JOIN harmony AS h2 ON p2.id = h2.id
              AND p2.tvab = h2.tvab
    LEFT JOIN lentus AS l2 ON p2.id = l2.id
              AND p2.tvab = l2.tvab,
    person_data AS p1,
    person_data AS p2,
    postal_groups AS pg
WHERE
    /* p1 gets main twin and p2 gets his/her twin. */
    /* ptvab is a field inverted from tvab */
    p1.id = tp.id AND p1.tvab = tp.tvab AND
    p2.id = p1.id AND p2.ptvab = p1.tvab AND
    /* Just the sceening survey */
    tp.survey_no = 5 AND
    /* Skip if partner died before 65 but allow emigration (dead=9) */
    (p2.dead = 0 OR p2.dead = 9 OR
     (p2.dead = 1 AND
      (p2.death_date = 0 OR
       (((TO_DAYS(p2.death_date) - TO_DAYS(p2.birthday)) / 365)
        &#62;= 65))))
    AND
    (
    /* Twin is suspect */
    (td.future_contact = 'Yes' AND td.suspect = 2) OR
    /* Twin is suspect - Informant is Blessed */
    (td.future_contact = 'Yes' AND td.suspect = 1
                               AND id.suspect = 1) OR
    /* No twin - Informant is Blessed */
    (ISNULL(td.suspect) AND id.suspect = 1
                        AND id.future_contact = 'Yes') OR
    /* Twin broken off - Informant is Blessed */
    (td.participation = 'Aborted'
     AND id.suspect = 1 AND id.future_contact = 'Yes') OR
    /* Twin broken off - No inform - Have partner */
    (td.participation = 'Aborted' AND ISNULL(id.suspect)
                                  AND p2.dead = 0))
    AND
    l.event = 'Finished'
    /* Get at area code */
    AND SUBSTRING(p1.postal_code, 1, 2) = pg.code
    /* Not already distributed */
    AND (h.nurse IS NULL OR h.nurse=00 OR h.doctor=00)
    /* Has not refused or been aborted */
    AND NOT (h.status = 'Refused' OR h.status = 'Aborted'
    OR h.status = 'Died' OR h.status = 'Other')
ORDER BY
    tvid;
</PRE>

<P>
Some explanations:
<DL COMPACT>

<DT><code>CONCAT(p1.id, p1.tvab) + 0 AS tvid</code>
<DD>
We want to sort on the concatenated <code>id</code> and <code>tvab</code> in
numerical order. Adding <code>0</code> to the result causes MySQL to
treat the result as a number.
<DT>column <code>id</code>
<DD>
This identifies a pair of twins. It is a key in all tables.
<DT>column <code>tvab</code>
<DD>
This identifies a twin in a pair. It has a value of <code>1</code> or <code>2</code>.
<DT>column <code>ptvab</code>
<DD>
This is an inverse of <code>tvab</code>. When <code>tvab</code> is <code>1</code> this is
<code>2</code>, and vice versa. It exists to save typing and to make it easier for
MySQL to optimize the query.
</DL>

<P>
This query demonstrates, among other things, how to do lookups on a table
from the same table with a join (<code>p1</code> and <code>p2</code>). In the example,
this is used to check whether a twin's partner died before the age of 65. If
so, the row is not returned.

</P>
<P>
All of the above exist in all tables with twin-related information. We
have a key on both <code>id,tvab</code> (all tables), and <code>id,ptvab</code>
(<code>person_data</code>) to make queries faster.

</P>
<P>
On our production machine (A 200MHz UltraSPARC), this query returns
about 150-200 rows and takes less than one second.

</P>
<P>
The current number of records in the tables used in the query:
<TABLE BORDER>
<TR><TD><strong>Table</strong> </TD><TD> <strong>Rows</strong>
</TD></TR>
<TR><TD><code>person_data</code> </TD><TD> 71074
</TD></TR>
<TR><TD><code>lentus</code> </TD><TD> 5291
</TD></TR>
<TR><TD><code>twin_project</code> </TD><TD> 5286
</TD></TR>
<TR><TD><code>twin_data</code> </TD><TD> 2012
</TD></TR>
<TR><TD><code>informant_data</code> </TD><TD> 663
</TD></TR>
<TR><TD><code>harmony</code> </TD><TD> 381
</TD></TR>
<TR><TD><code>postal_groups</code> </TD><TD> 100
</TD></TR>
</TABLE>

</P>



<H3><A NAME="Twin_event" HREF="manual_toc.html#Twin_event">3.7.2  Show a Table of Twin Pair Status</A></H3>

<P>
Each interview ends with a status code called <code>event</code>. The query
shown here is used to display a table over all twin pairs combined by
event. This indicates in how many pairs both twins are finished, in how many
pairs one twin is finished and the other refused, and so on.

</P>

<PRE>
SELECT
        t1.event,
        t2.event,
        COUNT(*)
FROM
        lentus AS t1,
        lentus AS t2,
        twin_project AS tp
WHERE
        /* We are looking at one pair at a time */
        t1.id = tp.id
        AND t1.tvab=tp.tvab
        AND t1.id = t2.id
        /* Just the sceening survey */
        AND tp.survey_no = 5
        /* This makes each pair only appear once */
        AND t1.tvab='1' AND t2.tvab='2'
GROUP BY
        t1.event, t2.event;

</PRE>



<H2><A NAME="Apache" HREF="manual_toc.html#Apache">3.8  Using MySQL with Apache</A></H2>

<P>
<A NAME="IDX411"></A>

</P>
<P>
There are programs that let you authenticate your users from a MySQL
database and also let you write your log files into a MySQL table.

</P>
<P>
You can change the Apache logging format to be easily readable by
MySQL by putting the following into the Apache configuration file:

</P>

<PRE>
LogFormat \
        "\"%h\",%{%Y%m%d%H%M%S}t,%&#62;s,\"%b\",\"%{Content-Type}o\",  \
        \"%U\",\"%{Referer}i\",\"%{User-Agent}i\""
</PRE>

<P>
To load a log file in that format into MySQL, you can use a statement
something like this:

</P>

<PRE>
LOAD DATA INFILE '<var>/local/access_log</var>' INTO TABLE <var>tbl_name</var>
FIELDS TERMINATED BY ',' OPTIONALLY ENCLOSED BY '"' ESCAPED BY '\\'
</PRE>

<P>
The named table should be created to have columns that correspond to those
that the <code>LogFormat</code> line writes to the log file.

</P>

<P><HR><P>
Go to the <A HREF="manual_Introduction.html">first</A>, <A HREF="manual_Installing.html">previous</A>, <A HREF="manual_Using_MySQL_Programs.html">next</A>, <A HREF="manual_Concept_Index.html">last</A> section, <A HREF="manual_toc.html">table of contents</A>.
 </BODY>
 </HTML>
