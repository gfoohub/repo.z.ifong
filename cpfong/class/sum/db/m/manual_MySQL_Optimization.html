  <HTML>
  <HEAD>
  
  <TITLE>MySQL Reference Manual for version 5.0.3-alpha - 7  MySQL Optimization</TITLE>
   <style> code {color:purple} tt {color:green} samp {color:navy} pre {color:maroon} </style>
  </HEAD>
  <BODY BGCOLOR=silver TEXT=#000000 LINK=#101090 VLINK=#7030B0>
Go to the <A HREF="manual_Introduction.html">first</A>, <A HREF="manual_Replication.html">previous</A>, <A HREF="manual_Client-Side_Scripts.html">next</A>, <A HREF="manual_Concept_Index.html">last</A> section, <A HREF="manual_toc.html">table of contents</A>.
<P><HR><P>


<H1><A NAME="MySQL_Optimization" HREF="manual_toc.html#MySQL_Optimization">7  MySQL Optimization</A></H1>

<P>
Optimization is a complex task because ultimately it requires understanding
of the entire system to be optimized. Although it may be possible to
perform some local optimizations with little knowledge of your system or
application, the more optimal you want your system to become, the more
you will have to know about it.

</P>
<P>
This chapter tries to explain and give some examples of different
ways to optimize MySQL.  Remember, however, that there are
always additional ways to make the system
even faster, although they may require increasing effort to achieve.

</P>



<H2><A NAME="Optimize_Overview" HREF="manual_toc.html#Optimize_Overview">7.1  Optimization Overview</A></H2>

<P>
The most important factor in making a system fast is its basic
design. You also need to know what kinds of things your system will be
doing, and what your bottlenecks are.

</P>
<P>
The most common system bottlenecks are:

</P>

<UL>
<LI>Disk seeks.

It takes time for the disk to find a piece of data. With modern disks,
the mean time for this is usually lower than 10ms, so we can in
theory do about 100 seeks a second. This time improves slowly with new
disks and is very hard to optimize for a single table. The way to
optimize seek time is to distribute the data onto more than one disk.

<LI>Disk reading and writing.

When the disk is at the correct position, we need to read the data. With
modern disks, one disk delivers at least 10-20MB/s throughput. This
is easier to optimize than seeks because you can read in parallel from
multiple disks.

<LI>CPU cycles.

When we have the data in main memory (or if it was already
there), we need to process it to get our result. Having small
tables compared to the amount of memory is the most common limiting
factor. But with small tables, speed is usually not the problem.

<LI>Memory bandwidth.

When the CPU needs more data than can fit in the CPU cache, main
memory bandwidth becomes a bottleneck. This is an uncommon bottleneck
for most systems, but one to be aware of.
</UL>



<H3><A NAME="Design_Limitations" HREF="manual_toc.html#Design_Limitations">7.1.1  MySQL Design Limitations and Tradeoffs</A></H3>

<P>
<A NAME="IDX686"></A>
<A NAME="IDX687"></A>

</P>
<P>
When using the <code>MyISAM</code> storage engine, MySQL uses extremely fast table
locking that allows multiple readers or a single writer. The biggest problem
with this storage engine occurs when you have a steady stream of mixed
updates and slow selects on a single table.  If this is a problem for
certain tables, you can use another storage engine for them. See section <A HREF="manual_Storage_engines.html#Storage_engines">14  MySQL Storage Engines and Table Types</A>.

</P>
<P>
MySQL can work with both transactional and non-transactional tables.
To be able to work smoothly with non-transactional tables (which can't
roll back if something goes wrong), MySQL has the following rules
(when not running in strict mode or if you use the <code>IGNORE</code>
specifier to <code>INSERT</code> or <code>UPDATE</code>).

</P>
<P>
<A NAME="IDX688"></A>

<UL>
<LI>

All columns have default values.
<LI>

If you insert an ``incorrect'' value in a column, such as a too-large numeric
value into a numeric column, MySQL sets the column to the ``best possible
value'' instead of giving an error.  For numerical values, this is 0,
the smallest possible value or the largest possible value. For strings,
this is either the empty string or the longest possible string that can
be stored in the column.
<LI>

All calculated expressions return a value that can be used instead of
signaling an error condition. For example, 1/0 returns <code>NULL</code>.
(This behavior can be changed by using the
<code>ERROR_FOR_DIVISION_BY_ZERO</code> SQL mode).
</UL>

<P>
If you are using non-transactional tables, you should not use MySQL to check
column content. In general, the safest (and often fastest) way is to let the
application ensure that it passes only legal values to the database.

</P>
<P>
For more information about this, see section <A HREF="manual_Introduction.html#Constraints">1.5.6  How MySQL Deals with Constraints</A> and section <A HREF="manual_SQL_Syntax.html#INSERT">13.1.4  <code>INSERT</code> Syntax</A> or
section <A HREF="manual_MySQL_Database_Administration.html#Server_SQL_mode">5.2.2  The Server SQL Mode</A>.

</P>


<H3><A NAME="Portability" HREF="manual_toc.html#Portability">7.1.2  Designing Applications for Portability</A></H3>

<P>
<A NAME="IDX689"></A>
<A NAME="IDX690"></A>
<A NAME="IDX691"></A>

</P>
<P>
Because all SQL servers implement different parts of standard SQL,
it takes work to write portable SQL applications.  It is very easy to
achieve portability for very simple selects and inserts, but becomes more
difficult the more capabilities you require.  If you want an application
that is fast with many database systems, it becomes even harder!

</P>
<P>
To make a complex application portable, you need to determine which SQL
servers it must work with, then determine what features those servers
support.

</P>
<P>
All database systems have some weak points. That is, they have different
design compromises that lead to different behavior.

</P>
<P>
You can use the MySQL <code>crash-me</code> program to find functions, types, and
limits that you can use with a selection of database servers.
<code>crash-me</code> does not check for every possible feature, but it is still
reasonably comprehensive, performing about 450 tests.

</P>
<P>
An example of the type of information <code>crash-me</code> can provide is that
you shouldn't have column names longer than 18 characters
if you want to be able to use Informix or DB2.

</P>
<P>
The <code>crash-me</code> program and the MySQL benchmarks are all very database
independent.  By taking a look at how they are written, you can get
a feeling for what you have to do to make your own applications database
independent.  The programs can be found in the <tt>`sql-bench'</tt> directory
of MySQL source distributions. They are written in Perl and use the DBI
database interface.  Use of DBI in itself solves part of the portability
problem because it provides database-independent access methods.

</P>
<P>
For <code>crash-me</code> results, visit
<a HREF="http://dev.mysql.com/tech-resources/crash-me.php">http://dev.mysql.com/tech-resources/crash-me.php</a>.
See <a HREF="http://dev.mysql.com/tech-resources/benchmarks/">http://dev.mysql.com/tech-resources/benchmarks/</a> for the results
from the benchmarks.

</P>
<P>
If you strive for database independence, you need to get a good feeling
for each SQL server's bottlenecks. For example, MySQL is very fast in
retrieving and updating records for <code>MyISAM</code> tables, but will have
a problem in mixing slow readers and writers on the same table. Oracle,
on the other hand, has a big problem when you try to access rows that
you have recently updated (until they are flushed to disk). Transactional
databases in general are not very good at generating summary tables from
log tables, because in this case row locking is almost useless.

</P>
<P>
To make your application <em>really</em> database independent, you need to define
an easily extendable interface through which you manipulate your data. As
C++ is available on most systems, it makes sense to use a C++ class-based
interface to the databases.

</P>
<P>
If you use some feature that is specific to a given database system (such
as the <code>REPLACE</code> statement, which is specific to MySQL), you should
implement the same feature for other SQL servers by coding an alternative
method. Although the alternative may be slower, it will allow the other
servers to perform the same tasks.

</P>
<P>
With MySQL, you can use the <code>/*!  */</code> syntax to add MySQL-specific
keywords to a query.  The code inside <code>/**/</code> will be treated as a
comment (and ignored) by most other SQL servers.

</P>
<P>
If high performance is more important than exactness, as in some
Web applications, it is possible to create an application layer that
caches all results to give you even higher performance. By letting
old results ``expire'' after a while, you can keep the cache reasonably
fresh.  This provides a method to handle high load spikes, in which case
you can dynamically increase the cache and set the expiration timeout higher
until things get back to normal.

</P>
<P>
In this case, the table creation information should contain information
of the initial size of the cache and how often the table should normally
be refreshed.

</P>
<P>
An alternative to implementing an application cache is to use the MySQL query
cache. By enabling the query cache, the server handles the details of
determining whether a query result can be reused. This simplifies your
application.
See section <A HREF="manual_MySQL_Database_Administration.html#Query_Cache">5.11  The MySQL Query Cache</A>.

</P>



<H3><A NAME="Internal_use" HREF="manual_toc.html#Internal_use">7.1.3  What We Have Used MySQL For</A></H3>

<P>
<A NAME="IDX692"></A>
<A NAME="IDX693"></A>

</P>
<P>
This section describes an early application for MySQL.

</P>
<P>
During MySQL initial development, the features of MySQL
were made to fit our largest customer, which handled data warehousing for a
couple of the largest retailers in Sweden.

</P>
<P>
From all stores, we got weekly summaries of all bonus card transactions,
and were expected to provide useful information for the store owners
to help them find how their advertising campaigns were affecting their
own customers.

</P>
<P>
The volume of data was quite huge (about seven million summary transactions
per month), and we had data for 4-10 years that we needed to present to
the users.  We got weekly requests from our customers, who wanted to get
``instant'' access to new reports from this data.

</P>
<P>
We solved this problem by storing all information per month in compressed
``transaction'' tables. We had a set of simple macros that
generated summary tables grouped by different criteria (product group,
customer id, store, and so on) from the tables in which the transactions
were stored.  The reports were Web pages that were dynamically generated
by a small Perl script. This script parsed a Web page, executed the SQL
statements in it, and inserted the results. We would have used PHP or
mod_perl instead, but they were not available at the time.

</P>
<P>
For graphical data, we wrote a simple tool in C that could process SQL
query results and produce GIF images based on those results.  This tool also
was dynamically executed from the Perl script that parses the Web pages.

</P>
<P>
In most cases, a new report could be created simply by copying an existing
script and modifying the SQL query in it.  In some cases, we needed to
add more columns to an existing summary table or generate a new one.
This also was quite simple because we kept all transaction-storage tables
on disk.  (This amounted to about 50GB of transaction tables and 200GB
of other customer data.)

</P>
<P>
We also let our customers access the summary tables directly with ODBC
so that the advanced users could experiment with the data themselves.

</P>
<P>
This system worked well and we had no problems handling the data with
quite modest Sun Ultra SPARCstation hardware (2x200MHz). Eventually the
system was migrated to Linux.

</P>



<H3><A NAME="MySQL_Benchmarks" HREF="manual_toc.html#MySQL_Benchmarks">7.1.4  The MySQL Benchmark Suite</A></H3>

<P>
<A NAME="IDX694"></A>
<A NAME="IDX695"></A>

</P>
<P>
This section should contain a technical description of the MySQL
benchmark suite (and <code>crash-me</code>), but that description has not yet
been written. Currently, you can get a good idea of the benchmarks by
looking at the code and results in the <tt>`sql-bench'</tt> directory in any
MySQL source distribution.

</P>
<P>
This benchmark suite is meant to tell any user what operations a given
SQL implementation performs well or poorly.

</P>
<P>
Note that this benchmark is single-threaded, so it measures the minimum
time for the operations performed. We plan to add multi-threaded tests to
the benchmark suite in the future.

</P>
<P>
To use the benchmark suite, the following requirements must be satisfied:

</P>

<UL>
<LI>

The benchmark suite is provided with MySQL source distributions.
You can either download a released distribution from
<a HREF="http://dev.mysql.com/downloads/">http://dev.mysql.com/downloads/</a>, or use the current development
source tree (see section <A HREF="manual_Installing.html#Installing_source_tree">2.8.3  Installing from the Development Source Tree</A>).

<LI>

The benchmark scripts are written in Perl and use the Perl DBI module to
access database servers, so DBI must be installed.  You will also need
the server-specific DBD drivers for each of the servers you want to test.
For example, to test MySQL, PostgreSQL, and DB2, you must have the
<code>DBD::mysql</code>, <code>DBD::Pg</code>, and <code>DBD::DB2</code> modules installed.
See section <A HREF="manual_Installing.html#Perl_support">2.13  Perl Installation Notes</A>.

</UL>

<P>
After you obtain a MySQL source distribution, you will find the benchmark
suite located in its <tt>`sql-bench'</tt> directory.  To run the benchmark tests,
build MySQL, then
change location into the <tt>`sql-bench'</tt> directory and execute the <code>run-all-tests</code>
script:

</P>

<PRE>
shell&#62; cd sql-bench
shell&#62; perl run-all-tests --server=<var>server_name</var>
</PRE>

<P>
<var>server_name</var> is one of the supported servers. To get a list of
all options and supported servers, invoke this command:

</P>

<PRE>
shell&#62; perl run-all-tests --help
</PRE>

<P>
<A NAME="IDX696"></A>
The <code>crash-me</code> script also is located in the <tt>`sql-bench'</tt> directory.
<code>crash-me</code> tries to determine what features a database supports and
what its capabilities and limitations are by actually running
queries. For example, it determines:

</P>

<UL>
<LI>

What column types are supported
<LI>

How many indexes are supported
<LI>

What functions are supported
<LI>

How big a query can be
<LI>

How big a <code>VARCHAR</code> column can be
</UL>

<P>
You can find the results from <code>crash-me</code> for many different database
servers at <a HREF="http://dev.mysql.com/tech-resources/crash-me.php">http://dev.mysql.com/tech-resources/crash-me.php</a>.
For more information about benchmark results, visit
<a HREF="http://dev.mysql.com/tech-resources/benchmarks/">http://dev.mysql.com/tech-resources/benchmarks/</a>.

</P>



<H3><A NAME="Custom_Benchmarks" HREF="manual_toc.html#Custom_Benchmarks">7.1.5  Using Your Own Benchmarks</A></H3>

<P>
<A NAME="IDX697"></A>
<A NAME="IDX698"></A>

</P>
<P>
You should definitely benchmark your application and database to find
out where the bottlenecks are.  By fixing a bottleneck (or by replacing it
with a ``dummy module''), you can then easily identify the next
bottleneck.  Even if the overall performance for your
application currently is acceptable, you should at least make a plan for each
bottleneck, and decide how to solve it if someday you really need the
extra performance.

</P>
<P>
For an example of portable benchmark programs, look at the MySQL
benchmark suite. See section <A HREF="manual_MySQL_Optimization.html#MySQL_Benchmarks">7.1.4  The MySQL Benchmark Suite</A>. You
can take any program from this suite and modify it for your needs. By doing
this, you can try different solutions to your problem and test which really is
fastest for you.

</P>
<P>
Another free benchmark suite is the Open Source Database Benchmark,
available at <a HREF="http://osdb.sourceforge.net/">http://osdb.sourceforge.net/</a>.

</P>
<P>
It is very common for a problem to occur only when the system is very
heavily loaded. We have had many customers who contact us when they
have a (tested) system in production and have encountered load problems. In
most cases, performance problems turn out to be due to issues of basic
database design (for example, table scans are <em>not good</em> at high load) or
problems with the operating system or libraries. Most of the time, these
problems would be a <em>lot</em> easier to fix if the systems were not
already in production.

</P>
<P>
To avoid problems like this, you should put some effort into benchmarking
your whole application under the worst possible load!  You can use
Super Smack for this. It is available at
<a HREF="http://jeremy.zawodny.com/mysql/super-smack/">http://jeremy.zawodny.com/mysql/super-smack/</a>.
As the name suggests, it can bring a system to its knees if you ask it,
so make sure to use it only on your development systems.

</P>



<H2><A NAME="Query_Speed" HREF="manual_toc.html#Query_Speed">7.2  Optimizing <code>SELECT</code> Statements and Other Queries</A></H2>

<P>
<A NAME="IDX699"></A>
<A NAME="IDX700"></A>
<A NAME="IDX701"></A>

</P>
<P>
First, one factor affects all statements: The more complex your permission
setup is, the more overhead you will have.

</P>
<P>
Using simpler permissions when you issue <code>GRANT</code> statements enables
MySQL to reduce permission-checking overhead when clients execute
statements.  For example, if you don't grant any table-level or column-level
privileges, the server need not ever check the contents of the
<code>tables_priv</code> and <code>columns_priv</code> tables. Similarly, if you place
no resource limits on any accounts, the server does not have to perform
resource counting.  If you have a very high query volume, it may be worth
the time to use a simplified grant structure to reduce permission-checking
overhead.

</P>
<P>
If your problem is with some specific MySQL expression or function, you can
use the <code>BENCHMARK()</code> function from the <code>mysql</code> client program
to perform a timing test. Its syntax is
<code>BENCHMARK(<var>loop_count</var>,<var>expression</var>)</code>. For example:

</P>

<PRE>
mysql&#62; SELECT BENCHMARK(1000000,1+1);
+------------------------+
| BENCHMARK(1000000,1+1) |
+------------------------+
|                      0 |
+------------------------+
1 row in set (0.32 sec)
</PRE>

<P>
This result was obtained on a Pentium II 400MHz system. It shows that
MySQL can execute 1,000,000 simple addition expressions in 0.32 seconds
on that system.

</P>
<P>
All MySQL functions should be very optimized, but there may be some
exceptions. <code>BENCHMARK()</code> is a great tool to find out if this is a
problem with your query.

</P>



<H3><A NAME="EXPLAIN" HREF="manual_toc.html#EXPLAIN">7.2.1  <code>EXPLAIN</code> Syntax (Get Information About a <code>SELECT</code>)</A></H3>

<P>
<A NAME="IDX702"></A>
<A NAME="IDX703"></A>

</P>


<PRE>
EXPLAIN <var>tbl_name</var>
</PRE>

<P>
Or:

</P>

<PRE>
EXPLAIN SELECT <var>select_options</var>
</PRE>

<P>
The <code>EXPLAIN</code> statement can be used either as a synonym for
<code>DESCRIBE</code> or as a way to obtain information about how MySQL will execute
a <code>SELECT</code> statement:

</P>

<UL>
<LI>

The <code>EXPLAIN <var>tbl_name</var></code> syntax is synonymous with <code>DESCRIBE <var>tbl_name</var></code>
or
<code>SHOW COLUMNS FROM <var>tbl_name</var></code>.
<LI>

When you precede a <code>SELECT</code> statement with the keyword <code>EXPLAIN</code>,
MySQL explains how it would process the <code>SELECT</code>, providing
information about how tables are joined and in which order.
</UL>

<P>
This section provides information about the second use of <code>EXPLAIN</code>.

</P>
<P>
With the help of <code>EXPLAIN</code>, you can see when you must add indexes
to tables to get a faster <code>SELECT</code> that uses indexes to find
records.

</P>
<P>
If you have a problem with incorrect index usage, you should run
<code>ANALYZE TABLE</code> to update table statistics such as cardinality of
keys, which can affect the choices the optimizer makes. See section <A HREF="manual_SQL_Syntax.html#ANALYZE_TABLE">13.5.2.1  <code>ANALYZE TABLE</code> Syntax</A>.

</P>
<P>
You can also see whether the optimizer joins the tables in an optimal order.
To force the optimizer to use a join order corresponding to the order
in which the tables are named in the <code>SELECT</code> statement, begin the
statement with <code>SELECT STRAIGHT_JOIN</code> rather than just <code>SELECT</code>.

</P>
<P>
<code>EXPLAIN</code> returns a row of information for each table used in the
<code>SELECT</code> statement. The tables are listed in the output in the order
that MySQL would read them while processing the query.  MySQL resolves
all joins using a single-sweep
multi-join method. This means that MySQL reads a row from the first
table, then finds a matching row in the second table, then in the third table,
and so on. When all tables are processed, it outputs the selected columns and
backtracks through the table list until a table is found for which there are
more matching rows. The next row is read from this table and the process
continues with the next table.

</P>
<P>
In MySQL version 4.1, the <code>EXPLAIN</code> output format was changed to work
better with constructs such as <code>UNION</code> statements, subqueries, and
derived tables. Most notable is the addition of two new columns: <code>id</code>
and <code>select_type</code>. You will not see these columns when using servers
older than MySQL 4.1.

</P>
<P>
Each output row from <code>EXPLAIN</code> provides information about one table, and
each row consists of the following columns:

</P>
<DL COMPACT>

<DT><code>id</code>
<DD>
The <code>SELECT</code> identifier. This is the sequential number of the
<code>SELECT</code> within the query.

<DT><code>select_type</code>
<DD>
The type of <code>SELECT</code>, which can be any of the following:

<DL COMPACT>

<DT><code>SIMPLE</code>
<DD>
Simple <code>SELECT</code> (not using <code>UNION</code> or subqueries)

<DT><code>PRIMARY</code>
<DD>
Outermost <code>SELECT</code>

<DT><code>UNION</code>
<DD>
Second or later <code>SELECT</code> statement in a <code>UNION</code>

<DT><code>DEPENDENT UNION</code>
<DD>
Second or later <code>SELECT</code> statement in a <code>UNION</code>, dependent on outer
query

<DT><code>UNION RESULT</code>
<DD>
Result of a <code>UNION</code>.

<DT><code>SUBQUERY</code>
<DD>
First <code>SELECT</code> in subquery

<DT><code>DEPENDENT SUBQUERY</code>
<DD>
First <code>SELECT</code> in subquery, dependent on outer query

<DT><code>DERIVED</code>
<DD>
Derived table <code>SELECT</code> (subquery in <code>FROM</code> clause)
</DL>

<DT><code>table</code>
<DD>
The table to which the row of output refers.

<DT><code>type</code>
<DD>
The join type. The different join types are listed here, ordered from the
best type to the worst:

<DL COMPACT>

<DT><code>system</code>
<DD>
<A NAME="IDX704"></A>
<A NAME="IDX705"></A>
The table has only one row (= system table). This is a special case of
the <code>const</code> join type.

<DT><code>const</code>
<DD>
<A NAME="IDX706"></A>
<A NAME="IDX707"></A>
The table has at most one matching row, which will be read at the start
of the query. Because there is only one row, values from the column in
this row can be regarded as constants by the rest of the
optimizer. <code>const</code> tables are very fast because they are read only once!

<code>const</code> is used when you compare all parts of a
<code>PRIMARY KEY</code> or <code>UNIQUE</code> index with constant values. In the
following queries, <var>tbl_name</var> can be used as a <code>const</code> table:


<PRE>
SELECT * FROM <var>tbl_name</var> WHERE <var>primary_key</var>=1;

SELECT * FROM <var>tbl_name</var>
WHERE <var>primary_key_part1</var>=1 AND <var>primary_key_part2</var>=2;
</PRE>

<DT><code>eq_ref</code>
<DD>
One row will be read from this table for each combination of rows from
the previous tables.  Other than the <code>const</code> types, this is the best
possible join type.  It is used when all parts of an index are used by
the join and the index is a <code>PRIMARY KEY</code> or <code>UNIQUE</code> index.

<code>eq_ref</code> can be used for indexed columns that are compared using the
<code>=</code> operator.  The comparison value can be a constant or an expression
that uses columns from tables that are read before this table.

In the following examples, MySQL can use an <code>eq_ref</code> join to process
<var>ref_table</var>:


<PRE>
SELECT * FROM <var>ref_table</var>,<var>other_table</var>
WHERE <var>ref_table</var>.<var>key_column</var>=<var>other_table</var>.<var>column</var>;

SELECT * FROM <var>ref_table</var>,<var>other_table</var>
WHERE <var>ref_table</var>.<var>key_column_part1</var>=<var>other_table</var>.<var>column</var>
AND <var>ref_table</var>.<var>key_column_part2</var>=1;
</PRE>

<DT><code>ref</code>
<DD>
All rows with matching index values will be read from this table for
each combination of rows from the previous tables.  <code>ref</code> is used
if the join uses only a leftmost prefix of the key or if the key is not
a <code>PRIMARY KEY</code> or <code>UNIQUE</code> index (in other words, if the join
cannot select a single row based on the key value).  If the key that is
used matches only a few rows, this is a good join type.

<code>ref</code> can be used for indexed columns that are compared using the <code>=</code>
operator.

In the following examples, MySQL can use a <code>ref</code> join to process
<var>ref_table</var>:


<PRE>
SELECT * FROM <var>ref_table</var> WHERE <var>key_column</var>=<var>expr</var>;

SELECT * FROM <var>ref_table</var>,<var>other_table</var>
WHERE <var>ref_table</var>.<var>key_column</var>=<var>other_table</var>.<var>column</var>;

SELECT * FROM <var>ref_table</var>,<var>other_table</var>
WHERE <var>ref_table</var>.<var>key_column_part1</var>=<var>other_table</var>.<var>column</var>
AND <var>ref_table</var>.<var>key_column_part2</var>=1;
</PRE>

<DT><code>ref_or_null</code>
<DD>
This join type is like <code>ref</code>, but with the addition that MySQL will
do an extra search for rows that contain <code>NULL</code> values.  This join
type optimization is new for MySQL 4.1.1 and is mostly used when resolving
subqueries.

In the following examples, MySQL can use a <code>ref_or_null</code> join to process
<var>ref_table</var>:


<PRE>
SELECT * FROM <var>ref_table</var>
WHERE <var>key_column</var>=<var>expr</var> OR <var>key_column</var> IS NULL; 
</PRE>

See section <A HREF="manual_MySQL_Optimization.html#IS_NULL_optimization">7.2.7  How MySQL Optimizes <code>IS NULL</code></A>.

<DT><code>index_merge</code>
<DD>
This join type indicates that the Index Merge optimization is used.
In this case, the <code>key</code> column contains a list of indexes used, and
<code>key_len</code> contains a list of the longest key parts for the indexes
used.  For more information, see
section <A HREF="manual_MySQL_Optimization.html#Index_Merge_optimization">7.2.6  Index Merge Optimization</A>.

<DT><code>unique_subquery</code>
<DD>
This type replaces <code>ref</code> for some <code>IN</code> subqueries of the following
form:

<PRE>
<var>value</var> IN (SELECT <var>primary_key</var> FROM <var>single_table</var> WHERE <var>some_expr</var>) 
</PRE>

<code>unique_subquery</code> is just an index lookup function that replaces the
subquery completely for better efficiency.

<DT><code>index_subquery</code>
<DD>
This join type is similar to
<code>unique_subquery</code>. It replaces <code>IN</code> subqueries, but
it works for non-unique indexes in subqueries of the following form:


<PRE>
<var>value</var> IN (SELECT <var>key_column</var> FROM <var>single_table</var> WHERE <var>some_expr</var>) 
</PRE>

<DT><code>range</code>
<DD>
Only rows that are in a given range will be retrieved, using an index to
select the rows.  The <code>key</code> column indicates which index is used.
The <code>key_len</code> contains the longest key part that was used.
The <code>ref</code> column will be <code>NULL</code> for this type.

<code>range</code> can be used for when a key column is compared to a
constant using any of the <code>=</code>, <code>&#60;&#62;</code>, <code>&#62;</code>, <code>&#62;=</code>, <code>&#60;</code>,
<code>&#60;=</code>, <code>IS NULL</code>, <code>&#60;=&#62;</code>, <code>BETWEEN</code>, or <code>IN</code> operators:


<PRE>
SELECT * FROM <var>tbl_name</var>
WHERE <var>key_column</var> = 10;

SELECT * FROM <var>tbl_name</var>
WHERE <var>key_column</var> BETWEEN 10 and 20;

SELECT * FROM <var>tbl_name</var>
WHERE <var>key_column</var> IN (10,20,30);

SELECT * FROM <var>tbl_name</var>
WHERE <var>key_part1</var>= 10 AND <var>key_part2</var> IN (10,20,30);
</PRE>

<DT><code>index</code>
<DD>
This join type is the same as <code>ALL</code>, except that only the index tree
is scanned.  This usually is faster than <code>ALL</code>, because the index
file usually is smaller than the data file.

MySQL can use this join type when the query uses only columns that are
part of a single index.

<DT><code>ALL</code>
<DD>
A full table scan will be done for each combination of rows from the
previous tables.  This is normally not good if the table is the first
table not marked <code>const</code>, and usually <em>very</em> bad in all other
cases. Normally, you can avoid <code>ALL</code> by adding indexes that allow row
retrieval from the table based on constant values or column values from
earlier tables.
</DL>

<DT><code>possible_keys</code>
<DD>
The <code>possible_keys</code> column indicates which indexes MySQL could use to
find the rows in this table. Note that this column is totally independent of
the order of the tables as displayed in the output from <code>EXPLAIN</code>. That
means that some of the keys in <code>possible_keys</code> might not be usable in
practice with the generated table order.

If this column is <code>NULL</code>, there are no relevant indexes. In this case,
you may be able to improve the performance of your query by examining
the <code>WHERE</code> clause to see whether it refers to some column or columns
that would be suitable for indexing.  If so, create an appropriate index
and check the query with <code>EXPLAIN</code> again.
See section <A HREF="manual_SQL_Syntax.html#ALTER_TABLE">13.2.2  <code>ALTER TABLE</code> Syntax</A>.

To see what indexes a table has, use <code>SHOW INDEX FROM <var>tbl_name</var></code>.

<DT><code>key</code>
<DD>
The <code>key</code> column indicates the key (index) that MySQL actually decided
to use. The key is <code>NULL</code> if no index was chosen. To force MySQL
to use or ignore an index listed in the <code>possible_keys</code> column, use
<code>FORCE INDEX</code>, <code>USE INDEX</code>, or <code>IGNORE INDEX</code> in your query.
See section <A HREF="manual_SQL_Syntax.html#SELECT">13.1.7  <code>SELECT</code> Syntax</A>.

For <code>MyISAM</code> and <code>BDB</code> tables, running <code>ANALYZE TABLE</code>
will help the optimizer choose better indexes.  For <code>MyISAM</code> tables,
<code>myisamchk --analyze</code> will do the same.  See section <A HREF="manual_SQL_Syntax.html#ANALYZE_TABLE">13.5.2.1  <code>ANALYZE TABLE</code> Syntax</A> and section <A HREF="manual_MySQL_Database_Administration.html#Table_maintenance">5.7.2  Table Maintenance and Crash Recovery</A>.

<DT><code>key_len</code>
<DD>
The <code>key_len</code> column indicates the length of the key that MySQL
decided to use.  The length is <code>NULL</code> if the <code>key</code> column says
<code>NULL</code>. Note that the value of <code>key_len</code> allows you to determine
how many parts of a multiple-part key MySQL will actually use.

<DT><code>ref</code>
<DD>
The <code>ref</code> column shows which columns or constants are used with the
<code>key</code> to select rows from the table.

<DT><code>rows</code>
<DD>
The <code>rows</code> column indicates the number of rows MySQL
believes it must examine to execute the query.

<DT><code>Extra</code>
<DD>
This column contains additional information about how MySQL will
resolve the query. Here is an explanation of the different text
strings that can appear in this column:

<DL COMPACT>

<DT><code>Distinct</code>
<DD>
MySQL will stop searching for more rows for the current row
combination after it has found the first matching row.

<DT><code>Not exists</code>
<DD>
MySQL was able to do a <code>LEFT JOIN</code> optimization on the
query and will not examine more rows in this table for the previous row
combination after it finds one row that matches the <code>LEFT JOIN</code> criteria.

Here is an example of the type of query that can be optimized this way:


<PRE>
SELECT * FROM t1 LEFT JOIN t2 ON t1.id=t2.id
WHERE t2.id IS NULL;
</PRE>

Assume that <code>t2.id</code> is defined as <code>NOT NULL</code>.  In this case,
MySQL will scan <code>t1</code> and look up the rows in <code>t2</code> using the values
of <code>t1.id</code>. If MySQL finds a matching row in <code>t2</code>, it knows that
<code>t2.id</code> can never be <code>NULL</code>, and will not scan through the rest
of the rows in <code>t2</code> that have the same <code>id</code> value.  In other
words, for each row in <code>t1</code>, MySQL needs to do only a single lookup
in <code>t2</code>, regardless of how many rows actually match in <code>t2</code>.

<DT><code><code>range checked for each record (index map: #)</code></code>
<DD>
MySQL found no good index to use, but found that some of indexes might
be used once column values from preceding tables are known.  For each
row combination in the preceding tables, MySQL will check whether it is
possible to use a <code>range</code> or <code>index_merge</code> access method to
retrieve rows. The applicability criteria are as described in section <A HREF="manual_MySQL_Optimization.html#Range_optimization">7.2.5  Range Optimization</A>
and section <A HREF="manual_MySQL_Optimization.html#Index_Merge_optimization">7.2.6  Index Merge Optimization</A>, with the exception that all column values for the
preceding table are known and considered to be constants.

This is not very fast, but is faster than performing a join with no index
at all.

<DT><code>Using filesort</code>
<DD>
MySQL will need to do an extra pass to find out how to retrieve
the rows in sorted order.  The sort is done by going through all rows
according to the join type and storing the sort key and pointer to
the row for all rows that match the <code>WHERE</code> clause. The keys then are
sorted and the rows are retrieved in sorted order.
See section <A HREF="manual_MySQL_Optimization.html#ORDER_BY_optimization">7.2.10  How MySQL Optimizes <code>ORDER BY</code></A>.

<DT><code>Using index</code>
<DD>
The column information is retrieved from the table using only
information in the index tree without having to do an additional seek to
read the actual row.  This strategy can be used when the query uses only
columns that are part of a single index.

<DT><code>Using temporary</code>
<DD>
To resolve the query, MySQL will need to create a temporary table to hold
the result.  This typically happens if the query contains <code>GROUP BY</code>
and <code>ORDER BY</code> clauses that list columns differently.

<DT><code>Using where</code>
<DD>
A <code>WHERE</code> clause will be used to restrict which rows to match
against the next table or send to the client. Unless you specifically intend
to fetch or examine all rows from the table, you may have something wrong
in your query if the <code>Extra</code> value is not <code>Using where</code>
and the table join type is <code>ALL</code> or <code>index</code>.

If you want to make your queries as fast as possible, you should look out for
<code>Extra</code> values of <code>Using filesort</code> and <code>Using temporary</code>.

<DT><code>Using sort_union(...)</code>
<DD>
<DT><code>Using union(...)</code>
<DD>
<DT><code>Using intersect(...)</code>
<DD>
These indicate how index scans are merged for the <code>index_merge</code>
join type.  See section <A HREF="manual_MySQL_Optimization.html#Index_Merge_optimization">7.2.6  Index Merge Optimization</A> for more information.

<DT><code>Using index for group-by</code>
<DD>
Similar to the <code>Using index</code> way of accessing a table, <code>Using
index for group-by</code> indicates that MySQL found an index that can be used
to retrieve all columns of a <code>GROUP BY</code> or <code>DISTINCT</code> query
without any extra disk access to the actual table. Additionally, the index
will be used in the most efficient way so that for each group, only a few
index entries will be read. For details, see
section <A HREF="manual_MySQL_Optimization.html#GROUP_BY_optimization">7.2.11  How MySQL Optimizes <code>GROUP BY</code></A>.
</DL>

</DL>

<P>
You can get a good indication of how good a join is by taking the
product of the values in the <code>rows</code> column of the <code>EXPLAIN</code>
output. This should tell you roughly how many rows MySQL must examine to
execute the query.  If you restrict queries with the <code>max_join_size</code>
system variable, this product also is used to determine which multiple-table
<code>SELECT</code> statements to execute.
See section <A HREF="manual_MySQL_Optimization.html#Server_parameters">7.5.2  Tuning Server Parameters</A>.

</P>
<P>
The following example shows how a multiple-table join can be optimized
progressively based on the information provided by <code>EXPLAIN</code>.

</P>
<P>
Suppose that you have the <code>SELECT</code> statement shown here and you plan to
examine it using <code>EXPLAIN</code>:

</P>

<PRE>
EXPLAIN SELECT tt.TicketNumber, tt.TimeIn,
            tt.ProjectReference, tt.EstimatedShipDate,
            tt.ActualShipDate, tt.ClientID,
            tt.ServiceCodes, tt.RepetitiveID,
            tt.CurrentProcess, tt.CurrentDPPerson,
            tt.RecordVolume, tt.DPPrinted, et.COUNTRY,
            et_1.COUNTRY, do.CUSTNAME
        FROM tt, et, et AS et_1, do
        WHERE tt.SubmitTime IS NULL
            AND tt.ActualPC = et.EMPLOYID
            AND tt.AssignedPC = et_1.EMPLOYID
            AND tt.ClientID = do.CUSTNMBR;
</PRE>

<P>
For this example, make the following assumptions:

</P>

<UL>
<LI>

The columns being compared have been declared as follows:

<TABLE BORDER>
<TR><TD><strong>Table</strong> </TD><TD> <strong>Column</strong> </TD><TD> <strong>Column Type</strong>
</TD></TR>
<TR><TD><code>tt</code> </TD><TD> <code>ActualPC</code> </TD><TD> <code>CHAR(10)</code>
</TD></TR>
<TR><TD><code>tt</code> </TD><TD> <code>AssignedPC</code> </TD><TD> <code>CHAR(10)</code>
</TD></TR>
<TR><TD><code>tt</code> </TD><TD> <code>ClientID</code> </TD><TD> <code>CHAR(10)</code>
</TD></TR>
<TR><TD><code>et</code> </TD><TD> <code>EMPLOYID</code> </TD><TD> <code>CHAR(15)</code>
</TD></TR>
<TR><TD><code>do</code> </TD><TD> <code>CUSTNMBR</code> </TD><TD> <code>CHAR(15)</code>
</TD></TR>
</TABLE>

<LI>

The tables have the following indexes:

<TABLE BORDER>
<TR><TD><strong>Table</strong> </TD><TD> <strong>Index</strong>
</TD></TR>
<TR><TD><code>tt</code> </TD><TD> <code>ActualPC</code>
</TD></TR>
<TR><TD><code>tt</code> </TD><TD> <code>AssignedPC</code>
</TD></TR>
<TR><TD><code>tt</code> </TD><TD> <code>ClientID</code>
</TD></TR>
<TR><TD><code>et</code> </TD><TD> <code>EMPLOYID</code> (primary key)
</TD></TR>
<TR><TD><code>do</code> </TD><TD> <code>CUSTNMBR</code> (primary key)
</TD></TR>
</TABLE>

<LI>

The <code>tt.ActualPC</code> values are not evenly distributed.
</UL>

<P>
Initially, before any optimizations have been performed, the <code>EXPLAIN</code>
statement produces the following information:

</P>

<PRE>
table type possible_keys key  key_len ref  rows  Extra
et    ALL  PRIMARY       NULL NULL    NULL 74
do    ALL  PRIMARY       NULL NULL    NULL 2135
et_1  ALL  PRIMARY       NULL NULL    NULL 74
tt    ALL  AssignedPC,   NULL NULL    NULL 3872
           ClientID,
           ActualPC
      range checked for each record (key map: 35)
</PRE>

<P>
Because <code>type</code> is <code>ALL</code> for each table, this output indicates
that MySQL is generating a Cartesian product of all the tables; that is,
every combination of rows.  This will take quite a long time, because the
product of the number of rows in each table must be examined.  For the case
at hand, this product is <code>74 * 2135 * 74 * 3872 = 45,268,558,720</code> rows.
If the tables were bigger, you can only imagine how long it would take.

</P>
<P>
One problem here is that MySQL can use indexes on columns more efficiently
if they are declared the same. (For <code>ISAM</code> tables, indexes may not be
used at all unless the columns are declared the same.)  In this context,
<code>VARCHAR</code> and <code>CHAR</code> are the same unless they are declared as
different lengths. Because <code>tt.ActualPC</code> is declared as <code>CHAR(10)</code>
and <code>et.EMPLOYID</code> is declared as <code>CHAR(15)</code>, there is a length
mismatch.

</P>
<P>
To fix this disparity between column lengths, use <code>ALTER TABLE</code> to
lengthen <code>ActualPC</code> from 10 characters to 15 characters:

</P>

<PRE>
mysql&#62; ALTER TABLE tt MODIFY ActualPC VARCHAR(15);
</PRE>

<P>
Now <code>tt.ActualPC</code> and <code>et.EMPLOYID</code> are both <code>VARCHAR(15)</code>.
Executing the <code>EXPLAIN</code> statement again produces this result:

</P>

<PRE>
table type   possible_keys key     key_len ref         rows    Extra
tt    ALL    AssignedPC,   NULL    NULL    NULL        3872    Using
             ClientID,                                         where
             ActualPC
do    ALL    PRIMARY       NULL    NULL    NULL        2135
      range checked for each record (key map: 1)
et_1  ALL    PRIMARY       NULL    NULL    NULL        74
      range checked for each record (key map: 1)
et    eq_ref PRIMARY       PRIMARY 15      tt.ActualPC 1
</PRE>

<P>
This is not perfect, but is much better: The product of the <code>rows</code>
values is now less by a factor of 74. This version is executed in a couple
of seconds.

</P>
<P>
A second alteration can be made to eliminate the column length mismatches
for the <code>tt.AssignedPC = et_1.EMPLOYID</code> and <code>tt.ClientID =
do.CUSTNMBR</code> comparisons:

</P>

<PRE>
mysql&#62; ALTER TABLE tt MODIFY AssignedPC VARCHAR(15),
    -&#62;                MODIFY ClientID   VARCHAR(15);
</PRE>

<P>
Now <code>EXPLAIN</code> produces the output shown here:

</P>

<PRE>
table type   possible_keys key      key_len ref           rows Extra
et    ALL    PRIMARY       NULL     NULL    NULL          74
tt    ref    AssignedPC,   ActualPC 15      et.EMPLOYID   52   Using
             ClientID,                                         where
             ActualPC
et_1  eq_ref PRIMARY       PRIMARY  15      tt.AssignedPC 1
do    eq_ref PRIMARY       PRIMARY  15      tt.ClientID   1
</PRE>

<P>
This is almost as good as it can get.

</P>
<P>
The remaining problem is that, by default, MySQL assumes that values
in the <code>tt.ActualPC</code> column are evenly distributed, and that is not the
case for the <code>tt</code> table.  Fortunately, it is easy to tell MySQL
to analyze the key distribution:

</P>

<PRE>
mysql&#62; ANALYZE TABLE tt;
</PRE>

<P>
Now the join is perfect, and <code>EXPLAIN</code> produces this result:

</P>

<PRE>
table type   possible_keys key     key_len ref           rows Extra
tt    ALL    AssignedPC    NULL    NULL    NULL          3872 Using
             ClientID,                                        where
             ActualPC
et    eq_ref PRIMARY       PRIMARY 15      tt.ActualPC   1
et_1  eq_ref PRIMARY       PRIMARY 15      tt.AssignedPC 1
do    eq_ref PRIMARY       PRIMARY 15      tt.ClientID   1
</PRE>

<P>
Note that the <code>rows</code> column in the output from <code>EXPLAIN</code> is an
educated guess from the MySQL join optimizer.  You should check whether the
numbers are even close to the truth.  If not, you may get better performance
by using <code>STRAIGHT_JOIN</code> in your <code>SELECT</code> statement and trying
to list the tables in a different order in the <code>FROM</code> clause.

</P>



<H3><A NAME="Estimating_performance" HREF="manual_toc.html#Estimating_performance">7.2.2  Estimating Query Performance</A></H3>

<P>
<A NAME="IDX708"></A>
<A NAME="IDX709"></A>
<A NAME="IDX710"></A>

</P>
<P>
In most cases, you can estimate the performance by counting disk seeks.
For small tables, you can usually find a row in one disk seek (because the
index is probably cached).  For bigger tables, you can estimate that,
using B-tree indexes, you will need this many seeks to find a row:
<code>log(<var>row_count</var>) / log(<var>index_block_length</var> / 3 * 2 /
(<var>index_length</var> + <var>data_pointer_length</var>)) +
1</code>.

</P>
<P>
In MySQL, an index block is usually 1024 bytes and the data
pointer is usually 4 bytes. For a 500,000-row table with an
index length of 3 bytes (medium integer), the formula indicates
<code>log(500,000)/log(1024/3*2/(3+4)) + 1</code> = <code>4</code> seeks.

</P>
<P>
This index would require storage of about 500,000 * 7 * 3/2 = 5.2MB
(assuming a typical index buffer fill ratio of 2/3), so
you will probably have much of the index in memory and you will probably
need only one or two calls to read data to find the row.

</P>
<P>
For writes, however, you will need four seek requests (as above) to find
where to place the new index and normally two seeks to update the index
and write the row.

</P>
<P>
Note that the preceding discussion doesn't mean that your application
performance will slowly degenerate by log N!  As long as everything
is cached by the OS or SQL server, things will become only marginally
slower as the table gets bigger. After the data gets too big to be cached,
things will start to go much slower until your applications is only bound
by disk-seeks (which increase by log <var>N</var>). To avoid this, increase the key
cache size as the data grows.  For <code>MyISAM</code> tables, the key cache
size is controlled by the <code>key_buffer_size</code> system variable.
See section <A HREF="manual_MySQL_Optimization.html#Server_parameters">7.5.2  Tuning Server Parameters</A>.

</P>



<H3><A NAME="SELECT_speed" HREF="manual_toc.html#SELECT_speed">7.2.3  Speed of <code>SELECT</code> Queries</A></H3>

<P>
<A NAME="IDX711"></A>

</P>
<P>
<A NAME="IDX712"></A>

</P>
<P>
In general, when you want to make a slow <code>SELECT ... WHERE</code> query
faster, the first thing to check is whether you can add an index.
All references between different tables should usually be done with
indexes. You can use the <code>EXPLAIN</code> statement to determine which
indexes are used for a <code>SELECT</code>.
See section <A HREF="manual_MySQL_Optimization.html#MySQL_indexes">7.4.5  How MySQL Uses Indexes</A> and
section <A HREF="manual_MySQL_Optimization.html#EXPLAIN">7.2.1  <code>EXPLAIN</code> Syntax (Get Information About a <code>SELECT</code>)</A>.

</P>
<P>
Some general tips for speeding up queries on <code>MyISAM</code> tables:

</P>

<UL>
<LI>

To help MySQL optimize queries better, use <code>ANALYZE TABLE</code> or
run <code>myisamchk --analyze</code> on a table after it has been loaded with
data. This updates a value for each index part that indicates the average
number of rows that have the same value.  (For unique indexes, this is
always 1.)  MySQL will use this to decide which index to choose when you
join two tables based on a non-constant expression.  You can check the
result from the table analysis by using <code>SHOW INDEX FROM <var>tbl_name</var></code>
and examining the <code>Cardinality</code> value.  <code>myisamchk --description
--verbose</code> shows index distribution information.

<LI>

To sort an index and data according to an index, use <code>myisamchk
--sort-index --sort-records=1</code> (if you want to sort on index 1). This is
a good way to make queries faster if you have a unique index from which
you want to read all records in order according to the index.  Note that
the first time you sort a large table this way, it may take a long time.
</UL>



<H3><A NAME="Where_optimizations" HREF="manual_toc.html#Where_optimizations">7.2.4  How MySQL Optimizes <code>WHERE</code> Clauses</A></H3>

<P>
<A NAME="IDX713"></A>

</P>
<P>
<A NAME="IDX714"></A>

</P>
<P>
This section discusses optimizations that can be made for processing
<code>WHERE</code> clauses. The examples use <code>SELECT</code> statements, but
the same optimizations apply for <code>WHERE</code> clauses in <code>DELETE</code>
and <code>UPDATE</code> statements.

</P>
<P>
Note that work on the MySQL optimizer is ongoing, so this section is
incomplete. MySQL does many optimizations, not all of which are documented
here.

</P>
<P>
Some of the optimizations performed by MySQL are listed here:

</P>

<UL>
<LI>

Removal of unnecessary parentheses:

<PRE>
   ((a AND b) AND c OR (((a AND b) AND (c AND d))))
-&#62; (a AND b AND c) OR (a AND b AND c AND d)
</PRE>

<LI>

Constant folding:

<PRE>
   (a&#60;b AND b=c) AND a=5
-&#62; b&#62;5 AND b=c AND a=5
</PRE>

<LI>

Constant condition removal (needed because of constant folding):

<PRE>
   (B&#62;=5 AND B=5) OR (B=6 AND 5=5) OR (B=7 AND 5=6)
-&#62; B=5 OR B=6
</PRE>

<LI>

Constant expressions used by indexes are evaluated only once.
<LI>

<code>COUNT(*)</code> on a single table without a <code>WHERE</code> is retrieved
directly from the table information for <code>MyISAM</code> and <code>HEAP</code> tables.
This is also done for any <code>NOT NULL</code> expression when used with only one
table.
<LI>

Early detection of invalid constant expressions. MySQL quickly
detects that some <code>SELECT</code> statements are impossible and returns no rows.
<LI>

<code>HAVING</code> is merged with <code>WHERE</code> if you don't use <code>GROUP BY</code>
or group functions (<code>COUNT()</code>, <code>MIN()</code>, and so on).
<LI>

For each table in a join, a simpler <code>WHERE</code> is constructed to get a fast
<code>WHERE</code> evaluation for the table and also to skip records as
soon as possible.
<A NAME="IDX715"></A>
<A NAME="IDX716"></A>
<LI>

All constant tables are read first before any other tables in the query.
A constant table is any of the following:

<UL>
<LI>

An empty table or a table with one row.
<LI>

A table that is used with a <code>WHERE</code> clause on a <code>PRIMARY KEY</code>
or a <code>UNIQUE</code> index, where all index parts are compared to constant
expressions and are defined as <code>NOT NULL</code>.
</UL>

All of the following tables are used as constant tables:


<PRE>
SELECT * FROM t WHERE <var>primary_key</var>=1;
SELECT * FROM t1,t2
    WHERE t1.<var>primary_key</var>=1 AND t2.<var>primary_key</var>=t1.id;
</PRE>

<LI>

The best join combination for joining the tables is found by trying all
possibilities. If all columns in <code>ORDER BY</code> and <code>GROUP
BY</code> clauses come from the same table, that table is preferred first when
joining.
<LI>

If there is an <code>ORDER BY</code> clause and a different <code>GROUP BY</code>
clause, or if the <code>ORDER BY</code> or <code>GROUP BY</code> contains columns
from tables other than the first table in the join queue, a temporary
table is created.
<LI>

If you use <code>SQL_SMALL_RESULT</code>, MySQL uses an in-memory
temporary table.
<LI>

Each table index is queried, and the best index is used unless the optimizer
believes that it will be more efficient to use a table scan. At one time, a
scan was used based on whether the best index spanned more than 30% of the
table.  Now the optimizer is more complex and bases its estimate on
additional factors such as table size, number of rows, and I/O block size,
so a fixed percentage no longer determines the choice between using an index
or a scan.
<LI>

In some cases, MySQL can read rows from the index without even
consulting the data file.  If all columns used from the index are numeric,
only the index tree is used to resolve the query.
<LI>

Before each record is output, those that do not match the <code>HAVING</code> clause
are skipped.
</UL>

<P>
Some examples of queries that are very fast:

</P>

<PRE>
SELECT COUNT(*) FROM <var>tbl_name</var>;

SELECT MIN(<var>key_part1</var>),MAX(<var>key_part1</var>) FROM <var>tbl_name</var>;

SELECT MAX(<var>key_part2</var>) FROM <var>tbl_name</var>
    WHERE <var>key_part1</var>=<var>constant</var>;

SELECT ... FROM <var>tbl_name</var>
    ORDER BY <var>key_part1</var>,<var>key_part2</var>,... LIMIT 10;

SELECT ... FROM <var>tbl_name</var>
    ORDER BY <var>key_part1</var> DESC, <var>key_part2</var> DESC, ... LIMIT 10;
</PRE>

<P>
The following queries are resolved using only the index tree, assuming
that the indexed columns are numeric:

</P>

<PRE>
SELECT <var>key_part1</var>,<var>key_part2</var> FROM <var>tbl_name</var> WHERE <var>key_part1</var>=<var>val</var>;

SELECT COUNT(*) FROM <var>tbl_name</var>
    WHERE <var>key_part1</var>=<var>val1</var> AND <var>key_part2</var>=<var>val2</var>;

SELECT <var>key_part2</var> FROM <var>tbl_name</var> GROUP BY <var>key_part1</var>;
</PRE>

<P>
The following queries use indexing to retrieve the rows in sorted
order without a separate sorting pass:

</P>

<PRE>
SELECT ... FROM <var>tbl_name</var>
    ORDER BY <var>key_part1</var>,<var>key_part2</var>,... ;

SELECT ... FROM <var>tbl_name</var>
    ORDER BY <var>key_part1</var> DESC, <var>key_part2</var> DESC, ... ;
</PRE>



<H3><A NAME="Range_optimization" HREF="manual_toc.html#Range_optimization">7.2.5  Range Optimization</A></H3>

<P>
The <code>range</code> access method uses a single index to retrieve a subset
of table records that are contained within one or several index value
intervals. It can be used for a single-part or multiple-part index.
A detailed description of how intervals are extracted from the
<code>WHERE</code> clause is given in the following sections.

</P>



<H4><A NAME="Range_access_single-part" HREF="manual_toc.html#Range_access_single-part">7.2.5.1  Range Access Method for Single-Part Indexes</A></H4>

<P>
For a single-part index, index value intervals can be conveniently
represented by corresponding conditions in the <code>WHERE</code> clause, so
we'll talk about ``range conditions'' instead of intervals.

</P>
<P>
The definition of a range condition for a single-part index is as follows:

</P>

<UL>

<LI>

For both <code>BTREE</code> and <code>HASH</code> indexes, comparison of a key part with
a constant value is a range condition when using the <code>=</code>, <code>&#60;=&#62;</code>,
<code>IN</code>, <code>IS NULL</code>, or <code>IS NOT NULL</code> operators.

<LI>

For <code>BTREE</code> indexes, comparison of a key part with a constant
value is a range condition when using the <code>&#62;</code>, <code>&#60;</code>, <code>&#62;=</code>,
<code>&#60;=</code>, <code>BETWEEN</code>, <code>!=</code>, or <code>&#60;&#62;</code> operators, or <code>LIKE
'<var>pattern</var>'</code> (where <code>'<var>pattern</var>'</code> doesn't start with a
wildcard).

<LI>

For all types of indexes, multiple range conditions combined with <code>OR</code>
or <code>AND</code> form a range condition.

</UL>

<P>
``Constant value'' in the preceding descriptions  means one of the following:

</P>

<UL>
<LI>

A constant from the query string
<LI>

A column of a <code>const</code> or <code>system</code> table from the same join
<LI>

The result of an uncorrelated subquery
<LI>

Any expression composed entirely from subexpressions of the preceding types
</UL>

<P>
Here are some examples of queries with range conditions in the
<code>WHERE</code> clause:

</P>

<PRE>
SELECT * FROM t1 WHERE <var>key_col</var> &#62; 1 AND <var>key_col</var> &#60; 10;

SELECT * FROM t1 WHERE <var>key_col</var> = 1 OR <var>key_col</var> IN (15,18,20);

SELECT * FROM t1 WHERE <var>key_col</var> LIKE 'ab%' OR <var>key_col</var> BETWEEN 
'bar' AND 'foo';
</PRE>

<P>
Note that some non-constant values may be converted to constants during
the constant propagation phase.

</P>
<P>
MySQL tries to extract range conditions from the <code>WHERE</code> clause for
each of the possible indexes. During the extraction process, conditions
that can't be used for constructing the range condition are dropped,
conditions that produce overlapping ranges are combined, and conditions that
produce empty ranges are removed.

</P>
<P>
For example, consider the following statement, where <code>key1</code> is an
indexed column and <code>nonkey</code> is not indexed:

</P>

<PRE>
SELECT * FROM t1 WHERE
   (key1 &#60; 'abc' AND (key1 LIKE 'abcde%' OR key1 LIKE '%b')) OR
   (key1 &#60; 'bar' AND nonkey = 4) OR
   (key1 &#60; 'uux' AND key1 &#62; 'z');
</PRE>

<P>
The extraction process for key <code>key1</code> is as follows:

</P>

<OL>
<LI>

Start with original <code>WHERE</code> clause:


<PRE>
(key1 &#60; 'abc' AND (key1 LIKE 'abcde%' OR key1 LIKE '%b')) OR
(key1 &#60; 'bar' AND nonkey = 4) OR
(key1 &#60; 'uux' AND key1 &#62; 'z')
</PRE>

<LI>

Remove <code>nonkey = 4</code> and <code>key1 LIKE '%b'</code> because they cannot be
used for a range scan. The right way to remove them is to replace them
with <code>TRUE</code>, so that we don't miss any matching records when doing
the range scan. Having replaced them with <code>TRUE</code>, we get:


<PRE>
(key1 &#60; 'abc' AND (key1 LIKE 'abcde%' OR TRUE)) OR
(key1 &#60; 'bar' AND TRUE) OR
(key1 &#60; 'uux' AND key1 &#62; 'z')
</PRE>

<LI>

Collapse conditions that are always true or false:


<UL>
<LI>

<code>(key1 LIKE 'abcde%' OR TRUE)</code>  is always true
<LI>

<code>(key1 &#60; 'uux' AND key1 &#62; 'z')</code> is always false
</UL>

Replacing these conditions with constants, we get:


<PRE>
(key1 &#60; 'abc' AND TRUE) OR (key1 &#60; 'bar' AND TRUE) OR (FALSE)
</PRE>

Removing unnecessary <code>TRUE</code> and <code>FALSE</code> constants, we obtain


<PRE>
(key1 &#60; 'abc') OR (key1 &#60; 'bar')
</PRE>

<LI>

Combining overlapping intervals into one yields the final condition to be used
for the range scan:


<PRE>
(key1 &#60; 'bar')
</PRE>

</OL>

<P>
In general (and as demonstrated in the example), the condition used for
a range scan is less restrictive than the <code>WHERE</code> clause. MySQL will
perform an additional check to filter out rows that satisfy the range
condition but not the full <code>WHERE</code> clause.

</P>
<P>
The range condition extraction algorithm can handle nested
<code>AND</code>/<code>OR</code> constructs of arbitrary depth, and its output doesn't
depend on the order in which conditions appear in <code>WHERE</code> clause.

</P>



<H4><A NAME="Range_access_multi-part" HREF="manual_toc.html#Range_access_multi-part">7.2.5.2  Range Access Method for Multiple-Part Indexes</A></H4>

<P>
Range conditions on a multiple-part index are an extension of range conditions
for a single-part index.  A range condition on a multiple-part index restricts
index records to lie within one or several key tuple intervals. Key
tuple intervals are defined over a set of key tuples, using ordering from
the index.

</P>
<P>
For example, consider a multiple-part index defined as
<code>key1(<var>key_part1</var>, <var>key_part2</var>, <var>key_part3</var>)</code>, and the
following set of key tuples listed in key order:

</P>

<PRE>
<var>key_part1</var>  <var>key_part2</var>  <var>key_part3</var>
  NULL       1          'abc'
  NULL       1          'xyz'
  NULL       2          'foo'
   1         1          'abc'
   1         1          'xyz'
   1         2          'abc'
   2         1          'aaa'
</PRE>

<P>
The condition <code><var>key_part1</var> = 1</code> defines this interval:

</P>

<PRE>
(1, -inf, -inf) &#60;= (<var>key_part1</var>, <var>key_part2</var>, <var>key_part3</var>) &#60; (1, +inf, +inf)
</PRE>

<P>
The interval covers the 4th, 5th, and 6th tuples in the preceding data
set and can be used by the range access method.

</P>
<P>
By contrast, the condition <code><var>key_part3</var> = 'abc'</code> does not define a single
interval and cannot be used by the range access method.

</P>
<P>
The following descriptions indicate how range conditions work for
multiple-part indexes in greater detail.

</P>

<UL>

<LI>

For <code>HASH</code> indexes, each interval containing identical values
can be used.  This means that the interval can be produced only for
conditions in the following form:


<PRE>
    <var>key_part1</var> <var>cmp</var> <var>const1</var>
AND <var>key_part2</var> <var>cmp</var> <var>const2</var>
AND ...
AND <var>key_partN</var> <var>cmp</var> <var>constN</var>;
</PRE>

Here, <var>const1</var>, <var>const2</var>, ... are constants, <var>cmp</var> is one of
the <code>=</code>, <code>&#60;=&#62;</code>, or <code>IS NULL</code> comparison operators, and the
conditions cover all index parts. (That is, there are <var>N</var> conditions,
one for each part of an <var>N</var>-part index.)

See section <A HREF="manual_MySQL_Optimization.html#Range_access_single-part">7.2.5.1  Range Access Method for Single-Part Indexes</A> for the definition of
what is considered to be a constant.

For example, the following is a range condition for a three-part
<code>HASH</code> index:


<PRE>
<var>key_part1</var> = 1 AND <var>key_part2</var> IS NULL AND <var>key_part3</var> = 'foo'
</PRE>

<LI>

For a <code>BTREE</code> index, an interval might be usable for conditions
combined with <code>AND</code>, where each condition compares a key part with
a constant value using <code>=</code>, <code>&#60;=&#62;</code>, <code>IS NULL</code>, <code>&#62;</code>,
<code>&#60;</code>, <code>&#62;=</code>, <code>&#60;=</code>, <code>!=</code>, <code>&#60;&#62;</code>, <code>BETWEEN</code>, or
<code>LIKE '<var>pattern</var>'</code> (where <code>'<var>pattern</var>'</code> doesn't start
with a wildcard).  An interval can be used as long as it is possible to
determine a single key tuple containing all records that match the condition
(or two intervals if <code>&#60;&#62;</code> or <code>!=</code> is used).  For example, for
this condition:


<PRE>
<var>key_part1</var> = 'foo' AND <var>key_part2</var> &#62;= 10 AND <var>key_part3</var> &#62; 10
</PRE>

The single interval will be:


<PRE>
('foo', 10, 10)
   &#60; (<var>key_part1</var>, <var>key_part2</var>, <var>key_part3</var>)
      &#60; ('foo', +inf, +inf)
</PRE>

It is possible that
the created interval will contain more records than the initial condition.
For example, the preceding interval includes the value <code>('foo', 11, 0)</code>,
which does not satisfy the original condition.

<LI>

If conditions that cover sets of records contained within intervals are
combined with <code>OR</code>, they form a condition that covers a set of records
contained within the union of their intervals. If the conditions are combined
with <code>AND</code>, they form a condition that covers a set of records
contained within the intersection of their intervals.  For example, for
this condition on a two-part index:


<PRE>
(<var>key_part1</var> = 1 AND <var>key_part2</var> &#60; 2)
OR (<var>key_part1</var> &#62; 5)
</PRE>

The intervals will be:


<PRE>
(1, -inf) &#60; (<var>key_part1</var>, <var>key_part2</var>) &#60; (1, 2)
(5, -inf) &#60; (<var>key_part1</var>, <var>key_part2</var>)
</PRE>

In this example, the interval on the first line uses one key part for the
left bound and two key parts for the right bound. The interval on the second
line uses only one key part. The <code>key_len</code> column in the <code>EXPLAIN</code>
output indicates the maximum length of the key prefix used.

In some cases, <code>key_len</code> may indicate that a key part was used, but
that might be not what you would expect.  Suppose that <var>key_part1</var>
and <var>key_part2</var> can be <code>NULL</code>.  Then the <code>key_len</code> column
will display two key part lengths for the following condition:


<PRE>
<var>key_part1</var> &#62;= 1 AND <var>key_part2</var> &#60; 2
</PRE>

But in fact, the condition will be converted to this:


<PRE>
<var>key_part1</var> &#62;= 1 AND <var>key_part2</var> IS NOT NULL
</PRE>

</UL>

<P>
section <A HREF="manual_MySQL_Optimization.html#Range_access_single-part">7.2.5.1  Range Access Method for Single-Part Indexes</A> describes how optimizations are performed
to combine or eliminate intervals for range conditions on single-part index.
Analogous steps are performed for range conditions on multiple-part keys.

</P>



<H3><A NAME="Index_Merge_optimization" HREF="manual_toc.html#Index_Merge_optimization">7.2.6  Index Merge Optimization</A></H3>

<P>
<A NAME="IDX717"></A>
<A NAME="IDX718"></A>
<A NAME="IDX719"></A>

</P>

<P>
The Index Merge (<code>index_merge</code>) method is used to retrieve rows with
several <code>ref</code>, <code>ref_or_null</code>, or <code>range</code> scans and merge
the results into one.  This method is employed when the table condition
is a disjunction of conditions for which <code>ref</code>, <code>ref_or_null</code>,
or <code>range</code> could be used with different keys.

</P>
<P>
This ``join'' type optimization is new in MySQL 5.0.0, and represents
a significant change in behavior with regard to indexes, because the
<em>old</em> rule was that the server is only ever able to use at most
one index for each referenced table.

</P>
<P>
In <code>EXPLAIN</code> output, this method appears as <code>index_merge</code> in the
<code>type</code> column. In this case, the <code>key</code> column contains a list of
indexes used, and <code>key_len</code> contains a list of the longest key parts
for those indexes.

</P>
<P>
Examples:

</P>

<PRE>
SELECT * FROM <var>tbl_name</var> WHERE <var>key_part1</var> = 10 OR <var>key_part2</var> = 20;

SELECT * FROM <var>tbl_name</var>
    WHERE (<var>key_part1</var> = 10 OR <var>key_part2</var> = 20) AND <var>non_key_part</var>=30;

SELECT * FROM t1, t2
    WHERE (t1.<var>key1</var> IN (1,2) OR t1.<var>key2</var> LIKE '<var>value</var>%')
    AND t2.<var>key1</var>=t1.<var>some_col</var>;

SELECT * FROM t1, t2
    WHERE t1.<var>key1</var>=1
    AND (t2.<var>key1</var>=t1.<var>some_col</var> OR t2.<var>key2</var>=t1.<var>some_col2</var>);
</PRE>

<P>
The Index Merge method has several access algorithms (seen in the
<code>Extra</code> field of <code>EXPLAIN</code> output):

</P>

<UL>
<LI>intersection

<LI>union

<LI>sort-union

</UL>

<P>
The following sections describe these methods in greater detail.

</P>
<P>
<strong>Note</strong>:
The Index Merge optimization algorithm has the following known deficiencies:

</P>

<UL>
<LI>

If a range scan is possible on some key, Index Merge will not
be considered.  For example, consider this query:


<PRE>
SELECT * FROM t1 WHERE (goodkey1 &#60; 10 OR goodkey2 &#60; 20) AND badkey &#60; 30;
</PRE>

For this query, two plans are possible:


<OL>
<LI>

An Index Merge scan using the <code>(goodkey1 &#60; 10 OR goodkey2 &#60; 20)</code>
condition.
<LI>

A range scan using the <code>badkey &#60; 30</code> condition.
</OL>

However, the optimizer will only consider the second plan. If that not what
you want, you can make the optimizer consider <code>index_merge</code> by using
<code>IGNORE INDEX</code> or <code>FORCE INDEX</code>. The following queries will be
executed using Index Merge:


<PRE>
SELECT * FROM t1 FORCE INDEX(goodkey1,goodkey2)
WHERE (goodkey1 &#60; 10 OR goodkey2 &#60; 20) AND badkey &#60; 30;

SELECT * FROM t1 IGNORE INDEX(badkey)
WHERE (goodkey1 &#60; 10 OR goodkey2 &#60; 20) AND badkey &#60; 30;
</PRE>

<LI>

If your query has a complex <code>WHERE</code> clause with deep
<code>AND</code>/<code>OR</code> nesting and MySQL doesn't choose the optimal plan,
try distributing terms using the following identity laws:


<PRE>
(<var>x</var> AND <var>y</var>) OR <var>z</var> = (<var>x</var> OR <var>z</var>) AND (<var>y</var> OR <var>z</var>)
(<var>x</var> OR <var>y</var>) AND <var>z</var> = (<var>x</var> AND <var>z</var>) OR (<var>y</var> AND <var>z</var>)
</PRE>

</UL>

<P>
The choice between different possible variants of the <code>index_merge</code>
access method and other access methods is based on cost estimates of
various available options.

</P>



<H4><A NAME="Index_merge_intersection" HREF="manual_toc.html#Index_merge_intersection">7.2.6.1  Index Merge Intersection Access Algorithm</A></H4>

<P>
This access algorithm can be employed when a <code>WHERE</code> clause was
converted to several range conditions on different keys combined with
<code>AND</code>, and each condition is one of the following:

</P>

<UL>

<LI>

In this form, where the index has exactly <var>N</var> parts (that is, all
index parts are covered):


<PRE>
<var>key_part1</var>=<var>const1</var> AND <var>key_part2</var>=<var>const2</var> ... AND <var>key_partN</var>=<var>constN</var>
</PRE>

<LI>

Any range condition over a primary key of an <code>InnoDB</code>
or <code>BDB</code>
table.

</UL>

<P>
Here are some examples:

</P>

<PRE>
SELECT * FROM <var>innodb_table</var> WHERE <var>primary_key</var> &#60; 10 AND <var>key_col1</var>=20;

SELECT * FROM <var>tbl_name</var>
WHERE (<var>key1_part1</var>=1 AND <var>key1_part2</var>=2) AND <var>key2</var>=2;
</PRE>

<P>
The Index Merge intersection algorithm performs simultaneous scans on
all used indexes and produces the intersection of row sequences that it
receives from the merged index scans.

</P>
<P>
If all columns used in the query are covered by the used indexes, full
table records will not be retrieved (<code>EXPLAIN</code> output will contain
<code>Using index</code> in <code>Extra</code> field in this case).  Here is an example
of such query:

</P>

<PRE>
SELECT COUNT(*) FROM t1 WHERE key1=1 AND key2=1;
</PRE>

<P>
If the used indexes don't cover all columns used in the query, full records
will be retrieved only when the range conditions for all used keys are
satisfied.

</P>
<P>
If one of the merged conditions is a condition over a primary key of an
<code>InnoDB</code> or <code>BDB</code> table, it is not used for record retrieval,
but is used to filter out records retrieved using other conditions.

</P>



<H4><A NAME="Index_merge_union" HREF="manual_toc.html#Index_merge_union">7.2.6.2  Index Merge Union Access Algorithm</A></H4>

<P>
The applicability criteria for this algorithm are similar to those of the
Index Merge method intersection algorithm.  The algorithm can be
employed when the table <code>WHERE</code> clause was converted to several range
conditions on different keys combined with <code>OR</code>, and each condition
is one of the following:

</P>

<UL>
<LI>

In this form, where the index has exactly <var>N</var> parts (that is, all
index parts are covered):


<PRE>
<var>key_part1</var>=<var>const1</var> AND <var>key_part2</var>=<var>const2</var> ... AND <var>key_partN</var>=<var>constN</var>
</PRE>

<LI>

Any range condition over a primary key of an <code>InnoDB</code> or <code>BDB</code> table.

<LI>

A condition for which the Index Merge method intersection algorithm
is applicable.

</UL>

<P>
Here are some examples:

</P>

<PRE>
SELECT * FROM t1 WHERE <var>key1</var>=1 OR <var>key2</var>=2 OR <var>key3</var>=3;

SELECT * FROM <var>innodb_table</var> WHERE (<var>key1</var>=1 AND <var>key2</var>=2) OR
  (<var>key3</var>='foo' AND <var>key4</var>='bar') AND <var>key5</var>=5;
</PRE>



<H4><A NAME="Index_merge_sort-union" HREF="manual_toc.html#Index_merge_sort-union">7.2.6.3  Index Merge Sort-Union Access Algorithm</A></H4>

<P>
This access algorithm is employed when the <code>WHERE</code> clause was converted
to several range conditions combined by <code>OR</code>, but for which the
Index Merge method union algorithm is not applicable.

</P>
<P>
Here are some examples:

</P>

<PRE>
SELECT * FROM <var>tbl_name</var> WHERE <var>key_col1</var> &#60; 10 OR <var>key_col2</var> &#60; 20;

SELECT * FROM <var>tbl_name</var>
     WHERE (<var>key_col1</var> &#62; 10 OR <var>key_col2</var> = 20) AND <var>nonkey_col</var>=30;
</PRE>

<P>
The difference between the sort-union algorithm and the union algorithm
is that the sort-union algorithm must first fetch row IDs for all records
and sort them before returning any records.

</P>



<H3><A NAME="IS_NULL_optimization" HREF="manual_toc.html#IS_NULL_optimization">7.2.7  How MySQL Optimizes <code>IS NULL</code></A></H3>

<P>
<A NAME="IDX720"></A>
<A NAME="IDX721"></A>

</P>
<P>
MySQL can do the same optimization on <var>col_name</var> <code>IS NULL</code> that it can do
with <var>col_name</var> <code>=</code> <var>constant_value</var>.  For example, MySQL can use
indexes and ranges to search for <code>NULL</code> with <code>IS NULL</code>.

</P>

<PRE>
SELECT * FROM <var>tbl_name</var> WHERE <var>key_col</var> IS NULL;

SELECT * FROM <var>tbl_name</var> WHERE <var>key_col</var> &#60;=&#62; NULL;

SELECT * FROM <var>tbl_name</var>
    WHERE <var>key_col</var>=<var>const1</var> OR <var>key_col</var>=<var>const2</var> OR <var>key_col</var> IS NULL;
</PRE>

<P>
If a <code>WHERE</code> clause includes a <var>col_name</var> <code>IS NULL</code> condition for a
column that is declared as <code>NOT NULL</code>, that expression will be
optimized away.  This optimization does not occur in cases when the column
might produce <code>NULL</code> anyway; for example, if it comes from a table on
the right side of a <code>LEFT JOIN</code>.

</P>
<P>
MySQL 4.1.1 and up can additionally optimize the combination
<code><var>col_name</var> = <var>expr</var> AND <var>col_name</var> IS NULL</code>,
a form that is common in resolved subqueries.
<code>EXPLAIN</code> will show <code>ref_or_null</code> when this
optimization is used.

</P>
<P>
This optimization can handle one <code>IS NULL</code> for any key part.

</P>
<P>
Some examples of queries that are optimized, assuming that there is an index
on columns <code>a</code> and <code>b</code> of table <code>t2</code>:

</P>

<PRE>
SELECT * FROM t1 WHERE t1.a=<var>expr</var> OR t1.a IS NULL;

SELECT * FROM t1, t2 WHERE t1.a=t2.a OR t2.a IS NULL;

SELECT * FROM t1, t2
    WHERE (t1.a=t2.a OR t2.a IS NULL) AND t2.b=t1.b;

SELECT * FROM t1, t2
    WHERE t1.a=t2.a AND (t2.b=t1.b OR t2.b IS NULL);

SELECT * FROM t1, t2
    WHERE (t1.a=t2.a AND t2.a IS NULL AND ...)
    OR (t1.a=t2.a AND t2.a IS NULL AND ...);
</PRE>

<P>
<code>ref_or_null</code> works by first doing a read on the reference key,
and then a separate search for rows with a <code>NULL</code> key value.

</P>
<P>
Note that the optimization can handle only one <code>IS NULL</code> level.
In the following query, MySQL will use key lookups only on the expression
<code>(t1.a=t2.a AND t2.a IS NULL)</code> and not be able to use the key part on
<code>b</code>:

</P>

<PRE>
SELECT * FROM t1, t2
     WHERE (t1.a=t2.a AND t2.a IS NULL)
     OR (t1.b=t2.b AND t2.b IS NULL);
</PRE>



<H3><A NAME="DISTINCT_optimization" HREF="manual_toc.html#DISTINCT_optimization">7.2.8  How MySQL Optimizes <code>DISTINCT</code></A></H3>

<P>
<A NAME="IDX722"></A>

</P>
<P>
<A NAME="IDX723"></A>

</P>
<P>
<code>DISTINCT</code> combined with <code>ORDER BY</code> will
need a temporary table in many cases.

</P>
<P>
Note that because <code>DISTINCT</code> may use <code>GROUP BY</code>, you should be
aware of how MySQL works with columns in <code>ORDER BY</code> or <code>HAVING</code>
clauses that are not part of the selected columns.
See section <A HREF="manual_Functions.html#GROUP-BY-hidden-fields">12.9.3  <code>GROUP BY</code> with Hidden Fields</A>.

</P>
<P>
In most cases, a <code>DISTINCT</code> clause can be considered as a special case
of <code>GROUP BY</code>. For example, the following two queries are equivalent:

</P>

<PRE>
SELECT DISTINCT c1, c2, c3 FROM t1 WHERE c1 &#62; <var>const</var>;

SELECT c1, c2, c3 FROM t1 WHERE c1 &#62; <var>const</var> GROUP BY c1, c2, c3;
</PRE>

<P>
Due to this equivalence, the optimizations applicable to <code>GROUP BY</code>
queries can be also applied to queries with a <code>DISTINCT</code> clause. Thus,
for more details on the optimization possibilities for <code>DISTINCT</code>
queries, see section <A HREF="manual_MySQL_Optimization.html#GROUP_BY_optimization">7.2.11  How MySQL Optimizes <code>GROUP BY</code></A>.

</P>
<P>
When combining <code>LIMIT <var>row_count</var></code> with <code>DISTINCT</code>, MySQL stops
as soon as it finds <var>row_count</var> unique rows.

</P>
<P>
If you don't use columns from all tables named in a query, MySQL stops
scanning the not-used tables as soon as it finds the first match.
In the following case, assuming that <code>t1</code> is used before <code>t2</code>
(which you can check with <code>EXPLAIN</code>), MySQL stops reading from <code>t2</code>
(for any particular row in <code>t1</code>) when the first row in <code>t2</code>
is found:

</P>

<PRE>
SELECT DISTINCT t1.a FROM t1, t2 where t1.a=t2.a;
</PRE>



<H3><A NAME="LEFT_JOIN_optimization" HREF="manual_toc.html#LEFT_JOIN_optimization">7.2.9  How MySQL Optimizes <code>LEFT JOIN</code> and <code>RIGHT JOIN</code></A></H3>

<P>
<A NAME="IDX724"></A>

</P>
<P>
<A NAME="IDX725"></A>

</P>
<P>
<code>A LEFT JOIN B join_condition</code> is implemented in MySQL as follows:

</P>

<UL>
<LI>

Table <code>B</code> is set to depend on table <code>A</code> and all tables
on which <code>A</code> depends.

<LI>

Table <code>A</code> is set to depend on all tables (except <code>B</code>)
that are used in the <code>LEFT JOIN</code> condition.

<LI>

The <code>LEFT JOIN</code> condition is used to decide how to retrieve rows
from table B. (In other words, any condition in the <code>WHERE</code> clause
is not used.)

<LI>

All standard join optimizations are done, with the exception that a table is
always read after all tables on which it depends.  If there is a circular
dependence, MySQL issues an error.

<LI>

All standard <code>WHERE</code> optimizations are done.

<LI>

If there is a row in <code>A</code> that matches the <code>WHERE</code> clause, but there
is no row in <code>B</code> that matches the <code>ON</code> condition,
an extra <code>B</code> row is generated with all columns set to <code>NULL</code>.

<LI>

If you use <code>LEFT JOIN</code> to find rows that don't exist in some
table and you have the following test: <code><var>col_name</var> IS NULL</code> in the
<code>WHERE</code> part, where <var>col_name</var> is a column that is declared as
<code>NOT NULL</code>, MySQL stops searching for more rows
(for a particular key combination) after it has found one row that
matches the <code>LEFT JOIN</code> condition.
</UL>

<P>
<code>RIGHT JOIN</code> is implemented analogously to <code>LEFT JOIN</code>, with the
roles of the tables reversed.

</P>
<P>
The join optimizer calculates the order in which tables should be joined.
The table read order forced by <code>LEFT JOIN</code> and <code>STRAIGHT_JOIN</code>
helps the join optimizer do its work much more quickly, because there are
fewer table permutations to check.
Note that this means that if you do a query of the following type,
MySQL will do a full scan on <code>b</code> because the <code>LEFT JOIN</code> forces
it to be read before <code>d</code>:

</P>

<PRE>
SELECT *
    FROM a,b LEFT JOIN c ON (c.key=a.key) LEFT JOIN d ON (d.key=a.key)
    WHERE b.key=d.key;
</PRE>

<P>
The fix in this case is to rewrite the query as follows:

</P>

<PRE>
SELECT *
    FROM b,a LEFT JOIN c ON (c.key=a.key) LEFT JOIN d ON (d.key=a.key)
    WHERE b.key=d.key;
</PRE>

<P>
Starting from 4.0.14, MySQL does the following <code>LEFT JOIN</code> optimization:
If the <code>WHERE</code> condition is always false for the generated
<code>NULL</code> row, the <code>LEFT JOIN</code> is changed to a normal join.

</P>
<P>
For example, the <code>WHERE</code> clause would be
false in the following query
if <code>t2.column1</code> would be <code>NULL</code>:

</P>

<PRE>
SELECT * FROM t1 LEFT JOIN t2 ON (column1) WHERE t2.column2=5;
</PRE>

<P>
Therefore, it's safe to convert the query to a normal join:

</P>

<PRE>
SELECT * FROM t1, t2 WHERE t2.column2=5 AND t1.column1=t2.column1;
</PRE>

<P>
This can be made faster because MySQL can now use table <code>t2</code> before
table <code>t1</code> if this would result in a better query plan.  To force a
specific table order, use <code>STRAIGHT_JOIN</code>.

</P>


<H3><A NAME="ORDER_BY_optimization" HREF="manual_toc.html#ORDER_BY_optimization">7.2.10  How MySQL Optimizes <code>ORDER BY</code></A></H3>

<P>
In some cases, MySQL can use an index to satisfy an <code>ORDER BY</code>
clause without doing any extra sorting.

</P>
<P>
The index can also be used even if the <code>ORDER BY</code> doesn't match the
index exactly, as long as all the unused index parts and all the extra
are <code>ORDER BY</code> columns are constants in the <code>WHERE</code>
clause. The following queries will use the index to resolve the
<code>ORDER BY</code> part:

</P>

<PRE>
SELECT * FROM t1 ORDER BY <var>key_part1</var>,<var>key_part2</var>,... ;
SELECT * FROM t1 WHERE <var>key_part1</var>=<var>constant</var> ORDER BY <var>key_part2</var>;
SELECT * FROM t1 ORDER BY <var>key_part1</var> DESC, <var>key_part2</var> DESC;
SELECT * FROM t1
    WHERE <var>key_part1</var>=1 ORDER BY <var>key_part1</var> DESC, <var>key_part2</var> DESC;
</PRE>

<P>
In some cases, MySQL <em>cannot</em> use indexes to resolve the <code>ORDER
BY</code>, although it still will use indexes to find the rows that
match the <code>WHERE</code> clause. These cases include the following:

</P>

<UL>
<LI>

You use <code>ORDER BY</code> on different keys:


<PRE>
SELECT * FROM t1 ORDER BY <var>key1</var>, <var>key2</var>;
</PRE>

<LI>

You use <code>ORDER BY</code> on non-consecutive key parts:


<PRE>
SELECT * FROM t1 WHERE <var>key2</var>=<var>constant</var> ORDER BY <var>key_part2</var>;
</PRE>

<LI>

You mix <code>ASC</code> and <code>DESC</code>:


<PRE>
SELECT * FROM t1 ORDER BY <var>key_part1</var> DESC, <var>key_part2</var> ASC;
</PRE>

<LI>

The key used to fetch the rows is not the same as the one used in
the <code>ORDER BY</code>:


<PRE>
SELECT * FROM t1 WHERE <var>key2</var>=<var>constant</var> ORDER BY <var>key1</var>;
</PRE>

<LI>

You are joining many tables, and the columns in the <code>ORDER
BY</code> are not all from the first non-constant table that is used to
retrieve rows. (This is the first table in the <code>EXPLAIN</code> output that
doesn't have a <code>const</code> join type.)

<LI>

You have different <code>ORDER BY</code> and <code>GROUP BY</code> expressions.

<LI>

The type of table index used doesn't store rows in order.  For example, this
is true for a <code>HASH</code> index in a <code>HEAP</code> table.

</UL>

<P>
With <code>EXPLAIN SELECT ... ORDER BY</code>, you can check whether MySQL can use
indexes to resolve the query.  It cannot if you see <code>Using filesort</code> in
the <code>Extra</code> column.
See section <A HREF="manual_MySQL_Optimization.html#EXPLAIN">7.2.1  <code>EXPLAIN</code> Syntax (Get Information About a <code>SELECT</code>)</A>.

</P>

<P>
<A NAME="IDX726"></A>
<A NAME="IDX727"></A>

</P>
<P>
In those cases where MySQL must sort the result, it uses the following
<code>filesort</code> algorithm before MySQL 4.1:

</P>

<OL>

<LI>

Read all rows according to key or by table scanning.
Rows that don't match the <code>WHERE</code> clause are skipped.

<LI>

For each row, store a pair of values in a buffer (the sort key and the row
pointer).  The size of the buffer is the value of the <code>sort_buffer_size</code>
system variable.

<LI>

When the buffer gets full, run a qsort (quicksort) on it and store the
result in a temporary file.  Save a pointer to the sorted block.  (If all
pairs fit into the sort buffer, no temporary file is created.)

<LI>

Repeat the preceding steps until all rows have been read.

<LI>

Do a multi-merge of up to <code>MERGEBUFF</code> (7) regions to one block in
another temporary file.  Repeat until all blocks from the first file
are in the second file.

<LI>

Repeat the following until there are fewer than <code>MERGEBUFF2</code> (15)
blocks left.

<LI>

On the last multi-merge, only the pointer to the row (the last part of
the sort key) is written to a result file.

<LI>

Read the rows in sorted order by using the row pointers in the result file.
To optimize this, we read in a big block of row pointers, sort them, and use
them to read the rows in sorted order into a row buffer. The size of the
buffer is the value of the <code>read_rnd_buffer_size</code> system variable.
The code for this step is in the <tt>`sql/records.cc'</tt> source file.

</OL>

<P>
One problem with this approach is that it reads rows twice: One time when
evaluating the <code>WHERE</code> clause, and again after sorting the pair values.
And even if the rows were accessed successively the first time (for example,
if a table scan is done), the second time they are accessed randomly. (The
sort keys are ordered, but the row positions are not.)

</P>
<P>
In MySQL 4.1 and up, a <code>filesort</code> optimization is used that records not
only the sort key value and row position, but also the columns required for
the query.  This avoids reading the rows twice. The modified <code>filesort</code>
algorithm works like this:

</P>

<OL>

<LI>

Read the rows that match the <code>WHERE</code> clause, as before.

<LI>

For each row, record a tuple of values consisting of the sort key value and
row position, and also the columns required for the query.

<LI>

Sort the tuples by sort key value

<LI>

Retrieve the rows in sorted order, but read the required columns directly from
the sorted tuples rather than by accessing the table a second time.

</OL>

<P>
Using the modified <code>filesort</code> algorithm, the tuples are longer than the
pairs used in the original method, and fewer of them fit in the sort buffer
(the size of which is given by <code>sort_buffer_size</code>). As a result, it is
possible for the extra I/O to make the modified approach slower, not faster.
To avoid a slowdown, the optimization is used only if the total size of the
extra columns in the sort tuple does not exceed the value of the
<code>max_length_for_sort_data</code> system variable. (A symptom of setting the
value of this variable too high is that you will see high disk activity and
low CPU activity.)

</P>
<P>
If you want to increase <code>ORDER BY</code> speed, first see whether you can get
MySQL to use indexes rather than an extra sorting phase. If this is not
possible, you can try the following strategies:

</P>

<UL>
<LI>

Increase the size of the <code>sort_buffer_size</code> variable.
<LI>

Increase the size of the <code>read_rnd_buffer_size</code> variable.
<LI>

Change <code>tmpdir</code> to point to a dedicated filesystem with lots of empty
space.  If you use MySQL 4.1 or later, this option accepts several paths
that are used in round-robin fashion. Paths should be separated by colon
characters (<samp>`:'</samp>) on Unix and semicolon characters (<samp>`;'</samp>) on
Windows, NetWare, and OS/2.  You can use this feature to spread the load
across several directories.  <em>Note:</em> The paths should be for
directories in filesystems that are located on different <em>physical</em>
disks, not different partitions of the same disk.

</UL>

<P>
By default, MySQL sorts all <code>GROUP BY <var>col1</var>, <var>col2</var>, ...</code> queries as if
you specified <code>ORDER BY <var>col1</var>, <var>col2</var>, ...</code> in the query as well. If you
include an <code>ORDER BY</code> clause explicitly that contains the same column
list,  MySQL optimizes it away without any speed penalty, although the sorting
still occurs.  If a query includes <code>GROUP BY</code> but you want to avoid the
overhead of sorting the result, you can suppress sorting by specifying
<code>ORDER BY NULL</code>. For example:

</P>

<PRE>
INSERT INTO foo
SELECT a, COUNT(*) FROM bar GROUP BY a ORDER BY NULL;
</PRE>



<H3><A NAME="GROUP_BY_optimization" HREF="manual_toc.html#GROUP_BY_optimization">7.2.11  How MySQL Optimizes <code>GROUP BY</code></A></H3>

<P>
<A NAME="IDX728"></A>
<A NAME="IDX729"></A>

</P>
<P>
The most general way to satisfy a <code>GROUP BY</code> clause is to scan the whole
table and create a new temporary table where all rows from each group are
consecutive, and then use this temporary table to discover groups and apply
aggregate functions (if any). In some cases, MySQL is able to do much better
than that and to avoid creation of temporary tables by using index access.

</P>
<P>
The most important preconditions for using indexes for <code>GROUP BY</code> are
that all <code>GROUP BY</code> columns reference attributes from the same index,
and the index stores its keys in order (for example, this is a B-Tree index,
and not a HASH index). Whether usage of temporary tables can be replaced by
index access also depends on which parts of an index are used in a query, the
conditions specified for these parts, and the selected aggregate functions.

</P>
<P>
There are two ways to execute a <code>GROUP BY</code> query via index access,
as detailed in the following sections. In the first method, the grouping
operation is applied together with all range predicates (if any). The second
method first performs a range scan, and then groups the resulting tuples.

</P>



<H4><A NAME="Loose_index_scan" HREF="manual_toc.html#Loose_index_scan">7.2.11.1  Loose index scan</A></H4>

<P>
The most efficient way is when the index is used to directly retrieve
the group fields. With this access method, MySQL uses the property of
some index types (for example, B-Trees) that the keys are ordered. This
property allows use of lookup groups in an index without having to consider
all keys in the index that satisfy all <code>WHERE</code> conditions. Since
this access method considers only a fraction of the keys in an index,
it is called ``loose index scan.'' When there is no <code>WHERE</code> clause,
a loose index scan will read as many keys as the number of groups, which
may be a much smaller number than all keys. If the <code>WHERE</code> clause
contains range predicates (described in section <A HREF="manual_MySQL_Optimization.html#EXPLAIN">7.2.1  <code>EXPLAIN</code> Syntax (Get Information About a <code>SELECT</code>)</A>,
under the <code>range</code> join type), a loose index scan looks up the first key of
each group that satisfies the range conditions, and again reads the least
possible number of keys. This is possible under the following conditions:

</P>

<UL>

<LI>

The query is over a single table.

<LI>

The <code>GROUP BY</code> includes the first consecutive parts of the index
(if instead of <code>GROUP BY</code>, the query has a <code>DISTINCT</code> clause,
then all distinct attributes refer to the beginning of the index).

<LI>

The only aggregate functions used (if any) are <code>MIN()</code> and <code>MAX()</code>,
and all of them refer to the same column.

<LI>

Any other index parts than the ones from <code>GROUP BY</code> referenced in the
query must be constants (that is, they must be referenced in equalities
with constants), except for the argument of <code>MIN()</code> or <code>MAX()</code>
functions.

</UL>

<P>
The <code>EXPLAIN</code> output for such queries shows <code>Using index for
group-by</code> in the <code>Extra</code> column.

</P>
<P>
The following queries provide several examples that fall into this
category, assuming there is an index <code>idx(c1, c2, c3)</code> on table
<code>t1(c1,c2,c3,c4)</code>:

</P>

<PRE>
SELECT c1, c2 FROM t1 GROUP BY c1, c2;
SELECT DISTINCT c1, c2 FROM t1;
SELECT c1, MIN(c2) FROM t1 GROUP BY c1;
SELECT c1, c2 FROM t1 WHERE c1 &#60; <var>const</var> GROUP BY c1, c2;
SELECT MAX(c3), MIN(c3), c1, c2 FROM t1 WHERE c2 &#62; <var>const</var> GROUP BY c1, c2;
SELECT c2 FROM t1 WHERE c1 &#60; <var>const</var> GROUP BY c1, c2;
SELECT c1, c2 FROM t1 WHERE c3 = <var>const</var> GROUP BY c1, c2;
</PRE>

<P>
The following queries cannot be executed with this quick select method,
for the reasons given:

</P>

<UL>

<LI>

There are other aggregate function than <code>MIN()</code> or <code>MAX()</code>:


<PRE>
SELECT c1, SUM(c2) FROM t1 GROUP BY c1;
</PRE>

<LI>

The fields in <code>GROUP BY</code> do not refer to the beginning of the index:


<PRE>
SELECT c1,c2 FROM t1 GROUP BY c2, c3;
</PRE>

<LI>

The query refers to a key part that is after the <code>GROUP BY</code> parts,
and for which there is no equality with a constant:


<PRE>
SELECT c1,c3 FROM t1 GROUP BY c1, c2;
</PRE>

</UL>



<H4><A NAME="Tight_index_scan" HREF="manual_toc.html#Tight_index_scan">7.2.11.2  Tight index scan</A></H4>

<P>
A tight index scan may be either a full index scan or a range index scan,
depending on the query conditions.

</P>
<P>
When the conditions for a loose index scan are not met, it is still
possible to avoid creation of temporary tables for <code>GROUP BY</code>
queries. If there are range conditions in the <code>WHERE</code> clause, this
method will read only the keys that satisfy these conditions. Otherwise,
it performs an index scan. Since this method reads all keys in each range
defined by the <code>WHERE</code> clause, or scans the whole index if there are
no range conditions, we term it a ``tight index scan.'' Notice that with a
tight index scan, the grouping operation is performed after all keys that
satisfy the range conditions have been found.

</P>
<P>
For this method to work, it is sufficient that for all columns in a query
referring to key parts before or in between the <code>GROUP BY</code> key parts,
there is a constant equality condition. The constants from the equality
conditions fill in the ``gaps'' in the search keys so that it is possible
to form complete prefixes of the index. Then these index prefixes can
be used for index lookups. If we require sorting of the <code>GROUP BY</code>
result, and it is possible to form search keys that are prefixes of the
index, MySQL also will avoid sorting because searching with prefixes in
an ordered index already retrieves all keys in order.

</P>
<P>
The following queries will not work with the first method above, but will
still work with the second index access method (assuming we have the
aforementioned index <code>idx</code> on table <code>t1</code>):

</P>

<UL>

<LI>

There is a ``gap'' in <code>GROUP BY</code>, but it is covered by the condition (c2 = 'a').


<PRE>
SELECT c1, c2, c3 FROM t1 WHERE c2 = 'a' GROUP BY c1, c3;
</PRE>

<LI>

<code>GROUP BY</code> does not begin from the first key part, but there is a
condition that provides a constant for that key part:


<PRE>
SELECT c1, c2, c3 FROM t1 WHERE c1 = 'a' GROUP BY c2, c3;
</PRE>

</UL>



<H3><A NAME="LIMIT_optimization" HREF="manual_toc.html#LIMIT_optimization">7.2.12  How MySQL Optimizes <code>LIMIT</code></A></H3>

<P>
<A NAME="IDX730"></A>

</P>
<P>
<A NAME="IDX731"></A>

</P>
<P>
In some cases, MySQL will handle a query differently when you are
using <code>LIMIT <var>row_count</var></code> and not using <code>HAVING</code>:

</P>

<UL>
<LI>

If you are selecting only a few rows with <code>LIMIT</code>, MySQL
uses indexes in some cases when normally it would prefer to do a
full table scan.
<LI>

If you use <code>LIMIT <var>row_count</var></code> with <code>ORDER BY</code>, MySQL ends the
sorting as soon as it has found the first <var>row_count</var> lines rather
than sorting the whole table.
<LI>

When combining <code>LIMIT <var>row_count</var></code> with <code>DISTINCT</code>, MySQL stops
as soon as it finds <var>row_count</var> unique rows.
<LI>

In some cases, a <code>GROUP BY</code> can be resolved by reading the key in order
(or doing a sort on the key) and then calculating summaries until the
key value changes.  In this case, <code>LIMIT <var>row_count</var></code> will not calculate any
unnecessary <code>GROUP BY</code> values.
<LI>

As soon as MySQL has sent the required number of rows to the client, it
aborts the query unless you are using <code>SQL_CALC_FOUND_ROWS</code>.
<LI>

<code>LIMIT 0</code> always quickly returns an empty set.  This is useful
to check the query or to get the column types of the result columns.
<LI>

When the server uses temporary tables to resolve the query, the
<code>LIMIT <var>row_count</var></code> is used to calculate how much space is required.
</UL>



<H3><A NAME="How_to_avoid_table_scan" HREF="manual_toc.html#How_to_avoid_table_scan">7.2.13  How to Avoid Table Scans</A></H3>

<P>
<A NAME="IDX732"></A>

</P>
<P>
The output from <code>EXPLAIN</code> will show <code>ALL</code> in the <code>type</code>
column when MySQL uses a table scan to resolve a query. This usually happens
under the following conditions:

</P>

<UL>
<LI>

The table is so small that it's faster to do a table scan than a key lookup.
This is a common case for tables with fewer than 10 rows and a short row length.
<LI>

There are no usable restrictions in the <code>ON</code> or <code>WHERE</code> clause
for indexed columns.
<LI>

You are comparing indexed columns with constant values and MySQL has
calculated (based on the index tree) that the constants cover too large a
part of the table and that a table scan would be faster.
See section <A HREF="manual_MySQL_Optimization.html#Where_optimizations">7.2.4  How MySQL Optimizes <code>WHERE</code> Clauses</A>.
<LI>

You are using a key with low cardinality (many rows match the key value)
through another column.  In this case, MySQL assumes that by using the
key it will probably do a lot of key lookups and that a table scan
would be faster.
</UL>

<P>
For small tables, a table scan often is appropriate. For large tables, try
the following techniques to avoid having the optimizer incorrectly choose
a table scan:

</P>

<UL>
<LI>

Use <code>ANALYZE TABLE <var>tbl_name</var></code> to update the key distributions for the
scanned table.  See section <A HREF="manual_SQL_Syntax.html#ANALYZE_TABLE">13.5.2.1  <code>ANALYZE TABLE</code> Syntax</A>.

<LI>

Use <code>FORCE INDEX</code> for the scanned table to tell MySQL that table
scans are very expensive compared to using the given index.
See section <A HREF="manual_SQL_Syntax.html#SELECT">13.1.7  <code>SELECT</code> Syntax</A>.


<PRE>
SELECT * FROM t1, t2 FORCE INDEX (<var>index_for_column</var>)
WHERE t1.<var>col_name</var>=t2.<var>col_name</var>;
</PRE>

<LI>

Start <code>mysqld</code> with the <code>--max-seeks-for-key=1000</code> option or use
<code>SET max_seeks_for_key=1000</code> to tell the optimizer to assume that no
key scan will cause more than 1,000 key seeks.
See section <A HREF="manual_MySQL_Database_Administration.html#Server_system_variables">5.2.3  Server System Variables</A>.
</UL>



<H3><A NAME="Insert_speed" HREF="manual_toc.html#Insert_speed">7.2.14  Speed of <code>INSERT</code> Statements</A></H3>

<P>
<A NAME="IDX733"></A>

</P>
<P>
<A NAME="IDX734"></A>
<A NAME="IDX735"></A>

</P>
<P>
The time to insert a record is determined by the following factors,
where the numbers indicate approximate proportions:

</P>

<UL>
<LI>

Connecting:              (3)
<LI>

Sending query to server: (2)
<LI>

Parsing query:           (2)
<LI>

Inserting record:        (1 x size of record)
<LI>

Inserting indexes:       (1 x number of indexes)
<LI>

Closing:                 (1)
</UL>

<P>
This does not take into consideration the initial overhead to open tables,
which is done once for each concurrently running query.

</P>
<P>
The size of the table slows down the insertion of indexes by log N,
assuming B-tree indexes.

</P>
<P>
You can use the following methods to speed up inserts:

</P>

<UL>

<LI>

If you are inserting many rows from the same client at the same time, use
<code>INSERT</code> statements with multiple <code>VALUES</code> lists to insert several
rows at a time.  This is much faster (many times faster in some cases) than
using separate single-row <code>INSERT</code> statements.  If you are adding data
to a non-empty table, you may tune the <code>bulk_insert_buffer_size</code>
variable to make it even faster.
See section <A HREF="manual_MySQL_Database_Administration.html#Server_system_variables">5.2.3  Server System Variables</A>.

<LI>

If you are inserting a lot of rows from different clients, you can get
higher speed by using the <code>INSERT DELAYED</code> statement. See section <A HREF="manual_SQL_Syntax.html#INSERT">13.1.4  <code>INSERT</code> Syntax</A>.

<LI>

With <code>MyISAM</code> tables you can insert rows at the same time that
<code>SELECT</code> statements are running if there are no deleted rows in the
tables.

<LI>

When loading a table from a text file, use <code>LOAD DATA INFILE</code>. This
is usually 20 times faster than using a lot of <code>INSERT</code> statements.
See section <A HREF="manual_SQL_Syntax.html#LOAD_DATA">13.1.5  <code>LOAD DATA INFILE</code> Syntax</A>.

<LI>

With some extra work, it is possible to make <code>LOAD DATA INFILE</code> run even
faster when the table has many indexes. Use the following procedure:


<OL>

<LI>

Optionally create the table with <code>CREATE TABLE</code>.

<LI>

Execute a <code>FLUSH TABLES</code> statement or a <code>mysqladmin flush-tables</code>
command.

<LI>

Use <code>myisamchk --keys-used=0 -rq <var>/path/to/db/tbl_name</var>.</code> This will
remove all use of all indexes for the table.

<LI>

Insert data into the table with <code>LOAD DATA INFILE</code>. This will not
update any indexes and will therefore be very fast.

<LI>

If you are going to only read the table in the future, use <code>myisampack</code>
to make it smaller. See section <A HREF="manual_Storage_engines.html#Compressed_format">14.1.3.3  Compressed Table Characteristics</A>.

<LI>

Re-create the indexes with <code>myisamchk -r -q
<var>/path/to/db/tbl_name</var></code>. This will create the index tree in memory before
writing it to disk, which is much faster because it avoids lots of disk
seeks. The resulting index tree is also perfectly balanced.

<LI>

Execute a <code>FLUSH TABLES</code> statement or a <code>mysqladmin flush-tables</code>
command.

</OL>

Note that <code>LOAD DATA INFILE</code> also performs the preceding optimization
if you insert into an empty <code>MyISAM</code> table; the main difference is that you can let
<code>myisamchk</code> allocate much more temporary memory for the index creation
than you might want the server to allocate for index re-creation when it
executes the <code>LOAD DATA INFILE</code> statement.

As of MySQL 4.0, you can also use
<code>ALTER TABLE <var>tbl_name</var> DISABLE KEYS</code> instead of
<code>myisamchk --keys-used=0 -rq <var>/path/to/db/tbl_name</var></code> and
<code>ALTER TABLE <var>tbl_name</var> ENABLE KEYS</code> instead of
<code>myisamchk -r -q <var>/path/to/db/tbl_name</var></code>. This way you can also skip the
<code>FLUSH TABLES</code> steps.

<LI>

You can speed up <code>INSERT</code> operations that are done
with multiple statements by locking your tables:


<PRE>
LOCK TABLES a WRITE;
INSERT INTO a VALUES (1,23),(2,34),(4,33);
INSERT INTO a VALUES (8,26),(6,29);
UNLOCK TABLES;
</PRE>

A performance benefit occurs because the index buffer is flushed to disk only
once, after all <code>INSERT</code> statements have completed. Normally there would
be as many index buffer flushes as there are different <code>INSERT</code>
statements. Explicit locking statements are not needed if you can insert
all rows with a single statement.

For transactional tables, you should use <code>BEGIN/COMMIT</code> instead of
<code>LOCK TABLES</code> to get a speedup.

Locking also lowers the total time of multiple-connection tests, although the
maximum wait time for individual connections might go up because they wait for
locks.  For example:


<PRE>
Connection 1 does 1000 inserts
Connections 2, 3, and 4 do 1 insert
Connection 5 does 1000 inserts
</PRE>

If you don't use locking, connections 2, 3, and 4 will finish before 1 and
5. If you use locking, connections 2, 3, and 4 probably will not finish
before 1 or 5, but the total time should be about 40% faster.

<code>INSERT</code>, <code>UPDATE</code>, and <code>DELETE</code> operations are very
fast in MySQL, but you will obtain better overall performance by
adding locks around everything that does more than about five inserts or
updates in a row.  If you do very many inserts in a row, you could do a
<code>LOCK TABLES</code> followed by an <code>UNLOCK TABLES</code> once in a while
(about each 1,000 rows) to allow other threads access to the table. This
would still result in a nice performance gain.

<code>INSERT</code> is still much slower for loading data than <code>LOAD DATA
INFILE</code>, even when using the strategies just outlined.

<LI>

To get some more speed for <code>MyISAM</code> tables, for both <code>LOAD DATA
INFILE</code> and <code>INSERT</code>, enlarge the key cache by increasing the
<code>key_buffer_size</code> system variable.
See section <A HREF="manual_MySQL_Optimization.html#Server_parameters">7.5.2  Tuning Server Parameters</A>.

</UL>



<H3><A NAME="Update_speed" HREF="manual_toc.html#Update_speed">7.2.15  Speed of <code>UPDATE</code> Statements</A></H3>

<P>
Update statements are optimized as a <code>SELECT</code> query with the additional
overhead of a write. The speed of the write depends on the amount of
data being updated and the number of indexes that are updated.  Indexes that
are not changed will not be updated.

</P>
<P>
Also, another way to get fast updates is to delay updates and then do
many updates in a row later. Doing many updates in a row is much quicker
than doing one at a time if you lock the table.

</P>
<P>
Note that for a <code>MyISAM</code> table that uses dynamic record format,
updating a record to a longer total length may split the record.  If you do
this often, it is very important to use <code>OPTIMIZE TABLE</code> occasionally.
See section <A HREF="manual_SQL_Syntax.html#OPTIMIZE_TABLE">13.5.2.5  <code>OPTIMIZE TABLE</code> Syntax</A>.

</P>



<H3><A NAME="Delete_speed" HREF="manual_toc.html#Delete_speed">7.2.16  Speed of <code>DELETE</code> Statements</A></H3>

<P>
The time to delete individual records is exactly proportional to the number
of indexes. To delete records more quickly, you can increase the size of the
key cache.
See section <A HREF="manual_MySQL_Optimization.html#Server_parameters">7.5.2  Tuning Server Parameters</A>.

</P>
<P>
If you want to delete all rows in the table, use <code>TRUNCATE TABLE
tbl_name</code> rather than <code>DELETE FROM <var>tbl_name</var></code>.
See section <A HREF="manual_SQL_Syntax.html#TRUNCATE">13.1.9  <code>TRUNCATE</code> Syntax</A>.

</P>



<H3><A NAME="Tips" HREF="manual_toc.html#Tips">7.2.17  Other Optimization Tips</A></H3>

<P>
<A NAME="IDX736"></A>
<A NAME="IDX737"></A>

</P>
<P>
This section lists a number of miscellaneous tips for improving query
processing speed:

</P>

<UL>

<LI>

Use persistent connections to the database to avoid connection
overhead. If you can't use persistent connections and you are initiating many
new connections to the database, you may want to change the value
of the <code>thread_cache_size</code> variable. See section <A HREF="manual_MySQL_Optimization.html#Server_parameters">7.5.2  Tuning Server Parameters</A>.

<LI>

Always check whether all your queries really use the indexes you have created
in the tables. In MySQL, you can do this with the <code>EXPLAIN</code>
statement. See section <A HREF="manual_MySQL_Optimization.html#EXPLAIN">7.2.1  <code>EXPLAIN</code> Syntax (Get Information About a <code>SELECT</code>)</A>.

<LI>

Try to avoid complex <code>SELECT</code> queries on <code>MyISAM</code> tables that are
updated frequently, to avoid problems with table locking that occur
due to contention between readers and writers.

<LI>

With <code>MyISAM</code> tables that have no deleted rows, you can insert rows at
the end at the same time that another query is reading from the table.  If this
is important for you, you should consider using the table in ways that avoid
deleting rows. Another possibility is to run <code>OPTIMIZE TABLE</code> after you
have deleted a lot of rows.

<LI>

Use <code>ALTER TABLE ... ORDER BY <var>expr1</var>, <var>expr2</var>, ...</code> if you mostly
retrieve rows in <code><var>expr1</var>, <var>expr2</var>, ...</code> order.  By using this option after
extensive changes to the table, you may be able to get higher performance.

<LI>

In some cases, it may make sense to introduce a column that is ``hashed''
based on information from other columns. If this column is short and
reasonably unique, it may be much faster than a big index on many
columns. In MySQL, it's very easy to use this extra column:


<PRE>
SELECT * FROM <var>tbl_name</var>
    WHERE <var>hash_col</var>=MD5(CONCAT(<var>col1</var>,<var>col2</var>))
    AND <var>col1</var>='<var>constant</var>' AND <var>col2</var>='<var>constant</var>';
</PRE>

<LI>

For <code>MyISAM</code> tables that change a lot, you should try to avoid all
variable-length columns (<code>VARCHAR</code>, <code>BLOB</code>, and <code>TEXT</code>). The
table will use dynamic record format if it includes even a single
variable-length column.
See section <A HREF="manual_Storage_engines.html#Storage_engines">14  MySQL Storage Engines and Table Types</A>.

<LI>

It's normally not useful to split a table into different tables just
because the rows get ``big.'' To access a row, the biggest performance
hit is the disk seek to find the first byte of the row. After finding
the data, most modern disks can read the whole row fast enough for most
applications. The only cases where it really matters to split up a table is if
it's a <code>MyISAM</code> table with dynamic record format (see above) that you can
change to a fixed record size,
or if you very often need to scan the table but do not need
most of the columns. See section <A HREF="manual_Storage_engines.html#Storage_engines">14  MySQL Storage Engines and Table Types</A>.

<LI>

If you very often need to calculate results such as counts based on
information from a lot of rows, it's probably much
better to introduce a new table and update the counter in real time. An
update of the following form is very fast:


<PRE>
UPDATE <var>tbl_name</var> SET <var>count_col</var>=<var>count_col</var>+1 WHERE <var>key_col</var>=<var>constant</var>;
</PRE>

This is really important when you use MySQL storage engines such as
<code>MyISAM</code> and <code>ISAM</code> that have only table-level locking (multiple
readers / single writers). This will also give better performance with most
databases, because the row locking manager in this case will have less to do.

<LI>

If you need to collect statistics from large log tables, use summary tables
instead of scanning the entire log table. Maintaining the summaries should be
much faster than trying to calculate statistics ``live.'' It's much faster to
regenerate new summary tables from the logs when things change
(depending on business decisions) than to have to change the running
application!

<LI>

If possible, you should classify reports as ``live'' or ``statistical,''
where data needed for statistical reports is created only from summary
tables that are generated periodically from the live data.

<LI>

Take advantage of the fact that columns have default values. Insert
values explicitly only when the value to be inserted differs from the
default. This reduces the parsing that MySQL needs to do and
improves the insert speed.

<LI>

In some cases, it's convenient to pack and store data into a <code>BLOB</code>
column. In this case, you must add some extra code in your application to
pack and unpack information in the <code>BLOB</code> values, but this may save a
lot of accesses at some stage.  This is practical when you have data that
doesn't conform to a rows-and-columns table structure.

<LI>

Normally, you should try to keep all data non-redundant (what
is called "third normal form" in database theory). However, do not be
afraid to duplicate information or create summary tables if necessary
to gain more speed.

<LI>

Stored procedures or UDFs (user-defined functions) may be a good way to get
more performance for some tasks. However, if you use a database system that
does not support these capabilities, you should always have another way to
perform the same tasks, even if the alternative method is slower.

<LI>

You can always gain something by caching queries or answers in your
application and then performing many inserts or updates together.  If
your database supports table locks (like MySQL and Oracle),
this should help to ensure that the index cache is only flushed once
after all updates.

<LI>

Use <code>INSERT DELAYED</code> when you do not need to know when your
data is written. This speeds things up because many records can be written
with a single disk write.

<LI>

Use <code>INSERT LOW_PRIORITY</code> when you want to give <code>SELECT</code>
statements higher priority than your inserts.

<LI>

Use <code>SELECT HIGH_PRIORITY</code> to get retrievals that jump the
queue. That is, the <code>SELECT</code> is done even if there is another client
waiting to do a write.

<LI>

Use multiple-row <code>INSERT</code> statements to store many rows with one
SQL statement (many SQL servers support this).

<LI>

Use <code>LOAD DATA INFILE</code> to load large amounts of data. This is
faster than using <code>INSERT</code> statements.

<LI>

Use <code>AUTO_INCREMENT</code> columns to generate unique values.

<LI>

Use <code>OPTIMIZE TABLE</code> once in a while to avoid fragmentation
with <code>MyISAM</code> tables
when
using a dynamic table format.
See section <A HREF="manual_Storage_engines.html#MyISAM_table_formats">14.1.3  <code>MyISAM</code> Table Storage Formats</A>.

<LI>

Use <code>HEAP</code> tables when possible to get more speed.
See section <A HREF="manual_Storage_engines.html#Storage_engines">14  MySQL Storage Engines and Table Types</A>.

<LI>

When using a normal Web server setup, images should be stored as
files. That is, store only a file reference in the database.  The main
reason for this is that a normal Web server is much better at caching
files than database contents, so it's much easier to get a fast
system if you are using files.

<LI>

Use in-memory tables for non-critical data that is accessed often, such as
information about the last displayed banner for users who don't have
cookies enabled in their Web browser.

<LI>

Columns with identical information in different tables should be
declared to have identical data types. Before MySQL 3.23, you
get slow joins otherwise.

Try to keep column names simple. For example, in a table named <code>customer</code>,
use a column name of <code>name</code> instead of <code>customer_name</code>. To make
your names portable to other SQL servers, you should keep them shorter than
18 characters.

<LI>

If you need really high speed, you should take a look at the low-level
interfaces for data storage that the different SQL servers support!  For
example, by accessing the MySQL <code>MyISAM</code> storage engine directly, you could
get a speed increase of two to five times compared to using the SQL interface.
To be able to do this, the data must be on the same server as
the application, and usually it should only be accessed by one process
(because external file locking is really slow).  One could eliminate these
problems by introducing low-level <code>MyISAM</code> commands in the
MySQL server (this could be one easy way to get more
performance if needed).  By carefully designing the database interface,
it should be quite easy to support this types of optimization.

<LI>

If you are using numerical data, it's faster in many cases to access
information from a database (using a live connection) than to access a text
file. Information in the database is likely to be stored in a more compact
format than in the text file, so accessing it will involve fewer disk
accesses.  You will also save code in your application because you don't
have to parse your text files to find line and column boundaries.

<LI>

Replication can provide a performance benefit for some operations. You can
distribute client retrievals among replication servers to split up the load.
To avoid slowing down the master while making backups, you can make backups
using a slave server.
See section <A HREF="manual_Replication.html#Replication">6  Replication in MySQL</A>.

<LI>

Declaring a <code>MyISAM</code> table with the <code>DELAY_KEY_WRITE=1</code> table
option makes index updates faster because they are not flushed to disk
until the table is closed.  The downside is that if something kills the
server while such a table is open, you should ensure that they are okay by
running the server with the <code>--myisam-recover</code> option, or by
running <code>myisamchk</code> before restarting the server.  (However, even in
this case, you should not lose anything by using <code>DELAY_KEY_WRITE</code>,
because the key information can always be generated from the data rows.)

</UL>



<H2><A NAME="Locking_Issues" HREF="manual_toc.html#Locking_Issues">7.3  Locking Issues</A></H2>



<H3><A NAME="Internal_locking" HREF="manual_toc.html#Internal_locking">7.3.1  Locking Methods</A></H3>

<P>
<A NAME="IDX738"></A>
<A NAME="IDX739"></A>
<A NAME="IDX740"></A>
<A NAME="IDX741"></A>
<A NAME="IDX742"></A>
<A NAME="IDX743"></A>
<A NAME="IDX744"></A>
<A NAME="IDX745"></A>
<A NAME="IDX746"></A>

</P>
<P>
Currently, MySQL supports table-level locking for <code>ISAM</code>,
<code>MyISAM</code>, and <code>MEMORY</code> (<code>HEAP</code>) tables, page-level locking
for <code>BDB</code> tables, and row-level locking for <code>InnoDB</code> tables.

</P>
<P>
In many cases, you can make an educated guess about which locking type is best
for an application, but generally it's very hard to say that a given
lock type is better than another. Everything depends on the application
and different parts of an application may require different lock types.

</P>
<P>
To decide whether you want to use a storage engine with row-level locking,
you will want to look at what your application does and what mix of select
and update statements it uses.  For example, most Web applications do lots
of selects, very few deletes, updates based mainly on key values, and
inserts into some specific tables.  The base MySQL <code>MyISAM</code> setup is
very well tuned for this.

</P>
<P>
Table locking in MySQL is deadlock-free for storage engines that use
table-level locking.  Deadlock avoidance is managed by always requesting all
needed locks at once at the beginning of a query and always locking the
tables in the same order.

</P>
<P>
The table-locking method MySQL uses for <code>WRITE</code> locks works as follows:

</P>

<UL>

<LI>

If there are no locks on the table, put a write lock on it.

<LI>

Otherwise, put the lock request in the write lock queue.

</UL>

<P>
The table-locking method MySQL uses for <code>READ</code> locks works as follows:

</P>

<UL>

<LI>

If there are no write locks on the table, put a read lock on it.

<LI>

Otherwise, put the lock request in the read lock queue.

</UL>

<P>
When a lock is released, the lock is made available to the threads
in the write lock queue, then to the threads in the read lock queue.

</P>
<P>
This means that if you have many updates for a table, <code>SELECT</code>
statements will wait until there are no more updates.

</P>
<P>
Starting in MySQL 3.23.33, you can analyze the table lock contention
on your system by checking the <code>Table_locks_waited</code> and
<code>Table_locks_immediate</code> status variables:

</P>

<PRE>
mysql&#62; SHOW STATUS LIKE 'Table%';
+-----------------------+---------+
| Variable_name         | Value   |
+-----------------------+---------+
| Table_locks_immediate | 1151552 |
| Table_locks_waited    | 15324   |
+-----------------------+---------+
</PRE>

<P>
<A NAME="IDX747"></A>

</P>
<P>
As of MySQL 3.23.7 (3.23.25 for Windows), you can freely mix concurrent
<code>INSERT</code> and <code>SELECT</code> statements for a <code>MyISAM</code> table without
locks if the <code>INSERT</code> statements are non-conflicting.  That is, you can
insert rows into a <code>MyISAM</code> table at the same time other clients are
reading from it.  No conflict occurs if the data file contains no free
blocks in the middle, because in that case, records always are inserted at
the end of the data file.  (Holes can result from rows having been deleted
from or updated in the middle of the table.) If there are holes, concurrent
inserts are re-enabled automatically when all holes have been filled with
new data.

</P>
<P>
If you want to do many <code>INSERT</code> and <code>SELECT</code> operations on a table
when concurrent inserts are not possible, you can insert rows in a temporary
table and update the real table with the records from the temporary table
once in a while.  This can be done with the following code:

</P>

<PRE>
mysql&#62; LOCK TABLES real_table WRITE, insert_table WRITE;
mysql&#62; INSERT INTO real_table SELECT * FROM insert_table;
mysql&#62; TRUNCATE TABLE insert_table;
mysql&#62; UNLOCK TABLES;
</PRE>

<P>
<code>InnoDB</code> uses row locks and <code>BDB</code> uses page locks. For the
<code>InnoDB</code> and <code>BDB</code> storage engines, deadlock is possible. This is
because <code>InnoDB</code> automatically acquires row locks and <code>BDB</code>
acquires page locks during the processing of SQL statements, not at the
start of the transaction.

</P>
<P>
Advantages of row-level locking:

</P>

<UL>
<LI>

Fewer lock conflicts when accessing different rows in many threads.
<LI>

Fewer changes for rollbacks.
<LI>

Makes it possible to lock a single row a long time.
</UL>

<P>
Disadvantages of row-level locking:

</P>

<UL>
<LI>

Takes more memory than page-level or table-level locks.
<LI>

Is slower than page-level or table-level locks when used on a large part of
the table because you must acquire many more locks.
<LI>

Is definitely much worse than other locks if you often do <code>GROUP
BY</code> operations on a large part of the data or if you often must scan the
entire table.
<LI>

With higher-level locks, you can also more easily support locks of
different types to tune the application, because the lock overhead is less
than for row-level locks.
</UL>

<P>
Table locks are superior to page-level or row-level locks in the
following cases:

</P>

<UL>
<LI>

Most statements for the table are reads.
<LI>

Read and updates on strict keys, where you update or delete
a row that can be fetched with a single key read:


<PRE>
UPDATE <var>tbl_name</var> SET <var>column</var>=<var>value</var> WHERE <var>unique_key_col</var>=<var>key_value</var>;
DELETE FROM <var>tbl_name</var> WHERE <var>unique_key_col</var>=<var>key_value</var>;
</PRE>

<LI>

<code>SELECT</code> combined with concurrent <code>INSERT</code> statements, and very
few <code>UPDATE</code> and <code>DELETE</code> statements.
<LI>

Many scans or <code>GROUP BY</code> operations on the entire table without any writers.
</UL>

<P>
Options other than row-level or page-level locking:

</P>
<P>
Versioning (such as we use in MySQL for concurrent inserts) where
you can have one writer at the same time as many readers.  This means
that the database/table supports different views for the data depending
on when you started to access it. Other names for this are time travel,
copy on write, or copy on demand.

</P>
<P>
Copy on demand is in many cases much better than page-level or row-level
locking. However, the worst case does use much more memory than
when using normal locks.

</P>
<P>
Instead of using row-level locks, you can use application-level locks,
such as <code>GET_LOCK()</code> and <code>RELEASE_LOCK()</code> in MySQL. These are
advisory locks, so they work only in well-behaved applications.

</P>



<H3><A NAME="Table_locking" HREF="manual_toc.html#Table_locking">7.3.2  Table Locking Issues</A></H3>

<P>
<A NAME="IDX748"></A>

</P>
<P>
To achieve a very high lock speed, MySQL uses table locking (instead of
page, row, or column locking) for all storage engines except <code>InnoDB</code>
and <code>BDB</code>.

</P>
<P>
For <code>InnoDB</code> and <code>BDB</code> tables, MySQL only uses table locking if
you explicitly lock the table with <code>LOCK TABLES</code>.  For these table
types, we recommend you to not use <code>LOCK TABLES</code> at all, because
<code>InnoDB</code> uses automatic row-level locking and <code>BDB</code> uses
page-level locking to ensure transaction isolation.

</P>
<P>
For large tables, table locking is much better than row locking for most
applications, but there are some pitfalls.

</P>
<P>
Table locking enables many threads to read from a table at the same
time, but if a thread wants to write to a table, it must first get
exclusive access.  During the update, all other threads that want to
access this particular table must wait until the update is done.

</P>
<P>
Table updates normally are considered to be more important than table
retrievals, so they are given higher priority.  This should ensure that
updates to a table are not ``starved'' even if there is heavy <code>SELECT</code>
activity for the table.

</P>
<P>
Table locking causes problems in cases such as when
a thread is waiting because the disk is full and free space needs to become
available before the thread can proceed. In this case, all
threads that want to access the problem table will also be put in a waiting
state until more disk space is made available.

</P>
<P>
Table locking is also disadvantageous under the following scenario:

</P>

<UL>

<LI>

A client issues a <code>SELECT</code> that takes a long time to run.

<LI>

Another client then issues an <code>UPDATE</code> on the same table. This client
will wait until the <code>SELECT</code> is finished.

<LI>

Another client issues another <code>SELECT</code> statement on the same table.
Because
<code>UPDATE</code> has higher priority than <code>SELECT</code>, this <code>SELECT</code>
will wait for the <code>UPDATE</code> to finish.  It will also wait for the first
<code>SELECT</code> to finish!
</UL>

<P>
The following list describes some ways to avoid or reduce contention caused by
table locking:

</P>

<UL>
<LI>

Try to get the <code>SELECT</code> statements to run faster. You might have to
create some summary tables to do this.

<LI>

Start <code>mysqld</code> with <code>--low-priority-updates</code>.  This gives
all statements that update (modify) a table lower priority than <code>SELECT</code>
statements. In this case, the second <code>SELECT</code> statement in the preceding
scenario would execute before the <code>INSERT</code> statement, and would not need
to wait for the first <code>SELECT</code> to finish.

<LI>

You can specify that all updates issued in a specific connection should be done
with low priority by using the <code>SET LOW_PRIORITY_UPDATES=1</code> statement.
See section <A HREF="manual_SQL_Syntax.html#SET_OPTION">13.5.3  <code>SET</code> Syntax</A>.

<LI>

You can give a specific <code>INSERT</code>, <code>UPDATE</code>, or <code>DELETE</code>
statement lower priority with the <code>LOW_PRIORITY</code> attribute.

<LI>

You can give a specific <code>SELECT</code> statement higher priority with the
<code>HIGH_PRIORITY</code> attribute. See section <A HREF="manual_SQL_Syntax.html#SELECT">13.1.7  <code>SELECT</code> Syntax</A>.

<LI>

Starting from MySQL 3.23.7, you can start <code>mysqld</code> with a low value for
the <code>max_write_lock_count</code> system variable to force MySQL to
temporarily elevate the priority of all <code>SELECT</code> statements that are
waiting for a table after a specific number of inserts to the table occur.
This allows <code>READ</code> locks after a certain number of <code>WRITE</code> locks.

<LI>

If you have problems with <code>INSERT</code> combined with <code>SELECT</code>, switch
to using <code>MyISAM</code> tables, which support concurrent <code>SELECT</code> and
<code>INSERT</code> statements.

<LI>

If you mix inserts and deletes on the same table, <code>INSERT DELAYED</code>
may be of great help.
See section <A HREF="manual_SQL_Syntax.html#INSERT_DELAYED">13.1.4.2  <code>INSERT DELAYED</code> Syntax</A>.

<LI>

If you have problems with mixed <code>SELECT</code> and <code>DELETE</code> statements,
the <code>LIMIT</code> option to <code>DELETE</code> may help.
See section <A HREF="manual_SQL_Syntax.html#DELETE">13.1.1  <code>DELETE</code> Syntax</A>.

<LI>

Using <code>SQL_BUFFER_RESULT</code> with <code>SELECT</code> statements can help to
make the duration of table locks shorter.
See section <A HREF="manual_SQL_Syntax.html#SELECT">13.1.7  <code>SELECT</code> Syntax</A>.

<LI>

You could change the locking code in <tt>`mysys/thr_lock.c'</tt> to use a
single queue.  In this case, write locks and read locks would have the same
priority, which might help some applications.

</UL>

<P>
Here are some tips about table locking in MySQL:

</P>

<UL>

<LI>

Concurrent users are not a problem if you don't mix updates with selects
that need to examine many rows in the same table.

<LI>

You can use <code>LOCK TABLES</code> to speed up things (many updates within
a single lock is much faster than updates without locks).  Splitting
table contents into separate tables may also help.

<LI>

If you encounter speed problems with table locks in MySQL, you may be able
to improve performance by converting some of your tables to <code>InnoDB</code> or
<code>BDB</code> tables.
See section <A HREF="manual_InnoDB.html#InnoDB">15  The <code>InnoDB</code> Storage Engine</A>.
See section <A HREF="manual_Storage_engines.html#BDB_storage_engine">14.4  The <code>BDB</code> (<code>BerkeleyDB</code>) Storage Engine</A>.
</UL>



<H2><A NAME="Optimizing_Database_Structure" HREF="manual_toc.html#Optimizing_Database_Structure">7.4  Optimizing Database Structure</A></H2>



<H3><A NAME="Design" HREF="manual_toc.html#Design">7.4.1  Design Choices</A></H3>

<P>
<A NAME="IDX749"></A>
<A NAME="IDX750"></A>
<A NAME="IDX751"></A>

</P>
<P>
MySQL keeps row data and index data in separate files. Many (almost all)
other databases mix row and index data in the same file. We believe that the
MySQL choice is better for a very wide range of modern systems.

</P>
<P>
Another way to store the row data is to keep the information for each
column in a separate area (examples are SDBM and Focus). This will cause a
performance hit for every query that accesses more than one column. Because
this degenerates so quickly when more than one column is accessed,
we believe that this model is not good for general-purpose databases.

</P>
<P>
The more common case is that the index and data are stored together
(as in Oracle/Sybase, et al). In this case, you will find the row
information at the leaf page of the index. The good thing with this
layout is that it, in many cases, depending on how well the index is
cached, saves a disk read.  The bad things with this layout are:

</P>

<UL>
<LI>

Table scanning is much slower because you have to read through the indexes
to get at the data.
<LI>

You can't use only the index table to retrieve data for a query.
<LI>

You use more space because you must duplicate indexes from the nodes
(you can't store the row in the nodes).
<LI>

Deletes will degenerate the table over time (because indexes in nodes are
usually not updated on delete).
<LI>

It's harder to cache only the index data.
</UL>



<H3><A NAME="Data_size" HREF="manual_toc.html#Data_size">7.4.2  Make Your Data as Small as Possible</A></H3>

<P>
<A NAME="IDX752"></A>
<A NAME="IDX753"></A>
<A NAME="IDX754"></A>
<A NAME="IDX755"></A>
<A NAME="IDX756"></A>

</P>
<P>
One of the most basic optimizations is to design your tables to take as
little space on the disk as possible. This can give huge improvements
because disk reads are faster, and smaller tables normally require less main
memory while their contents are being actively processed during query
execution.  Indexing also is a lesser resource burden if done on smaller
columns.

</P>
<P>
MySQL supports a lot of different table types and row formats.  For each
table, you can decide which storage/index method to use.  Choosing the
right table format for your application may give you a big performance gain.
See section <A HREF="manual_Storage_engines.html#Storage_engines">14  MySQL Storage Engines and Table Types</A>.

</P>
<P>
You can get better performance on a table and minimize storage space
using the techniques listed here:

</P>

<UL>
<LI>

Use the most efficient (smallest) data types possible. MySQL has
many specialized types that save disk space and memory.

<LI>

Use the smaller integer types if possible to get smaller tables. For
example, <code>MEDIUMINT</code> is often better than <code>INT</code>.

<LI>

Declare columns to be <code>NOT NULL</code> if possible. It makes everything
faster and you save one bit per column. If you really need
<code>NULL</code> in your application, you should definitely use it. Just avoid
having it on all columns by default.

<LI>

For <code>MyISAM</code> tables, if you don't have any variable-length columns
(<code>VARCHAR</code>, <code>TEXT</code>, or <code>BLOB</code> columns), a fixed-size record
format is used. This is faster but unfortunately may waste some space.
See section <A HREF="manual_Storage_engines.html#MyISAM_table_formats">14.1.3  <code>MyISAM</code> Table Storage Formats</A>.
You can hint that you want to have fixed length rows even if you have
<code>VARCHAR</code> columns with the <code>CREATE</code> option
<code>ROW_FORMAT=fixed</code>.

<LI>

Starting with MySQL/InnoDB 5.0.3, <code>InnoDB</code> tables use a more
compact storage format.  In earlier versions of MySQL, InnoDB records
contain some redundant information, such as the number of columns and
the lengths of each column, even for fixed-size columns.  By default,
tables will be created in the compact format
(<code>ROW_FORMAT=COMPACT</code>).  If you wish to downgrade to older
versions of MySQL/InnoDB, you can request the old format with
<code>ROW_FORMAT=REDUNDANT</code>.

<LI>

The primary index of a table should be as short as possible. This makes
identification of each row easy and efficient.

<LI>

Create only the indexes that you really need. Indexes are good for
retrieval but bad when you need to store things fast. If you mostly
access a table by searching on a combination of columns, make an index
on them. The first index part should be the most used column. If you are
<em>always</em> using many columns, you should use the column with more
duplicates first to get better compression of the index.

<LI>

If it's very likely that a column has a unique prefix on the first number of
characters, it's better to index only this prefix. MySQL supports an index
on the leftmost part of a character column. Shorter indexes are faster not
only because they take less disk space, but also because they will give you
more hits in the index cache and thus fewer disk seeks.
See section <A HREF="manual_MySQL_Optimization.html#Server_parameters">7.5.2  Tuning Server Parameters</A>.

<LI>

In some circumstances, it can be beneficial to split into two a table that is
scanned very often. This is especially true if it is a dynamic
format table and it is possible to use a smaller static format table that
can be used to find the relevant rows when scanning the table.
</UL>



<H3><A NAME="Indexes" HREF="manual_toc.html#Indexes">7.4.3  Column Indexes</A></H3>

<P>
<A NAME="IDX757"></A>
<A NAME="IDX758"></A>
<A NAME="IDX759"></A>

</P>
<P>
All MySQL column types can be indexed.  Use of indexes on the
relevant columns is the best way to improve the performance of <code>SELECT</code>
operations.

</P>
<P>
The maximum number of indexes per table and the maximum index length is
defined per storage engine. See section <A HREF="manual_Storage_engines.html#Storage_engines">14  MySQL Storage Engines and Table Types</A>. All storage engines support at
least 16 indexes per table and a total index length of at least 256 bytes.
Most storage engines have higher limits.

</P>
<P>
With <code><var>col_name</var>(<var>length</var>)</code> syntax in an index specification,
you can create an index that uses only the first <var>length</var> characters of
a <code>CHAR</code> or <code>VARCHAR</code> column. Indexing only a prefix of column
values like this can make the index file much smaller.
See section <A HREF="manual_MySQL_Optimization.html#Indexes">7.4.3  Column Indexes</A>.

</P>
<P>
<A NAME="IDX760"></A>
<A NAME="IDX761"></A>
<A NAME="IDX762"></A>
<A NAME="IDX763"></A>
The <code>MyISAM</code> and (as of MySQL 4.0.14) <code>InnoDB</code> storage engines also
support indexing on <code>BLOB</code> and <code>TEXT</code> columns.  When indexing
a <code>BLOB</code> or <code>TEXT</code> column, you <em>must</em> specify a prefix
length for the index. For example:

</P>

<PRE>
CREATE TABLE test (blob_col BLOB, INDEX(blob_col(10)));
</PRE>

<P>
Prefixes can be up to 255 bytes long (or 1000 bytes for <code>MyISAM</code>
and <code>InnoDB</code> tables as of MySQL 4.1.2).  Note that prefix limits
are measured in bytes, whereas the prefix length in <code>CREATE TABLE</code>
statements is interpreted as number of characters.  Take this into account
when specifying a prefix length for a column that uses a multi-byte
character set.

</P>
<P>
As of MySQL 3.23.23, you can also create <code>FULLTEXT</code> indexes.
They are used for full-text searches. Only the <code>MyISAM</code> table type
supports <code>FULLTEXT</code> indexes and only for <code>CHAR</code>, <code>VARCHAR</code>,
and <code>TEXT</code> columns.  Indexing always happens over the entire column and
partial (prefix) indexing is not supported. See section <A HREF="manual_Functions.html#Fulltext_Search">12.6  Full-Text Search Functions</A> for
details.

</P>
<P>
As of MySQL 4.1.0, you can create indexes on spatial column types.
Currently, spatial types are supported only by the <code>MyISAM</code> storage
engine. Spatial indexes use R-trees.

</P>
<P>
The <code>MEMORY</code> (<code>HEAP</code>) storage engine uses hash indexes by default.
It also supports B-tree indexes as of MySQL 4.1.0.

</P>



<H3><A NAME="Multiple-column_indexes" HREF="manual_toc.html#Multiple-column_indexes">7.4.4  Multiple-Column Indexes</A></H3>

<P>
<A NAME="IDX764"></A>
<A NAME="IDX765"></A>
<A NAME="IDX766"></A>

</P>
<P>
MySQL can create indexes on multiple columns.  An index may consist of up to
15 columns. For certain column types, you can index a prefix of the column
(see section <A HREF="manual_MySQL_Optimization.html#Indexes">7.4.3  Column Indexes</A>).

</P>
<P>
A multiple-column index can be considered a sorted array containing values
that are created by concatenating the values of the indexed columns.

</P>
<P>
MySQL uses multiple-column indexes in such a way that queries are
fast when you specify a known quantity for the first column of the index in a
<code>WHERE</code> clause, even if you don't specify values for the other columns.

</P>
<P>
Suppose that a table has the following specification:

</P>

<PRE>
CREATE TABLE test (
    id INT NOT NULL,
    last_name CHAR(30) NOT NULL,
    first_name CHAR(30) NOT NULL,
    PRIMARY KEY (id),
    INDEX name (last_name,first_name));
</PRE>

<P>
The <code>name</code> index is an index over <code>last_name</code> and
<code>first_name</code>.  The index can be used for queries that specify
values in a known range for <code>last_name</code>, or for both <code>last_name</code>
and <code>first_name</code>.
Therefore, the <code>name</code> index will be used in the following queries:

</P>

<PRE>
SELECT * FROM test WHERE last_name='Widenius';

SELECT * FROM test
    WHERE last_name='Widenius' AND first_name='Michael';

SELECT * FROM test
    WHERE last_name='Widenius'
    AND (first_name='Michael' OR first_name='Monty');

SELECT * FROM test
    WHERE last_name='Widenius'
    AND first_name &#62;='M' AND first_name &#60; 'N';
</PRE>

<P>
However, the <code>name</code> index will <em>not</em> be used in the following
queries:

</P>

<PRE>
SELECT * FROM test WHERE first_name='Michael';

SELECT * FROM test
    WHERE last_name='Widenius' OR first_name='Michael';
</PRE>

<P>
The manner in which MySQL uses indexes to improve query performance is
discussed further in the next section.

</P>



<H3><A NAME="MySQL_indexes" HREF="manual_toc.html#MySQL_indexes">7.4.5  How MySQL Uses Indexes</A></H3>

<P>
<A NAME="IDX767"></A>

</P>
<P>
Indexes are used to find rows with specific column values
fast. Without an index, MySQL has to start with the first record
and then read through the whole table to find the relevant
rows. The larger the table, the more this costs. If the table has an index
for the columns in question, MySQL can quickly determine the position to
seek to in the middle of the data file without having to look at all the
data. If a table has 1,000 rows, this is at least 100 times faster than
reading sequentially. Note that if you need to access almost all 1,000
rows, it is faster to read sequentially, because that minimizes disk seeks.

</P>
<P>
Most MySQL indexes (<code>PRIMARY KEY</code>, <code>UNIQUE</code>, <code>INDEX</code>, and
<code>FULLTEXT</code>) are stored in B-trees. Exceptions are that indexes on
spatial column types use R-trees, and <code>MEMORY</code> (<code>HEAP</code>) tables
support hash indexes.

</P>
<P>
Strings are automatically prefix- and end-space compressed.
See section <A HREF="manual_SQL_Syntax.html#CREATE_INDEX">13.2.5  <code>CREATE INDEX</code> Syntax</A>.

</P>
<P>
In general, indexes are used as described in the following discussion.
Characteristics specific to hash indexes (as used in <code>MEMORY</code> tables)
are described at the end of this section.

</P>
<P>
Indexes are used for these operations:

</P>

<UL>

<LI>

To quickly find the rows that match a <code>WHERE</code> clause.

<LI>

To eliminate rows from consideration.  If there is a choice between multiple
indexes, MySQL normally uses the index that finds the smallest number of
rows.

<LI>

To retrieve rows from other tables when performing joins.

<LI>

To find the <code>MIN()</code> or <code>MAX()</code> value for a specific indexed column
<var>key_col</var>. This is optimized by a preprocessor that checks whether you are
using <code>WHERE <var>key_part_#</var> = <var>constant</var></code> on all key parts that occur before
<var>key_col</var> in the index.  In this case, MySQL will do a single key
lookup for each <code>MIN()</code> or <code>MAX()</code> expression and replace it
with a constant.  If all expressions are replaced with constants, the
query will return at once. For example:


<PRE>
SELECT MIN(<var>key_part2</var>),MAX(<var>key_part2</var>)
FROM <var>tbl_name</var> WHERE <var>key_part1</var>=10;
</PRE>

<LI>

To sort or group a table if the sorting or grouping is done on a leftmost
prefix of a usable key (for example, <code>ORDER BY <var>key_part1</var>,
<var>key_part2</var></code>).  If all key parts are followed by <code>DESC</code>, the key
is read in reverse order.
See section <A HREF="manual_MySQL_Optimization.html#ORDER_BY_optimization">7.2.10  How MySQL Optimizes <code>ORDER BY</code></A>.

<LI>

In some cases, a query can be optimized to retrieve values without
consulting the data rows. If a query uses only columns from a table that are
numeric and that form a leftmost prefix for some key, the selected values
may be retrieved from the index tree for greater speed:


<PRE>
SELECT <var>key_part3</var> FROM <var>tbl_name</var> WHERE <var>key_part1</var>=1
</PRE>

</UL>

<P>
Suppose that you issue the following <code>SELECT</code> statement:

</P>

<PRE>
mysql&#62; SELECT * FROM <var>tbl_name</var> WHERE col1=val1 AND col2=val2;
</PRE>

<P>
If a multiple-column index exists on <code>col1</code> and <code>col2</code>, the
appropriate rows can be fetched directly. If separate single-column
indexes exist on <code>col1</code> and <code>col2</code>, the optimizer tries to
find the most restrictive index by deciding which index will find fewer
rows and using that index to fetch the rows.

</P>
<P>
<A NAME="IDX768"></A>
<A NAME="IDX769"></A>
If the table has a multiple-column index, any leftmost prefix of the
index can be used by the optimizer to find rows. For example, if you
have a three-column index on <code>(col1, col2, col3)</code>, you have indexed
search capabilities on <code>(col1)</code>, <code>(col1, col2)</code>, and
<code>(col1, col2, col3)</code>.

</P>
<P>
MySQL can't use a partial index if the columns don't form a
leftmost prefix of the index.  Suppose that you have the <code>SELECT</code>
statements shown here:

</P>

<PRE>
SELECT * FROM <var>tbl_name</var> WHERE col1=val1;
SELECT * FROM <var>tbl_name</var> WHERE col2=val2;
SELECT * FROM <var>tbl_name</var> WHERE col2=val2 AND col3=val3;
</PRE>

<P>
If an index exists on <code>(col1, col2, col3)</code>, only the first of the preceding
queries uses the index. The second and third queries do involve
indexed columns, but <code>(col2)</code> and <code>(col2, col3)</code> are not
leftmost prefixes of <code>(col1, col2, col3)</code>.

</P>
<P>
<A NAME="IDX770"></A>
<A NAME="IDX771"></A>
<A NAME="IDX772"></A>
<A NAME="IDX773"></A>
A B-tree index can be used for column comparisons in expressions that use
the <code>=</code>, <code>&#62;</code>, <code>&#62;=</code>, <code>&#60;</code>, <code>&#60;=</code>, or <code>BETWEEN</code>
operators. The index also can be used for <code>LIKE</code> comparisons if the
argument to <code>LIKE</code> is a constant string that doesn't start with a
wildcard character.  For example, the following <code>SELECT</code> statements
use indexes:

</P>

<PRE>
SELECT * FROM <var>tbl_name</var> WHERE <var>key_col</var> LIKE 'Patrick%';
SELECT * FROM <var>tbl_name</var> WHERE <var>key_col</var> LIKE 'Pat%_ck%';
</PRE>

<P>
In the first statement, only rows with <code>'Patrick' &#60;= <var>key_col</var> &#60;
'Patricl'</code> are considered.  In the second statement, only rows with
<code>'Pat' &#60;= <var>key_col</var> &#60; 'Pau'</code> are considered.

</P>
<P>
The following <code>SELECT</code> statements will not use indexes:

<PRE>
SELECT * FROM <var>tbl_name</var> WHERE <var>key_col</var> LIKE '%Patrick%';
SELECT * FROM <var>tbl_name</var> WHERE <var>key_col</var> LIKE <var>other_col</var>;
</PRE>

<P>
In the first statement, the <code>LIKE</code> value begins with a wildcard
character.  In the second statement, the <code>LIKE</code> value is not a
constant.

</P>
<P>
MySQL 4.0 and up performs an additional <code>LIKE</code> optimization.  If you use
<code>... LIKE '%<var>string</var>%'</code> and <var>string</var> is longer than three characters,
MySQL will use the <code>Turbo Boyer-Moore</code> algorithm to initialize the
pattern for the string and then use this pattern to perform the search
quicker.

</P>
<P>
<A NAME="IDX774"></A>
<A NAME="IDX775"></A>
Searching using <code><var>col_name</var> IS NULL</code> will use indexes if <var>col_name</var>
is indexed.

</P>
<P>
Any index that doesn't span all <code>AND</code> levels in the <code>WHERE</code> clause
is not used to optimize the query. In other words, to be able to use an
index, a prefix of the index must be used in every <code>AND</code> group.

</P>
<P>
The following <code>WHERE</code> clauses use indexes:

<PRE>
... WHERE <var>index_part1</var>=1 AND <var>index_part2</var>=2 AND <var>other_column</var>=3
    /* <var>index</var> = 1 OR <var>index</var> = 2 */
... WHERE <var>index</var>=1 OR A=10 AND <var>index</var>=2
    /* optimized like "<var>index_part1</var>='hello'" */
... WHERE <var>index_part1</var>='hello' AND <var>index_part3</var>=5
    /* Can use index on <var>index1</var> but not on <var>index2</var> or <var>index3</var> */
... WHERE <var>index1</var>=1 AND <var>index2</var>=2 OR <var>index1</var>=3 AND <var>index3</var>=3;
</PRE>

<P>
These <code>WHERE</code> clauses do <em>not</em> use indexes:

</P>


<PRE>
    /* <var>index_part1</var> is not used */
... WHERE <var>index_part2</var>=1 AND <var>index_part3</var>=2 
    /* Index is not used in both AND parts */
... WHERE <var>index</var>=1 OR A=10                 
    /* No index spans all rows  */
... WHERE <var>index_part1</var>=1 OR <var>index_part2</var>=10
</PRE>

<P>
Sometimes MySQL will not use an index, even if one is available.  One way
this occurs is when the optimizer estimates that using the index would
require MySQL to access a large percentage of the rows in the table.
(In this case, a table scan is probably much faster, because it will
require many fewer seeks.) However, if such a query uses <code>LIMIT</code> to
only retrieve part of the rows, MySQL will use an index anyway, because
it can much more quickly find the few rows to return in the result.

</P>
<P>
Hash indexes have somewhat different characteristics than those just
discussed:

</P>

<UL>

<LI>

They are used only for equality comparisons that use the <code>=</code> or
<code>&#60;=&#62;</code> operators (but are <em>very</em> fast).  They are not used for
comparison operators such as <code>&#60;</code> that find a range of values.

<LI>

The optimizer cannot use a hash index to speed up <code>ORDER BY</code>
operations. (This type of index cannot be used to search for the next entry
in order.)

<LI>

MySQL cannot determine approximately how many rows there
are between two values (this is used by the range optimizer to decide which
index to use).  This may affect some queries if you change a <code>MyISAM</code>
table to a hash-indexed <code>MEMORY</code> table.

<LI>

Only whole keys can be used to search for a row. (With a B-tree index,
any leftmost prefix of the key can be used to find rows.)

</UL>



<H3><A NAME="MyISAM_key_cache" HREF="manual_toc.html#MyISAM_key_cache">7.4.6  The <code>MyISAM</code> Key Cache</A></H3>

<P>
<A NAME="IDX776"></A>
<A NAME="IDX777"></A>

</P>

<P>
To minimize disk I/O, the <code>MyISAM</code> storage engine employs a strategy that
is used by many database management systems. It exploits a cache
mechanism to keep the most frequently accessed table blocks in memory:

</P>

<UL>
<LI>

For index blocks, a special structure called the key cache (key buffer)
is maintained. The structure contains a number of block buffers where the
most-used index blocks are placed.

<LI>

For data blocks, MySQL uses no special cache. Instead it relies on the
native operating system filesystem cache.

</UL>

<P>
This section first describes the basic operation of the <code>MyISAM</code> key
cache. Then it discusses changes made in MySQL 4.1 that improve key cache
performance and that enable you to better control cache operation:

</P>

<UL>
<LI>

Access to the key cache no longer is serialized among threads. Multiple
threads can access the cache concurrently.

<LI>

You can set up multiple key caches and assign table indexes to specific
caches.

</UL>

<P>
The key cache mechanism also is used for <code>ISAM</code> tables.  However, the
significance of this fact is on the wane.  <code>ISAM</code> table use has been
decreasing since MySQL 3.23 when <code>MyISAM</code> was introduced. MySQL 4.1
carries this trend further; the <code>ISAM</code> storage engine is disabled by
default.

</P>
<P>
You can control the size of the key cache by means of the
<code>key_buffer_size</code> system variable.  If this variable is set equal
to zero, no key cache is used.  The key cache also is not used if the
<code>key_buffer_size</code> value is too small to allocate the minimal number
of block buffers (8).

</P>
<P>
When the key cache is not operational, index files are accessed using only
the native filesystem buffering provided by the operating system.  (In other
words, table index blocks are accessed using the same strategy as that
employed for table data blocks.)

</P>
<P>
An index block is a contiguous unit of access to the <code>MyISAM</code> index files.
Usually the size of an index block is equal to the size of nodes of the
index B-tree. (Indexes are represented on disk using a B-tree data structure.
Nodes at the bottom of the tree are leaf nodes. Nodes above the leaf nodes
are non-leaf nodes.)

</P>
<P>
All block buffers in a key cache structure are the same size. This size can
be equal to, greater than, or less than the size of a table index block.
Usually one these two values is a multiple of the other.

</P>
<P>
When data from any table index block must be accessed, the server first
checks whether it is available in some block buffer of the key cache. If
it is, the server accesses data in the key cache rather than on disk.
That is, it reads from the cache or writes into it rather than reading
from or writing to disk. Otherwise, the server chooses a cache block
buffer containing a different table index block (or blocks) and replaces
the data there by a copy of required table index block.  As soon as the
new index block is in the cache, the index data can be accessed.

</P>
<P>
If it happens that a block selected for replacement has been modified,
the block is considered ``dirty.'' In this case, before being replaced, its
contents are flushed to the table index from which it came.

</P>
<P>
Usually the server follows an LRU (Least Recently Used) strategy: When
choosing a block for replacement, it selects the least recently used index
block. To be able to make such a choice easy, the key cache module maintains
a special queue (LRU chain) of all used blocks.  When a block is accessed,
it is placed at the end of the queue.  When blocks need to be replaced,
blocks at the beginning of the queue are the least recently used and become
the first candidates for eviction.

</P>



<H4><A NAME="Shared_key_cache" HREF="manual_toc.html#Shared_key_cache">7.4.6.1  Shared Key Cache Access</A></H4>

<P>
Prior to MySQL 4.1, access to the key cache is serialized:
No two threads can access key cache buffers simultaneously.
The server processes a request for an index block only after it has
finished processing the previous request. As a result, a request for an
index block not present in any key cache buffer blocks access by other
threads while a buffer is being updated to contain the requested index block.

</P>
<P>
Starting from version 4.1.0, the server supports shared access to the key
cache:

</P>

<UL>
<LI>

A buffer that is not being updated can be accessed by multiple threads.

<LI>

A buffer that is being updated causes threads that need to use it to wait
until the update is complete.

<LI>

Multiple threads can initiate requests that result in cache block
replacements, as long as they do not interfere with each other (that is,
as long as they need different index blocks, and thus cause different
cache blocks to be replaced).

</UL>

<P>
Shared access to the key cache allows the server to improve throughput
significantly.

</P>



<H4><A NAME="Multiple_key_caches" HREF="manual_toc.html#Multiple_key_caches">7.4.6.2  Multiple Key Caches</A></H4>

<P>
Shared access to the key cache improves performance but does not eliminate
contention among threads entirely. They still compete for control structures
that manage access to the key cache buffers. To reduce key cache access
contention further, MySQL 4.1.1 offers the feature of multiple key caches.
This allows you to assign different table indexes to different key caches.

</P>
<P>
When there can be multiple key caches, the server must know which cache to
use when processing queries for a given <code>MyISAM</code> table. By default, all
<code>MyISAM</code> table indexes are cached in the default key cache. To assign
table indexes to a specific key cache, use the <code>CACHE INDEX</code> statement.

</P>
<P>
For example, the following statement assigns indexes from the tables
<code>t1</code>, <code>t2</code>, and <code>t3</code> to the key cache named <code>hot_cache</code>:

</P>

<PRE>
mysql&#62; CACHE INDEX t1, t2, t3 IN hot_cache;
+---------+--------------------+----------+----------+
| Table   | Op                 | Msg_type | Msg_text |
+---------+--------------------+----------+----------+
| test.t1 | assign_to_keycache | status   | OK       |
| test.t2 | assign_to_keycache | status   | OK       |
| test.t3 | assign_to_keycache | status   | OK       |
+---------+--------------------+----------+----------+
</PRE>

<P>
<strong>Note</strong>: If the server has been built with the <code>ISAM</code> storage
engine enabled, <code>ISAM</code> tables use the key cache mechanism. However,
<code>ISAM</code> indexes use only the default key cache and cannot be reassigned to
a different cache.

</P>
<P>
The key cache referred to in a <code>CACHE INDEX</code> statement can be created
by setting its size with a <code>SET GLOBAL</code> parameter setting statement or by
using server startup options.  For example:

</P>

<PRE>
mysql&#62; SET GLOBAL keycache1.key_buffer_size=128*1024;
</PRE>

<P>
To destroy a key cache, set its size to zero:

</P>

<PRE>
mysql&#62; SET GLOBAL keycache1.key_buffer_size=0;
</PRE>

<P>
Key cache variables are structured system variables that have a name and
components. For <code>keycache1.key_buffer_size</code>, <code>keycache1</code> is the
cache variable name and <code>key_buffer_size</code> is the cache component.
See section <A HREF="manual_Language_Structure.html#Structured_System_Variables">9.4.1  Structured System Variables</A> for a description of the syntax used
for referring to structured key cache system variables.

</P>
<P>
By default, table indexes are assigned to the main (default) key cache
created at the server startup. When a key cache is destroyed, all indexes
assigned to it are reassigned to the default key cache.

</P>
<P>
For a busy server, we recommend a strategy that uses three key caches:

</P>

<UL>

<LI>

A hot key cache that takes up 20% of the space allocated for all key
caches. This is used for tables that are heavily used for searches but that
are not updated.

<LI>

A cold key cache that takes up 20% of the space allocated for all key
caches.  This is used for medium-sized intensively modified tables,
such as temporary tables.

<LI>

A warm key cache that takes up 60% of the key cache space.  This is the
default key cache, to be used by default for all other tables.

</UL>

<P>
One reason the use of three key caches is beneficial is that access to one
key cache structure does not block access to the others.  Queries that
access tables assigned to one cache do not compete with queries that
access tables assigned to another cache.  Performance gains occur for
other reasons as well:

</P>

<UL>

<LI>

The hot cache is used only for retrieval queries, so its contents are
never modified.  Consequently, whenever an index block needs to be pulled
in from disk, the contents of the cache block chosen for replacement need
not be flushed first.

<LI>

For an index assigned to the hot cache, if there are no queries
requiring an index scan, there is a high probability that the index
blocks corresponding to non-leaf nodes of the index B-tree will remain
in the cache.

<LI>

An update operation most frequently executed for temporary tables is
performed much faster when the updated node already is in the cache and need
not be read in from disk first. If the size of the indexes of the temporary
tables are comparable with the size of cold key cache, the probability is
very high that the updated node already will be in the cache.

</UL>

<P>
<code>CACHE INDEX</code> sets up an association between a table and a key cache,
but the association is lost each time the server restarts.  If you want the
association to take effect each time the server starts, one way to accomplish
this is to use an option file:  Include variable settings that configure
your key caches, and an <code>init-file</code> option that names a file containing
<code>CACHE INDEX</code> statements to be executed.  For example:

</P>

<PRE>
key_buffer_size = 4G
hot_cache.key_buffer_size = 2G
cold_cache.key_buffer_size = 2G
init_file=/path/to/data-directory/mysqld_init.sql
</PRE>

<P>
The statements in <tt>`mysqld_init.sql'</tt> will be executed each time the
server starts. It should contain one SQL statement per line.  The following
example assigns several tables each to <code>hot_cache</code> and <code>cold_cache</code>:

</P>

<PRE>
CACHE INDEX a.t1, a.t2, b.t3 IN hot_cache
CACHE INDEX a.t4, b.t5, b.t6 IN cold_cache
</PRE>



<H4><A NAME="Midpoint_insertion" HREF="manual_toc.html#Midpoint_insertion">7.4.6.3  Midpoint Insertion Strategy</A></H4>

<P>
By default, the key cache management system of MySQL 4.1 uses the LRU
strategy for choosing key cache blocks to be evicted, but it also supports a
more sophisticated method called the "midpoint insertion strategy."

</P>
<P>
When using the midpoint insertion strategy, the LRU chain is divided into
two parts: a hot sub-chain and a warm sub-chain. The division point between
two parts is not fixed, but the key cache management system takes care that
the warm part is not ``too short,'' always containing at least
<code>key_cache_division_limit</code> percent of the key cache blocks.
<code>key_cache_division_limit</code> is a component of structured key cache
variables, so its value is a parameter that can be set per cache.

</P>
<P>
When an index block is read from a table into the key cache, it is placed
at the end of the warm sub-chain. After a certain number of hits (accesses
of the block), it is promoted to the hot sub-chain.  At present, the number
of hits required to promote a block (3) is the same for all index blocks.
In the future, we will allow the hit count to depend on the B-tree level
of the node corresponding to an index block: Fewer hits will be required
for promotion of an index block if it contains a non-leaf node from the
upper levels of the index B-tree than if it contains a leaf node.

</P>
<P>
A block promoted into the hot sub-chain is placed at the end of the chain.
The block then circulates within this sub-chain. If the block stays at the
beginning of the sub-chain for a long enough time, it is demoted to the warm
chain. This time is determined by the value of the
<code>key_cache_age_threshold</code> component of the key cache.

</P>
<P>
The threshold value prescribes that, for a key cache containing <var>N</var>
blocks, the block at the beginning of the hot sub-chain not accessed within
the last <code><var>N</var>*key_cache_age_threshold/100</code> hits is to be moved to the
beginning of the warm sub-chain. It then becomes the first candidate for
eviction, because blocks for replacement always are taken from the beginning
of the warm sub-chain.

</P>
<P>
The midpoint insertion strategy allows you to keep more-valued blocks
always in the cache. If you prefer to use the plain LRU strategy, leave the
<code>key_cache_division_limit</code> value set to its default of 100.

</P>
<P>
The midpoint insertion strategy helps to improve performance when execution
of a query that requires an index scan effectively pushes out of the cache
all the index blocks corresponding to valuable high-level B-tree nodes. To
avoid this, you must use a midpoint insertion strategy with the
<code>key_cache_division_limit</code> set to much less than 100.  Then valuable
frequently hit nodes will be preserved in the hot sub-chain during an index
scan operation as well.

</P>



<H4><A NAME="Index_preloading" HREF="manual_toc.html#Index_preloading">7.4.6.4  Index Preloading</A></H4>

<P>
If there are enough blocks in a key cache to hold blocks of an entire
index, or at least the blocks corresponding to its non-leaf nodes, then
it makes sense to preload the key cache with index blocks before starting
to use it. Preloading allows you to put the table index blocks into a key
cache buffer in the most efficient way: by reading the index blocks from
disk sequentially.

</P>
<P>
Without preloading, the blocks still will be placed into the key cache as
needed by queries. Although the blocks will stay
in the cache, because there are enough buffers for all of them, they will be
fetched from disk in a random order, not sequentially.

</P>
<P>
To preload an index into a cache, use the <code>LOAD INDEX INTO CACHE</code>
statement. For example,
the following statement preloads nodes (index blocks) of indexes of the
tables <code>t1</code> and <code>t2</code>:

</P>

<PRE>
mysql&#62; LOAD INDEX INTO CACHE t1, t2 IGNORE LEAVES;
+---------+--------------+----------+----------+
| Table   | Op           | Msg_type | Msg_text |
+---------+--------------+----------+----------+
| test.t1 | preload_keys | status   | OK       |
| test.t2 | preload_keys | status   | OK       |
+---------+--------------+----------+----------+
</PRE>

<P>
The <code>IGNORE LEAVES</code> modifier causes only blocks for the non-leaf
nodes of the index to be preloaded. Thus,
the statement shown preloads all index blocks from <code>t1</code>, but only
blocks for the non-leaf nodes from <code>t2</code>.

</P>
<P>
If an index has been assigned to a key cache using a
<code>CACHE INDEX</code> statement, preloading places index blocks into that cache.
Otherwise, the index is loaded into the default key cache.

</P>



<H4><A NAME="Key_cache_block_size" HREF="manual_toc.html#Key_cache_block_size">7.4.6.5  Key Cache Block Size</A></H4>

<P>
MySQL 4.1 introduces a new <code>key_cache_block_size</code> variable on
a per-key cache basis. This variable specifies the size of the block
buffers for a key cache.  It is intended to allow tuning of the performance
of I/O operations for index files.

</P>
<P>
The best performance for I/O operations is achieved when the size of
read buffers is equal to the size of the native operating system I/O
buffers. But setting the size of key nodes equal to the size of the I/O buffer
does not always ensure the best overall performance. When reading the
big leaf nodes, the server pulls in a lot of unnecessary data, effectively
preventing reading other leaf nodes.

</P>
<P>
Currently, you cannot control the size of the index blocks in a table.  This
size is set by the server when the <tt>`.MYI'</tt> index file is created,
depending on the size of the keys in the indexes present in the table
definition.  In most cases, it is set equal to the I/O buffer size. In the
future, this will be changed and then <code>key_cache_block_size</code> variable
will be fully employed.

</P>



<H4><A NAME="Key_cache_restructuring" HREF="manual_toc.html#Key_cache_restructuring">7.4.6.6  Restructuring a Key Cache</A></H4>

<P>
A key cache can be restructured at any time by updating its parameter
values.  For example:

</P>

<PRE>
mysql&#62; SET GLOBAL cold_cache.key_buffer_size=4*1024*1024;
</PRE>

<P>
If you assign to either the <code>key_buffer_size</code> or
<code>key_cache_block_size</code> key cache component a value that differs from
the component's current value, the server destroys the cache's old
structure and creates a new one based on the new values.  If the cache
contains any dirty blocks, the server saves them to disk before destroying
and re-creating the cache. Restructuring does not occur if you set other key
cache parameters.

</P>
<P>
When restructuring a key cache, the server first flushes the contents of any
dirty buffers to disk. After that, the cache contents become unavailable.
However, restructuring does not block queries that need to use indexes
assigned to the cache.  Instead, the server directly accesses the table
indexes using native filesystem caching.  Filesystem caching is not as
efficient as using a key cache, so although queries will execute, a slowdown
can be anticipated.  Once the cache has been restructured, it becomes
available again for caching indexes assigned to it, and the use of filesystem
caching for the indexes ceases.

</P>



<H3><A NAME="Open_tables" HREF="manual_toc.html#Open_tables">7.4.7  How MySQL Counts Open Tables</A></H3>

<P>
<A NAME="IDX778"></A>
<A NAME="IDX779"></A>

</P>
<P>
When you execute a <code>mysqladmin status</code> command, you'll see something
like this:

</P>

<PRE>
Uptime: 426 Running threads: 1 Questions: 11082
Reloads: 1 Open tables: 12
</PRE>

<P>
The <code>Open tables</code> value of 12 can be somewhat puzzling if you have
only six tables.

</P>
<P>
MySQL is multi-threaded, so there may be many clients issuing queries for a
given table simultaneously. To minimize the problem with multiple client threads
having different states on the same table, the table is opened independently
by each concurrent thread. This takes some memory but normally increases
performance.  With <code>MyISAM</code> tables, one extra file descriptor is
required for the data file for each client that has the table open. (By
contrast, the index file descriptor is shared between all threads.) The
<code>ISAM</code> storage engine shares this behavior.

</P>
<P>
You can read more about this topic in the next section. See section <A HREF="manual_MySQL_Optimization.html#Table_cache">7.4.8  How MySQL Opens and Closes Tables</A>.

</P>


<H3><A NAME="Table_cache" HREF="manual_toc.html#Table_cache">7.4.8  How MySQL Opens and Closes Tables</A></H3>

<P>
<A NAME="IDX780"></A>

</P>
<P>
<A NAME="IDX781"></A>
<A NAME="IDX782"></A>
<A NAME="IDX783"></A>
<A NAME="IDX784"></A>
<A NAME="IDX785"></A>

</P>
<P>
The <code>table_cache</code>, <code>max_connections</code>, and <code>max_tmp_tables</code>
system variables affect the maximum number of files the server keeps open.
If you increase one or more of these values, you may run up against a limit
imposed by your operating system on the per-process number of open file
descriptors.  Many operating systems allow you to increase the open-files
limit, although the method varies widely from system to system.  Consult your
operating system documentation to determine whether it is possible to
increase the limit and how to do so.

</P>
<P>
<code>table_cache</code> is related to <code>max_connections</code>.  For example,
for 200 concurrent running connections, you should have a table cache size of
at least <code>200 * <var>N</var></code>, where <var>N</var> is the maximum number of tables
in a join.  You also need to reserve some extra file descriptors for
temporary tables and files.

</P>
<P>
Make sure that your operating system can handle the number of open file
descriptors implied by the <code>table_cache</code> setting.  If
<code>table_cache</code> is set too high, MySQL may run out of file
descriptors and refuse connections, fail to perform queries, and be very
unreliable.  You also have to take into account that the <code>MyISAM</code> storage
engine needs two file descriptors for each unique open table. You can
increase the number of file descriptors available for MySQL with
the <code>--open-files-limit</code> startup option to <code>mysqld_safe</code>.
See section <A HREF="manual_Problems.html#Not_enough_file_handles">A.2.17  File Not Found</A>.

</P>
<P>
The cache of open tables will be kept at a level of <code>table_cache</code>
entries. The default value is 64; this can be changed with the
<code>--table_cache</code> option to <code>mysqld</code>.  Note that MySQL may
temporarily open even more tables to be able to execute queries.

</P>
<P>
An unused table is closed and removed from the table cache under the
following circumstances:

</P>

<UL>
<LI>

When the cache is full and a thread tries to open a table that is not in
the cache.
<LI>

When the cache contains more than <code>table_cache</code> entries and
a thread is no longer using a table.
<LI>

When a table flushing operation occurs. This happens when someone issues a
<code>FLUSH TABLES</code> statement or executes a <code>mysqladmin flush-tables</code>
or <code>mysqladmin refresh</code> command.
</UL>

<P>
When the table cache fills up, the server uses the following procedure
to locate a cache entry to use:

</P>

<UL>
<LI>

Tables that are not currently in use are released, in least recently used
order.

<LI>

If a new table needs to be opened, but the cache is full and no tables
can be released, the cache is temporarily extended as necessary.
</UL>

<P>
When the cache is in a temporarily extended state and a table goes from a used
to unused state, the table is closed and released from the cache.

</P>

<P>
A table is opened for each concurrent access. This means the table needs
to be opened twice if two threads access the same table or if a thread
accesses the table twice in the same query (for example, by joining the
table to itself).  Each concurrent open requires an entry in the table
cache. The first open of any table takes two file descriptors: one for the
data file and one for the index file.  Each additional use of the table
takes only one file descriptor, for the data file.  The index file
descriptor is shared among all threads.

</P>
<P>
If you are opening a table with the <code>HANDLER <var>tbl_name</var> OPEN</code>
statement, a dedicated table object is allocated for the thread.
This table object is not shared by other threads and is not closed
until the thread calls <code>HANDLER <var>tbl_name</var> CLOSE</code> or the thread
terminates.  When this happens, the table is put back in the table cache
(if the cache isn't full).
See section <A HREF="manual_SQL_Syntax.html#HANDLER">13.1.3  <code>HANDLER</code> Syntax</A>.

</P>
<P>
You can determine whether your table cache is too small by checking the
<code>mysqld</code> status variable <code>Opened_tables</code>:

</P>

<PRE>
mysql&#62; SHOW STATUS LIKE 'Opened_tables';
+---------------+-------+
| Variable_name | Value |
+---------------+-------+
| Opened_tables | 2741  |
+---------------+-------+
</PRE>

<P>
If the value is quite big, even when you haven't issued a lot of <code>FLUSH
TABLES</code> statements, you should increase your table cache size.
See section <A HREF="manual_MySQL_Database_Administration.html#Server_system_variables">5.2.3  Server System Variables</A> and section <A HREF="manual_MySQL_Database_Administration.html#Server_status_variables">5.2.4  Server Status Variables</A>.

</P>



<H3><A NAME="Creating_many_tables" HREF="manual_toc.html#Creating_many_tables">7.4.9  Drawbacks to Creating Many Tables in the Same Database</A></H3>

<P>
<A NAME="IDX786"></A>

</P>
<P>
If you have many <code>MyISAM</code> or <code>ISAM</code> tables in a database
directory, open, close, and create operations will be slow.  If you execute
<code>SELECT</code> statements on many different tables, there will be a little
overhead when the table cache is full, because for every table that has to
be opened, another must be closed. You can reduce this overhead by making
the table cache larger.

</P>



<H2><A NAME="Optimizing_the_Server" HREF="manual_toc.html#Optimizing_the_Server">7.5  Optimizing the MySQL Server</A></H2>



<H3><A NAME="System" HREF="manual_toc.html#System">7.5.1  System Factors and Startup Parameter Tuning</A></H3>

<P>
<A NAME="IDX787"></A>
<A NAME="IDX788"></A>
<A NAME="IDX789"></A>

</P>
<P>
We start with system-level factors, because some of these decisions must be
made very early to achieve large performance gains. In other cases, a quick
look at this section may suffice. However, it is always nice to have a sense
of how much can be gained by changing things at this level.

</P>
<P>
The default operating system to use is very important!  To get the best
use of multiple-CPU machines, you should use Solaris (because its threads
implementation works really well) or Linux (because the 2.4 kernel has
really good SMP support).  Note that older Linux kernels have a 2GB filesize
limit by default. If you have such a kernel and a desperate need for files
larger than 2GB, you should get the Large File Support (LFS) patch for the
ext2 filesystem.  Other filesystems such as ReiserFS and XFS do not have
this 2GB limitation.

</P>
<P>
Before using MySQL in production, we advise you to test it on your intended
platform.

</P>
<P>
<A NAME="IDX790"></A>
Other tips:

<UL>

<LI>

If you have enough RAM, you could remove all swap devices. Some
operating systems will use a swap device in some contexts even if you
have free memory.

<LI>

Use the <code>--skip-external-locking</code> MySQL option to avoid external
locking.  This option is on by default as of MySQL 4.0.
Before that, it is on by default when compiling with
MIT-pthreads, because <code>flock()</code> isn't fully supported by
MIT-pthreads on all platforms.  It's also on by default for Linux
because Linux file locking is not yet safe.

Note that the <code>--skip-external-locking</code> option will not affect MySQL's
functionality as long as you run only one server. Just remember to take
down the server (or lock and flush the relevant tables) before you run
<code>myisamchk</code>. On some systems this option is mandatory, because the
external locking does not work in any case.

The only case when you can't use <code>--skip-external-locking</code> is if you run
multiple MySQL <em>servers</em> (not clients) on the same data,
or if you run <code>myisamchk</code> to check (not repair) a table without telling
the server to flush and lock the tables first.

You can still use <code>LOCK TABLES</code> and <code>UNLOCK TABLES</code> even if you
are using <code>--skip-external-locking</code>.
</UL>



<H3><A NAME="Server_parameters" HREF="manual_toc.html#Server_parameters">7.5.2  Tuning Server Parameters</A></H3>

<P>
<A NAME="IDX791"></A>
<A NAME="IDX792"></A>
<A NAME="IDX793"></A>
<A NAME="IDX794"></A>

</P>
<P>
You can determine the default buffer sizes used by the <code>mysqld</code> server
with this command (prior to MySQL 4.1, omit <code>--verbose</code>):

</P>

<PRE>
shell&#62; mysqld --verbose --help
</PRE>

<P>
<A NAME="IDX795"></A>
<A NAME="IDX796"></A>
This command produces a list of all <code>mysqld</code> options and configurable
system variables. The output includes the default variable values and
looks something like this:

</P>

<PRE>
back_log                 current value: 5
bdb_cache_size           current value: 1048540
binlog_cache_size        current value: 32768
connect_timeout          current value: 5
delayed_insert_limit     current value: 100
delayed_insert_timeout   current value: 300
delayed_queue_size       current value: 1000
flush_time               current value: 0
interactive_timeout      current value: 28800
join_buffer_size         current value: 131072
key_buffer_size          current value: 1048540
long_query_time          current value: 10
lower_case_table_names   current value: 0
max_allowed_packet       current value: 1048576
max_binlog_cache_size    current value: 4294967295
max_connect_errors       current value: 10
max_connections          current value: 100
max_delayed_threads      current value: 20
max_heap_table_size      current value: 16777216
max_join_size            current value: 4294967295
max_sort_length          current value: 1024
max_tmp_tables           current value: 32
max_write_lock_count     current value: 4294967295
myisam_sort_buffer_size  current value: 8388608
net_buffer_length        current value: 16384
net_read_timeout         current value: 30
net_retry_count          current value: 10
net_write_timeout        current value: 60
read_buffer_size         current value: 131072
read_rnd_buffer_size     current value: 262144
slow_launch_time         current value: 2
sort_buffer              current value: 2097116
table_cache              current value: 64
thread_concurrency       current value: 10
thread_stack             current value: 131072
tmp_table_size           current value: 1048576
wait_timeout             current value: 28800
</PRE>

<P>
If there is a <code>mysqld</code> server currently running, you can see what
values it actually is using for the system variables by connecting to it and
issuing this statement:

</P>

<PRE>
mysql&#62; SHOW VARIABLES;
</PRE>

<P>
You can also see some statistical and status indicators for a running server
by issuing this statement:

</P>

<PRE>
mysql&#62; SHOW STATUS;
</PRE>

<P>
System variable and status information also can be obtained using
<code>mysqladmin</code>:

</P>

<PRE>
shell&#62; mysqladmin variables
shell&#62; mysqladmin extended-status
</PRE>

<P>
You can find a full description for all system and status variables in
section <A HREF="manual_MySQL_Database_Administration.html#Server_system_variables">5.2.3  Server System Variables</A> and section <A HREF="manual_MySQL_Database_Administration.html#Server_status_variables">5.2.4  Server Status Variables</A>.

</P>
<P>
MySQL uses algorithms that are very scalable, so you can usually run with
very little memory. However, normally you will get better performance by
giving MySQL more memory.

</P>
<P>
When tuning a MySQL server, the two most important variables to configure
are <code>key_buffer_size</code> and <code>table_cache</code>.  You should first feel
confident that you have these set appropriately before trying to change
any other variables.

</P>
<P>
The following examples indicate some typical variable values for different
runtime configurations. The examples use the <code>mysqld_safe</code> script and
use <code>--<var>var_name</var>=<var>value</var></code> syntax to set the variable <var>var_name</var> to the value
<var>value</var>.  This syntax is available as of MySQL 4.0.  For older versions
of MySQL, take the following differences into account:

</P>

<UL>
<LI>

Use <code>safe_mysqld</code> rather than <code>mysqld_safe</code>.

<LI>

Set variables using <code>--set-variable=<var>var_name</var>=<var>value</var></code> or <code>-O
<var>var_name</var>=<var>value</var></code> syntax.

<LI>

For variable names that end in <code>_size</code>, you may need to specify them
without <code>_size</code>. For example, the old name for <code>sort_buffer_size</code> is
<code>sort_buffer</code>. The old name for <code>read_buffer_size</code> is
<code>record_buffer</code>. To see which variables your version of the server
recognizes, use <code>mysqld --help</code>.

</UL>

<P>
If you have at least 256MB of memory and many tables and want maximum
performance with a moderate number of clients, you should use something
like this:

</P>

<PRE>
shell&#62; mysqld_safe --key_buffer_size=64M --table_cache=256 \
           --sort_buffer_size=4M --read_buffer_size=1M &#38;
</PRE>

<P>
If you have only 128MB of memory and only a few tables, but you still do a
lot of sorting, you can use something like this:

</P>

<PRE>
shell&#62; mysqld_safe --key_buffer_size=16M --sort_buffer_size=1M
</PRE>

<P>
If there are very many simultaneous connections, swapping problems
may occur unless <code>mysqld</code> has been configured to use very
little memory for each connection. <code>mysqld</code> performs better
if you have enough memory for all connections.

</P>
<P>
With little memory and lots of connections, use something like this:

</P>

<PRE>
shell&#62; mysqld_safe --key_buffer_size=512K --sort_buffer_size=100K \
           --read_buffer_size=100K &#38;
</PRE>

<P>
Or even this:

</P>

<PRE>
shell&#62; mysqld_safe --key_buffer_size=512K --sort_buffer_size=16K \
           --table_cache=32 --read_buffer_size=8K \
           --net_buffer_length=1K &#38;
</PRE>

<P>
If you are doing <code>GROUP BY</code> or <code>ORDER BY</code> operations on tables
that are much larger than your available memory, you should increase the
value of <code>read_rnd_buffer_size</code> to speed up the reading of rows after
sorting operations.

</P>
<P>
When you have installed MySQL, the <tt>`support-files'</tt> directory will
contain some different <tt>`my.cnf'</tt> sample files: <tt>`my-huge.cnf'</tt>,
<tt>`my-large.cnf'</tt>, <tt>`my-medium.cnf'</tt>, and <tt>`my-small.cnf'</tt>. You can
use these as a basis for optimizing your system.

</P>
<P>
Note that if you specify an option on the command line for <code>mysqld</code> or
<code>mysqld_safe</code>, it remains in effect only for that invocation of the server.
To use the option every time the server runs, put it in an option file.

</P>
<P>
To see the effects of a parameter change, do something like this (prior to
MySQL 4.1, omit <code>--verbose</code>):

</P>

<PRE>
shell&#62; mysqld --key_buffer_size=32M --verbose --help
</PRE>

<P>
The variable values are listed near the end of the output.
Make sure that the <code>--verbose</code> and <code>--help</code> options are
last. Otherwise, the effect of any options listed after them on the command
line will not be reflected in the output.

</P>
<P>
For information on tuning the <code>InnoDB</code> storage engine, see
section <A HREF="manual_InnoDB.html#InnoDB_tuning">15.12  <code>InnoDB</code> Performance Tuning Tips</A>.

</P>



<H3><A NAME="Controlling_optimizer" HREF="manual_toc.html#Controlling_optimizer">7.5.3  Controlling Query Optimizer Performance</A></H3>

<P>
<A NAME="IDX797"></A>

</P>
<P>
The task of the query optimizer is to find an optimal plan for executing
an SQL query. Because the difference in performance between ``good'' and
``bad'' plans can be orders of magnitude (that is, seconds versus hours
or even days), most query optimizers, including that of MySQL, perform
more or less exhaustive search for an optimal plan among all possible
query evaluation plans. For join queries, the number of possible plans
investigated by the MySQL optimizer grows exponentially with the number
of tables referenced in a query. For small numbers of tables (typically
less than 7-10) this is not a problem. However, when bigger queries are
submitted, the time spent in query optimization may easily become the
major bottleneck in the server performance.

</P>
<P>
MySQL 5.0.1 introduces a new more flexible method for query optimization
that allows the user to control how exhaustive the optimizer is in its
search for an optimal query evaluation plan. The general idea is that the
fewer plans that are investigated by the optimizer, the less time it will
spend in compiling a query. On the other hand, because the optimizer will
skip some plans, it may miss finding an optimal plan.

</P>
<P>
The behavior of the optimizer with respect to the number of plans it
evaluates can be controlled via two system variables:

</P>

<UL>
<LI>

The <code>optimizer_prune_level</code> variable tells the optimizer to skip
certain plans based on estimates of the number of rows accessed for each
table. Our experience shows that this kind of ``educated guess'' rarely
misses optimal plans, while it may dramatically reduce query compilation
times. That is why this option is on (<code>optimizer_prune_level</code>=1)
by default. However, if you believe that the optimizer missed better query
plans, then this option can be switched off (<code>optimizer_prune_level</code>=0)
with the risk that query compilation may take much longer. Notice that
even with the use of this heuristic, the optimizer will still explore a
roughly exponential number of plans.

<LI>

The <code>optimizer_search_depth</code> variable tells how far in the
``future'' of each incomplete plan the optimizer should look in order
to evaluate whether it should be expanded further.  Smaller values of
<code>optimizer_search_depth</code> may result in orders of magnitude smaller query
compilation times. For example, queries with 12-13 or more tables may easily
require hours and even days to compile if <code>optimizer_search_depth</code>
is close to the number of tables in the query. At the same time, if
compiled with <code>optimizer_search_depth</code> equal to 3 or 4, the compiler
may compile in less than a minute for the same query. If you are unsure of
what a reasonable value is for <code>optimizer_search_depth</code>, this variable
can be set to 0 to tell the optimizer to determine the value automatically.

</UL>



<H3><A NAME="Compile_and_link_options" HREF="manual_toc.html#Compile_and_link_options">7.5.4  How Compiling and Linking Affects the Speed of MySQL</A></H3>

<P>
<A NAME="IDX798"></A>
<A NAME="IDX799"></A>
<A NAME="IDX800"></A>
<A NAME="IDX801"></A>

</P>
<P>
Most of the following tests were performed on Linux with the
MySQL benchmarks, but they should give some indication for
other operating systems and workloads.

</P>
<P>
You get the fastest executables when you link with <code>-static</code>.

</P>
<P>
On Linux, you will get the fastest code when compiling with <code>pgcc</code>
and <code>-O3</code>.  You need about 200MB memory to compile <tt>`sql_yacc.cc'</tt>
with these options, because <code>gcc/pgcc</code> needs a lot of memory to
make all functions inline. You should also set <code>CXX=gcc</code> when
configuring MySQL to avoid inclusion of the <code>libstdc++</code>
library, which is not needed. Note that with some versions of <code>pgcc</code>,
the resulting code will run only on true Pentium processors, even if you
use the compiler option indicating that you want the resulting code to work on
all x586-type processors (such as AMD).

</P>
<P>
By just using a better compiler and better compiler options, you can
get a 10-30% speed increase in your application.  This is particularly
important if you compile the MySQL server yourself.

</P>
<P>
We have tested both the Cygnus CodeFusion and Fujitsu compilers, but
when we tested them, neither was sufficiently bug-free to allow
MySQL to be compiled with optimizations enabled.

</P>
<P>
The standard MySQL binary distributions are compiled with support for all
character sets.  When you compile MySQL yourself, you should include support
only for the character sets that you are going to use. This is controlled by
the <code>--with-charset</code> option to <code>configure</code>.

</P>
<P>
Here is a list of some measurements that we have made:

</P>

<UL>

<LI>

If you use <code>pgcc</code> and compile everything with <code>-O6</code>, the
<code>mysqld</code> server is 1% faster than with <code>gcc</code> 2.95.2.

<LI>

If you link dynamically (without <code>-static</code>), the result is 13%
slower on Linux.  Note that you still can use a dynamically linked
MySQL library for your client applications. It is the server that is most
critical for performance.

<LI>

If you strip your <code>mysqld</code> binary with <code>strip mysqld</code>,
the resulting binary can be up to 4% faster.

<LI>

For a connection from a client to a server running on the same host,
if you connect using TCP/IP rather than a Unix socket file, performance is 7.5%
slower. (On Unix, if you connect to the hostname <code>localhost</code>,
MySQL uses a socket file by default.)

<LI>

For TCP/IP connections from a client to a server, connecting to a remote
server on another host will be 8-11% slower than connecting to the local
server on the same host, even for connections over 100Mb/s Ethernet.

<LI>

When running our benchmark tests using secure connections (all data
encrypted with internal SSL support) performance was 55% slower than for
unencrypted connections.

<LI>

If you compile with <code>--with-debug=full</code>, most queries will be 20% slower.
Some queries may take substantially longer; for example,
the MySQL benchmarks ran 35% slower.  If you use <code>--with-debug</code> (without
<code>=full</code>),
the slowdown will be only 15%.  For a version of <code>mysqld</code> that has
been compiled with <code>--with-debug=full</code>, you can disable memory
checking at runtime by starting it with the <code>--skip-safemalloc</code>
option. The execution speed should then be close to that obtained when
configuring with <code>--with-debug</code>.

<LI>

On a Sun UltraSPARC-IIe, a server compiled with Forte 5.0 is 4% faster than
one compiled with <code>gcc</code> 3.2.

<LI>

On a Sun UltraSPARC-IIe, a server compiled with Forte 5.0 is 4% faster in
32-bit mode than in 64-bit mode.

<LI>

Compiling with <code>gcc</code> 2.95.2 for UltraSPARC with the
<code>-mcpu=v8 -Wa,-xarch=v8plusa</code> options gives 4% more performance.

<LI>

On Solaris 2.5.1, MIT-pthreads is 8-12% slower than Solaris native
threads on a single processor. With more load or CPUs, the difference should
be larger.

<LI>

Compiling on Linux-x86 using <code>gcc</code> without frame pointers
(<code>-fomit-frame-pointer</code> or <code>-fomit-frame-pointer -ffixed-ebp</code>)
makes <code>mysqld</code> 1-4% faster.
</UL>

<P>
Binary MySQL distributions for Linux that are provided by MySQL AB used
to be compiled with <code>pgcc</code>. We had to go back to regular <code>gcc</code>
due to a bug in <code>pgcc</code> that would generate code that does
not run on AMD. We will continue using <code>gcc</code> until that bug is resolved.
In the meantime, if you have a non-AMD machine, you can get a faster
binary by compiling with <code>pgcc</code>.  The standard MySQL
Linux binary is linked statically to make it faster and more portable.

</P>



<H3><A NAME="Memory_use" HREF="manual_toc.html#Memory_use">7.5.5  How MySQL Uses Memory</A></H3>

<P>
<A NAME="IDX802"></A>

</P>
<P>
The following list indicates some of the ways that the <code>mysqld</code> server
uses memory.  Where applicable, the name of the system variable relevant
to the memory use is given:

</P>

<UL>
<LI>

The key buffer (variable <code>key_buffer_size</code>) is shared by all
threads; other buffers used by the server are allocated as
needed. See section <A HREF="manual_MySQL_Optimization.html#Server_parameters">7.5.2  Tuning Server Parameters</A>.

<LI>

Each connection uses some thread-specific space:


<UL>
<LI>

A stack (default 64KB, variable <code>thread_stack</code>)

<LI>

A connection buffer (variable <code>net_buffer_length</code>)

<LI>

A result buffer (variable <code>net_buffer_length</code>)

</UL>

The connection buffer and result buffer are
dynamically enlarged up to <code>max_allowed_packet</code> when needed.  While
a query is running, a copy of the current query string is also allocated.

<LI>

All threads share the same base memory.

<LI>

Only compressed <code>ISAM</code> and <code>MyISAM</code> tables are memory mapped.  This
is because the 32-bit memory space of 4GB is not large enough for most
big tables. When systems with a 64-bit address space become more
common, we may add general support for memory mapping.

<LI>

Each request that performs a sequential scan of a table allocates a read buffer
(variable <code>read_buffer_size</code>).

<LI>

When reading rows in ``random'' order (for example, after a sort), a
random-read buffer may be allocated to avoid disk seeks.
(variable <code>read_rnd_buffer_size</code>).

<LI>

All joins are done in one pass, and most joins can be done without even
using a temporary table. Most temporary tables are memory-based (<code>HEAP</code>)
tables.  Temporary tables with a large record length (calculated as the
sum of all column lengths) or that contain <code>BLOB</code> columns are
stored on disk.

One problem before MySQL 3.23.2 is that if an internal in-memory
heap table exceeds the size of <code>tmp_table_size</code>, the error <code>The
table <var>tbl_name</var> is full</code> occurs. From 3.23.2 on, this is handled
automatically by changing the in-memory heap table to a disk-based
<code>MyISAM</code> table as necessary. To work around this problem for older
servers, you can increase the temporary table size by setting the
<code>tmp_table_size</code> option to <code>mysqld</code>, or by setting the SQL option
<code>SQL_BIG_TABLES</code> in the client program.
See section <A HREF="manual_SQL_Syntax.html#SET_OPTION">13.5.3  <code>SET</code> Syntax</A>.

In MySQL 3.20, the maximum size of the temporary table is
<code>record_buffer*16</code>; if you are using this version, you have to increase
the value of <code>record_buffer</code>. You can also start <code>mysqld</code> with the
<code>--big-tables</code> option to always store temporary tables on disk.
However, this will affect the speed of many complicated queries.

<LI>

Most requests that perform a sort allocate a sort buffer and zero to two temporary
files depending on the result set size. See section <A HREF="manual_Problems.html#Temporary_files">A.4.4  Where MySQL Stores Temporary Files</A>.

<LI>

Almost all parsing and calculating is done in a local memory store. No
memory overhead is needed for small items, so the normal slow memory
allocation and freeing is avoided. Memory is allocated only for
unexpectedly large strings; this is done with <code>malloc()</code> and
<code>free()</code>.

<LI>

For each <code>MyISAM</code> and <code>ISAM</code> table that is opened, the index file
is opened once and the data file is opened once for each concurrently running
thread. For each concurrent thread, a table structure, column structures for
each column, and a buffer of size <code>3 * <var>N</var></code> are allocated (where <var>N</var>
is the maximum row length, not counting <code>BLOB</code> columns). A <code>BLOB</code>
column requires five to eight bytes plus the length of the <code>BLOB</code> data.
The <code>MyISAM</code> and <code>ISAM</code> storage engines maintain one extra row
buffer for internal use.

<LI>

For each table having <code>BLOB</code> columns, a buffer is enlarged dynamically
to read in larger <code>BLOB</code> values. If you scan a table, a buffer as large
as the largest <code>BLOB</code> value is allocated.

<LI>

Handler structures for all in-use tables are saved in a cache and managed as a
FIFO. By default, the cache has 64 entries. If a table has been used by two
running threads at the same time, the cache contains two entries for the
table. See section <A HREF="manual_MySQL_Optimization.html#Table_cache">7.4.8  How MySQL Opens and Closes Tables</A>.

<LI>

A <code>FLUSH TABLES</code> statement or  <code>mysqladmin flush-tables</code> command
closes all tables that are not in use at once and marks all in-use tables to be
closed when the currently executing thread finishes. This effectively frees
most in-use memory. <code>FLUSH TABLES</code> does not return until all tables have
been closed.

</UL>

<P>
<code>ps</code> and other system status programs may report that <code>mysqld</code>
uses a lot of memory. This may be caused by thread stacks on different
memory addresses. For example, the Solaris version of <code>ps</code> counts
the unused memory between stacks as used memory. You can verify this by
checking available swap with <code>swap -s</code>. We have tested
<code>mysqld</code> with several memory-leakage detectors (both commercial and open
source), so there should be no memory leaks.

</P>



<H3><A NAME="DNS" HREF="manual_toc.html#DNS">7.5.6  How MySQL Uses DNS</A></H3>

<P>
<A NAME="IDX803"></A>
<A NAME="IDX804"></A>

</P>
<P>
When a new client connects to <code>mysqld</code>, <code>mysqld</code> spawns a
new thread to handle the request.  This thread first checks whether the
hostname is in the hostname cache. If not, the thread attempts to resolve the
hostname:

</P>

<UL>
<LI>

If the operating system supports the thread-safe <code>gethostbyaddr_r()</code> and
<code>gethostbyname_r()</code> calls, the thread uses them to perform hostname
resolution.

<LI>

If the operating system doesn't support the thread-safe calls, the
thread locks a mutex and calls <code>gethostbyaddr()</code> and
<code>gethostbyname()</code> instead. In this case, no other thread
can resolve hostnames that are not in the hostname cache until the
first thread unlocks the mutex.

</UL>

<P>
You can disable DNS hostname lookups by starting <code>mysqld</code> with the
<code>--skip-name-resolve</code> option.  However, in this case, you can use only IP
numbers in the MySQL grant tables.

</P>
<P>
If you have a very slow DNS and many hosts, you can get more performance by
either disabling DNS lookups with <code>--skip-name-resolve</code> or by
increasing the <code>HOST_CACHE_SIZE</code> define (default value: 128) and
recompiling <code>mysqld</code>.

</P>
<P>
You can disable the hostname cache by starting the server with the
<code>--skip-host-cache</code> option. To clear the hostname cache, issue a
<code>FLUSH HOSTS</code> statement or execute the <code>mysqladmin flush-hosts</code>
command.

</P>
<P>
If you want to disallow TCP/IP connections entirely, start <code>mysqld</code> with
the <code>--skip-networking</code> option.

</P>



<H2><A NAME="Disk_issues" HREF="manual_toc.html#Disk_issues">7.6  Disk Issues</A></H2>

<P>
<A NAME="IDX805"></A>
<A NAME="IDX806"></A>

</P>

<UL>
<LI>

Disk seeks are a big performance bottleneck. This problem becomes more
apparent when the amount of data starts to grow so
large that effective caching becomes impossible. For large databases
where you access data more or less randomly, you can be sure that you
will need at least one disk seek to read and a couple of disk seeks to
write things. To minimize this problem, use disks with low seek times.

<LI>

Increase the number of available disk spindles (and thereby reduce
the seek overhead) by either symlinking files to different disks or striping
the disks:

<DL COMPACT>

<DT>Using symbolic links
<DD>
This means that, for <code>MyISAM</code> tables, you symlink the index file and/or
data file from their usual location in the data directory to another disk
(that may also be striped). This makes both the seek and read times better,
assuming that the disk is not used for other purposes as well. See section <A HREF="manual_MySQL_Optimization.html#Symbolic_links">7.6.1  Using Symbolic Links</A>.

<DT>Striping
<DD>
<A NAME="IDX807"></A>
Striping means that you have many disks and put the first block on the
first disk, the second block on the second disk, and the Nth block on the
(N mod number_of_disks) disk, and so on. This means if your normal data
size is less than the stripe size (or perfectly aligned), you will get
much better performance. Striping is very dependent on the operating system
and the stripe size, so benchmark your application with different
stripe sizes. See section <A HREF="manual_MySQL_Optimization.html#Custom_Benchmarks">7.1.5  Using Your Own Benchmarks</A>.

The speed difference for striping is <em>very</em> dependent on
the parameters. Depending on how you set the striping parameters and number
of disks, you may get differences measured in orders of magnitude.
You have to choose to optimize for random or sequential access.

</DL>

<LI>

For reliability you may want to use RAID 0+1 (striping plus mirroring), but
in this case, you will need 2*N drives to hold N drives of data. This is
probably the best option if you have the money for it!  However, you may
also have to invest in some volume-management software to handle it
efficiently.

<LI>

A good option is to vary the RAID level according to how critical a type of
data is. For example, store semi-important data that can be regenerated
on a RAID 0 disk, but store really important data such as host information
and logs on a RAID 0+1 or RAID N disk. RAID N can be a problem if you
have many writes, due to the time required to update the parity bits.

<LI>

On Linux, you can get much more performance by using <code>hdparm</code> to
configure your disk's interface.  (Up to 100% under load is not uncommon.)
The following <code>hdparm</code> options should be quite good for MySQL, and
probably for many other applications:


<PRE>
hdparm -m 16 -d 1
</PRE>

Note that performance and reliability when using this command depends
on your hardware, so we strongly suggest that you test your system
thoroughly after using <code>hdparm</code>.  Please consult the <code>hdparm</code>
manual page for more information.  If <code>hdparm</code> is not used wisely,
filesystem corruption may result, so back up everything before
experimenting!

<LI>

You can also set the parameters for the filesystem that the database uses:

If you don't need to know when files were last accessed (which is
not really useful on a database server), you can mount your
filesystems with the <code>-o noatime</code> option.  That skips updates
to the last access time in inodes on the filesystem, which avoids
some disk seeks.

On many operating systems, you can set a filesystem to be updated
asynchronously by mounting it with the <code>-o async</code> option.  If your
computer is reasonably stable, this should give you more performance without
sacrificing too much reliability.  (This flag is on by default on Linux.)

</UL>



<H3><A NAME="Symbolic_links" HREF="manual_toc.html#Symbolic_links">7.6.1  Using Symbolic Links</A></H3>

<P>
<A NAME="IDX808"></A>
<A NAME="IDX809"></A>

</P>
<P>
You can move tables and databases from the database directory to other
locations and replace them with symbolic links to the new locations.
You might want to do this, for example, to move a database to a file
system with more free space or increase the speed of your system by
spreading your tables to different disk.

</P>
<P>
The recommended way to do this is to just symlink databases to a
different disk. Symlink tables only as a last resort.

</P>



<H4><A NAME="Symbolic_links_to_databases" HREF="manual_toc.html#Symbolic_links_to_databases">7.6.1.1  Using Symbolic Links for Databases on Unix</A></H4>

<P>
<A NAME="IDX810"></A>

</P>
<P>
On Unix, the way to symlink a database is to first create a directory on some
disk where you have free space and then create a symlink to it from
the MySQL data directory.

</P>

<PRE>
shell&#62; mkdir /dr1/databases/test
shell&#62; ln -s /dr1/databases/test <var>/path/to/datadir</var>
</PRE>

<P>
MySQL doesn't support linking one directory to multiple
databases.  Replacing a database directory with a symbolic link will
work fine as long as you don't make a symbolic link between databases.
Suppose that you have a database <code>db1</code> under the MySQL data
directory, and then make a symlink <code>db2</code> that points to <code>db1</code>:

</P>

<PRE>
shell&#62; cd <var>/path/to/datadir</var>
shell&#62; ln -s db1 db2
</PRE>

<P>
Now, for any table <code>tbl_a</code> in <code>db1</code>, there also appears to be
a table <code>tbl_a</code> in <code>db2</code>.  If one client updates <code>db1.tbl_a</code>
and another client updates <code>db2.tbl_a</code>, there will be problems.

</P>
<P>
If you really need to do this, you can change one of the source files.
The file to modify depends on your version of MySQL. For MySQL 4.0 and up,
look for the following statement in the <tt>`mysys/my_symlink.c'</tt> file:

</P>

<PRE>
if (!(MyFlags &#38; MY_RESOLVE_LINK) || 
    (!lstat(filename,&#38;stat_buff) &#38;&#38; S_ISLNK(stat_buff.st_mode)))
</PRE>

<P>
Before MySQL 4.0, look for this statement in the <tt>`mysys/mf_format.c'</tt> file:

</P>

<PRE>
if (flag &#38; 32 || (!lstat(to,&#38;stat_buff) &#38;&#38; S_ISLNK(stat_buff.st_mode)))
</PRE>

<P>
Change the statement to this:

</P>

<PRE>
if (1)
</PRE>

<P>
On Windows, you can use internal symbolic links to directories by compiling
MySQL with <code>-DUSE_SYMDIR</code>. This allows you to put different
databases on different disks. See section <A HREF="manual_MySQL_Optimization.html#Windows_symbolic_links">7.6.1.3  Using Symbolic Links for Databases on Windows</A>.

</P>



<H4><A NAME="Symbolic_links_to_tables" HREF="manual_toc.html#Symbolic_links_to_tables">7.6.1.2  Using Symbolic Links for Tables on Unix</A></H4>

<P>
<A NAME="IDX811"></A>

</P>
<P>
Before MySQL 4.0, you should not symlink tables unless you are
<em>very</em> careful with them. The problem is that if you run <code>ALTER
TABLE</code>, <code>REPAIR TABLE</code>, or <code>OPTIMIZE TABLE</code> on a symlinked
table, the symlinks will be removed and replaced by the original
files. This happens because these statements work by creating a
temporary file in the database directory and replacing the original
file with the temporary file when the statement operation is complete.

</P>
<P>
You should not symlink tables on systems that don't have a fully
working <code>realpath()</code> call. (At least Linux and Solaris support
<code>realpath()</code>). You can check whether your system supports symbolic links
by issuing a <code>SHOW VARIABLES LIKE 'have_symlink'</code> statement.

</P>
<P>
In MySQL 4.0, symlinks are fully supported only for <code>MyISAM</code>
tables.  For other table types, you will probably get strange problems
if you try to use symbolic links on files in the operating system with
any of the preceding statements.

</P>
<P>
The handling of symbolic links for <code>MyISAM</code> tables in MySQL 4.0 works
the following way:

</P>

<UL>
<LI>

In the data directory, you will always have the table definition
file, the data file, and the index file. The data file and index file
can be moved elsewhere and replaced in the data directory by
symlinks. The definition file cannot.

<LI>

You can symlink the data file and the index file independently to different
directories.

<LI>

The symlinking can be done manually from the command line with <code>ln -s</code>
if <code>mysqld</code> is not running. With SQL, you can instruct the server to
perform the symlinking by using the <code>DATA DIRECTORY</code> and <code>INDEX
DIRECTORY</code> options to <code>CREATE TABLE</code>.
See section <A HREF="manual_SQL_Syntax.html#CREATE_TABLE">13.2.6  <code>CREATE TABLE</code> Syntax</A>.

<LI>

<code>myisamchk</code> will not replace a symlink with the data file or index file.
It works directly on the file a symlink points to. Any temporary files
are created in the directory where the data file or index file is
located.

<LI>

When you drop a table that is using symlinks, both the symlink and the
file the symlink points to are dropped.  This is a good reason why you
should <em>not</em> run <code>mysqld</code> as <code>root</code> or allow
users to have write access to the MySQL database directories.

<LI>

If you rename a table with <code>ALTER TABLE ... RENAME</code> and you don't move
the table to another database, the symlinks in the database directory
are renamed to the new names and the data file and index file are
renamed accordingly.

<LI>

If you use <code>ALTER TABLE ... RENAME</code> to move a table to another database,
the table is moved to the other database directory. The old
symlinks and the files to which they pointed are deleted.  In other words,
the new table will not be symlinked.

<LI>

If you are not using symlinks, you should use the <code>--skip-symbolic-links</code>
option to <code>mysqld</code> to ensure that no one can use <code>mysqld</code> to drop
or rename a file outside of the data directory.
</UL>

<P>
<code>SHOW CREATE TABLE</code> doesn't report if a table has symbolic links
prior to MySQL 4.0.15. This is also true for <code>mysqldump</code>, which uses
<code>SHOW CREATE TABLE</code> to generate <code>CREATE TABLE</code> statements.

</P>
<P>
Table symlink operations that are not yet supported:

</P>
<P>
<A NAME="IDX812"></A>

<UL>
<LI>

<code>ALTER TABLE</code> ignores the <code>DATA DIRECTORY</code> and <code>INDEX
DIRECTORY</code> table options.
<LI>

<code>BACKUP TABLE</code> and <code>RESTORE TABLE</code> don't respect symbolic
links.
<LI>

The <tt>`.frm'</tt> file must <em>never</em> be a symbolic link (as indicated
previously, only the data and index files can be symbolic links).  Attempting
to do this (for example, to make synonyms) will produce incorrect results.
Suppose that you have a database <code>db1</code> under the MySQL data directory,
a table <code>tbl1</code> in this database, and in the <code>db1</code> directory you
make a symlink <code>tbl2</code> that points to <code>tbl1</code>:


<PRE>
shell&#62; cd <var>/path/to/datadir</var>/db1
shell&#62; ln -s tbl1.frm tbl2.frm
shell&#62; ln -s tbl1.MYD tbl2.MYD
shell&#62; ln -s tbl1.MYI tbl2.MYI
</PRE>

Now there will be problems if one thread reads <code>db1.tbl1</code> and another
thread updates <code>db1.tbl2</code>:


<UL>
<LI>

The query cache will be fooled (it will believe <code>tbl1</code> has not been
updated so will return out-of-date results).
<LI>

<code>ALTER</code> statements on <code>tbl2</code> will also fail.
</UL>

</UL>



<H4><A NAME="Windows_symbolic_links" HREF="manual_toc.html#Windows_symbolic_links">7.6.1.3  Using Symbolic Links for Databases on Windows</A></H4>

<P>
<A NAME="IDX813"></A>
<A NAME="IDX814"></A>
<A NAME="IDX815"></A>

</P>
<P>
Beginning with MySQL 3.23.16, the <code>mysqld-max</code>
and <code>mysql-max-nt</code> servers for Windows are
compiled with the <code>-DUSE_SYMDIR</code> option.  This allows you to put a
database directory on a different disk by setting up a symbolic link to it.
This is similar to the way that symbolic links work on Unix, although the
procedure for setting up the link is different.

</P>
<P>
As of MySQL 4.0, symbolic links are enabled by default. If you don't need them,
you can disable them with the <code>skip-symbolic-links</code> option:

</P>

<PRE>
[mysqld]
skip-symbolic-links
</PRE>

<P>
Before MySQL 4.0, symbolic links are disabled by default. To enable them,
you should put the following entry in your <tt>`my.cnf'</tt> or <tt>`my.ini'</tt>
file:

</P>

<PRE>
[mysqld]
symbolic-links
</PRE>

<P>
On Windows, you make a symbolic link to a MySQL database by creating a file
in the data directory that contains the path to the destination directory.
The file should be named <tt>`db_name.sym'</tt>, where <var>db_name</var> is the
database name.

</P>
<P>
Suppose that the MySQL data directory is <tt>`C:\mysql\data'</tt>
and you want to have database <code>foo</code> located at <tt>`D:\data\foo'</tt>.
Set up a symlink like this:

</P>

<OL>

<LI>

Make sure that the <tt>`D:\data\foo'</tt> directory exists by creating it if
necessary.  If you
already have a database directory named <tt>`foo'</tt> in the data directory,
you should move it to <tt>`D:\data'</tt>. Otherwise, the symbolic link will be
ineffective.  To avoid problems, the server should not be running when you
move the database directory.

<LI>

Create a file <tt>`C:\mysql\data\foo.sym'</tt> that contains the pathname
<code>D:\data\foo\</code>.

</OL>

<P>
After that, all tables created in the database <code>foo</code> will be created in
<tt>`D:\data\foo'</tt>.  Note that the symbolic link will not be used if a
directory with the database name exists in the MySQL data directory.

</P>

<P><HR><P>
Go to the <A HREF="manual_Introduction.html">first</A>, <A HREF="manual_Replication.html">previous</A>, <A HREF="manual_Client-Side_Scripts.html">next</A>, <A HREF="manual_Concept_Index.html">last</A> section, <A HREF="manual_toc.html">table of contents</A>.
 </BODY>
 </HTML>
