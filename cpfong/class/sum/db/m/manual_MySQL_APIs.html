  <HTML>
  <HEAD>
  
  <TITLE>MySQL Reference Manual for version 5.0.3-alpha - 21  MySQL APIs</TITLE>
   <style> code {color:purple} tt {color:green} samp {color:navy} pre {color:maroon} </style>
  </HEAD>
  <BODY BGCOLOR=silver TEXT=#000000 LINK=#101090 VLINK=#7030B0>
Go to the <A HREF="manual_Introduction.html">first</A>, <A HREF="manual_Triggers.html">previous</A>, <A HREF="manual_MySQL_Connectors.html">next</A>, <A HREF="manual_Concept_Index.html">last</A> section, <A HREF="manual_toc.html">table of contents</A>.
<P><HR><P>


<H1><A NAME="MySQL_APIs" HREF="manual_toc.html#MySQL_APIs">21  MySQL APIs</A></H1>

<P>
<A NAME="IDX2082"></A>
<A NAME="IDX2083"></A>
<A NAME="IDX2084"></A>
<A NAME="IDX2085"></A>
<A NAME="IDX2086"></A>

</P>

<P>
This chapter describes the APIs available for MySQL, where to get
them, and how to use them.  The C API is the most extensively covered,
because it was developed by the MySQL team, and is the basis for most of the
other APIs.

</P>



<H2><A NAME="Programming_utilities" HREF="manual_toc.html#Programming_utilities">21.1  MySQL Program Development Utilities</A></H2>

<P>
This section describes some utilities that you may find useful when
developing MySQL programs.

</P>
<DL COMPACT>

<DT><code>msql2mysql</code>
<DD>
<A NAME="IDX2087"></A>
A shell script that converts <code>mSQL</code> programs to MySQL. It doesn't
handle every case, but it gives a good start when converting.

<DT><code>mysql_config</code>
<DD>
<A NAME="IDX2088"></A>
A shell script that produces the option values needed when compiling MySQL
programs.

</DL>



<H3><A NAME="msql2mysql" HREF="manual_toc.html#msql2mysql">21.1.1  <code>msql2mysql</code>, Convert mSQL Programs for Use with MySQL</A></H3>

<P>
Initially, the MySQL C API was developed to be very similar to that for the
mSQL database system. Because of this, mSQL programs often can be converted
relatively easily for use with MySQL by changing the names of the C API
functions.

</P>
<P>
The <code>msql2mysql</code> utility performs the conversion of mSQL C API function
calls to their MySQL equivalents.
<code>msql2mysql</code> converts the input file in place, so make a copy of the
original before converting it.  For example, use <code>msql2mysql</code> like
this:

</P>


<PRE>
shell&#62; cp client-prog.c client-prog.c.orig
shell&#62; msql2mysql client-prog.c
client-prog.c converted
</PRE>

<P>
Then examine <tt>`client-prog.c'</tt> and make any post-conversion revisions
that may be necessary.

</P>
<P>
<code>msql2mysql</code> uses the <code>replace</code> utility to make the function name
substitutions.
See section <A HREF="manual_Client-Side_Scripts.html#replace_utility">8.13  The <code>replace</code> String-Replacement Utility</A>.

</P>


<H3><A NAME="mysql_config" HREF="manual_toc.html#mysql_config">21.1.2  <code>mysql_config</code>, Get compile options for compiling clients</A></H3>

<P>
<code>mysql_config</code> provides you with useful information for compiling
your MySQL client and connecting it to MySQL.

</P>
<P>
<code>mysql_config</code> supports the following options:

</P>
<DL COMPACT>

<DT><code>--cflags</code>
<DD>
Compiler flags to find include files and critical compiler flags and
defines used when compiling the <code>libmysqlclient</code> library.

<DT><code>--include</code>
<DD>
Compiler options to find MySQL include files. (Note that normally you would use
<code>--cflags</code> instead of this option.)

<DT><code>--libmysqld-libs, --embedded</code>
<DD>
Libraries and options required to link with the MySQL embedded server.

<DT><code>--libs</code>
<DD>
Libraries and options required to link with the MySQL client library.

<DT><code>--libs_r</code>
<DD>
Libraries and options required to link with the thread-safe MySQL client library.

<DT><code>--port</code>
<DD>
The default TCP/IP port number, defined when configuring MySQL.

<DT><code>--socket</code>
<DD>
The default Unix socket file, defined when configuring MySQL.

<DT><code>--version</code>
<DD>
Version number and version for the MySQL distribution.

</DL>

<P>
If you invoke <code>mysql_config</code> with no options, it displays a list of all
options that it supports, and their values:

</P>

<PRE>
shell&#62; mysql_config
Usage: /usr/local/mysql/bin/mysql_config [options]
Options:
  --cflags         [-I/usr/local/mysql/include/mysql -mcpu=pentiumpro]
  --include        [-I/usr/local/mysql/include/mysql]
  --libs           [-L/usr/local/mysql/lib/mysql -lmysqlclient -lz
                    -lcrypt -lnsl -lm -L/usr/lib -lssl -lcrypto]
  --libs_r         [-L/usr/local/mysql/lib/mysql -lmysqlclient_r
                    -lpthread -lz -lcrypt -lnsl -lm -lpthread]
  --socket         [/tmp/mysql.sock]
  --port           [3306]
  --version        [4.0.16]
  --libmysqld-libs [-L/usr/local/mysql/lib/mysql -lmysqld -lpthread -lz
                    -lcrypt -lnsl -lm -lpthread -lrt]
</PRE>

<P>
You can use <code>mysql_config</code> within a command line to include the value
that it displays for a particular option. For example, to compile a MySQL
client program, use <code>mysql_config</code> as follows:

</P>

<PRE>
CFG=/usr/local/mysql/bin/mysql_config
sh -c "gcc -o progname `$CFG --cflags` progname.c `$CFG --libs`"
</PRE>

<P>
When you use <code>mysql_config</code> this way, be sure to invoke it within
backtick (<samp>``'</samp>) characters.  That tells the shell to execute it and
subsitute its output into the surrounding command.

</P>



<H2><A NAME="C" HREF="manual_toc.html#C">21.2  MySQL C API</A></H2>

<P>
<A NAME="IDX2089"></A>
<A NAME="IDX2090"></A>

</P>

<P>
The C API code is distributed with MySQL. It is included in the
<code>mysqlclient</code> library and allows C programs to access a database.

</P>
<P>
Many of the clients in the MySQL source distribution are
written in C.  If you are looking for examples that demonstrate how to
use the C API, take a look at these clients. You can find these in the
<code>clients</code> directory in the MySQL source distribution.

</P>
<P>
Most of the other client APIs (all except Connector/J) use the <code>mysqlclient</code>
library to communicate with the MySQL server. This means that, for
example, you can take advantage of many of the same environment variables
that are used by other client programs, because they are referenced from the
library.  See section <A HREF="manual_Client-Side_Scripts.html#Client-Side_Scripts">8  MySQL Client and Utility Programs</A>, for a list of these variables.

</P>
<P>
The client has a maximum communication buffer size. The size of the buffer
that is allocated initially (16KB) is automatically increased up to the
maximum size (the maximum is 16MB). Because buffer sizes are increased
only as demand warrants, simply increasing the default maximum limit does not
in itself cause more resources to be used. This size check is mostly a check
for erroneous queries and communication packets.

</P>
<P>
The communication buffer must be large enough to contain a single SQL
statement (for client-to-server traffic) and one row of returned data (for
server-to-client traffic).  Each thread's communication buffer is dynamically
enlarged to handle any query or row up to the maximum limit.  For example, if
you have <code>BLOB</code> values that contain up to 16MB of data, you must have a
communication buffer limit of at least 16MB (in both server and client).  The
client's default maximum is 16MB, but the default maximum in the server is
1MB.  You can increase this by changing the value of the
<code>max_allowed_packet</code> parameter when the server is started.  See section <A HREF="manual_MySQL_Optimization.html#Server_parameters">7.5.2  Tuning Server Parameters</A>.

</P>
<P>
The MySQL server shrinks each communication buffer to
<code>net_buffer_length</code> bytes after each query.  For clients, the size of
the buffer associated with a connection is not decreased until the connection
is closed, at which time client memory is reclaimed.

</P>
<P>
For programming with threads, see section <A HREF="manual_MySQL_APIs.html#Threaded_clients">21.2.15  How to Make a Threaded Client</A>.
For creating a standalone application which includes the
"server" and "client" in the same program (and does not
communicate with an external MySQL server), see section <A HREF="manual_MySQL_APIs.html#libmysqld">21.2.16  libmysqld, the Embedded MySQL Server Library</A>.

</P>



<H3><A NAME="C_API_datatypes" HREF="manual_toc.html#C_API_datatypes">21.2.1  C API Data types</A></H3>

<DL COMPACT>

<DT><code>MYSQL</code>
<DD>
<A NAME="IDX2091"></A>
This structure represents a handle to one database connection. It is
used for almost all MySQL functions.

<DT><code>MYSQL_RES</code>
<DD>
<A NAME="IDX2092"></A>
This structure represents the result of a query that returns rows
(<code>SELECT</code>, <code>SHOW</code>, <code>DESCRIBE</code>, <code>EXPLAIN</code>).  The
information returned from a query is called the <em>result set</em> in the
remainder of this section.

<DT><code>MYSQL_ROW</code>
<DD>
<A NAME="IDX2093"></A>
This is a type-safe representation of one row of data. It is currently
implemented as an array of counted byte strings.  (You cannot treat these as
null-terminated strings if field values may contain binary data, because such
values may contain null bytes internally.)  Rows are obtained by calling
<code>mysql_fetch_row()</code>.

<DT><code>MYSQL_FIELD</code>
<DD>
<A NAME="IDX2094"></A>
This structure contains information about a field, such as the field's
name, type, and size. Its members are described in more detail here.
You may obtain the <code>MYSQL_FIELD</code> structures for each field by
calling <code>mysql_fetch_field()</code> repeatedly.  Field values are not part of
this structure; they are contained in a <code>MYSQL_ROW</code> structure.

<DT><code>MYSQL_FIELD_OFFSET</code>
<DD>
<A NAME="IDX2095"></A>
This is a type-safe representation of an offset into a MySQL field
list.  (Used by <code>mysql_field_seek()</code>.)  Offsets are field numbers
within a row, beginning at zero.

<DT><code>my_ulonglong</code>
<DD>
<A NAME="IDX2096"></A>
<A NAME="IDX2097"></A>
The type used for the number of rows and for <code>mysql_affected_rows()</code>,
<code>mysql_num_rows()</code>, and <code>mysql_insert_id()</code>. This type provides a
range of <code>0</code> to <code>1.84e19</code>.

On some systems, attempting to print a value of type <code>my_ulonglong</code>
will not work.  To print such a value, convert it to <code>unsigned long</code>
and use a <code>%lu</code> print format.  Example:

<PRE>
printf ("Number of rows: %lu\n", (unsigned long) mysql_num_rows(result));
</PRE>

</DL>

<P>
The <code>MYSQL_FIELD</code> structure contains the members listed here:

</P>
<DL COMPACT>

<DT><code>char * name</code>
<DD>
The name of the field, as a null-terminated string.

<DT><code>char * table</code>
<DD>
The name of the table containing this field, if it isn't a calculated field.
For calculated fields, the <code>table</code> value is an empty string.

<DT><code>char * def</code>
<DD>
The default value of this field, as a null-terminated string.  This is set
only if you use <code>mysql_list_fields()</code>.

<DT><code>enum enum_field_types type</code>
<DD>
The type of the field.
The <code>type</code> value may be one of the following:

<TABLE BORDER>
<TR><TD><strong>Type Value</strong> </TD><TD> <strong>Type Description</strong>
</TD></TR>
<TR><TD><code>FIELD_TYPE_TINY</code> </TD><TD> <code>TINYINT</code> field
</TD></TR>
<TR><TD><code>FIELD_TYPE_SHORT</code> </TD><TD> <code>SMALLINT</code> field
</TD></TR>
<TR><TD><code>FIELD_TYPE_LONG</code> </TD><TD> <code>INTEGER</code> field
</TD></TR>
<TR><TD><code>FIELD_TYPE_INT24</code> </TD><TD> <code>MEDIUMINT</code> field
</TD></TR>
<TR><TD><code>FIELD_TYPE_LONGLONG</code> </TD><TD> <code>BIGINT</code> field
</TD></TR>
<TR><TD><code>FIELD_TYPE_DECIMAL</code> </TD><TD> <code>DECIMAL</code> or <code>NUMERIC</code> field
</TD></TR>
<TR><TD><code>FIELD_TYPE_FLOAT</code> </TD><TD> <code>FLOAT</code> field
</TD></TR>
<TR><TD><code>FIELD_TYPE_DOUBLE</code> </TD><TD> <code>DOUBLE</code> or <code>REAL</code> field
</TD></TR>
<TR><TD><code>FIELD_TYPE_TIMESTAMP</code> </TD><TD> <code>TIMESTAMP</code> field
</TD></TR>
<TR><TD><code>FIELD_TYPE_DATE</code> </TD><TD> <code>DATE</code> field
</TD></TR>
<TR><TD><code>FIELD_TYPE_TIME</code> </TD><TD> <code>TIME</code> field
</TD></TR>
<TR><TD><code>FIELD_TYPE_DATETIME</code> </TD><TD> <code>DATETIME</code> field
</TD></TR>
<TR><TD><code>FIELD_TYPE_YEAR</code> </TD><TD> <code>YEAR</code> field
</TD></TR>
<TR><TD><code>FIELD_TYPE_STRING</code> </TD><TD> <code>CHAR</code> field
</TD></TR>
<TR><TD><code>FIELD_TYPE_VAR_STRING</code> </TD><TD> <code>VARCHAR</code> field
</TD></TR>
<TR><TD><code>FIELD_TYPE_BLOB</code> </TD><TD> <code>BLOB</code> or <code>TEXT</code> field (use <code>max_length</code> to determine the maximum length)
</TD></TR>
<TR><TD><code>FIELD_TYPE_SET</code> </TD><TD> <code>SET</code> field
</TD></TR>
<TR><TD><code>FIELD_TYPE_ENUM</code> </TD><TD> <code>ENUM</code> field
</TD></TR>
<TR><TD><code>FIELD_TYPE_NULL</code> </TD><TD> <code>NULL</code>-type field
</TD></TR>
<TR><TD><code>FIELD_TYPE_CHAR</code> </TD><TD> Deprecated; use <code>FIELD_TYPE_TINY</code> instead
</TD></TR>
</TABLE>

You can use the <code>IS_NUM()</code> macro to test whether a field has a
numeric type.  Pass the <code>type</code> value to <code>IS_NUM()</code> and it
will evaluate to TRUE if the field is numeric:


<PRE>
if (IS_NUM(field-&#62;type))
    printf("Field is numeric\n");
</PRE>

<DT><code>unsigned int length</code>
<DD>
The width of the field, as specified in the table definition.

<DT><code>unsigned int max_length</code>
<DD>
The maximum width of the field for the result set (the length of the longest
field value for the rows actually in the result set). If you use
<code>mysql_store_result()</code> or <code>mysql_list_fields()</code>, this contains the
maximum length for the field.  If you use <code>mysql_use_result()</code>, the
value of this variable is zero.

<DT><code>unsigned int flags</code>
<DD>
Different bit-flags for the field.  The <code>flags</code> value may have zero
or more of the following bits set:

<TABLE BORDER>
<TR><TD><strong>Flag Value</strong> </TD><TD> <strong>Flag Description</strong>
</TD></TR>
<TR><TD><code>NOT_NULL_FLAG</code> </TD><TD> Field can't be <code>NULL</code>
</TD></TR>
<TR><TD><code>PRI_KEY_FLAG</code> </TD><TD> Field is part of a primary key
</TD></TR>
<TR><TD><code>UNIQUE_KEY_FLAG</code> </TD><TD> Field is part of a unique key
</TD></TR>
<TR><TD><code>MULTIPLE_KEY_FLAG</code> </TD><TD> Field is part of a non-unique key
</TD></TR>
<TR><TD><code>UNSIGNED_FLAG</code> </TD><TD> Field has the <code>UNSIGNED</code> attribute
</TD></TR>
<TR><TD><code>ZEROFILL_FLAG</code> </TD><TD> Field has the <code>ZEROFILL</code> attribute
</TD></TR>
<TR><TD><code>BINARY_FLAG</code> </TD><TD> Field has the <code>BINARY</code> attribute
</TD></TR>
<TR><TD><code>AUTO_INCREMENT_FLAG</code> </TD><TD> Field has the <code>AUTO_INCREMENT</code>
attribute
</TD></TR>
<TR><TD><code>ENUM_FLAG</code> </TD><TD> Field is an <code>ENUM</code> (deprecated)
</TD></TR>
<TR><TD><code>SET_FLAG</code> </TD><TD> Field is a <code>SET</code> (deprecated)
</TD></TR>
<TR><TD><code>BLOB_FLAG</code> </TD><TD> Field is a <code>BLOB</code> or <code>TEXT</code> (deprecated)
</TD></TR>
<TR><TD><code>TIMESTAMP_FLAG</code> </TD><TD> Field is a <code>TIMESTAMP</code> (deprecated)
</TD></TR>
</TABLE>

Use of the <code>BLOB_FLAG</code>, <code>ENUM_FLAG</code>, <code>SET_FLAG</code>, and
<code>TIMESTAMP_FLAG</code> flags is deprecated because they indicate the type of
a field rather than an attribute of its type.  It is preferable to test
<code>field-&#62;type</code> against <code>FIELD_TYPE_BLOB</code>, <code>FIELD_TYPE_ENUM</code>,
<code>FIELD_TYPE_SET</code>, or <code>FIELD_TYPE_TIMESTAMP</code> instead.

The following example illustrates a typical use of the <code>flags</code> value:


<PRE>
if (field-&#62;flags &#38; NOT_NULL_FLAG)
    printf("Field can't be null\n");
</PRE>

You may use the following convenience macros to determine the boolean
status of the <code>flags</code> value:

<TABLE BORDER>
<TR><TD><strong>Flag Status</strong> </TD><TD> <strong>Description</strong>
</TD></TR>
<TR><TD><code>IS_NOT_NULL(flags)</code> </TD><TD> True if this field is defined as <code>NOT NULL</code>
</TD></TR>
<TR><TD><code>IS_PRI_KEY(flags)</code> </TD><TD> True if this field is a primary key
</TD></TR>
<TR><TD><code>IS_BLOB(flags)</code> </TD><TD> True if this field is a <code>BLOB</code> or <code>TEXT</code> (deprecated; test <code>field-&#62;type</code> instead)
</TD></TR>
</TABLE>

<DT><code>unsigned int decimals</code>
<DD>
The number of decimals for numeric fields.
</DL>



<H3><A NAME="C_API_function_overview" HREF="manual_toc.html#C_API_function_overview">21.2.2  C API Function Overview</A></H3>

<P>
<A NAME="IDX2098"></A>
<A NAME="IDX2099"></A>

</P>
<P>
The functions available in the C API are summarized here and described in
greater detail in a later section.
See section <A HREF="manual_MySQL_APIs.html#C_API_functions">21.2.3  C API Function Descriptions</A>.

</P>
<TABLE BORDER>
<TR><TD><strong>Function</strong> </TD><TD> <strong>Description</strong>

</TD></TR>
<TR><TD><strong>mysql_affected_rows()</strong> </TD><TD>
Returns the number of rows changed/deleted/inserted by the last <code>UPDATE</code>,
<code>DELETE</code>, or <code>INSERT</code> query.

</TD></TR>
<TR><TD><strong>mysql_change_user()</strong> </TD><TD>
Changes user and database on an open connection.

</TD></TR>
<TR><TD><strong>mysql_charset_name()</strong> </TD><TD>
Returns the name of the default character set for the connection.

</TD></TR>
<TR><TD><strong>mysql_close()</strong> </TD><TD>
Closes a server connection.

</TD></TR>
<TR><TD><strong>mysql_connect()</strong> </TD><TD>
Connects to a MySQL server. This function is deprecated; use
<code>mysql_real_connect()</code> instead.

</TD></TR>
<TR><TD><strong>mysql_create_db()</strong> </TD><TD>
Creates a database. This function is deprecated; use the SQL statement
<code>CREATE DATABASE</code> instead.

</TD></TR>
<TR><TD><strong>mysql_data_seek()</strong> </TD><TD>
Seeks to an arbitrary row number in a query result set.

</TD></TR>
<TR><TD><strong>mysql_debug()</strong> </TD><TD>
Does a <code>DBUG_PUSH</code> with the given string.

</TD></TR>
<TR><TD><strong>mysql_drop_db()</strong> </TD><TD>
Drops a database. This function is deprecated; use the SQL statement
<code>DROP DATABASE</code> instead.

</TD></TR>
<TR><TD><strong>mysql_dump_debug_info()</strong> </TD><TD>
Makes the server write debug information to the log.

</TD></TR>
<TR><TD><strong>mysql_eof()</strong> </TD><TD>
Determines whether the last row of a result set has been read.
This function is deprecated; <code>mysql_errno()</code> or <code>mysql_error()</code>
may be used instead.

</TD></TR>
<TR><TD><strong>mysql_errno()</strong> </TD><TD>
Returns the error number for the most recently invoked MySQL function.

</TD></TR>
<TR><TD><strong>mysql_error()</strong> </TD><TD>
Returns the error message for the most recently invoked MySQL function.

</TD></TR>
<TR><TD><strong>mysql_escape_string()</strong> </TD><TD>
Escapes special characters in a string for use in an SQL statement.

</TD></TR>
<TR><TD><strong>mysql_fetch_field()</strong> </TD><TD>
Returns the type of the next table field.

</TD></TR>
<TR><TD><strong>mysql_fetch_field_direct()</strong> </TD><TD>
Returns the type of a table field, given a field number.

</TD></TR>
<TR><TD><strong>mysql_fetch_fields()</strong> </TD><TD>
Returns an array of all field structures.

</TD></TR>
<TR><TD><strong>mysql_fetch_lengths()</strong> </TD><TD>
Returns the lengths of all columns in the current row.

</TD></TR>
<TR><TD><strong>mysql_fetch_row()</strong> </TD><TD>
Fetches the next row from the result set.

</TD></TR>
<TR><TD><strong>mysql_field_seek()</strong> </TD><TD>
Puts the column cursor on a specified column.

</TD></TR>
<TR><TD><strong>mysql_field_count()</strong> </TD><TD>
Returns the number of result columns for the most recent statement.

</TD></TR>
<TR><TD><strong>mysql_field_tell()</strong> </TD><TD>
Returns the position of the field cursor used for the last
<code>mysql_fetch_field()</code>.

</TD></TR>
<TR><TD><strong>mysql_free_result()</strong> </TD><TD>
Frees memory used by a result set.

</TD></TR>
<TR><TD><strong>mysql_get_client_info()</strong> </TD><TD>
Returns client version information as a string.

</TD></TR>
<TR><TD><strong>mysql_get_client_version()</strong> </TD><TD>
Returns client version information as an integer.

</TD></TR>
<TR><TD><strong>mysql_get_host_info()</strong> </TD><TD>
Returns a string describing the connection.

</TD></TR>
<TR><TD><strong>mysql_get_server_version()</strong> </TD><TD>
Returns version number of server as an integer (new in 4.1).

</TD></TR>
<TR><TD><strong>mysql_get_proto_info()</strong> </TD><TD>
Returns the protocol version used by the connection.

</TD></TR>
<TR><TD><strong>mysql_get_server_info()</strong> </TD><TD>
Returns the server version number.

</TD></TR>
<TR><TD><strong>mysql_info()</strong> </TD><TD>
Returns information about the most recently executed query.

</TD></TR>
<TR><TD><strong>mysql_init()</strong> </TD><TD>
Gets or initializes a <code>MYSQL</code> structure.

</TD></TR>
<TR><TD><strong>mysql_insert_id()</strong> </TD><TD>
Returns the ID generated for an <code>AUTO_INCREMENT</code> column by the previous
query.

</TD></TR>
<TR><TD><strong>mysql_kill()</strong> </TD><TD>
Kills a given thread.

</TD></TR>
<TR><TD><strong>mysql_list_dbs()</strong> </TD><TD>
Returns database names matching a simple regular expression.

</TD></TR>
<TR><TD><strong>mysql_list_fields()</strong> </TD><TD>
Returns field names matching a simple regular expression.

</TD></TR>
<TR><TD><strong>mysql_list_processes()</strong> </TD><TD>
Returns a list of the current server threads.

</TD></TR>
<TR><TD><strong>mysql_list_tables()</strong> </TD><TD>
Returns table names matching a simple regular expression.

</TD></TR>
<TR><TD><strong>mysql_num_fields()</strong> </TD><TD>
Returns the number of columns in a result set.

</TD></TR>
<TR><TD><strong>mysql_num_rows()</strong> </TD><TD>
Returns the number of rows in a result set.

</TD></TR>
<TR><TD><strong>mysql_options()</strong> </TD><TD>
Sets connect options for <code>mysql_connect()</code>.

</TD></TR>
<TR><TD><strong>mysql_ping()</strong> </TD><TD>
Checks whether the connection to the server is working, reconnecting
as necessary.

</TD></TR>
<TR><TD><strong>mysql_query()</strong> </TD><TD>
Executes an SQL query specified as a null-terminated string.

</TD></TR>
<TR><TD><strong>mysql_real_connect()</strong> </TD><TD>
Connects to a MySQL server.

</TD></TR>
<TR><TD><strong>mysql_real_escape_string()</strong> </TD><TD>
Escapes special characters in a string for use in an SQL statement, taking
into account the current charset of the connection.

</TD></TR>
<TR><TD><strong>mysql_real_query()</strong> </TD><TD>
Executes an SQL query specified as a counted string.

</TD></TR>
<TR><TD><strong>mysql_reload()</strong> </TD><TD>
Tells the server to reload the grant tables.

</TD></TR>
<TR><TD><strong>mysql_row_seek()</strong> </TD><TD>
Seeks to a row offset in a result set, using value returned from
<code>mysql_row_tell()</code>.

</TD></TR>
<TR><TD><strong>mysql_row_tell()</strong> </TD><TD>
Returns the row cursor position.

</TD></TR>
<TR><TD><strong>mysql_select_db()</strong> </TD><TD>
Selects a database.

</TD></TR>
<TR><TD><strong>mysql_set_server_option()</strong> </TD><TD>
Sets an option for the connection (like <code>multi-statements</code>).

</TD></TR>
<TR><TD><strong>mysql_sqlstate()</strong> </TD><TD>
Returns the SQLSTATE error code for the last error.

</TD></TR>
<TR><TD><strong>mysql_shutdown()</strong> </TD><TD>
Shuts down the database server.

</TD></TR>
<TR><TD><strong>mysql_stat()</strong> </TD><TD>
Returns the server status as a string.

</TD></TR>
<TR><TD><strong>mysql_store_result()</strong> </TD><TD>
Retrieves a complete result set to the client.

</TD></TR>
<TR><TD><strong>mysql_thread_id()</strong> </TD><TD>
Returns the current thread ID.

</TD></TR>
<TR><TD><strong>mysql_thread_safe()</strong> </TD><TD>
Returns 1 if the clients are compiled as thread-safe.

</TD></TR>
<TR><TD><strong>mysql_use_result()</strong> </TD><TD>
Initiates a row-by-row result set retrieval.

</TD></TR>
<TR><TD><strong>mysql_warning_count()</strong> </TD><TD>
Returns the warning count for the previous SQL statement.

</TD></TR>
<TR><TD><strong>mysql_commit()</strong> </TD><TD>
Commits the transaction.

</TD></TR>
<TR><TD><strong>mysql_rollback()</strong> </TD><TD>
Rolls back the transaction.

</TD></TR>
<TR><TD><strong>mysql_autocommit()</strong> </TD><TD>
Toggles autocommit mode on/off.

</TD></TR>
<TR><TD><strong>mysql_more_results()</strong> </TD><TD>
Checks whether any more results exist.

</TD></TR>
<TR><TD><strong>mysql_next_result()</strong> </TD><TD>
Returns/initiates the next result in multiple-statement executions.
</TD></TR>
</TABLE>

<P>
To connect to the server, call <code>mysql_init()</code> to initialize a
connection handler, then call <code>mysql_real_connect()</code> with that
handler (along with other information such as the hostname, username,
and password).  Upon connection, <code>mysql_real_connect()</code> sets the
<code>reconnect</code> flag (part of the <code>MYSQL</code> structure) to a value of
<code>1</code> in versions of the API strictly older than 5.0.3, of <code>0</code> in newer
versions. A value of <code>1</code> for this flag indicates, in the event that a
query cannot be performed because of a lost connection, to try reconnecting to
the server before giving up.  When you are done with the connection, call
<code>mysql_close()</code> to terminate it.

</P>
<P>
While a connection is active, the client may send SQL queries to the server
using <code>mysql_query()</code> or <code>mysql_real_query()</code>.  The difference
between the two is that <code>mysql_query()</code> expects the query to be
specified as a null-terminated string whereas <code>mysql_real_query()</code>
expects a counted string.  If the string contains binary data (which may
include null bytes), you must use <code>mysql_real_query()</code>.

</P>
<P>
For each non-<code>SELECT</code> query (for example, <code>INSERT</code>, <code>UPDATE</code>,
<code>DELETE</code>), you can find out how many rows were changed (affected)
by calling <code>mysql_affected_rows()</code>.

</P>
<P>
For <code>SELECT</code> queries, you retrieve the selected rows as a result set.
(Note that some statements are <code>SELECT</code>-like in that they return rows.
These include <code>SHOW</code>, <code>DESCRIBE</code>, and <code>EXPLAIN</code>.  They should
be treated the same way as <code>SELECT</code> statements.)

</P>
<P>
There are two ways for a client to process result sets.  One way is to
retrieve the entire result set all at once by calling
<code>mysql_store_result()</code>.  This function acquires from the server all the
rows returned by the query and stores them in the client.  The second way is
for the client to initiate a row-by-row result set retrieval by calling
<code>mysql_use_result()</code>.  This function initializes the retrieval, but does
not actually get any rows from the server.

</P>
<P>
In both cases, you access rows by calling <code>mysql_fetch_row()</code>.  With
<code>mysql_store_result()</code>, <code>mysql_fetch_row()</code> accesses rows that have
already been fetched from the server.  With <code>mysql_use_result()</code>,
<code>mysql_fetch_row()</code> actually retrieves the row from the server.
Information about the size of the data in each row is available by
calling <code>mysql_fetch_lengths()</code>.

</P>
<P>
After you are done with a result set, call <code>mysql_free_result()</code>
to free the memory used for it.

</P>
<P>
The two retrieval mechanisms are complementary.  Client programs should
choose the approach that is most appropriate for their requirements.
In practice, clients tend to use <code>mysql_store_result()</code> more
commonly.

</P>
<P>
An advantage of <code>mysql_store_result()</code> is that because the rows have all
been fetched to the client, you not only can access rows sequentially, you
can move back and forth in the result set using <code>mysql_data_seek()</code> or
<code>mysql_row_seek()</code> to change the current row position within the result
set.  You can also find out how many rows there are by calling
<code>mysql_num_rows()</code>.  On the other hand, the memory requirements for
<code>mysql_store_result()</code> may be very high for large result sets and you
are more likely to encounter out-of-memory conditions.

</P>
<P>
An advantage of <code>mysql_use_result()</code> is that the client requires less
memory for the result set because it maintains only one row at a time (and
because there is less allocation overhead, <code>mysql_use_result()</code> can be
faster).  Disadvantages are that you must process each row quickly to avoid
tying up the server, you don't have random access to rows within the result
set (you can only access rows sequentially), and you don't know how many rows
are in the result set until you have retrieved them all.  Furthermore, you
<strong>must</strong> retrieve all the rows even if you determine in mid-retrieval that
you've found the information you were looking for.

</P>
<P>
The API makes it possible for clients to respond appropriately to
queries (retrieving rows only as necessary) without knowing whether or
not the query is a <code>SELECT</code>.  You can do this by calling
<code>mysql_store_result()</code> after each <code>mysql_query()</code> (or
<code>mysql_real_query()</code>).  If the result set call succeeds, the query
was a <code>SELECT</code> and you can read the rows.  If the result set call
fails, call <code>mysql_field_count()</code> to determine whether a
result was actually to be expected.  If <code>mysql_field_count()</code>
returns zero, the query returned no data (indicating that it was an
<code>INSERT</code>, <code>UPDATE</code>, <code>DELETE</code>, etc.), and was not
expected to return rows.  If <code>mysql_field_count()</code> is non-zero, the
query should have returned rows, but didn't.  This indicates that the
query was a <code>SELECT</code> that failed.  See the description for
<code>mysql_field_count()</code> for an example of how this can be done.

</P>
<P>
Both <code>mysql_store_result()</code> and <code>mysql_use_result()</code> allow you to
obtain information about the fields that make up the result set (the number
of fields, their names and types, etc.).  You can access field information
sequentially within the row by calling <code>mysql_fetch_field()</code> repeatedly,
or by field number within the row by calling
<code>mysql_fetch_field_direct()</code>.  The current field cursor position may be
changed by calling <code>mysql_field_seek()</code>.  Setting the field cursor
affects subsequent calls to <code>mysql_fetch_field()</code>.  You can also get
information for fields all at once by calling <code>mysql_fetch_fields()</code>.

</P>
<P>
For detecting and reporting errors, MySQL provides access to error
information by means of the <code>mysql_errno()</code> and <code>mysql_error()</code>
functions.  These return the error code or error message for the most
recently invoked function that can succeed or fail, allowing you to determine
when an error occurred and what it was.

</P>



<H3><A NAME="C_API_functions" HREF="manual_toc.html#C_API_functions">21.2.3  C API Function Descriptions</A></H3>

<P>
In the descriptions here, a parameter or return value of <code>NULL</code> means
<code>NULL</code> in the sense of the C programming language, not a
MySQL <code>NULL</code> value.

</P>
<P>
Functions that return a value generally return a pointer or an integer.
Unless specified otherwise, functions returning a pointer return a
non-<code>NULL</code> value to indicate success or a <code>NULL</code> value to indicate
an error, and functions returning an integer return zero to indicate success
or non-zero to indicate an error.  Note that ``non-zero'' means just that.
Unless the function description says otherwise, do not test against a value
other than zero:

</P>

<PRE>
if (result)                   /* correct */
    ... error ...

if (result &#60; 0)               /* incorrect */
    ... error ...

if (result == -1)             /* incorrect */
    ... error ...
</PRE>

<P>
When a function returns an error, the <strong>Errors</strong> subsection of the
function description lists the possible types of errors.  You can
find out which of these occurred by calling <code>mysql_errno()</code>.
A string representation of the error may be obtained by calling
<code>mysql_error()</code>.

</P>



<H4><A NAME="mysql_affected_rows" HREF="manual_toc.html#mysql_affected_rows">21.2.3.1  <code>mysql_affected_rows()</code></A></H4>

<P>
<A NAME="IDX2100"></A>

</P>
<P>
<code>my_ulonglong mysql_affected_rows(MYSQL *mysql)</code>

</P>

<H4>Description</H4>

<P>
Returns the number of rows changed by the last <code>UPDATE</code>, deleted by
the last <code>DELETE</code> or inserted by the last <code>INSERT</code>
statement. May be called immediately after <code>mysql_query()</code> for
<code>UPDATE</code>, <code>DELETE</code>, or <code>INSERT</code> statements.  For
<code>SELECT</code> statements, <code>mysql_affected_rows()</code> works like
<code>mysql_num_rows()</code>.

</P>

<H4>Return Values</H4>

<P>
An integer greater than zero indicates the number of rows affected or
retrieved.  Zero indicates that no records were updated for an
<code>UPDATE</code> statement, no rows matched the <code>WHERE</code> clause in the
query or that no query has yet been executed.  -1 indicates that the
query returned an error or that, for a <code>SELECT</code> query,
<code>mysql_affected_rows()</code> was called prior to calling
<code>mysql_store_result()</code>. Because <code>mysql_affected_rows()</code>
returns an unsigned value, you can check for -1 by comparing the
return value to <code>(my_ulonglong)-1</code> (or to <code>(my_ulonglong)~0</code>,
which is equivalent).

</P>

<H4>Errors</H4>

<P>
None.

</P>

<H4>Example</H4>


<PRE>
mysql_query(&#38;mysql,"UPDATE products SET cost=cost*1.25 WHERE group=10");
printf("%ld products updated",(long) mysql_affected_rows(&#38;mysql));
</PRE>

<P>
If you specify the flag <code>CLIENT_FOUND_ROWS</code> when connecting to
<code>mysqld</code>, <code>mysql_affected_rows()</code> will return the number of
rows matched by the <code>WHERE</code> statement for <code>UPDATE</code> statements.

</P>
<P>
Note that when you use a <code>REPLACE</code> command,
<code>mysql_affected_rows()</code> returns 2 if the new row replaced an
old row.  This is because in this case one row was inserted after the
duplicate was deleted.

</P>
<P>
If you use <code>INSERT ... ON DUPLICATE KEY UPDATE</code> to insert a row,
<code>mysql_affected_rows()</code> returns 1 if the row is inserted as a new row and
2 if an existing row is updated.

</P>



<H4><A NAME="mysql_change_user" HREF="manual_toc.html#mysql_change_user">21.2.3.2  <code>mysql_change_user()</code></A></H4>

<P>
<A NAME="IDX2101"></A>

</P>
<P>
<code>my_bool mysql_change_user(MYSQL *mysql, const char *user, const
char *password, const char *db)</code>

</P>

<H4>Description</H4>

<P>
Changes the user and causes the database specified by <code>db</code> to
become the default (current) database on the connection specified by
<code>mysql</code>.  In subsequent queries, this database is the default for
table references that do not include an explicit database specifier.

</P>
<P>
This function was introduced in MySQL 3.23.3.

</P>
<P>
<code>mysql_change_user()</code> fails if the connected user cannot be
authenticated or doesn't have permission to use the database.  In
this case the user and database are not changed

</P>
<P>
The <code>db</code> parameter may be set to <code>NULL</code> if you don't want to have a
default database.

</P>
<P>
Starting from MySQL 4.0.6 this command will always <code>ROLLBACK</code> any
active transactions, close all temporary tables, unlock all locked
tables and reset the state as if one had done a new connect.
This will happen even if the user didn't change.

</P>

<H4>Return Values</H4>

<P>
Zero for success.  Non-zero if an error occurred.

</P>

<H4>Errors</H4>

<P>
The same that you can get from <code>mysql_real_connect()</code>.

</P>
<DL COMPACT>

<DT><code>CR_COMMANDS_OUT_OF_SYNC</code>
<DD>
Commands were executed in an improper order.
<DT><code>CR_SERVER_GONE_ERROR</code>
<DD>
The MySQL server has gone away.
<DT><code>CR_SERVER_LOST</code>
<DD>
The connection to the server was lost during the query.
<DT><code>CR_UNKNOWN_ERROR</code>
<DD>
An unknown error occurred.
<DT><code>ER_UNKNOWN_COM_ERROR</code>
<DD>
The MySQL server doesn't implement this command (probably an old server).
<DT><code>ER_ACCESS_DENIED_ERROR</code>
<DD>
The user or password was wrong.
<DT><code>ER_BAD_DB_ERROR</code>
<DD>
The database didn't exist.
<DT><code>ER_DBACCESS_DENIED_ERROR</code>
<DD>
The user did not have access rights to the database.
<DT><code>ER_WRONG_DB_NAME</code>
<DD>
The database name was too long.
</DL>


<H4>Example</H4>


<PRE>
if (mysql_change_user(&#38;mysql, "user", "password", "new_database"))
{
   fprintf(stderr, "Failed to change user.  Error: %s\n",
           mysql_error(&#38;mysql));
}
</PRE>



<H4><A NAME="mysql_character_set_name" HREF="manual_toc.html#mysql_character_set_name">21.2.3.3  <code>mysql_character_set_name()</code></A></H4>

<P>
<A NAME="IDX2102"></A>

</P>
<P>
<code>const char *mysql_character_set_name(MYSQL *mysql)</code>

</P>

<H4>Description</H4>

<P>
Returns the default character set for the current connection.

</P>

<H4>Return Values</H4>

<P>
The default character set

</P>

<H4>Errors</H4>
<P>
None.

</P>



<H4><A NAME="mysql_close" HREF="manual_toc.html#mysql_close">21.2.3.4  <code>mysql_close()</code></A></H4>

<P>
<A NAME="IDX2103"></A>

</P>
<P>
<code>void mysql_close(MYSQL *mysql)</code>

</P>

<H4>Description</H4>
<P>
Closes a previously opened connection.  <code>mysql_close()</code> also deallocates
the connection handle pointed to by <code>mysql</code> if the handle was allocated
automatically by <code>mysql_init()</code> or <code>mysql_connect()</code>.

</P>

<H4>Return Values</H4>

<P>
None.

</P>

<H4>Errors</H4>

<P>
None.

</P>



<H4><A NAME="mysql_connect" HREF="manual_toc.html#mysql_connect">21.2.3.5  <code>mysql_connect()</code></A></H4>

<P>
<A NAME="IDX2104"></A>

</P>
<P>
<code>MYSQL *mysql_connect(MYSQL *mysql, const char *host, const char *user, const char *passwd)</code>

</P>

<H4>Description</H4>

<P>
This function is deprecated.  It is preferable to use
<code>mysql_real_connect()</code> instead.

</P>
<P>
<code>mysql_connect()</code> attempts to establish a connection to a MySQL
database engine running on <code>host</code>.  <code>mysql_connect()</code> must complete
successfully before you can execute any of the other API functions, with the
exception of <code>mysql_get_client_info()</code>.

</P>
<P>
The meanings of the parameters are the same as for the corresponding
parameters for <code>mysql_real_connect()</code> with the difference that the
connection parameter may be <code>NULL</code>. In this case the C API
allocates memory for the connection structure automatically and frees it
when you call <code>mysql_close()</code>. The disadvantage of this approach is
that you can't retrieve an error message if the connection fails.  (To
get error information from <code>mysql_errno()</code> or <code>mysql_error()</code>,
you must provide a valid <code>MYSQL</code> pointer.)

</P>

<H4>Return Values</H4>

<P>
Same as for <code>mysql_real_connect()</code>.

</P>

<H4>Errors</H4>

<P>
Same as for <code>mysql_real_connect()</code>.

</P>



<H4><A NAME="mysql_create_db" HREF="manual_toc.html#mysql_create_db">21.2.3.6  <code>mysql_create_db()</code></A></H4>

<P>
<A NAME="IDX2105"></A>

</P>
<P>
<code>int mysql_create_db(MYSQL *mysql, const char *db)</code>

</P>

<H4>Description</H4>
<P>
Creates the database named by the <code>db</code> parameter.

</P>
<P>
This function is deprecated.  It is preferable to use <code>mysql_query()</code>
to issue an SQL <code>CREATE DATABASE</code> statement instead.

</P>

<H4>Return Values</H4>

<P>
Zero if the database was created successfully. Non-zero if an error
occurred.

</P>

<H4>Errors</H4>
<DL COMPACT>

<DT><code>CR_COMMANDS_OUT_OF_SYNC</code>
<DD>
Commands were executed in an improper order.

<DT><code>CR_SERVER_GONE_ERROR</code>
<DD>
The MySQL server has gone away.

<DT><code>CR_SERVER_LOST</code>
<DD>
The connection to the server was lost during the query.

<DT><code>CR_UNKNOWN_ERROR</code>
<DD>
An unknown error occurred.
</DL>


<H4>Example</H4>


<PRE>
if(mysql_create_db(&#38;mysql, "my_database"))
{
   fprintf(stderr, "Failed to create new database.  Error: %s\n",
           mysql_error(&#38;mysql));
}
</PRE>



<H4><A NAME="mysql_data_seek" HREF="manual_toc.html#mysql_data_seek">21.2.3.7  <code>mysql_data_seek()</code></A></H4>

<P>
<A NAME="IDX2106"></A>

</P>
<P>
<code>void mysql_data_seek(MYSQL_RES *result, my_ulonglong offset)</code>

</P>

<H4>Description</H4>
<P>
Seeks to an arbitrary row in a query result set.  The <code>offset</code>
value is a row number and should be in the range from <code>0</code> to
<code>mysql_num_rows(result)-1</code>.

</P>
<P>
This function requires that the result set structure contains the
entire result of the query, so <code>mysql_data_seek()</code> may be
used only in conjunction with <code>mysql_store_result()</code>, not with
<code>mysql_use_result()</code>.

</P>

<H4>Return Values</H4>

<P>
None.

</P>

<H4>Errors</H4>
<P>
None.

</P>



<H4><A NAME="mysql_debug" HREF="manual_toc.html#mysql_debug">21.2.3.8  <code>mysql_debug()</code></A></H4>

<P>
<A NAME="IDX2107"></A>

</P>
<P>
<code>void mysql_debug(const char *debug)</code>

</P>

<H4>Description</H4>
<P>
Does a <code>DBUG_PUSH</code> with the given string. <code>mysql_debug()</code> uses the
Fred Fish debug library. To use this function, you must compile the client
library to support debugging.
See section <A HREF="manual_Porting.html#Debugging_server">E.1  Debugging a MySQL Server</A>. See section <A HREF="manual_Porting.html#Debugging_client">E.2  Debugging a MySQL Client</A>.

</P>

<H4>Return Values</H4>

<P>
None.

</P>

<H4>Errors</H4>
<P>
None.

</P>

<H4>Example</H4>

<P>
The call shown here causes the client library to generate a trace file in
<tt>`/tmp/client.trace'</tt> on the client machine:

</P>

<PRE>
mysql_debug("d:t:O,/tmp/client.trace");
</PRE>



<H4><A NAME="mysql_drop_db" HREF="manual_toc.html#mysql_drop_db">21.2.3.9  <code>mysql_drop_db()</code></A></H4>

<P>
<A NAME="IDX2108"></A>

</P>
<P>
<code>int mysql_drop_db(MYSQL *mysql, const char *db)</code>

</P>

<H4>Description</H4>
<P>
Drops the database named by the <code>db</code> parameter.

</P>
<P>
This function is deprecated.  It is preferable to use <code>mysql_query()</code>
to issue an SQL <code>DROP DATABASE</code> statement instead.

</P>

<H4>Return Values</H4>

<P>
Zero if the database was dropped successfully. Non-zero if an error
occurred.

</P>

<H4>Errors</H4>

<DL COMPACT>

<DT><code>CR_COMMANDS_OUT_OF_SYNC</code>
<DD>
Commands were executed in an improper order.
<DT><code>CR_SERVER_GONE_ERROR</code>
<DD>
The MySQL server has gone away.
<DT><code>CR_SERVER_LOST</code>
<DD>
The connection to the server was lost during the query.
<DT><code>CR_UNKNOWN_ERROR</code>
<DD>
An unknown error occurred.
</DL>


<H4>Example</H4>


<PRE>
if(mysql_drop_db(&#38;mysql, "my_database"))
  fprintf(stderr, "Failed to drop the database: Error: %s\n",
          mysql_error(&#38;mysql));
</PRE>



<H4><A NAME="mysql_dump_debug_info" HREF="manual_toc.html#mysql_dump_debug_info">21.2.3.10  <code>mysql_dump_debug_info()</code></A></H4>

<P>
<A NAME="IDX2109"></A>

</P>
<P>
<code>int mysql_dump_debug_info(MYSQL *mysql)</code>

</P>

<H4>Description</H4>

<P>
Instructs the server to write some debug information to the log. For
this to work, the connected user must have the <code>SUPER</code> privilege.

</P>

<H4>Return Values</H4>

<P>
Zero if the command was successful. Non-zero if an error occurred.

</P>

<H4>Errors</H4>
<DL COMPACT>

<DT><code>CR_COMMANDS_OUT_OF_SYNC</code>
<DD>
Commands were executed in an improper order.
<DT><code>CR_SERVER_GONE_ERROR</code>
<DD>
The MySQL server has gone away.
<DT><code>CR_SERVER_LOST</code>
<DD>
The connection to the server was lost during the query.
<DT><code>CR_UNKNOWN_ERROR</code>
<DD>
An unknown error occurred.
</DL>



<H4><A NAME="mysql_eof" HREF="manual_toc.html#mysql_eof">21.2.3.11  <code>mysql_eof()</code></A></H4>

<P>
<A NAME="IDX2110"></A>

</P>
<P>
<code>my_bool mysql_eof(MYSQL_RES *result)</code>

</P>

<H4>Description</H4>

<P>
This function is deprecated.  <code>mysql_errno()</code> or <code>mysql_error()</code>
may be used instead.

</P>
<P>
<code>mysql_eof()</code> determines whether the last row of a result
set has been read.

</P>
<P>
If you acquire a result set from a successful call to
<code>mysql_store_result()</code>, the client receives the entire set in one
operation.  In this case, a <code>NULL</code> return from
<code>mysql_fetch_row()</code> always means the end of the result set has been
reached and it is unnecessary to call <code>mysql_eof()</code>.  When used
with <code>mysql_store_result()</code>, <code>mysql_eof()</code> will always return
true.

</P>
<P>
On the other hand, if you use <code>mysql_use_result()</code> to initiate a result
set retrieval, the rows of the set are obtained from the server one by one as
you call <code>mysql_fetch_row()</code> repeatedly.  Because an error may occur on
the connection during this process, a <code>NULL</code> return value from
<code>mysql_fetch_row()</code> does not necessarily mean the end of the result set
was reached normally.  In this case, you can use <code>mysql_eof()</code> to
determine what happened.  <code>mysql_eof()</code> returns a non-zero value if the
end of the result set was reached and zero if an error occurred.

</P>
<P>
Historically, <code>mysql_eof()</code> predates the standard MySQL error
functions <code>mysql_errno()</code> and <code>mysql_error()</code>.  Because those error
functions provide the same information, their use is preferred over
<code>mysql_eof()</code>, which is now deprecated.  (In fact, they provide more
information, because <code>mysql_eof()</code> returns only a boolean value whereas
the error functions indicate a reason for the error when one occurs.)

</P>

<H4>Return Values</H4>

<P>
Zero if no error occurred. Non-zero if the end of the result set has been
reached.

</P>

<H4>Errors</H4>
<P>
None.

</P>

<H4>Example</H4>

<P>
The following example shows how you might use <code>mysql_eof()</code>:

</P>

<PRE>
mysql_query(&#38;mysql,"SELECT * FROM some_table");
result = mysql_use_result(&#38;mysql);
while((row = mysql_fetch_row(result)))
{
    // do something with data
}
if(!mysql_eof(result))  // mysql_fetch_row() failed due to an error
{
    fprintf(stderr, "Error: %s\n", mysql_error(&#38;mysql));
}
</PRE>

<P>
However, you can achieve the same effect with the standard MySQL
error functions:

</P>

<PRE>
mysql_query(&#38;mysql,"SELECT * FROM some_table");
result = mysql_use_result(&#38;mysql);
while((row = mysql_fetch_row(result)))
{
    // do something with data
}
if(mysql_errno(&#38;mysql))  // mysql_fetch_row() failed due to an error
{
    fprintf(stderr, "Error: %s\n", mysql_error(&#38;mysql));
}
</PRE>



<H4><A NAME="mysql_errno" HREF="manual_toc.html#mysql_errno">21.2.3.12  <code>mysql_errno()</code></A></H4>

<P>
<A NAME="IDX2111"></A>

</P>
<P>
<code>unsigned int mysql_errno(MYSQL *mysql)</code>

</P>

<H4>Description</H4>

<P>
For the connection specified by <code>mysql</code>, <code>mysql_errno()</code> returns
the error code for the most recently invoked API function that can succeed
or fail.  A return value of zero means that no error occurred. Client error
message numbers are listed in the MySQL <tt>`errmsg.h'</tt> header file.
Server error message numbers are listed in <tt>`mysqld_error.h'</tt>. In the
MySQL source distribution you can find a complete list of
error messages and error numbers in the file <tt>`Docs/mysqld_error.txt'</tt>.
The server error codes also are listed at section <A HREF="manual_Error-handling.html#Error-handling">23  Error Handling in MySQL</A>.

</P>
<P>
Note that some functions like <code>mysql_fetch_row()</code> don't set
<code>mysql_errno()</code> if they succeed.

</P>
<P>
A rule of thumb is that all functions that have to ask the server for
information will reset <code>mysql_errno()</code> if they succeed.

</P>

<H4>Return Values</H4>

<P>
An error code value for the last <code>mysql_<var>xxx</var>()</code> call, if it failed.
zero means no error occurred.

</P>

<H4>Errors</H4>
<P>
None.

</P>



<H4><A NAME="mysql_error" HREF="manual_toc.html#mysql_error">21.2.3.13  <code>mysql_error()</code></A></H4>

<P>
<A NAME="IDX2112"></A>

</P>
<P>
<code>const char *mysql_error(MYSQL *mysql)</code>

</P>

<H4>Description</H4>

<P>
For the connection specified by <code>mysql</code>, <code>mysql_error()</code>
returns a null-terminated string containing the error message for the
most recently invoked API function that failed. If a function didn't
fail, the return value of <code>mysql_error()</code> may be the previous error
or an empty string to indicate no error.

</P>
<P>
A rule of thumb is that all functions that have to ask the server for
information will reset <code>mysql_error()</code> if they succeed.

</P>
<P>
For functions that reset <code>mysql_errno()</code>, the following two tests
are equivalent:

</P>

<PRE>
if(mysql_errno(&#38;mysql))
{
    // an error occurred
}

if(mysql_error(&#38;mysql)[0] != '\0')
{
    // an error occurred
}
</PRE>

<P>
The language of the client error messages may be changed by
recompiling the MySQL client library. Currently you can choose
error messages in several different languages.
See section <A HREF="manual_MySQL_Database_Administration.html#Languages">5.8.2  Setting the Error Message Language</A>.

</P>

<H4>Return Values</H4>

<P>
A null-terminated character string that describes the error.  An empty string
if no error occurred.

</P>

<H4>Errors</H4>
<P>
None.

</P>



<H4><A NAME="mysql_escape_string" HREF="manual_toc.html#mysql_escape_string">21.2.3.14  <code>mysql_escape_string()</code></A></H4>

<P>
<A NAME="IDX2113"></A>

</P>
<P>
You should use <code>mysql_real_escape_string()</code> instead!

</P>
<P>
This function is identical to <code>mysql_real_escape_string()</code> except
that <code>mysql_real_escape_string()</code> takes a connection handler as
its first argument and escapes the string according to the current
character set.  <code>mysql_escape_string()</code> does not take a connection
argument and does not respect the current charset setting.

</P>



<H4><A NAME="mysql_fetch_field" HREF="manual_toc.html#mysql_fetch_field">21.2.3.15  <code>mysql_fetch_field()</code></A></H4>

<P>
<A NAME="IDX2114"></A>

</P>
<P>
<code>MYSQL_FIELD *mysql_fetch_field(MYSQL_RES *result)</code>

</P>

<H4>Description</H4>

<P>
Returns the definition of one column of a result set as a <code>MYSQL_FIELD</code>
structure. Call this function repeatedly to retrieve information about all
columns in the result set.  <code>mysql_fetch_field()</code> returns <code>NULL</code>
when no more fields are left.

</P>
<P>
<code>mysql_fetch_field()</code> is reset to return information about the first
field each time you execute a new <code>SELECT</code> query.  The field returned by
<code>mysql_fetch_field()</code> is also affected by calls to
<code>mysql_field_seek()</code>.

</P>
<P>
If you've called <code>mysql_query()</code> to perform a <code>SELECT</code> on a table
but have not called <code>mysql_store_result()</code>, MySQL returns the
default blob length (8KB) if you call <code>mysql_fetch_field()</code> to ask
for the length of a <code>BLOB</code> field.  (The 8KB size is chosen because
MySQL doesn't know the maximum length for the <code>BLOB</code>. This
should be made configurable sometime.) Once you've retrieved the result set,
<code>field-&#62;max_length</code> contains the length of the largest value for this
column in the specific query.

</P>

<H4>Return Values</H4>

<P>
The <code>MYSQL_FIELD</code> structure for the current column. <code>NULL</code>
if no columns are left.

</P>

<H4>Errors</H4>
<P>
None.

</P>

<H4>Example</H4>


<PRE>
MYSQL_FIELD *field;

while((field = mysql_fetch_field(result)))
{
    printf("field name %s\n", field-&#62;name);
}
</PRE>



<H4><A NAME="mysql_fetch_fields" HREF="manual_toc.html#mysql_fetch_fields">21.2.3.16  <code>mysql_fetch_fields()</code></A></H4>

<P>
<A NAME="IDX2115"></A>

</P>
<P>
<code>MYSQL_FIELD *mysql_fetch_fields(MYSQL_RES *result)</code>

</P>

<H4>Description</H4>

<P>
Returns an array of all <code>MYSQL_FIELD</code> structures for a result set.
Each structure provides the field definition for one column of the result
set.

</P>

<H4>Return Values</H4>

<P>
An array of <code>MYSQL_FIELD</code> structures for all columns of a result set.

</P>

<H4>Errors</H4>
<P>
None.

</P>

<H4>Example</H4>


<PRE>
unsigned int num_fields;
unsigned int i;
MYSQL_FIELD *fields;

num_fields = mysql_num_fields(result);
fields = mysql_fetch_fields(result);
for(i = 0; i &#60; num_fields; i++)
{
   printf("Field %u is %s\n", i, fields[i].name);
}
</PRE>



<H4><A NAME="mysql_fetch_field_direct" HREF="manual_toc.html#mysql_fetch_field_direct">21.2.3.17  <code>mysql_fetch_field_direct()</code></A></H4>

<P>
<A NAME="IDX2116"></A>

</P>
<P>
<code>MYSQL_FIELD *mysql_fetch_field_direct(MYSQL_RES *result, unsigned int fieldnr)</code>

</P>

<H4>Description</H4>

<P>
Given a field number <code>fieldnr</code> for a column within a result set, returns
that column's field definition as a <code>MYSQL_FIELD</code> structure. You may use
this function to retrieve the definition for an arbitrary column.  The value
of <code>fieldnr</code> should be in the range from 0 to
<code>mysql_num_fields(result)-1</code>.

</P>

<H4>Return Values</H4>

<P>
The <code>MYSQL_FIELD</code> structure for the specified column.

</P>

<H4>Errors</H4>
<P>
None.

</P>

<H4>Example</H4>


<PRE>
unsigned int num_fields;
unsigned int i;
MYSQL_FIELD *field;

num_fields = mysql_num_fields(result);
for(i = 0; i &#60; num_fields; i++)
{
    field = mysql_fetch_field_direct(result, i);
    printf("Field %u is %s\n", i, field-&#62;name);
}
</PRE>



<H4><A NAME="mysql_fetch_lengths" HREF="manual_toc.html#mysql_fetch_lengths">21.2.3.18  <code>mysql_fetch_lengths()</code></A></H4>

<P>
<A NAME="IDX2117"></A>

</P>
<P>
<code>unsigned long *mysql_fetch_lengths(MYSQL_RES *result)</code>

</P>

<H4>Description</H4>

<P>
Returns the lengths of the columns of the current row within a result set.
If you plan to copy field values, this length information is also useful for
optimization, because you can avoid calling <code>strlen()</code>.  In addition, if
the result set contains binary data, you <strong>must</strong> use this function to
determine the size of the data, because <code>strlen()</code> returns incorrect
results for any field containing null characters.

</P>
<P>
The length for empty columns and for columns containing <code>NULL</code> values is
zero.  To see how to distinguish these two cases, see the description for
<code>mysql_fetch_row()</code>.

</P>

<H4>Return Values</H4>

<P>
An array of unsigned long integers representing the size of each column (not
including any terminating null characters).
<code>NULL</code> if an error occurred.

</P>

<H4>Errors</H4>
<P>
<code>mysql_fetch_lengths()</code> is valid only for the current row of the result
set.  It returns <code>NULL</code> if you call it before calling
<code>mysql_fetch_row()</code> or after retrieving all rows in the result.

</P>

<H4>Example</H4>


<PRE>
MYSQL_ROW row;
unsigned long *lengths;
unsigned int num_fields;
unsigned int i;

row = mysql_fetch_row(result);
if (row)
{
    num_fields = mysql_num_fields(result);
    lengths = mysql_fetch_lengths(result);
    for(i = 0; i &#60; num_fields; i++)
    {
         printf("Column %u is %lu bytes in length.\n", i, lengths[i]);
    }
}
</PRE>



<H4><A NAME="mysql_fetch_row" HREF="manual_toc.html#mysql_fetch_row">21.2.3.19  <code>mysql_fetch_row()</code></A></H4>

<P>
<A NAME="IDX2118"></A>

</P>
<P>
<code>MYSQL_ROW mysql_fetch_row(MYSQL_RES *result)</code>

</P>

<H4>Description</H4>

<P>
Retrieves the next row of a result set. When used after
<code>mysql_store_result()</code>, <code>mysql_fetch_row()</code> returns <code>NULL</code>
when there are no more rows to retrieve.  When used after
<code>mysql_use_result()</code>, <code>mysql_fetch_row()</code> returns <code>NULL</code> when
there are no more rows to retrieve or if an error occurred.

</P>
<P>
The number of values in the row is given by <code>mysql_num_fields(result)</code>.
If <code>row</code> holds the return value from a call to <code>mysql_fetch_row()</code>,
pointers to the values are accessed as <code>row[0]</code> to
<code>row[mysql_num_fields(result)-1]</code>.  <code>NULL</code> values in the row are
indicated by <code>NULL</code> pointers.

</P>
<P>
The lengths of the field values in the row may be obtained by calling
<code>mysql_fetch_lengths()</code>.  Empty fields and fields containing
<code>NULL</code> both have length 0; you can distinguish these by checking
the pointer for the field value.  If the pointer is <code>NULL</code>, the field
is <code>NULL</code>; otherwise, the field is empty.

</P>

<H4>Return Values</H4>

<P>
A <code>MYSQL_ROW</code> structure for the next row.  <code>NULL</code> if
there are no more rows to retrieve or if an error occurred.

</P>

<H4>Errors</H4>

<P>
Note that error is not reset between calls to <code>mysql_fetch_row()</code>

</P>
<DL COMPACT>

<DT><code>CR_SERVER_LOST</code>
<DD>
The connection to the server was lost during the query.
<DT><code>CR_UNKNOWN_ERROR</code>
<DD>
An unknown error occurred.
</DL>


<H4>Example</H4>


<PRE>
MYSQL_ROW row;
unsigned int num_fields;
unsigned int i;

num_fields = mysql_num_fields(result);
while ((row = mysql_fetch_row(result)))
{
   unsigned long *lengths;
   lengths = mysql_fetch_lengths(result);
   for(i = 0; i &#60; num_fields; i++)
   {
       printf("[%.*s] ", (int) lengths[i], row[i] ? row[i] : "NULL");
   }
   printf("\n");
}
</PRE>



<H4><A NAME="mysql_field_count" HREF="manual_toc.html#mysql_field_count">21.2.3.20  <code>mysql_field_count()</code></A></H4>

<P>
<A NAME="IDX2119"></A>

</P>
<P>
<code>unsigned int mysql_field_count(MYSQL *mysql)</code>

</P>
<P>
If you are using a version of MySQL earlier than Version 3.22.24, you
should use <code>unsigned int mysql_num_fields(MYSQL *mysql)</code> instead.

</P>

<H4>Description</H4>

<P>
Returns the number of columns for the most recent query on the connection.

</P>
<P>
The normal use of this function is when <code>mysql_store_result()</code>
returned <code>NULL</code> (and thus you have no result set pointer).
In this case, you can call <code>mysql_field_count()</code> to
determine whether <code>mysql_store_result()</code> should have produced a
non-empty result.  This allows the client program to take proper action
without knowing whether the query was a <code>SELECT</code> (or
<code>SELECT</code>-like) statement.  The example shown here illustrates how this
may be done.

</P>
<P>
See section <A HREF="manual_MySQL_APIs.html#NULL_mysql_store_result">21.2.13.1  Why <code>mysql_store_result()</code> Sometimes Returns <code>NULL</code> After <code>mysql_query()</code> Returns Success</A>.

</P>

<H4>Return Values</H4>

<P>
An unsigned integer representing the number of columns in a result set.

</P>

<H4>Errors</H4>
<P>
None.

</P>

<H4>Example</H4>


<PRE>
MYSQL_RES *result;
unsigned int num_fields;
unsigned int num_rows;

if (mysql_query(&#38;mysql,query_string))
{
    // error
}
else // query succeeded, process any data returned by it
{
    result = mysql_store_result(&#38;mysql);
    if (result)  // there are rows
    {
        num_fields = mysql_num_fields(result);
        // retrieve rows, then call mysql_free_result(result)
    }
    else  // mysql_store_result() returned nothing; should it have?
    {
        if(mysql_field_count(&#38;mysql) == 0)
        {
            // query does not return data
            // (it was not a SELECT)
            num_rows = mysql_affected_rows(&#38;mysql);
        }
        else // mysql_store_result() should have returned data
        {
            fprintf(stderr, "Error: %s\n", mysql_error(&#38;mysql));
        }
    }
}
</PRE>

<P>
An alternative is to replace the <code>mysql_field_count(&#38;mysql)</code> call with
<code>mysql_errno(&#38;mysql)</code>.  In this case, you are checking directly for an
error from <code>mysql_store_result()</code> rather than inferring from the value
of <code>mysql_field_count()</code> whether the statement was a
<code>SELECT</code>.

</P>



<H4><A NAME="mysql_field_seek" HREF="manual_toc.html#mysql_field_seek">21.2.3.21  <code>mysql_field_seek()</code></A></H4>

<P>
<A NAME="IDX2120"></A>

</P>
<P>
<code>MYSQL_FIELD_OFFSET mysql_field_seek(MYSQL_RES *result, MYSQL_FIELD_OFFSET offset)</code>

</P>

<H4>Description</H4>

<P>
Sets the field cursor to the given offset.   The next call to
<code>mysql_fetch_field()</code> will retrieve the field definition of the column
associated with that offset.

</P>
<P>
To seek to the beginning of a row, pass an <code>offset</code> value of zero.

</P>

<H4>Return Values</H4>

<P>
The previous value of the field cursor.

</P>

<H4>Errors</H4>
<P>
None.

</P>



<H4><A NAME="mysql_field_tell" HREF="manual_toc.html#mysql_field_tell">21.2.3.22  <code>mysql_field_tell()</code></A></H4>

<P>
<A NAME="IDX2121"></A>

</P>
<P>
<code>MYSQL_FIELD_OFFSET mysql_field_tell(MYSQL_RES *result)</code>

</P>

<H4>Description</H4>

<P>
Returns the position of the field cursor used for the last
<code>mysql_fetch_field()</code>. This value can be used as an argument to
<code>mysql_field_seek()</code>.

</P>

<H4>Return Values</H4>

<P>
The current offset of the field cursor.

</P>

<H4>Errors</H4>
<P>
None.

</P>



<H4><A NAME="mysql_free_result" HREF="manual_toc.html#mysql_free_result">21.2.3.23  <code>mysql_free_result()</code></A></H4>

<P>
<A NAME="IDX2122"></A>

</P>
<P>
<code>void mysql_free_result(MYSQL_RES *result)</code>

</P>

<H4>Description</H4>

<P>
Frees the memory allocated for a result set by <code>mysql_store_result()</code>,
<code>mysql_use_result()</code>, <code>mysql_list_dbs()</code>, etc.  When you are done
with a result set, you must free the memory it uses by calling
<code>mysql_free_result()</code>.

</P>
<P>
Do not attempt to access a result set after freeing it.

</P>

<H4>Return Values</H4>

<P>
None.

</P>

<H4>Errors</H4>
<P>
None.

</P>



<H4><A NAME="mysql_get_client_info" HREF="manual_toc.html#mysql_get_client_info">21.2.3.24  <code>mysql_get_client_info()</code></A></H4>

<P>
<A NAME="IDX2123"></A>

</P>
<P>
<code>char *mysql_get_client_info(void)</code>

</P>

<H4>Description</H4>

<P>
Returns a string that represents the client library version.

</P>

<H4>Return Values</H4>

<P>
A character string that represents the MySQL client library version.

</P>

<H4>Errors</H4>
<P>
None.

</P>



<H4><A NAME="mysql_get_client_version" HREF="manual_toc.html#mysql_get_client_version">21.2.3.25  <code>mysql_get_client_version()</code></A></H4>

<P>
<A NAME="IDX2124"></A>

</P>
<P>
<code>unsigned long mysql_get_client_version(void)</code>

</P>

<H4>Description</H4>

<P>
Returns an integer that represents the client library version.
The value has the format <code>XYYZZ</code> where <code>X</code> is the major
version, <code>YY</code> is the release level, and <code>ZZ</code> is the version
number within the release level. For example, a value of <code>40102</code>
represents a client library version of <code>4.1.2</code>.

</P>
<P>
This function was added in MySQL 4.0.16.

</P>

<H4>Return Values</H4>

<P>
An integer that represents the MySQL client library version.

</P>

<H4>Errors</H4>
<P>
None.

</P>


<H4><A NAME="mysql_get_host_info" HREF="manual_toc.html#mysql_get_host_info">21.2.3.26  <code>mysql_get_host_info()</code></A></H4>

<P>
<A NAME="IDX2125"></A>

</P>
<P>
<code>char *mysql_get_host_info(MYSQL *mysql)</code>

</P>

<H4>Description</H4>

<P>
Returns a string describing the type of connection in use, including the
server hostname.

</P>

<H4>Return Values</H4>

<P>
A character string representing the server hostname and the connection type.

</P>

<H4>Errors</H4>
<P>
None.

</P>



<H4><A NAME="mysql_get_proto_info" HREF="manual_toc.html#mysql_get_proto_info">21.2.3.27  <code>mysql_get_proto_info()</code></A></H4>

<P>
<A NAME="IDX2126"></A>

</P>
<P>
<code>unsigned int mysql_get_proto_info(MYSQL *mysql)</code>

</P>

<H4>Description</H4>

<P>
Returns the protocol version used by current connection.

</P>

<H4>Return Values</H4>

<P>
An unsigned integer representing the protocol version used by the current
connection.

</P>

<H4>Errors</H4>
<P>
None.

</P>



<H4><A NAME="mysql_get_server_info" HREF="manual_toc.html#mysql_get_server_info">21.2.3.28  <code>mysql_get_server_info()</code></A></H4>

<P>
<A NAME="IDX2127"></A>

</P>
<P>
<code>char *mysql_get_server_info(MYSQL *mysql)</code>

</P>

<H4>Description</H4>

<P>
Returns a string that represents the server version number.

</P>

<H4>Return Values</H4>

<P>
A character string that represents the server version number.

</P>

<H4>Errors</H4>
<P>
None.

</P>



<H4><A NAME="mysql_get_server_version" HREF="manual_toc.html#mysql_get_server_version">21.2.3.29  <code>mysql_get_server_version()</code></A></H4>

<P>
<A NAME="IDX2128"></A>

</P>
<P>
<code>unsigned long mysql_get_server_version(MYSQL *mysql)</code>

</P>

<H4>Description</H4>

<P>
Returns the version number of the server as an integer.

</P>
<P>
This function was added in MySQL 4.1.0.

</P>

<H4>Return Values</H4>

<P>
A number that represents the MySQL server version in this format:

</P>

<PRE>
major_version*10000 + minor_version *100 + sub_version
</PRE>

<P>
For example, 4.1.2 is returned as 40102.

</P>
<P>
This function is useful in client programs for quickly determining
whether some version-specific server capability exists.

</P>

<H4>Errors</H4>
<P>
None.

</P>



<H4><A NAME="mysql_hex_string" HREF="manual_toc.html#mysql_hex_string">21.2.3.30  <code>mysql_hex_string()</code></A></H4>

<P>
<A NAME="IDX2129"></A>

</P>
<P>
<code>unsigned long mysql_hex_string(char *to, const char *from, unsigned long length)</code>

</P>

<H4>Description</H4>

<P>
This function is used to create a legal SQL string that you can use in a
SQL statement. See section <A HREF="manual_Language_Structure.html#String_syntax">9.1.1  Strings</A>.

</P>
<P>
The string in <code>from</code> is encoded to hexadecimal format, with each
character encoded as two hexadecimal digits.  The result is placed in
<code>to</code> and a terminating null byte is appended.

</P>
<P>
The string pointed to by <code>from</code> must be <code>length</code> bytes long.
You must allocate the <code>to</code> buffer to be at least <code>length*2+1</code>
bytes long.  When <code>mysql_hex_string()</code> returns, the contents of
<code>to</code> will be a null-terminated string.  The return value is the length
of the encoded string, not including the terminating null character.

</P>
<P>
The return value can be placed into an SQL statement using either
<code>0x<var>value</var></code> or <code>X'<var>value</var>'</code> format.  However, the
return value does not include the <code>0x</code> or <code>X'...'</code>. The caller
must supply whichever of those is desired.

</P>
<P>
<code>mysql_hex_string()</code> was added in MySQL 4.0.23 and 4.1.8.

</P>

<H4>Example</H4>


<PRE>
char query[1000],*end;

end = strmov(query,"INSERT INTO test_table values(");
end = strmov(end,"0x");
end += mysql_hex_string(end,"What's this",11);
end = strmov(end,",0x");
end += mysql_hex_string(end,"binary data: \0\r\n",16);
*end++ = ')';

if (mysql_real_query(&#38;mysql,query,(unsigned int) (end - query)))
{
   fprintf(stderr, "Failed to insert row, Error: %s\n",
           mysql_error(&#38;mysql));
}
</PRE>

<P>
The <code>strmov()</code> function used in the example is included in the
<code>mysqlclient</code> library and works like <code>strcpy()</code> but returns a
pointer to the terminating null of the first parameter.

</P>

<H4>Return Values</H4>

<P>
The length of the value placed into <code>to</code>, not including the
terminating null character.

</P>

<H4>Errors</H4>
<P>
None.

</P>



<H4><A NAME="mysql_info" HREF="manual_toc.html#mysql_info">21.2.3.31  <code>mysql_info()</code></A></H4>

<P>
<A NAME="IDX2130"></A>

</P>
<P>
<code>char *mysql_info(MYSQL *mysql)</code>

</P>

<H4>Description</H4>

<P>
Retrieves a string providing information about the most recently executed
query, but only for the statements listed here.  For other statements,
<code>mysql_info()</code> returns <code>NULL</code>.  The format of the string varies
depending on the type of query, as described here.  The numbers are
illustrative only; the string will contain values appropriate for the query.

</P>
<DL COMPACT>

<DT><code>INSERT INTO ... SELECT ...</code>
<DD>
String format: <code>Records: 100 Duplicates: 0 Warnings: 0</code>
<DT><code>INSERT INTO ... VALUES (...),(...),(...)...</code>
<DD>
String format: <code>Records: 3  Duplicates: 0  Warnings: 0</code>
<DT><code>LOAD DATA INFILE ...</code>
<DD>
String format: <code>Records: 1 Deleted: 0 Skipped: 0 Warnings: 0</code>
<DT><code>ALTER TABLE</code>
<DD>
String format: <code>Records: 3 Duplicates: 0 Warnings: 0</code>
<DT><code>UPDATE</code>
<DD>
String format: <code>Rows matched: 40 Changed: 40 Warnings: 0</code>
</DL>

<P>
Note that <code>mysql_info()</code> returns a non-<code>NULL</code> value for
<code>INSERT ... VALUES</code> only for the multiple-row form
of the statement (that is, only if multiple value lists are
specified).

</P>

<H4>Return Values</H4>

<P>
A character string representing additional information about the most
recently executed query.  <code>NULL</code> if no information is available for the
query.

</P>

<H4>Errors</H4>
<P>
None.

</P>



<H4><A NAME="mysql_init" HREF="manual_toc.html#mysql_init">21.2.3.32  <code>mysql_init()</code></A></H4>

<P>
<A NAME="IDX2131"></A>

</P>
<P>
<code>MYSQL *mysql_init(MYSQL *mysql)</code>

</P>

<H4>Description</H4>

<P>
Allocates or initializes a <code>MYSQL</code> object suitable for
<code>mysql_real_connect()</code>.  If <code>mysql</code> is a <code>NULL</code> pointer, the
function allocates, initializes, and returns a new object.  Otherwise, the
object is initialized and the address of the object is returned.  If
<code>mysql_init()</code> allocates a new object, it will be freed when
<code>mysql_close()</code> is called to close the connection.

</P>

<H4>Return Values</H4>

<P>
An initialized <code>MYSQL*</code> handle.  <code>NULL</code> if there was
insufficient memory to allocate a new object.

</P>

<H4>Errors</H4>
<P>
In case of insufficient memory, <code>NULL</code> is returned.

</P>



<H4><A NAME="mysql_insert_id" HREF="manual_toc.html#mysql_insert_id">21.2.3.33  <code>mysql_insert_id()</code></A></H4>

<P>
<A NAME="IDX2132"></A>

</P>
<P>
<code>my_ulonglong mysql_insert_id(MYSQL *mysql)</code>

</P>

<H4>Description</H4>

<P>
Returns the value generated for an <code>AUTO_INCREMENT</code> column by the
previous <code>INSERT</code> or <code>UPDATE</code> statement.  Use this function after
you have performed an <code>INSERT</code> statement into a table that contains an
<code>AUTO_INCREMENT</code> field.

</P>
<P>
More precisely, <code>mysql_insert_id()</code> is updated under these conditions:

</P>

<UL>
<LI>

<code>INSERT</code> statements that store a value into an <code>AUTO_INCREMENT</code>
column. This is true whether the value is automatically generated by
storing the special values <code>NULL</code> or <code>0</code> into the column, or is
an explicit non-special value.

<LI>

In the case of a multiple-row <code>INSERT</code> statement, <code>mysql_insert_id()</code>
returns the <strong>first</strong> automatically generated <code>AUTO_INCREMENT</code>
value; if no such value is generated, it returns the last <strong>last</strong>
explicit value inserted into the <code>AUTO_INCREMENT</code> column.

<LI>

<code>INSERT</code> statements that generate an <code>AUTO_INCREMENT</code> value by
inserting <code>LAST_INSERT_ID(<var>expr</var>)</code> into any column.

<LI>

<code>INSERT</code> statements that generate an <code>AUTO_INCREMENT</code> value by
updating any column to <code>LAST_INSERT_ID(<var>expr</var>)</code>.

<LI>

The value of <code>mysql_insert_id()</code> is not affected by statements such as
<code>SELECT</code> that return a result set.

<LI>

If the previous statement returned an error,
the value of <code>mysql_insert_id()</code> is undefined.
</UL>

<P>
Note that <code>mysql_insert_id()</code> returns <code>0</code> if the previous statement
does not use an <code>AUTO_INCREMENT</code> value.  If you need to save
the value for later, be sure to call <code>mysql_insert_id()</code> immediately
after the statement that generates the value.

</P>
<P>
The value of <code>mysql_insert_id()</code> is affected only by statements issued
within the current client connection. It is not affected by statements issued
by other clients.

</P>
<P>
See section <A HREF="manual_Functions.html#Information_functions">12.8.3  Information Functions</A>.

</P>
<P>
Also note that the value of the SQL <code>LAST_INSERT_ID()</code> function always
contains the most recently generated <code>AUTO_INCREMENT</code> value, and is
not reset between statements because the value of that function is maintained
in the server.  Another difference is that <code>LAST_INSERT_ID()</code> is not
updated if you set an <code>AUTO_INCREMENT</code> column to a specific non-special
value.

</P>
<P>
The reason for the difference between <code>LAST_INSERT_ID()</code> and
<code>mysql_insert_id()</code> is that <code>LAST_INSERT_ID()</code> is made easy to
use in scripts while <code>mysql_insert_id()</code> tries to provide a little
more exact information of what happens to the <code>AUTO_INCREMENT</code> column.

</P>

<H4>Return Values</H4>

<P>
Described in the preceding discussion.

</P>

<H4>Errors</H4>
<P>
None.

</P>



<H4><A NAME="mysql_kill" HREF="manual_toc.html#mysql_kill">21.2.3.34  <code>mysql_kill()</code></A></H4>

<P>
<A NAME="IDX2133"></A>

</P>
<P>
<code>int mysql_kill(MYSQL *mysql, unsigned long pid)</code>

</P>

<H4>Description</H4>

<P>
Asks the server to kill the thread specified by <code>pid</code>.

</P>

<H4>Return Values</H4>

<P>
Zero for success.  Non-zero if an error occurred.

</P>

<H4>Errors</H4>

<DL COMPACT>

<DT><code>CR_COMMANDS_OUT_OF_SYNC</code>
<DD>
Commands were executed in an improper order.
<DT><code>CR_SERVER_GONE_ERROR</code>
<DD>
The MySQL server has gone away.
<DT><code>CR_SERVER_LOST</code>
<DD>
The connection to the server was lost during the query.
<DT><code>CR_UNKNOWN_ERROR</code>
<DD>
An unknown error occurred.
</DL>



<H4><A NAME="mysql_list_dbs" HREF="manual_toc.html#mysql_list_dbs">21.2.3.35  <code>mysql_list_dbs()</code></A></H4>

<P>
<A NAME="IDX2134"></A>

</P>
<P>
<code>MYSQL_RES *mysql_list_dbs(MYSQL *mysql, const char *wild)</code>

</P>

<H4>Description</H4>

<P>
Returns a result set consisting of database names on the server that match
the simple regular expression specified by the <code>wild</code> parameter.
<code>wild</code> may contain the wildcard characters <samp>`%'</samp> or <samp>`_'</samp>, or may
be a <code>NULL</code> pointer to match all databases.  Calling
<code>mysql_list_dbs()</code> is similar to executing the query <code>SHOW
databases [LIKE wild]</code>.

</P>
<P>
You must free the result set with <code>mysql_free_result()</code>.

</P>

<H4>Return Values</H4>

<P>
A <code>MYSQL_RES</code> result set for success.  <code>NULL</code> if an error occurred.

</P>

<H4>Errors</H4>

<DL COMPACT>

<DT><code>CR_COMMANDS_OUT_OF_SYNC</code>
<DD>
Commands were executed in an improper order.
<DT><code>CR_OUT_OF_MEMORY</code>
<DD>
Out of memory.
<DT><code>CR_SERVER_GONE_ERROR</code>
<DD>
The MySQL server has gone away.
<DT><code>CR_SERVER_LOST</code>
<DD>
The connection to the server was lost during the query.
<DT><code>CR_UNKNOWN_ERROR</code>
<DD>
An unknown error occurred.
</DL>



<H4><A NAME="mysql_list_fields" HREF="manual_toc.html#mysql_list_fields">21.2.3.36  <code>mysql_list_fields()</code></A></H4>

<P>
<A NAME="IDX2135"></A>

</P>
<P>
<code>MYSQL_RES *mysql_list_fields(MYSQL *mysql, const char *table, const char *wild)</code>

</P>

<H4>Description</H4>

<P>
Returns a result set consisting of field names in the given table that match
the simple regular expression specified by the <code>wild</code> parameter.
<code>wild</code> may contain the wildcard characters <samp>`%'</samp> or <samp>`_'</samp>, or may
be a <code>NULL</code> pointer to match all fields.  Calling
<code>mysql_list_fields()</code> is similar to executing the query <code>SHOW
COLUMNS FROM <var>tbl_name</var> [LIKE <var>wild</var>]</code>.

</P>
<P>
Note that it's recommended that you use <code>SHOW COLUMNS FROM <var>tbl_name</var></code>
instead of <code>mysql_list_fields()</code>.

</P>
<P>
You must free the result set with <code>mysql_free_result()</code>.

</P>

<H4>Return Values</H4>

<P>
A <code>MYSQL_RES</code> result set for success.  <code>NULL</code> if an error occurred.

</P>

<H4>Errors</H4>

<DL COMPACT>

<DT><code>CR_COMMANDS_OUT_OF_SYNC</code>
<DD>
Commands were executed in an improper order.
<DT><code>CR_SERVER_GONE_ERROR</code>
<DD>
The MySQL server has gone away.
<DT><code>CR_SERVER_LOST</code>
<DD>
The connection to the server was lost during the query.
<DT><code>CR_UNKNOWN_ERROR</code>
<DD>
An unknown error occurred.
</DL>



<H4><A NAME="mysql_list_processes" HREF="manual_toc.html#mysql_list_processes">21.2.3.37  <code>mysql_list_processes()</code></A></H4>

<P>
<A NAME="IDX2136"></A>

</P>
<P>
<code>MYSQL_RES *mysql_list_processes(MYSQL *mysql)</code>

</P>

<H4>Description</H4>

<P>
Returns a result set describing the current server threads.  This is the same
kind of information as that reported by <code>mysqladmin processlist</code> or
a <code>SHOW PROCESSLIST</code> query.

</P>
<P>
You must free the result set with <code>mysql_free_result()</code>.

</P>

<H4>Return Values</H4>

<P>
A <code>MYSQL_RES</code> result set for success.  <code>NULL</code> if an error occurred.

</P>

<H4>Errors</H4>

<DL COMPACT>

<DT><code>CR_COMMANDS_OUT_OF_SYNC</code>
<DD>
Commands were executed in an improper order.
<DT><code>CR_SERVER_GONE_ERROR</code>
<DD>
The MySQL server has gone away.
<DT><code>CR_SERVER_LOST</code>
<DD>
The connection to the server was lost during the query.
<DT><code>CR_UNKNOWN_ERROR</code>
<DD>
An unknown error occurred.
</DL>



<H4><A NAME="mysql_list_tables" HREF="manual_toc.html#mysql_list_tables">21.2.3.38  <code>mysql_list_tables()</code></A></H4>

<P>
<A NAME="IDX2137"></A>

</P>
<P>
<code>MYSQL_RES *mysql_list_tables(MYSQL *mysql, const char *wild)</code>

</P>

<H4>Description</H4>

<P>
Returns a result set consisting of table names in the current database that
match the simple regular expression specified by the <code>wild</code> parameter.
<code>wild</code> may contain the wildcard characters <samp>`%'</samp> or <samp>`_'</samp>, or may
be a <code>NULL</code> pointer to match all tables.  Calling
<code>mysql_list_tables()</code> is similar to executing the query <code>SHOW
tables [LIKE wild]</code>.

</P>
<P>
You must free the result set with <code>mysql_free_result()</code>.

</P>

<H4>Return Values</H4>

<P>
A <code>MYSQL_RES</code> result set for success.  <code>NULL</code> if an error occurred.

</P>

<H4>Errors</H4>

<DL COMPACT>

<DT><code>CR_COMMANDS_OUT_OF_SYNC</code>
<DD>
Commands were executed in an improper order.
<DT><code>CR_SERVER_GONE_ERROR</code>
<DD>
The MySQL server has gone away.
<DT><code>CR_SERVER_LOST</code>
<DD>
The connection to the server was lost during the query.
<DT><code>CR_UNKNOWN_ERROR</code>
<DD>
An unknown error occurred.
</DL>



<H4><A NAME="mysql_num_fields" HREF="manual_toc.html#mysql_num_fields">21.2.3.39  <code>mysql_num_fields()</code></A></H4>

<P>
<A NAME="IDX2138"></A>
<A NAME="IDX2139"></A>

</P>
<P>
<code>unsigned int mysql_num_fields(MYSQL_RES *result)</code>

</P>
<P>
Or:

</P>
<P>
<code>unsigned int mysql_num_fields(MYSQL *mysql)</code>

</P>
<P>
The second form doesn't work on MySQL 3.22.24 or newer.  To pass a
<code>MYSQL*</code> argument, you must use
<code>unsigned int mysql_field_count(MYSQL *mysql)</code> instead.

</P>

<H4>Description</H4>

<P>
Returns the number of columns in a result set.

</P>
<P>
Note that you can get the number of columns either from a pointer to a result
set or to a connection handle.  You would use the connection handle if
<code>mysql_store_result()</code> or <code>mysql_use_result()</code> returned
<code>NULL</code> (and thus you have no result set pointer).  In this case, you can
call <code>mysql_field_count()</code> to determine whether
<code>mysql_store_result()</code> should have produced a non-empty result.  This
allows the client program to take proper action without knowing whether or
not the query was a <code>SELECT</code> (or <code>SELECT</code>-like) statement.  The
example shown here illustrates how this may be done.

</P>
<P>
See section <A HREF="manual_MySQL_APIs.html#NULL_mysql_store_result">21.2.13.1  Why <code>mysql_store_result()</code> Sometimes Returns <code>NULL</code> After <code>mysql_query()</code> Returns Success</A>.

</P>

<H4>Return Values</H4>

<P>
An unsigned integer representing the number of columns in a result set.

</P>

<H4>Errors</H4>
<P>
None.

</P>

<H4>Example</H4>


<PRE>
MYSQL_RES *result;
unsigned int num_fields;
unsigned int num_rows;

if (mysql_query(&#38;mysql,query_string))
{
    // error
}
else // query succeeded, process any data returned by it
{
    result = mysql_store_result(&#38;mysql);
    if (result)  // there are rows
    {
        num_fields = mysql_num_fields(result);
        // retrieve rows, then call mysql_free_result(result)
    }
    else  // mysql_store_result() returned nothing; should it have?
    {
        if (mysql_errno(&#38;mysql))
        {
           fprintf(stderr, "Error: %s\n", mysql_error(&#38;mysql));
        }
        else if (mysql_field_count(&#38;mysql) == 0)
        {
            // query does not return data
            // (it was not a SELECT)
            num_rows = mysql_affected_rows(&#38;mysql);
        }
    }
}
</PRE>

<P>
An alternative (if you know that your query should have returned a result set)
is to replace the <code>mysql_errno(&#38;mysql)</code> call with a check whether
<code>mysql_field_count(&#38;mysql)</code> is = 0.  This will happen only if something
went wrong.

</P>



<H4><A NAME="mysql_num_rows" HREF="manual_toc.html#mysql_num_rows">21.2.3.40  <code>mysql_num_rows()</code></A></H4>

<P>
<A NAME="IDX2140"></A>

</P>
<P>
<code>my_ulonglong mysql_num_rows(MYSQL_RES *result)</code>

</P>

<H4>Description</H4>

<P>
Returns the number of rows in the result set.

</P>
<P>
The use of <code>mysql_num_rows()</code> depends on whether you use
<code>mysql_store_result()</code> or <code>mysql_use_result()</code> to return the result
set.  If you use <code>mysql_store_result()</code>, <code>mysql_num_rows()</code> may be
called immediately.  If you use <code>mysql_use_result()</code>,
<code>mysql_num_rows()</code> will not return the correct value until all the rows
in the result set have been retrieved.

</P>

<H4>Return Values</H4>

<P>
The number of rows in the result set.

</P>

<H4>Errors</H4>
<P>
None.

</P>



<H4><A NAME="mysql_options" HREF="manual_toc.html#mysql_options">21.2.3.41  <code>mysql_options()</code></A></H4>

<P>
<A NAME="IDX2141"></A>

</P>
<P>
<code>int mysql_options(MYSQL *mysql, enum mysql_option option, const char *arg)</code>

</P>

<H4>Description</H4>

<P>
Can be used to set extra connect options and affect behavior for a connection.
This function may be called multiple times to set several options.

</P>
<P>
<code>mysql_options()</code> should be called after <code>mysql_init()</code> and before
<code>mysql_connect()</code> or <code>mysql_real_connect()</code>.

</P>
<P>
The <code>option</code> argument is the option that you want to set; the <code>arg</code>
argument is the value for the option. If the option is an integer, then
<code>arg</code> should point to the value of the integer.

</P>
<P>
Possible option values:

</P>
<TABLE BORDER>
<TR><TD><strong>Option</strong> </TD><TD> <strong>Argument Type</strong> </TD><TD> <strong>Function</strong>
</TD></TR>
<TR><TD><code>MYSQL_INIT_COMMAND</code> </TD><TD> <code>char *</code> </TD><TD> Command to execute when connecting to the MySQL server. Will automatically be re-executed when reconnecting.
</TD></TR>
<TR><TD><code>MYSQL_OPT_COMPRESS</code> </TD><TD> Not used </TD><TD> Use the compressed client/server protocol.
</TD></TR>
<TR><TD><code>MYSQL_OPT_CONNECT_TIMEOUT</code> </TD><TD> <code>unsigned int *</code> </TD><TD> Connect timeout in seconds.
</TD></TR>
<TR><TD><code>MYSQL_OPT_LOCAL_INFILE</code> </TD><TD> optional pointer to uint </TD><TD> If no pointer is given or if pointer points to an <code>unsigned int != 0</code> the command <code>LOAD LOCAL INFILE</code> is enabled.
</TD></TR>
<TR><TD><code>MYSQL_OPT_NAMED_PIPE</code> </TD><TD> Not used </TD><TD> Use named pipes to connect to a MySQL server on NT.
</TD></TR>
<TR><TD><code>MYSQL_OPT_PROTOCOL</code> </TD><TD> <code>unsigned int *</code> </TD><TD> Type of protocol to use. Should be one of the enum values of <code>mysql_protocol_type</code> defined in <tt>`mysql.h'</tt>. New in 4.1.0.
</TD></TR>
<TR><TD><code>MYSQL_OPT_READ_TIMEOUT</code> </TD><TD> <code>unsigned int *</code> </TD><TD> Timeout for reads from server (works currently only on Windows on TCP/IP connections). New in 4.1.1.
</TD></TR>
<TR><TD><code>MYSQL_OPT_WRITE_TIMEOUT</code> </TD><TD> <code>unsigned int *</code> </TD><TD> Timeout for writes to server (works currently only on Windows on TCP/IP connections). New in 4.1.1.
</TD></TR>
<TR><TD><code>MYSQL_READ_DEFAULT_FILE</code> </TD><TD> <code>char *</code> </TD><TD> Read options from the named option file instead of from <tt>`my.cnf'</tt>.
</TD></TR>
<TR><TD><code>MYSQL_READ_DEFAULT_GROUP</code> </TD><TD> <code>char *</code> </TD><TD> Read options from the named group from <tt>`my.cnf'</tt> or the file specified with <code>MYSQL_READ_DEFAULT_FILE</code>.
</TD></TR>
<TR><TD><code>MYSQL_REPORT_DATA_TRUNCATION</code> </TD><TD> <code>my_bool *</code> </TD><TD> Enable or disable reporting of data truncation errors for prepared statements via <code>MYSQL_BIND.error</code>. (Default: disabled) New in 5.0.3.
</TD></TR>
<TR><TD><code>MYSQL_SECURE_AUTH</code> </TD><TD> <code>my_bool*</code> </TD><TD> Whether to connect to a server that does not support the new 4.1.1 password hashing. New in 4.1.1.
</TD></TR>
<TR><TD><code>MYSQL_SET_CHARSET_DIR</code> </TD><TD> <code>char*</code> </TD><TD> The pathname to the directory that contains character set definition files.
</TD></TR>
<TR><TD><code>MYSQL_SET_CHARSET_NAME</code> </TD><TD> <code>char*</code> </TD><TD> The name of the character set to use as the default character set.
</TD></TR>
<TR><TD><code>MYSQL_SHARED_MEMORY_BASE_NAME</code> </TD><TD> <code>char*</code> </TD><TD> Named of shared memory object for communication to server. Should be same as the option <code>-shared-memory-base-name</code> used for the mysqld server you want's to connect to. New in 4.1.0.
</TD></TR>
</TABLE>

<P>
Note that the <code>client</code> group is always read if you use
<code>MYSQL_READ_DEFAULT_FILE</code> or <code>MYSQL_READ_DEFAULT_GROUP</code>.

</P>
<P>
The specified group in the option file may contain the following options:

</P>
<TABLE BORDER>
<TR><TD><strong>Option</strong> </TD><TD> <strong>Description</strong>
</TD></TR>
<TR><TD><code>connect-timeout</code> </TD><TD> Connect timeout in seconds. On Linux this timeout is also used for waiting for the first answer from the server.
</TD></TR>
<TR><TD><code>compress</code> </TD><TD> Use the compressed client/server protocol.
</TD></TR>
<TR><TD><code>database</code> </TD><TD> Connect to this database if no database was specified in the connect command.
</TD></TR>
<TR><TD><code>debug</code> </TD><TD> Debug options.
</TD></TR>
<TR><TD><code>disable-local-infile</code> </TD><TD> Disable use of <code>LOAD DATA LOCAL</code>.
</TD></TR>
<TR><TD><code>host</code> </TD><TD> Default hostname.
</TD></TR>
<TR><TD><code>init-command</code> </TD><TD> Command to execute when connecting to MySQL server. Will automatically be re-executed when reconnecting.
</TD></TR>
<TR><TD><code>interactive-timeout</code> </TD><TD> Same as specifying <code>CLIENT_INTERACTIVE</code> to <code>mysql_real_connect()</code>. See section <A HREF="manual_MySQL_APIs.html#mysql_real_connect">21.2.3.44  <code>mysql_real_connect()</code></A>.
</TD></TR>
<TR><TD><code>local-infile[=(0|1)]</code> </TD><TD> If no argument or argument != 0 then enable use of <code>LOAD DATA LOCAL</code>.
</TD></TR>
<TR><TD><code>max_allowed_packet</code> </TD><TD> Max size of packet client can read from server.
</TD></TR>
<TR><TD><code>multi-results</code> </TD><TD> Allow multiple result sets from multiple-statement executions or stored procedures.  New in 4.1.1.
</TD></TR>
<TR><TD><code>multi-statements</code> </TD><TD> Allow the client to send multiple statements in a single string (separated by <samp>`;'</samp>). New in 4.1.9.
</TD></TR>
<TR><TD><code>password</code> </TD><TD> Default password.
</TD></TR>
<TR><TD><code>pipe</code> </TD><TD> Use named pipes to connect to a MySQL server on NT.
</TD></TR>
<TR><TD><code>protocol={TCP | SOCKET | PIPE | MEMORY}</code> </TD><TD> The protocol to use when connecting to server (New in 4.1)
</TD></TR>
<TR><TD><code>port</code> </TD><TD> Default port number.
</TD></TR>
<TR><TD><code>return-found-rows</code> </TD><TD> Tell <code>mysql_info()</code> to return found rows instead of updated rows when using <code>UPDATE</code>.
</TD></TR>
<TR><TD><code>shared-memory-base-name=<var>name</var></code> </TD><TD> Shared memory name to use to connect to server (default is "MYSQL"). New in MySQL 4.1.
</TD></TR>
<TR><TD><code>socket</code> </TD><TD> Default socket file.
</TD></TR>
<TR><TD><code>user</code> </TD><TD> Default user.
</TD></TR>
</TABLE>

<P>
Note that <code>timeout</code> has been replaced by <code>connect-timeout</code>, but
<code>timeout</code> will still work for a while.

</P>
<P>
For more information about option files, see section <A HREF="manual_Using_MySQL_Programs.html#Option_files">4.3.2  Using Option Files</A>.

</P>

<H4>Return Values</H4>

<P>
Zero for success.  Non-zero if you used an unknown option.

</P>

<H4>Example</H4>


<PRE>
MYSQL mysql;

mysql_init(&#38;mysql);
mysql_options(&#38;mysql,MYSQL_OPT_COMPRESS,0);
mysql_options(&#38;mysql,MYSQL_READ_DEFAULT_GROUP,"odbc");
if (!mysql_real_connect(&#38;mysql,"host","user","passwd","database",0,NULL,0))
{
    fprintf(stderr, "Failed to connect to database: Error: %s\n",
          mysql_error(&#38;mysql));
}
</PRE>

<P>
This code requests the client to use the compressed client/server protocol and
read the additional options from the <code>odbc</code> section in the <tt>`my.cnf'</tt>
file.

</P>



<H4><A NAME="mysql_ping" HREF="manual_toc.html#mysql_ping">21.2.3.42  <code>mysql_ping()</code></A></H4>

<P>
<A NAME="IDX2142"></A>

</P>
<P>
<code>int mysql_ping(MYSQL *mysql)</code>

</P>

<H4>Description</H4>

<P>
Checks whether the connection to the server is working. If it has gone
down, an automatic reconnection is attempted.

</P>
<P>
This function can be used by clients that remain idle for a long while,
to check whether the server has closed the connection and reconnect
if necessary.

</P>

<H4>Return Values</H4>

<P>
Zero if the server is alive. Non-zero if an error occurred.

</P>

<H4>Errors</H4>

<DL COMPACT>

<DT><code>CR_COMMANDS_OUT_OF_SYNC</code>
<DD>
Commands were executed in an improper order.
<DT><code>CR_SERVER_GONE_ERROR</code>
<DD>
The MySQL server has gone away.
<DT><code>CR_UNKNOWN_ERROR</code>
<DD>
An unknown error occurred.
</DL>



<H4><A NAME="mysql_query" HREF="manual_toc.html#mysql_query">21.2.3.43  <code>mysql_query()</code></A></H4>

<P>
<A NAME="IDX2143"></A>

</P>
<P>
<code>int mysql_query(MYSQL *mysql, const char *query)</code>

</P>

<H4>Description</H4>
<P>
Executes the SQL query pointed to by the null-terminated string <code>query</code>.
Normally, the string must consist of a single SQL statement and you should
not add a terminating semicolon (<samp>`;'</samp>) or <code>\g</code> to the statement.
If multiple-statement execution has been enabled, the string can contain
several statements separated by semicolons.
See section <A HREF="manual_MySQL_APIs.html#C_API_multiple_queries">21.2.9  C API Handling of Multiple Query Execution</A>.

</P>
<P>
<code>mysql_query()</code> cannot be used for queries that contain binary data; you
should use <code>mysql_real_query()</code> instead.  (Binary data may contain the
<samp>`\0'</samp> character, which <code>mysql_query()</code> interprets as the end of the
query string.)

</P>
<P>
If you want to know whether the query should return a result set, you can
use <code>mysql_field_count()</code> to check for this.
See section <A HREF="manual_MySQL_APIs.html#mysql_field_count">21.2.3.20  <code>mysql_field_count()</code></A>.

</P>

<H4>Return Values</H4>

<P>
Zero if the query was successful. Non-zero if an error occurred.

</P>

<H4>Errors</H4>

<DL COMPACT>

<DT><code>CR_COMMANDS_OUT_OF_SYNC</code>
<DD>
Commands were executed in an improper order.
<DT><code>CR_SERVER_GONE_ERROR</code>
<DD>
The MySQL server has gone away.
<DT><code>CR_SERVER_LOST</code>
<DD>
The connection to the server was lost during the query.
<DT><code>CR_UNKNOWN_ERROR</code>
<DD>
An unknown error occurred.
</DL>



<H4><A NAME="mysql_real_connect" HREF="manual_toc.html#mysql_real_connect">21.2.3.44  <code>mysql_real_connect()</code></A></H4>

<P>
<A NAME="IDX2144"></A>

</P>
<P>
<code>MYSQL *mysql_real_connect(MYSQL *mysql, const char *host,
                 const char *user, const char *passwd, const char *db,
                 unsigned int port, const char *unix_socket,
                 unsigned long client_flag)</code>

</P>

<H4>Description</H4>

<P>
<code>mysql_real_connect()</code> attempts to establish a connection to a
MySQL database engine running on <code>host</code>.
<code>mysql_real_connect()</code> must complete successfully before you can execute
any of the other API functions, with the exception of
<code>mysql_get_client_info()</code>.

</P>
<P>
The parameters are specified as follows:

</P>

<UL>
<LI>

The first parameter should be the address of an existing <code>MYSQL</code>
structure.  Before calling <code>mysql_real_connect()</code> you must call
<code>mysql_init()</code> to initialize the <code>MYSQL</code> structure. You can
change a lot of connect options with the <code>mysql_options()</code>
call.  See section <A HREF="manual_MySQL_APIs.html#mysql_options">21.2.3.41  <code>mysql_options()</code></A>.

<LI>

The value of <code>host</code> may be either a hostname or an IP address.  If
<code>host</code> is <code>NULL</code> or the string <code>"localhost"</code>, a connection to
the local host is assumed. If the OS supports sockets (Unix) or named pipes
(Windows), they are used instead of TCP/IP to connect to the server.

<LI>

The <code>user</code> parameter contains the user's MySQL login ID.  If
<code>user</code> is <code>NULL</code> or the empty string <code>""</code>, the current
user is assumed.  Under Unix, this is the current login name.  Under
Windows ODBC, the current username must be specified explicitly.
See section <A HREF="manual_MySQL_Connectors.html#DSN_on_Windows">22.1.9.2  Configuring a MyODBC DSN on Windows</A>.

<LI>

The <code>passwd</code> parameter contains the password for <code>user</code>.  If
<code>passwd</code> is <code>NULL</code>, only entries in the <code>user</code> table for the
user that have a blank (empty) password field will be checked for a match. This
allows the database administrator to set up the MySQL privilege
system in such a way that users get different privileges depending on whether
or not they have specified a password.

Note: Do not attempt to encrypt the password before calling
<code>mysql_real_connect()</code>; password encryption is handled automatically by
the client API.

<LI>

<code>db</code> is the database name.
If <code>db</code> is not <code>NULL</code>, the connection will set the default
database to this value.

<LI>

If <code>port</code> is not 0, the value will be used as the port number
for the TCP/IP connection.  Note that the <code>host</code> parameter
determines the type of the connection.

<LI>

If <code>unix_socket</code> is not <code>NULL</code>, the string specifies the
socket or named pipe that should be used.  Note that the <code>host</code>
parameter determines the type of the connection.

<LI>

The value of <code>client_flag</code> is usually 0, but can be set to a combination
of the following flags in very special circumstances:

<TABLE BORDER>
<TR><TD><strong>Flag Name</strong> </TD><TD> <strong>Flag Nescription</strong>
</TD></TR>
<TR><TD><code>CLIENT_COMPRESS</code> </TD><TD> Use compression protocol.
</TD></TR>
<TR><TD><code>CLIENT_FOUND_ROWS</code> </TD><TD> Return the number of found (matched) rows, not the number of affected rows.
</TD></TR>
<TR><TD><code>CLIENT_IGNORE_SPACE</code> </TD><TD> Allow spaces after function names. Makes all functions names reserved words.
</TD></TR>
<TR><TD><code>CLIENT_INTERACTIVE</code> </TD><TD> Allow <code>interactive_timeout</code> seconds (instead of <code>wait_timeout</code> seconds) of inactivity before closing the connection. The client's session <code>wait_timeout</code> variable will be set to the value of the session <code>interactive_timeout</code> variable.
</TD></TR>
<TR><TD><code>CLIENT_LOCAL_FILES</code> </TD><TD> Enable <code>LOAD DATA LOCAL</code> handling.
</TD></TR>
<TR><TD><code>CLIENT_MULTI_STATEMENTS</code> </TD><TD> Tell the server that the client may send multiple statements in a single string (separated by <samp>`;'</samp>). If this flag is not set, multiple-statement execution is disabled. New in 4.1.
</TD></TR>
<TR><TD><code>CLIENT_MULTI_RESULTS</code> </TD><TD> Tell the server that the client can handle multiple result sets from multiple-statement executions or stored procedures.  This is automatically set if <code>CLIENT_MULTI_STATEMENTS</code> is set. New in 4.1.
</TD></TR>
<TR><TD><code>CLIENT_NO_SCHEMA</code> </TD><TD> Don't allow the <var>db_name.tbl_name.col_name</var> syntax.  This is for ODBC. It causes the parser to generate an error if you use that syntax, which is useful for trapping bugs in some ODBC programs.
</TD></TR>
<TR><TD><code>CLIENT_ODBC</code> </TD><TD> The client is an ODBC client. This changes <code>mysqld</code> to be more ODBC-friendly.
</TD></TR>
<TR><TD><code>CLIENT_SSL</code> </TD><TD> Use SSL (encrypted protocol). This option should not be set by application programs; it is set internally in the client library.
</TD></TR>
</TABLE>
</UL>


<H4>Return Values</H4>

<P>
A <code>MYSQL*</code> connection handle if the connection was successful,
<code>NULL</code> if the connection was unsuccessful.  For a successful connection,
the return value is the same as the value of the first parameter.

</P>

<H4>Errors</H4>

<DL COMPACT>

<DT><code>CR_CONN_HOST_ERROR</code>
<DD>
Failed to connect to the MySQL server.

<DT><code>CR_CONNECTION_ERROR</code>
<DD>
Failed to connect to the local MySQL server.

<DT><code>CR_IPSOCK_ERROR</code>
<DD>
Failed to create an IP socket.

<DT><code>CR_OUT_OF_MEMORY</code>
<DD>
Out of memory.

<DT><code>CR_SOCKET_CREATE_ERROR</code>
<DD>
Failed to create a Unix socket.

<DT><code>CR_UNKNOWN_HOST</code>
<DD>
Failed to find the IP address for the hostname.

<DT><code>CR_VERSION_ERROR</code>
<DD>
A protocol mismatch resulted from attempting to connect to a server with a
client library that uses a different protocol version.  This can happen if you
use a very old client library to connect to a new server that wasn't started
with the <code>--old-protocol</code> option.

<DT><code>CR_NAMEDPIPEOPEN_ERROR</code>
<DD>
Failed to create a named pipe on Windows.

<DT><code>CR_NAMEDPIPEWAIT_ERROR</code>
<DD>
Failed to wait for a named pipe on Windows.

<DT><code>CR_NAMEDPIPESETSTATE_ERROR</code>
<DD>
Failed to get a pipe handler on Windows.

<DT><code>CR_SERVER_LOST</code>
<DD>
If <code>connect_timeout</code> &#62; 0 and it took longer than <code>connect_timeout</code>
seconds to connect to the server or if the server died while executing the
<code>init-command</code>.

</DL>


<H4>Example</H4>


<PRE>
MYSQL mysql;

mysql_init(&#38;mysql);
mysql_options(&#38;mysql,MYSQL_READ_DEFAULT_GROUP,"your_prog_name");
if (!mysql_real_connect(&#38;mysql,"host","user","passwd","database",0,NULL,0))
{
    fprintf(stderr, "Failed to connect to database: Error: %s\n",
          mysql_error(&#38;mysql));
}
</PRE>

<P>
By using <code>mysql_options()</code> the MySQL library will read the
<code>[client]</code> and <code>[your_prog_name]</code> sections in the <tt>`my.cnf'</tt>
file which will ensure that your program will work, even if someone has
set up MySQL in some non-standard way.

</P>
<P>
Note that upon connection, <code>mysql_real_connect()</code> sets the
<code>reconnect</code> flag (part of the <code>MYSQL</code> structure) to a value of
<code>1</code> in versions of the API strictly older than 5.0.3, of <code>0</code> in newer
versions. A value of <code>1</code> for this flag indicates, in the event that a
query cannot be performed because of a lost connection, to try reconnecting to
the server before giving up.

</P>



<H4><A NAME="mysql_real_escape_string" HREF="manual_toc.html#mysql_real_escape_string">21.2.3.45  <code>mysql_real_escape_string()</code></A></H4>

<P>
<A NAME="IDX2145"></A>

</P>
<P>
<code>unsigned long mysql_real_escape_string(MYSQL *mysql, char *to, const char *from, unsigned long length)</code>

</P>
<P>
Note that <code>mysql</code> must be a valid, open connection. This is needed
because the escaping depends on the character-set in use by the server.

</P>

<H4>Description</H4>

<P>
This function is used to create a legal SQL string that you can use in a
SQL statement. See section <A HREF="manual_Language_Structure.html#String_syntax">9.1.1  Strings</A>.

</P>
<P>
The string in <code>from</code> is encoded to an escaped SQL string, taking
into account the current character set of the connection. The result is placed
in <code>to</code> and a terminating null byte is appended.  Characters
encoded are <code>NUL</code> (ASCII 0), <samp>`\n'</samp>, <samp>`\r'</samp>, <samp>`\'</samp>,
<samp>`''</samp>, <samp>`"'</samp>, and Control-Z (see section <A HREF="manual_Language_Structure.html#Literals">9.1  Literal Values</A>).
(Strictly speaking, MySQL requires only that backslash and the quote
character used to quote the string in the query be escaped.  This function
quotes the other characters to make them easier to read in log files.)

</P>
<P>
The string pointed to by <code>from</code> must be <code>length</code> bytes long.  You
must allocate the <code>to</code> buffer to be at least <code>length*2+1</code> bytes
long.  (In the worst case, each character may need to be encoded as using two
bytes, and you need room for the terminating null byte.)  When
<code>mysql_real_escape_string()</code> returns, the contents of <code>to</code> will be a
null-terminated string.  The return value is the length of the encoded
string, not including the terminating null character.

</P>

<H4>Example</H4>


<PRE>
char query[1000],*end;

end = strmov(query,"INSERT INTO test_table values(");
*end++ = '\'';
end += mysql_real_escape_string(&#38;mysql, end,"What's this",11);
*end++ = '\'';
*end++ = ',';
*end++ = '\'';
end += mysql_real_escape_string(&#38;mysql, end,"binary data: \0\r\n",16);
*end++ = '\'';
*end++ = ')';

if (mysql_real_query(&#38;mysql,query,(unsigned int) (end - query)))
{
   fprintf(stderr, "Failed to insert row, Error: %s\n",
           mysql_error(&#38;mysql));
}
</PRE>

<P>
The <code>strmov()</code> function used in the example is included in the
<code>mysqlclient</code> library and works like <code>strcpy()</code> but returns a
pointer to the terminating null of the first parameter.

</P>

<H4>Return Values</H4>

<P>
The length of the value placed into <code>to</code>, not including the
terminating null character.

</P>

<H4>Errors</H4>
<P>
None.

</P>



<H4><A NAME="mysql_real_query" HREF="manual_toc.html#mysql_real_query">21.2.3.46  <code>mysql_real_query()</code></A></H4>

<P>
<A NAME="IDX2146"></A>

</P>
<P>
<code>int mysql_real_query(MYSQL *mysql, const char *query, unsigned long length)</code>

</P>

<H4>Description</H4>

<P>
Executes the SQL query pointed to by <code>query</code>, which should be a string
<code>length</code> bytes long.
Normally, the string must consist of a single SQL statement and you should
not add a terminating semicolon (<samp>`;'</samp>) or <code>\g</code> to the statement.
If multiple-statement execution has been enabled, the string can contain
several statements separated by semicolons.
See section <A HREF="manual_MySQL_APIs.html#C_API_multiple_queries">21.2.9  C API Handling of Multiple Query Execution</A>.

</P>
<P>
You <strong>must</strong> use <code>mysql_real_query()</code> rather than
<code>mysql_query()</code> for queries that contain binary data, because binary data
may contain the <samp>`\0'</samp> character.  In addition, <code>mysql_real_query()</code>
is faster than <code>mysql_query()</code> because it does not call <code>strlen()</code> on
the query string.

</P>
<P>
If you want to know whether the query should return a result set, you can
use <code>mysql_field_count()</code> to check for this.
See section <A HREF="manual_MySQL_APIs.html#mysql_field_count">21.2.3.20  <code>mysql_field_count()</code></A>.

</P>

<H4>Return Values</H4>

<P>
Zero if the query was successful. Non-zero if an error occurred.

</P>

<H4>Errors</H4>

<DL COMPACT>

<DT><code>CR_COMMANDS_OUT_OF_SYNC</code>
<DD>
Commands were executed in an improper order.
<DT><code>CR_SERVER_GONE_ERROR</code>
<DD>
The MySQL server has gone away.
<DT><code>CR_SERVER_LOST</code>
<DD>
The connection to the server was lost during the query.
<DT><code>CR_UNKNOWN_ERROR</code>
<DD>
An unknown error occurred.
</DL>



<H4><A NAME="mysql_reload" HREF="manual_toc.html#mysql_reload">21.2.3.47  <code>mysql_reload()</code></A></H4>

<P>
<A NAME="IDX2147"></A>

</P>
<P>
<code>int mysql_reload(MYSQL *mysql)</code>

</P>

<H4>Description</H4>

<P>
Asks the MySQL server to reload the grant tables. The
connected user must have the <code>RELOAD</code> privilege.

</P>
<P>
This function is deprecated.  It is preferable to use <code>mysql_query()</code>
to issue an SQL <code>FLUSH PRIVILEGES</code> statement instead.

</P>

<H4>Return Values</H4>

<P>
Zero for success.  Non-zero if an error occurred.

</P>

<H4>Errors</H4>

<DL COMPACT>

<DT><code>CR_COMMANDS_OUT_OF_SYNC</code>
<DD>
Commands were executed in an improper order.
<DT><code>CR_SERVER_GONE_ERROR</code>
<DD>
The MySQL server has gone away.
<DT><code>CR_SERVER_LOST</code>
<DD>
The connection to the server was lost during the query.
<DT><code>CR_UNKNOWN_ERROR</code>
<DD>
An unknown error occurred.
</DL>



<H4><A NAME="mysql_row_seek" HREF="manual_toc.html#mysql_row_seek">21.2.3.48  <code>mysql_row_seek()</code></A></H4>

<P>
<A NAME="IDX2148"></A>

</P>
<P>
<code>MYSQL_ROW_OFFSET mysql_row_seek(MYSQL_RES *result, MYSQL_ROW_OFFSET offset)</code>

</P>

<H4>Description</H4>
<P>
Sets the row cursor to an arbitrary row in a query result set.
The <code>offset</code> value is a row offset that should be a value returned
from <code>mysql_row_tell()</code> or from <code>mysql_row_seek()</code>.
This value is not a row number; if you want to seek to a row within a
result set by number, use <code>mysql_data_seek()</code> instead.

</P>
<P>
This function requires that the result set structure contains the
entire result of the query, so <code>mysql_row_seek()</code> may be used
only in conjunction with <code>mysql_store_result()</code>, not with
<code>mysql_use_result()</code>.

</P>

<H4>Return Values</H4>

<P>
The previous value of the row cursor.  This value may be passed to a
subsequent call to <code>mysql_row_seek()</code>.

</P>

<H4>Errors</H4>
<P>
None.

</P>



<H4><A NAME="mysql_row_tell" HREF="manual_toc.html#mysql_row_tell">21.2.3.49  <code>mysql_row_tell()</code></A></H4>

<P>
<A NAME="IDX2149"></A>

</P>
<P>
<code>MYSQL_ROW_OFFSET mysql_row_tell(MYSQL_RES *result)</code>

</P>

<H4>Description</H4>

<P>
Returns the current position of the row cursor for the last
<code>mysql_fetch_row()</code>. This value can be used as an argument to
<code>mysql_row_seek()</code>.

</P>
<P>
You should use <code>mysql_row_tell()</code> only after <code>mysql_store_result()</code>,
not after <code>mysql_use_result()</code>.

</P>

<H4>Return Values</H4>

<P>
The current offset of the row cursor.

</P>

<H4>Errors</H4>
<P>
None.

</P>


<H4><A NAME="mysql_select_db" HREF="manual_toc.html#mysql_select_db">21.2.3.50  <code>mysql_select_db()</code></A></H4>

<P>
<A NAME="IDX2150"></A>

</P>
<P>
<code>int mysql_select_db(MYSQL *mysql, const char *db)</code>

</P>

<H4>Description</H4>

<P>
Causes the database specified by <code>db</code> to become the default (current)
database on the connection specified by <code>mysql</code>.  In subsequent queries,
this database is the default for table references that do not include an
explicit database specifier.

</P>
<P>
<code>mysql_select_db()</code> fails unless the connected user can be authenticated
as having permission to use the database.

</P>

<H4>Return Values</H4>

<P>
Zero for success.  Non-zero if an error occurred.

</P>

<H4>Errors</H4>

<DL COMPACT>

<DT><code>CR_COMMANDS_OUT_OF_SYNC</code>
<DD>
Commands were executed in an improper order.
<DT><code>CR_SERVER_GONE_ERROR</code>
<DD>
The MySQL server has gone away.
<DT><code>CR_SERVER_LOST</code>
<DD>
The connection to the server was lost during the query.
<DT><code>CR_UNKNOWN_ERROR</code>
<DD>
An unknown error occurred.
</DL>



<H4><A NAME="mysql_set_server_option" HREF="manual_toc.html#mysql_set_server_option">21.2.3.51  <code>mysql_set_server_option()</code></A></H4>

<P>
<A NAME="IDX2151"></A>

</P>
<P>
<code>int mysql_set_server_option(MYSQL *mysql, enum enum_mysql_set_option option)</code>

</P>

<H4>Description</H4>

<P>
Enables or disables an option for the connection. <code>option</code> can have one
of the following values:

</P>
<TABLE BORDER>
<TR><TD>MYSQL_OPTION_MULTI_STATEMENTS_ON </TD><TD> Enable multi statement support.
</TD></TR>
<TR><TD>MYSQL_OPTION_MULTI_STATEMENTS_OFF </TD><TD> Disable multi statement support.
</TD></TR>
</TABLE>

<P>
This function was added in MySQL 4.1.1.

</P>

<H4>Return Values</H4>

<P>
Zero for success.  Non-zero if an error occurred.

</P>

<H4>Errors</H4>

<DL COMPACT>

<DT><code>CR_COMMANDS_OUT_OF_SYNC</code>
<DD>
Commands were executed in an improper order.
<DT><code>CR_SERVER_GONE_ERROR</code>
<DD>
The MySQL server has gone away.
<DT><code>CR_SERVER_LOST</code>
<DD>
The connection to the server was lost during the query.
<DT><code>ER_UNKNOWN_COM_ERROR</code>
<DD>
The server didn't support <code>mysql_set_server_option()</code> (which is the
case that the server is older than 4.1.1) or the server didn't support
the option one tried to set.
</DL>



<H4><A NAME="mysql_shutdown" HREF="manual_toc.html#mysql_shutdown">21.2.3.52  <code>mysql_shutdown()</code></A></H4>

<P>
<A NAME="IDX2152"></A>

</P>
<P>
<code>int mysql_shutdown(MYSQL *mysql, enum enum_shutdown_level shutdown_level)</code>

</P>

<H4>Description</H4>

<P>
Asks the database server to shut down. The connected user must have
<code>SHUTDOWN</code> privileges.
The <code>shutdown_level</code> argument was added in MySQL 4.1.3 (and 5.0.1). The
MySQL server currently supports only one type (level of gracefulness) of
shutdown; <code>shutdown_level</code> must be equal to
<code>SHUTDOWN_DEFAULT</code>. Later we will add more levels and then the
<code>shutdown_level</code> argument will enable to choose the desired level.
MySQL servers and MySQL clients before and after 4.1.3 are compatible; MySQL
servers newer than 4.1.3 accept the <code>mysql_shutdown(MYSQL *mysql)</code> call,
and MySQL servers older than 4.1.3 accept the new <code>mysql_shutdown()</code>
call. But dynamically linked executables which have been compiled with older
versions of <code>libmysqlclient</code> headers, and call <code>mysql_shutdown()</code>,
need to be used with the old <code>libmysqlclient</code> dynamic library.

</P>
<P>
The shutdown process is described in section <A HREF="manual_MySQL_Database_Administration.html#Server_Shutdown">5.3  The MySQL Server Shutdown Process</A>.

</P>

<H4>Return Values</H4>

<P>
Zero for success.  Non-zero if an error occurred.

</P>

<H4>Errors</H4>

<DL COMPACT>

<DT><code>CR_COMMANDS_OUT_OF_SYNC</code>
<DD>
Commands were executed in an improper order.
<DT><code>CR_SERVER_GONE_ERROR</code>
<DD>
The MySQL server has gone away.
<DT><code>CR_SERVER_LOST</code>
<DD>
The connection to the server was lost during the query.
<DT><code>CR_UNKNOWN_ERROR</code>
<DD>
An unknown error occurred.
</DL>



<H4><A NAME="mysql_sqlstate" HREF="manual_toc.html#mysql_sqlstate">21.2.3.53  <code>mysql_sqlstate()</code></A></H4>

<P>
<A NAME="IDX2153"></A>

</P>
<P>
<code>const char *mysql_sqlstate(MYSQL *mysql)</code>

</P>

<H4>Description</H4>

<P>
Returns a null-terminated string containing the SQLSTATE error code for the
last error.  The error code consists of five characters.
<code>'00000'</code> means ``no error.''
The values are specified by ANSI SQL and ODBC.
For a list of possible values, see section <A HREF="manual_Error-handling.html#Error-handling">23  Error Handling in MySQL</A>.

</P>
<P>
Note that not all MySQL errors are yet mapped to SQLSTATE's.
The value <code>'HY000'</code> (general error) is used
for unmapped errors.

</P>
<P>
This function was added to MySQL 4.1.1.

</P>

<H4>Return Values</H4>

<P>
A null-terminated character string containing the SQLSTATE error code.

</P>

<H4>See Also</H4>

<P>
See section <A HREF="manual_MySQL_APIs.html#mysql_errno">21.2.3.12  <code>mysql_errno()</code></A>.
See section <A HREF="manual_MySQL_APIs.html#mysql_error">21.2.3.13  <code>mysql_error()</code></A>.
See section <A HREF="manual_MySQL_APIs.html#mysql_stmt_sqlstate">21.2.7.26  <code>mysql_stmt_sqlstate()</code></A>.

</P>



<H4><A NAME="mysql_ssl_set" HREF="manual_toc.html#mysql_ssl_set">21.2.3.54  <code>mysql_ssl_set()</code></A></H4>

<P>
<A NAME="IDX2154"></A>

</P>
<P>
<code>int mysql_ssl_set(MYSQL *mysql, const char *key,
                 const char *cert, const char *ca,
                 const char *capath, const char *cipher)</code>

</P>

<H4>Description</H4>

<P>
<code>mysql_ssl_set()</code> is used for establishing secure connections using
SSL. It must be called before <code>mysql_real_connect()</code>.

</P>
<P>
<code>mysql_ssl_set()</code> does nothing unless OpenSSL support is enabled in
the client library.

</P>
<P>
<code>mysql</code> is the connection handler returned from <code>mysql_init()</code>.
The other parameters are specified as follows:

</P>

<UL>
<LI>

<code>key</code> is the pathname to the key file.

<LI>

<code>cert</code> is the pathname to the certificate file.

<LI>

<code>ca</code> is the pathname to the certificate authority file.

<LI>

<code>capath</code> is the pathname to a directory that contains trusted 
SSL CA certificates in pem format.

<LI>

<code>cipher</code> is a list of allowable ciphers to use for SSL encryption.

</UL>

<P>
Any unused SSL parameters may be given as <code>NULL</code>.

</P>

<H4>Return Values</H4>

<P>
This function always returns <code>0</code>. If SSL setup is incorrect,
<code>mysql_real_connect()</code> will return an error when you attempt to connect.

</P>


<H4><A NAME="mysql_stat" HREF="manual_toc.html#mysql_stat">21.2.3.55  <code>mysql_stat()</code></A></H4>

<P>
<A NAME="IDX2155"></A>

</P>
<P>
<code>char *mysql_stat(MYSQL *mysql)</code>

</P>

<H4>Description</H4>

<P>
Returns a character string containing information similar to that provided by
the <code>mysqladmin status</code> command.  This includes uptime in seconds and
the number of running threads, questions, reloads, and open tables.

</P>

<H4>Return Values</H4>

<P>
A character string describing the server status. <code>NULL</code> if an
error occurred.

</P>

<H4>Errors</H4>

<DL COMPACT>

<DT><code>CR_COMMANDS_OUT_OF_SYNC</code>
<DD>
Commands were executed in an improper order.
<DT><code>CR_SERVER_GONE_ERROR</code>
<DD>
The MySQL server has gone away.
<DT><code>CR_SERVER_LOST</code>
<DD>
The connection to the server was lost during the query.
<DT><code>CR_UNKNOWN_ERROR</code>
<DD>
An unknown error occurred.
</DL>



<H4><A NAME="mysql_store_result" HREF="manual_toc.html#mysql_store_result">21.2.3.56  <code>mysql_store_result()</code></A></H4>

<P>
<A NAME="IDX2156"></A>

</P>
<P>
<code>MYSQL_RES *mysql_store_result(MYSQL *mysql)</code>

</P>

<H4>Description</H4>

<P>
You must call <code>mysql_store_result()</code> or <code>mysql_use_result()</code>
for every query that successfully retrieves data (<code>SELECT</code>,
<code>SHOW</code>, <code>DESCRIBE</code>, <code>EXPLAIN</code>, <code>CHECK TABLE</code>, and so forth).

</P>
<P>
You don't have to call <code>mysql_store_result()</code> or
<code>mysql_use_result()</code> for other queries, but it will not do any
harm or cause any notable performance if you call <code>mysql_store_result()</code>
in all cases.  You can detect if the query didn't have a result set by
checking if <code>mysql_store_result()</code> returns 0 (more about this later on).

</P>
<P>
If you want to know whether the query should return a result set, you can
use <code>mysql_field_count()</code> to check for this.
See section <A HREF="manual_MySQL_APIs.html#mysql_field_count">21.2.3.20  <code>mysql_field_count()</code></A>.

</P>
<P>
<code>mysql_store_result()</code> reads the entire result of a query to the client,
allocates a <code>MYSQL_RES</code> structure, and places the result into this
structure.

</P>
<P>
<code>mysql_store_result()</code> returns a null pointer if the query didn't return
a result set (if the query was, for example, an <code>INSERT</code> statement).

</P>
<P>
<code>mysql_store_result()</code> also returns a null pointer if reading of the
result set failed. You can check whether an error occurred by checking if
<code>mysql_error()</code> returns a non-empty string, if
<code>mysql_errno()</code> returns non-zero, or if <code>mysql_field_count()</code>
returns zero.

</P>
<P>
An empty result set is returned if there are no rows returned.  (An empty
result set differs from a null pointer as a return value.)

</P>
<P>
Once you have called <code>mysql_store_result()</code> and got a result back
that isn't a null pointer, you may call <code>mysql_num_rows()</code> to find
out how many rows are in the result set.

</P>
<P>
You can call <code>mysql_fetch_row()</code> to fetch rows from the result set,
or <code>mysql_row_seek()</code> and <code>mysql_row_tell()</code> to obtain or
set the current row position within the result set.

</P>
<P>
You must call <code>mysql_free_result()</code> once you are done with the result
set.

</P>
<P>
See section <A HREF="manual_MySQL_APIs.html#NULL_mysql_store_result">21.2.13.1  Why <code>mysql_store_result()</code> Sometimes Returns <code>NULL</code> After <code>mysql_query()</code> Returns Success</A>.

</P>

<H4>Return Values</H4>

<P>
A <code>MYSQL_RES</code> result structure with the results. <code>NULL</code> if
an error occurred.

</P>

<H4>Errors</H4>

<P>
<code>mysql_store_result()</code> resets <code>mysql_error()</code> and
<code>mysql_errno()</code> if it succeeds.

</P>
<DL COMPACT>

<DT><code>CR_COMMANDS_OUT_OF_SYNC</code>
<DD>
Commands were executed in an improper order.
<DT><code>CR_OUT_OF_MEMORY</code>
<DD>
Out of memory.
<DT><code>CR_SERVER_GONE_ERROR</code>
<DD>
The MySQL server has gone away.
<DT><code>CR_SERVER_LOST</code>
<DD>
The connection to the server was lost during the query.
<DT><code>CR_UNKNOWN_ERROR</code>
<DD>
An unknown error occurred.
</DL>



<H4><A NAME="mysql_thread_id" HREF="manual_toc.html#mysql_thread_id">21.2.3.57  <code>mysql_thread_id()</code></A></H4>

<P>
<A NAME="IDX2157"></A>

</P>
<P>
<code>unsigned long mysql_thread_id(MYSQL *mysql)</code>

</P>

<H4>Description</H4>

<P>
Returns the thread ID of the current connection.  This value can be used as
an argument to <code>mysql_kill()</code> to kill the thread.

</P>
<P>
If the connection is lost and you reconnect with <code>mysql_ping()</code>, the
thread ID will change.  This means you should not get the thread ID and store
it for later. You should get it when you need it.

</P>

<H4>Return Values</H4>

<P>
The thread ID of the current connection.

</P>

<H4>Errors</H4>
<P>
None.

</P>



<H4><A NAME="mysql_use_result" HREF="manual_toc.html#mysql_use_result">21.2.3.58  <code>mysql_use_result()</code></A></H4>

<P>
<A NAME="IDX2158"></A>

</P>
<P>
<code>MYSQL_RES *mysql_use_result(MYSQL *mysql)</code>

</P>

<H4>Description</H4>

<P>
You must call <code>mysql_store_result()</code> or <code>mysql_use_result()</code> for
every query that successfully retrieves data (<code>SELECT</code>, <code>SHOW</code>,
<code>DESCRIBE</code>, <code>EXPLAIN</code>).

</P>
<P>
<code>mysql_use_result()</code> initiates a result set retrieval but does not
actually read the result set into the client like <code>mysql_store_result()</code>
does.  Instead, each row must be retrieved individually by making calls to
<code>mysql_fetch_row()</code>.  This reads the result of a query directly from the
server without storing it in a temporary table or local buffer, which is
somewhat faster and uses much less memory than <code>mysql_store_result()</code>.
The client will allocate memory only for the current row and a communication
buffer that may grow up to <code>max_allowed_packet</code> bytes.

</P>
<P>
On the other hand, you shouldn't use <code>mysql_use_result()</code> if you are
doing a lot of processing for each row on the client side, or if the output
is sent to a screen on which the user may type a <code>^S</code> (stop scroll).
This will tie up the server and prevent other threads from updating any
tables from which the data is being fetched.

</P>
<P>
When using <code>mysql_use_result()</code>, you must execute
<code>mysql_fetch_row()</code> until a <code>NULL</code> value is returned, otherwise, the
unfetched rows will be returned as part of the result set for your next
query. The C API will give the error <code>Commands out of sync; you can't
run this command now</code> if you forget to do this!

</P>
<P>
You may not use <code>mysql_data_seek()</code>, <code>mysql_row_seek()</code>,
<code>mysql_row_tell()</code>, <code>mysql_num_rows()</code>, or
<code>mysql_affected_rows()</code> with a result returned from
<code>mysql_use_result()</code>, nor may you issue other queries until the
<code>mysql_use_result()</code> has finished.  (However, after you have fetched all
the rows, <code>mysql_num_rows()</code> will accurately return the number of rows
fetched.)

</P>
<P>
You must call <code>mysql_free_result()</code> once you are done with the result
set.

</P>

<H4>Return Values</H4>

<P>
A <code>MYSQL_RES</code> result structure. <code>NULL</code> if an error occurred.

</P>

<H4>Errors</H4>

<P>
<code>mysql_use_result()</code> resets <code>mysql_error()</code> and
<code>mysql_errno()</code> if it succeeds.

</P>
<DL COMPACT>

<DT><code>CR_COMMANDS_OUT_OF_SYNC</code>
<DD>
Commands were executed in an improper order.
<DT><code>CR_OUT_OF_MEMORY</code>
<DD>
Out of memory.
<DT><code>CR_SERVER_GONE_ERROR</code>
<DD>
The MySQL server has gone away.
<DT><code>CR_SERVER_LOST</code>
<DD>
The connection to the server was lost during the query.
<DT><code>CR_UNKNOWN_ERROR</code>
<DD>
An unknown error occurred.
</DL>



<H4><A NAME="mysql_warning_count" HREF="manual_toc.html#mysql_warning_count">21.2.3.59  <code>mysql_warning_count()</code></A></H4>

<P>
<A NAME="IDX2159"></A>

</P>
<P>
<code>unsigned int mysql_warning_count(MYSQL *mysql)</code>

</P>

<H4>Description</H4>

<P>
Returns the number of warnings generated during execution of the previous
SQL statement.

</P>
<P>
This function was added in MySQL 4.1.0.

</P>

<H4>Return Values</H4>

<P>
The warning count.

</P>

<H4>Errors</H4>

<P>
None.

</P>



<H4><A NAME="mysql_commit" HREF="manual_toc.html#mysql_commit">21.2.3.60  <code>mysql_commit()</code></A></H4>

<P>
<A NAME="IDX2160"></A>

</P>
<P>
<code>my_bool mysql_commit(MYSQL *mysql)</code>

</P>

<H4>Description</H4>

<P>
Commits the current transaction.

</P>
<P>
This function was added in MySQL 4.1.0.

</P>

<H4>Return Values</H4>

<P>
Zero if successful. Non-zero if an error occurred.

</P>

<H4>Errors</H4>

<P>
None.

</P>



<H4><A NAME="mysql_rollback" HREF="manual_toc.html#mysql_rollback">21.2.3.61  <code>mysql_rollback()</code></A></H4>

<P>
<A NAME="IDX2161"></A>

</P>
<P>
<code>my_bool mysql_rollback(MYSQL *mysql)</code>

</P>

<H4>Description</H4>

<P>
Rolls back the current transaction.

</P>
<P>
This function was added in MySQL 4.1.0.

</P>

<H4>Return Values</H4>

<P>
Zero if successful. Non-zero if an error occurred.

</P>

<H4>Errors</H4>

<P>
None.

</P>



<H4><A NAME="mysql_autocommit" HREF="manual_toc.html#mysql_autocommit">21.2.3.62  <code>mysql_autocommit()</code></A></H4>

<P>
<A NAME="IDX2162"></A>

</P>
<P>
<code>my_bool mysql_autocommit(MYSQL *mysql, my_bool mode)</code>

</P>

<H4>Description</H4>

<P>
Sets autocommit mode on if <code>mode</code> is 1, off if <code>mode</code> is 0.

</P>
<P>
This function was added in MySQL 4.1.0.

</P>

<H4>Return Values</H4>

<P>
Zero if successful. Non-zero if an error occurred.

</P>

<H4>Errors</H4>

<P>
None.

</P>



<H4><A NAME="mysql_more_results" HREF="manual_toc.html#mysql_more_results">21.2.3.63  <code>mysql_more_results()</code></A></H4>

<P>
<A NAME="IDX2163"></A>

</P>
<P>
<code>my_bool mysql_more_results(MYSQL *mysql)</code>

</P>

<H4>Description</H4>

<P>
Returns true if more results exist from the currently executed query,
and the application must call <code>mysql_next_result()</code> to fetch the
results.

</P>
<P>
This function was added in MySQL 4.1.0.

</P>

<H4>Return Values</H4>

<P>
<code>TRUE</code> (1) if more results exist. <code>FALSE</code> (0) if no more results
exist.

</P>
<P>
In most cases, you can call <code>mysql_next_result()</code> instead to
test whether more results exist and initiate retrieval if so.

</P>
<P>
See section <A HREF="manual_MySQL_APIs.html#C_API_multiple_queries">21.2.9  C API Handling of Multiple Query Execution</A>.
See section <A HREF="manual_MySQL_APIs.html#mysql_next_result">21.2.3.64  <code>mysql_next_result()</code></A>.

</P>

<H4>Errors</H4>

<P>
None.

</P>



<H4><A NAME="mysql_next_result" HREF="manual_toc.html#mysql_next_result">21.2.3.64  <code>mysql_next_result()</code></A></H4>

<P>
<A NAME="IDX2164"></A>

</P>
<P>
<code>int mysql_next_result(MYSQL *mysql)</code>

</P>

<H4>Description</H4>

<P>
If more query results exist, <code>mysql_next_result()</code> reads the
next query results and returns the status back to application.

</P>
<P>
You must call <code>mysql_free_result()</code> for the preceding
query if it returned a result set.

</P>
<P>
After calling <code>mysql_next_result()</code> the state of the connection
is as if you had called <code>mysql_real_query()</code> or <code>mysql_query()</code>
for the next query.
This means that you can now call <code>mysql_store_result()</code>,
<code>mysql_warning_count()</code>, <code>mysql_affected_rows()</code>, and so forth.

</P>
<P>
If <code>mysql_next_result()</code> returns an error, no other statements will
be executed and there are no more results to fetch.

</P>
<P>
See section <A HREF="manual_MySQL_APIs.html#C_API_multiple_queries">21.2.9  C API Handling of Multiple Query Execution</A>.

</P>
<P>
This function was added in MySQL 4.1.0.

</P>

<H4>Return Values</H4>

<TABLE BORDER>
<TR><TD><strong>Return Value</strong> </TD><TD> <strong>Description</strong>
</TD></TR>
<TR><TD>0 </TD><TD> Successful and there are more results
</TD></TR>
<TR><TD>-1 </TD><TD> Successful and there are no more results
</TD></TR>
<TR><TD>&#62;0 </TD><TD> An error occurred
</TD></TR>
</TABLE>


<H4>Errors</H4>

<DL COMPACT>

<DT><code>CR_COMMANDS_OUT_OF_SYNC</code>
<DD>
Commands were executed in an improper order. For example if you didn't call
<code>mysql_use_result()</code> for a previous result set.
<DT><code>CR_SERVER_GONE_ERROR</code>
<DD>
The MySQL server has gone away.
<DT><code>CR_SERVER_LOST</code>
<DD>
The connection to the server was lost during the query.
<DT><code>CR_UNKNOWN_ERROR</code>
<DD>
An unknown error occurred.
</DL>



<H3><A NAME="C_API_Prepared_statements" HREF="manual_toc.html#C_API_Prepared_statements">21.2.4  C API Prepared Statements</A></H3>

<P>
As of MySQL 4.1, the client/server protocol provides for the use of
prepared statements. This capability uses the
<code>MYSQL_STMT</code> statement handler data structure returned by the
<code>mysql_stmt_init()</code> initialization function.
Prepared execution is an efficient way to execute a statement more than
once. The statement is first parsed to prepare it for execution. Then
it is executed one or more times at a later time, using the statement
handle returned by the initialization function.

</P>
<P>
Prepared execution is faster than direct execution for statements
executed more than once, primarly because the query is parsed only
once. In the case of direct execution, the query is parsed every
time it is executed. Prepared execution also can provide a reduction of network
traffic because for each execution of the prepared statement,
it is necessary only to send the data for the parameters.

</P>
<P>
Another advantage of prepared statements is that it uses a binary protocol
that makes data transfer between client and server more efficient.

</P>
<P>
The following statements can be used as prepared statements:
<code>CREATE TABLE</code>,
<code>DELETE</code>,
<code>DO</code>,
<code>INSERT</code>,
<code>REPLACE</code>,
<code>SELECT</code>,
<code>SET</code>,
<code>UPDATE</code>,
and most
<code>SHOW</code>,
statements.
Other statements are not yet supported.

</P>



<H3><A NAME="C_API_Prepared_statement_datatypes" HREF="manual_toc.html#C_API_Prepared_statement_datatypes">21.2.5  C API Prepared Statement Data types</A></H3>

<P>
<strong>Note</strong>:
Some incompatible changes were made in MySQL 4.1.2.
See section <A HREF="manual_MySQL_APIs.html#C_API_Prepared_statement_functions">21.2.7  C API Prepared Statement Function Descriptions</A> for details.

</P>
<P>
Prepared statements mainly use the <code>MYSQL_STMT</code> and
<code>MYSQL_BIND</code> data structures. A third structure, <code>MYSQL_TIME</code>,
is used to transfer temporal data.

</P>
<DL COMPACT>

<DT><code>MYSQL_STMT</code>
<DD>
<A NAME="IDX2165"></A>
This structure represents a prepared statement.
A statement is created by calling <code>mysql_stmt_init()</code>,
which returns a statement handle, that is, a pointer to a
<code>MYSQL_STMT</code>.
The handle is used for all subsequent statement-related functions until you
close it with <code>mysql_stmt_close()</code>.

The <code>MYSQL_STMT</code> structure has no members that are for application
use.

Multiple statement handles can be associated with a single connection.
The limit on the number of handles depends on the available system resources.

<DT><code>MYSQL_BIND</code>
<DD>
<A NAME="IDX2166"></A>
This structure is used both for statement input (data values sent to the server)
and output (result values returned from the server). For input, it is used with
<code>mysql_stmt_bind_param()</code> to bind parameter data values to
buffers for use by <code>mysql_stmt_execute()</code>. For output, it is
used with <code>mysql_stmt_bind_result()</code> to bind result set
buffers for use in fetching rows with <code>mysql_stmt_fetch()</code>.

The <code>MYSQL_BIND</code> structure contains the following members for
use by application programs.
Each is used both for input and for output, although sometimes for different
purposes depending on the direction of data transfer.

<DL COMPACT>

<DT><code>enum enum_field_types buffer_type</code>
<DD>
The type of the buffer. The allowable <code>buffer_type</code> values are listed
later in this section. For input, <code>buffer_type</code> indicates what type of
value you are binding to a statement parameter. For output, it indicates what
type of value you expect to receive in a result buffer.

<DT><code>void *buffer</code>
<DD>
For input, this is a pointer to the buffer in which a statement parameter's data
value is stored. For output, it is
a pointer to the buffer in which to return a result set column value.
For numeric column types, <code>buffer</code> should point to a variable of the proper
C type.  (If you are associating the variable with a column that has the
<code>UNSIGNED</code> attribute, the variable should be an <code>unsigned</code> C type.
Indicate whether the variable is signed or unsigned by using the
<code>is_unsigned</code> member, described later in this list.)
For date and time column types, <code>buffer</code> should point to a
<code>MYSQL_TIME</code> structure.  For character and binary string column types,
<code>buffer</code> should point to a character buffer.

<DT><code>unsigned long buffer_length</code>
<DD>
The actual size of <code>*buffer</code> in bytes. This indicates the maximum amount
of data that can be stored in the buffer. For character and binary C data,
the <code>buffer_length</code> value specifies the length of <code>*buffer</code>
when used with <code>mysql_stmt_bind_param()</code>,
or the maximum number of data bytes that can be fetched into the buffer
when used with <code>mysql_stmt_bind_result()</code>.

<DT><code>unsigned long *length</code>
<DD>
A pointer to an <code>unsigned long</code> variable that indicates the actual number
of bytes of data stored in <code>*buffer</code>.
<code>length</code> is used for character or binary C data.
For input parameter data binding, <code>length</code>
points to an <code>unsigned long</code> variable that indicates the
length of the parameter value stored in <code>*buffer</code>; this is used by
<code>mysql_stmt_execute()</code>.
For output value binding, <code>mysql_stmt_fetch()</code> places
the length of the column value that is returned
into the variable that <code>length</code> points to.

<code>length</code>
is ignored for numeric and temporal data types because the length
of the data value is determined by the <code>buffer_type</code> value.

<DT><code>my_bool *is_null</code>
<DD>
This member points to a <code>my_bool</code> variable that is true if a value is
<code>NULL</code>, false if it is not <code>NULL</code>. For input, set <code>*is_null</code>
to true to
indicate that you are passing a <code>NULL</code> value as a statement parameter. For
output, this value will be set to true after you fetch a row if the result
set column value returned from the statement is <code>NULL</code>.

<DT><code>my_bool is_unsigned</code>
<DD>
This member is used for integer types.
(These correspond to the <code>MYSQL_TYPE_TINY</code>, <code>MYSQL_TYPE_SHORT</code>,
<code>MYSQL_TYPE_LONG</code>, and <code>MYSQL_TYPE_LONGLONG</code> type codes.)
<code>is_unsigned</code>
should be set to true for unsigned types and false for signed types.

<DT><code>my_bool error</code>
<DD>
For output, this member is used output to report data truncation errors.
Truncation reporting must be enabled by calling <code>mysql_options()</code>
with the <code>MYSQL_REPORT_DATA_TRUNCATION</code> option.  When enabled,
<code>mysql_stmt_fetch()</code> returns <code>MYSQL_DATA_TRUNCATED</code> and
<code>error</code> is true in the <code>MYSQL_BIND</code> structures for parameters
in which truncation occurred. Truncation indicates loss of sign or
significant digits, or that a string was too long to fit in a column.
The <code>error</code> member was added in MySQL 5.0.3.

</DL>

To use a <code>MYSQL_BIND</code> structure, you should zero its contents
to initialize it, and then set the members just described appropriately.
For example, to declare and initialize an array of three <code>MYSQL_BIND</code>
structures, use this code:


<PRE>
MYSQL_BIND    bind[3];
memset(bind, 0, sizeof(bind));
</PRE>

<DT><code>MYSQL_TIME</code>
<DD>
<A NAME="IDX2167"></A>
This structure is used to send and receive <code>DATE</code>, <code>TIME</code>,
<code>DATETIME</code>, and <code>TIMESTAMP</code> data directly to and from the server.
This is done by setting the <code>buffer_type</code> member of a <code>MYSQL_BIND</code>
structure to one of the temporal types, and setting the <code>buffer</code> member
to point to a <code>MYSQL_TIME</code> structure.

The <code>MYSQL_TIME</code> structure contains the following members:

<DL COMPACT>

<DT><code>unsigned int year</code>
<DD>
The year.

<DT><code>unsigned int month</code>
<DD>
The month of the year.

<DT><code>unsigned int day</code>
<DD>
The day of the month.

<DT><code>unsigned int hour</code>
<DD>
The hour of the day.

<DT><code>unsigned int minute</code>
<DD>
The minute of the hour.

<DT><code>unsigned int second</code>
<DD>
The second of the minute.

<DT><code>my_bool neg</code>
<DD>
A boolean flag to indicate whether the time is negative.

<DT><code>unsigned long second_part</code>
<DD>
The fractional part of the second.
This member currently is unused.

</DL>

Only those parts of a <code>MYSQL_TIME</code> structure that apply to a given
type of temporal value are used:
The <code>year</code>, <code>month</code>, and <code>day</code> elements are used for
<code>DATE</code>, <code>DATETIME</code>, and <code>TIMESTAMP</code> values.
The <code>hour</code>, <code>minute</code>, and <code>second</code> elements are used for
<code>TIME</code>, <code>DATETIME</code>, and <code>TIMESTAMP</code> values.
See section <A HREF="manual_MySQL_APIs.html#C_API_date_handling">21.2.10  C API Handling of Date and Time Values</A>.

</DL>

<P>
The following table shows the allowable values that may be specified in the
<code>buffer_type</code> member of <code>MYSQL_BIND</code> structures.
The table also shows those SQL types that correspond most closely to each
<code>buffer_type</code> value, and, for numeric and temporal types, the
corresponding C type.

</P>
<TABLE BORDER>
<TR><TD><code>buffer_type</code> <strong>Value</strong> </TD><TD> <strong>SQL Type</strong> </TD><TD> <strong>C Type</strong>
</TD></TR>
<TR><TD><code>MYSQL_TYPE_TINY</code> </TD><TD> <code>TINYINT</code> </TD><TD> <code>char</code>
</TD></TR>
<TR><TD><code>MYSQL_TYPE_SHORT</code> </TD><TD> <code>SMALLINT</code> </TD><TD> <code>short int</code>
</TD></TR>
<TR><TD><code>MYSQL_TYPE_LONG</code> </TD><TD> <code>INT</code> </TD><TD> <code>int</code>
</TD></TR>
<TR><TD><code>MYSQL_TYPE_LONGLONG</code> </TD><TD> <code>BIGINT</code> </TD><TD> <code>long long int</code>
</TD></TR>
<TR><TD><code>MYSQL_TYPE_FLOAT</code> </TD><TD> <code>FLOAT</code> </TD><TD> <code>float</code>
</TD></TR>
<TR><TD><code>MYSQL_TYPE_DOUBLE</code> </TD><TD> <code>DOUBLE</code> </TD><TD> <code>double</code>
</TD></TR>
<TR><TD><code>MYSQL_TYPE_TIME</code> </TD><TD> <code>TIME</code> </TD><TD> <code>MYSQL_TIME</code>
</TD></TR>
<TR><TD><code>MYSQL_TYPE_DATE</code> </TD><TD> <code>DATE</code> </TD><TD> <code>MYSQL_TIME</code>
</TD></TR>
<TR><TD><code>MYSQL_TYPE_DATETIME</code> </TD><TD> <code>DATETIME</code> </TD><TD> <code>MYSQL_TIME</code>
</TD></TR>
<TR><TD><code>MYSQL_TYPE_TIMESTAMP</code> </TD><TD> <code>TIMESTAMP</code> </TD><TD> <code>MYSQL_TIME</code>
</TD></TR>
<TR><TD><code>MYSQL_TYPE_STRING</code> </TD><TD> <code>CHAR</code> </TD><TD>
</TD></TR>
<TR><TD><code>MYSQL_TYPE_VAR_STRING</code> </TD><TD> <code>VARCHAR</code> </TD><TD>
</TD></TR>
<TR><TD><code>MYSQL_TYPE_TINY_BLOB</code> </TD><TD> <code>TINYBLOB/TINYTEXT</code> </TD><TD>
</TD></TR>
<TR><TD><code>MYSQL_TYPE_BLOB</code> </TD><TD> <code>BLOB/TEXT</code> </TD><TD>
</TD></TR>
<TR><TD><code>MYSQL_TYPE_MEDIUM_BLOB</code> </TD><TD> <code>MEDIUMBLOB/MEDIUMTEXT</code> </TD><TD>
</TD></TR>
<TR><TD><code>MYSQL_TYPE_LONG_BLOB</code> </TD><TD> <code>LONGBLOB/LONGTEXT</code> </TD><TD>
</TD></TR>
</TABLE>

<P>
Implicit type conversion may be performed in both directions.

</P>



<H3><A NAME="C_API_Prepared_statement_function_overview" HREF="manual_toc.html#C_API_Prepared_statement_function_overview">21.2.6  C API Prepared Statement Function Overview</A></H3>

<P>
<A NAME="IDX2168"></A>
<A NAME="IDX2169"></A>

</P>
<P>
<strong>Note</strong>:
Some incompatible changes were made in MySQL 4.1.2.
See section <A HREF="manual_MySQL_APIs.html#C_API_Prepared_statement_functions">21.2.7  C API Prepared Statement Function Descriptions</A> for details.

</P>

<P>
The functions available for prepared statement processing are summarized here and
described in greater detail in a later section.
See section <A HREF="manual_MySQL_APIs.html#C_API_Prepared_statement_functions">21.2.7  C API Prepared Statement Function Descriptions</A>.

</P>

<TABLE BORDER>
<TR><TD><strong>Function</strong> </TD><TD> <strong>Description</strong>

</TD></TR>
<TR><TD><strong>mysql_stmt_affected_rows()</strong> </TD><TD>
Returns the number of rows changes, deleted, or inserted by prepared
<code>UPDATE</code>, <code>DELETE</code>, or <code>INSERT</code> statement.

</TD></TR>
<TR><TD><strong>mysql_stmt_attr_get()</strong> </TD><TD>
Get value of an attribute for a prepared statement.

</TD></TR>
<TR><TD><strong>mysql_stmt_attr_set()</strong> </TD><TD>
Sets an attribute for a prepared statement.

</TD></TR>
<TR><TD><strong>mysql_stmt_bind_param()</strong> </TD><TD>
Associates application data buffers with the parameter markers in a prepared
SQL statement.

</TD></TR>
<TR><TD><strong>mysql_stmt_bind_result()</strong> </TD><TD>
Associates application data buffers with columns in the result set.

</TD></TR>
<TR><TD><strong>mysql_stmt_close()</strong> </TD><TD>
Frees memory used by prepared statement.

</TD></TR>
<TR><TD><strong>mysql_stmt_data_seek()</strong> </TD><TD>
Seeks to an arbitrary row number in a statement result set.

</TD></TR>
<TR><TD><strong>mysql_stmt_errno()</strong> </TD><TD>
Returns the error number for the last statement execution.

</TD></TR>
<TR><TD><strong>mysql_stmt_error()</strong> </TD><TD>
Returns the error message for the last statement execution.

</TD></TR>
<TR><TD><strong>mysql_stmt_execute()</strong> </TD><TD>
Executes the prepared statement.

</TD></TR>
<TR><TD><strong>mysql_stmt_fetch()</strong> </TD><TD>
Fetches the next row of data from the result set and returns data for all bound columns.

</TD></TR>
<TR><TD><strong>mysql_stmt_fetch_column()</strong> </TD><TD>
Fetch data for one column of the current row of the result set.

</TD></TR>
<TR><TD><strong>mysql_stmt_field_count()</strong> </TD><TD>
Returns the number of result columns for the most recent statement.

</TD></TR>
<TR><TD><strong>mysql_stmt_free_result()</strong> </TD><TD>
Free the resources allocated to the statement handle.

</TD></TR>
<TR><TD><strong>mysql_stmt_init()</strong> </TD><TD>
Allocates memory for <code>MYSQL_STMT</code> structure and initializes it.

</TD></TR>
<TR><TD><strong>mysql_stmt_insert_id()</strong> </TD><TD>
Returns the ID generated for an <code>AUTO_INCREMENT</code> column by prepared
statement.

</TD></TR>
<TR><TD><strong>mysql_stmt_num_rows()</strong> </TD><TD>
Returns total rows from the statement buffered result set.

</TD></TR>
<TR><TD><strong>mysql_stmt_param_count()</strong> </TD><TD>
Returns the number of parameters in a prepared SQL statement.

</TD></TR>
<TR><TD><strong>mysql_stmt_param_metadata()</strong> </TD><TD>
Return parameter metadata in the form of a result set.

</TD></TR>
<TR><TD><strong>mysql_stmt_prepare()</strong> </TD><TD>
Prepares an SQL string for execution.

</TD></TR>
<TR><TD><strong>mysql_stmt_reset()</strong> </TD><TD>
Reset the statement buffers in the server.

</TD></TR>
<TR><TD><strong>mysql_stmt_result_metadata()</strong> </TD><TD>
Returns prepared statement metadata in the form of a result set.

</TD></TR>
<TR><TD><strong>mysql_stmt_row_seek()</strong> </TD><TD>
Seeks to a row offset in a statement result set, using value returned from
<code>mysql_stmt_row_tell()</code>.

</TD></TR>
<TR><TD><strong>mysql_stmt_row_tell()</strong> </TD><TD>
Returns the statement row cursor position.

</TD></TR>
<TR><TD><strong>mysql_stmt_send_long_data()</strong> </TD><TD>
Sends long data in chunks to server.

</TD></TR>
<TR><TD><strong>mysql_stmt_sqlstate()</strong> </TD><TD>
Returns the SQLSTATE error code for the last statement execution.

</TD></TR>
<TR><TD><strong>mysql_stmt_store_result()</strong> </TD><TD>
Retrieves the complete result set to the client.

</TD></TR>
</TABLE>

<P>
Call <code>mysql_stmt_init()</code> to create a statement
handle, then <code>mysql_stmt_prepare</code> to prepare it, 
<code>mysql_stmt_bind_param()</code> to supply the parameter
data, and <code>mysql_stmt_execute()</code> to execute the statement. You can
repeat the <code>mysql_stmt_execute()</code> by changing parameter values in the
respective buffers supplied through <code>mysql_stmt_bind_param()</code>.

</P>
<P>
If the statement is a <code>SELECT</code> or any other statement that produces
a result set, <code>mysql_stmt_prepare()</code> will also return the result
set metadata information in the form of a <code>MYSQL_RES</code> result set 
through <code>mysql_stmt_result_metadata()</code>.

</P>
<P>
You can supply the result buffers using <code>mysql_stmt_bind_result()</code>, so
that the <code>mysql_stmt_fetch()</code> will automatically return data to these
buffers. This is row-by-row fetching.

</P>
<P>
You can also send the text or binary data in chunks to server using
<code>mysql_stmt_send_long_data()</code>.
See section <A HREF="manual_MySQL_APIs.html#mysql_stmt_send_long_data">21.2.7.25  <code>mysql_stmt_send_long_data()</code></A>.

</P>
<P>
When statement execution has been completed, the statement handle must be
closed using <code>mysql_stmt_close()</code> so that all resources associated
with it can be freed.

</P>
<P>
If you obtained a <code>SELECT</code> statement's result set metadata by calling
<code>mysql_stmt_result_metadata()</code>, you should also free the metadata using
<code>mysql_free_result()</code>.

</P>

<H4>Execution Steps</H4>

<P>
To prepare and execute a statement, an application follows these steps:

</P>

<OL>
<LI>

Create a prepared statement handle with <code>msyql_stmt_init()</code>.
To prepare the statement on the server, call <code>mysql_stmt_prepare()</code> and
pass it a string containing the SQL statement.
<LI>

If the statement produces a result set, call <code>mysql_stmt_result_metadata()</code>
to obtain the result set metadata.  This metadata is itself in the form of
result set, albeit a separate one from the one that contains the rows returned
by the query. The metadata result set indicates how many columns are in the
result and contains information about each column.
<LI>

Set the values of any parameters using <code>mysql_stmt_bind_param()</code>. All
parameters must be set. Otherwise, statement execution will return an error or
produce unexpected results.
<LI>

Call <code>mysql_stmt_execute()</code> to execute the statement.
<LI>

If the statement produces a result set,
bind the data buffers to use for retrieving the row values by calling
<code>mysql_stmt_bind_result()</code>.
<LI>

Fetch the data into the buffers row by row by calling
<code>mysql_stmt_fetch()</code> repeatedly until no more rows are found.
<LI>

Repeat steps 3 through 6 as necessary, by changing the parameter values and
re-executing the statement.

</OL>

<P>
When <code>mysql_stmt_prepare()</code> is called, the MySQL client/server protocol
performs these actions:

</P>

<UL>
<LI>

The server parses the statement and sends the okay status back to the client by
assigning a statement ID. It also sends total number of parameters,
a column count, and its metadata if it is a result set oriented
statement. All syntax and semantics of the statement are checked by the server
during this call.
<LI>

The client uses this statement ID for the further operations, so that the server
can identify the statement from among its pool of statements.
</UL>

<P>
When <code>mysql_stmt_execute()</code> is called, the MySQL
client/server protocol performs these actions:

</P>

<UL>
<LI>

The client uses the statement handle and sends the parameter data to the
server.
<LI>

The server identifies the statement using the ID provided by the client,
replaces the parameter markers with the newly supplied data, and executes
the statement. If the statement produces a result set, the server sends
the data back to the client. Otherwise, it sends an okay status and total
number of rows changed, deleted, or inserted.
</UL>

<P>
When <code>mysql_stmt_fetch()</code> is called, the MySQL client/server protocol
performs these actions:

</P>

<UL>
<LI>

The client reads the data from the packet row by row and places it into the
application data buffers by doing the necessary conversions. If the
application buffer type is same as that of the field type returned from the
server, the conversions are straightforward.
</UL>

<P>
If an error occurs,
you can get the statement error code, error message, and SQLSTATE value using
<code>mysql_stmt_errno()</code>, <code>mysql_stmt_error()</code>, and
<code>mysql_stmt_sqlstate()</code>, respectively.

</P>



<H3><A NAME="C_API_Prepared_statement_functions" HREF="manual_toc.html#C_API_Prepared_statement_functions">21.2.7  C API Prepared Statement Function Descriptions</A></H3>

<P>
To prepare and execute queries, use the functions in the following sections.

</P>
<P>
In MySQL 4.1.2, the names of several prepared statement functions were
changed:

</P>
<TABLE BORDER>
<TR><TD><strong>Old Name</strong> </TD><TD> <strong>New Name</strong>
</TD></TR>
<TR><TD><code>mysql_bind_param()</code> </TD><TD> <code>mysql_stmt_bind_param()</code>
</TD></TR>
<TR><TD><code>mysql_bind_result()</code> </TD><TD> <code>mysql_stmt_bind_result()</code>
</TD></TR>
<TR><TD><code>mysql_prepare()</code> </TD><TD> <code>mysql_stmt_prepare()</code>
</TD></TR>
<TR><TD><code>mysql_execute()</code> </TD><TD> <code>mysql_stmt_execute()</code>
</TD></TR>
<TR><TD><code>mysql_fetch()</code> </TD><TD> <code>mysql_stmt_fetch()</code>
</TD></TR>
<TR><TD><code>mysql_fetch_column()</code> </TD><TD> <code>mysql_stmt_fetch_column()</code>
</TD></TR>
<TR><TD><code>mysql_param_count()</code> </TD><TD> <code>mysql_stmt_param_count()</code>
</TD></TR>
<TR><TD><code>mysql_param_result()</code> </TD><TD> <code>mysql_stmt_param_metadata()</code>
</TD></TR>
<TR><TD><code>mysql_get_metadata()</code> </TD><TD> <code>mysql_stmt_result_metadata()</code>
</TD></TR>
<TR><TD><code>mysql_send_long_data()</code> </TD><TD> <code>mysql_stmt_send_long_data()</code>
</TD></TR>
</TABLE>

<P>
All functions that operate with a <code>MYSQL_STMT</code> structure now begin with
the prefix <code>mysql_stmt_</code>.

</P>
<P>
Also in 4.1.2, the signature of the <code>mysql_stmt_prepare()</code> function was
changed to <code>int mysql_stmt_prepare(MYSQL_STMT *stmt, const char *query,
unsigned long length)</code>.  To create a <code>MYSQL_STMT</code> handle, you should
use the <code>mysql_stmt_init()</code> function.

</P>



<H4><A NAME="mysql_stmt_affected_rows" HREF="manual_toc.html#mysql_stmt_affected_rows">21.2.7.1  <code>mysql_stmt_affected_rows()</code></A></H4>

<P>
<A NAME="IDX2170"></A>

</P>
<P>
<code>my_ulonglong mysql_stmt_affected_rows(MYSQL_STMT *stmt)</code>

</P>

<H4>Description</H4>

<P>
Returns the total number of rows changed, deleted, or inserted by the last
executed statement. May be called immediately after <code>mysql_stmt_execute()</code>
for <code>UPDATE</code>, <code>DELETE</code>, or <code>INSERT</code> statements. For
<code>SELECT</code> statements, <code>mysql_stmt_affected_rows()</code> works like
<code>mysql_num_rows()</code>.

</P>

<P>
This function was added in MySQL 4.1.0.

</P>

<H4>Return Values</H4>

<P>
An integer greater than zero indicates the number of rows affected
or retrieved. Zero indicates that no records were updated for an
<code>UPDATE</code> statement, no rows matched the <code>WHERE</code> clause in
the query, or that no query has yet been executed. -1 indicates that
the query returned an error or that, for a <code>SELECT</code> query,
<code>mysql_stmt_affected_rows()</code> was called prior to calling
<code>mysql_stmt_store_result()</code>.
Because <code>mysql_stmt_affected_rows()</code>
returns an unsigned value, you can check for -1 by comparing the
return value to <code>(my_ulonglong)-1</code> (or to <code>(my_ulonglong)~0</code>,
which is equivalent).

</P>
<P>
See section <A HREF="manual_MySQL_APIs.html#mysql_affected_rows">21.2.3.1  <code>mysql_affected_rows()</code></A> for additional
information on the return value.

</P>

<H4>Errors</H4>

<P>
None.

</P>

<H4>Example</H4>

<P>
For the usage of <code>mysql_stmt_affected_rows()</code>, refer to the Example
from section <A HREF="manual_MySQL_APIs.html#mysql_stmt_execute">21.2.7.10  <code>mysql_stmt_execute()</code></A>.

</P>



<H4><A NAME="mysql_stmt_attr_get" HREF="manual_toc.html#mysql_stmt_attr_get">21.2.7.2  <code>mysql_stmt_attr_get()</code></A></H4>

<P>
<A NAME="IDX2171"></A>

</P>
<P>
<code>int mysql_stmt_attr_get(MYSQL_STMT *stmt, enum enum_stmt_attr_type option, void *arg)</code>

</P>

<H4>Description</H4>

<P>
Can be used to get the current value for a statement attribute.

</P>
<P>
The <code>option</code> argument is the option that you want to get; the
<code>arg</code> should point to a variable that should contain the option
value. If the option is an integer, then <code>arg</code> should point to the
value of the integer.

</P>
<P>
See <code>mysql_stmt_attr_set()</code> for a list of options and option
types. See section <A HREF="manual_MySQL_APIs.html#mysql_stmt_attr_set">21.2.7.3  <code>mysql_stmt_attr_set()</code></A>.

</P>
<P>
This function was added in MySQL 4.1.2.

</P>

<H4>Return Values</H4>

<P>
<code>0</code> if okay.  Non-zero if <code>option</code> is unknown.

</P>

<H4>Errors</H4>

<P>
None.

</P>



<H4><A NAME="mysql_stmt_attr_set" HREF="manual_toc.html#mysql_stmt_attr_set">21.2.7.3  <code>mysql_stmt_attr_set()</code></A></H4>

<P>
<A NAME="IDX2172"></A>

</P>
<P>
<code>int mysql_stmt_attr_set(MYSQL_STMT *stmt, enum enum_stmt_attr_type option, const void *arg)</code>

</P>

<H4>Description</H4>

<P>
Can be used to set affect behavior for a statement.
This function may be called multiple times to set several options.

</P>
<P>
The <code>option</code> argument is the option that you want to set; the <code>arg</code>
argument is the value for the option. If the option is an integer, then
<code>arg</code> should point to the value of the integer.

</P>
<P>
Possible options values:

</P>
<TABLE BORDER>
<TR><TD><strong>Option</strong> </TD><TD> <strong>Argument Type</strong> </TD><TD> <strong>Function</strong>
</TD></TR>
<TR><TD><code>STMT_ATTR_UPDATE_MAX_LENGTH</code> </TD><TD> <code>my_bool *</code> </TD><TD> If set to 1: Update metadata <code>MYSQL_FIELD-&#62;max_length</code> in <code>mysql_stmt_store_result()</code>.
</TD></TR>
</TABLE>

<P>
This function was added in MySQL 4.1.2.

</P>

<H4>Return Values</H4>

<P>
<code>0</code> if okay.  Non-zero if <code>option</code> is unknown.

</P>

<H4>Errors</H4>

<P>
None.

</P>



<H4><A NAME="mysql_stmt_bind_param" HREF="manual_toc.html#mysql_stmt_bind_param">21.2.7.4  <code>mysql_stmt_bind_param()</code></A></H4>

<P>
<A NAME="IDX2173"></A>

</P>
<P>
<code>my_bool mysql_stmt_bind_param(MYSQL_STMT *stmt, MYSQL_BIND *bind)</code>

</P>

<H4>Description</H4>

<P>
<code>mysql_stmt_bind_param()</code> is used to bind data for the parameter markers
in the SQL statement that was passed to <code>mysql_stmt_prepare()</code>. It uses
<code>MYSQL_BIND</code> structures to supply the data. <code>bind</code> is the address
of an array of <code>MYSQL_BIND</code> structures.
The client library expects the array to contain an element for each
<samp>`?'</samp> parameter marker that is present in the query.

</P>
<P>
Suppose that you prepare the following statement:

</P>

<PRE>
INSERT INTO mytbl VALUES(?,?,?)
</PRE>

<P>
When you bind the parameters, the array of <code>MYSQL_BIND</code> structures must
contain three elements, and can be declared like this:

</P>

<PRE>
MYSQL_BIND bind[3];
</PRE>

<P>
The members of each <code>MYSQL_BIND</code> element that should be set are described
in section <A HREF="manual_MySQL_APIs.html#C_API_Prepared_statement_datatypes">21.2.5  C API Prepared Statement Data types</A>.

</P>
<P>
This function was added in MySQL 4.1.2.

</P>

<H4>Return Values</H4>

<P>
Zero if the bind was successful. Non-zero if an error occurred.

</P>

<H4>Errors</H4>
<DL COMPACT>

<DT><code>CR_INVALID_BUFFER_USE</code>
<DD>
Indicates if the bind is to supply the long data in chunks and if the
buffer type is non string or binary.
<DT><code>CR_UNSUPPORTED_PARAM_TYPE</code>
<DD>
The conversion is not supported. Possibly the <code>buffer_type</code> value is
illegal or is not one of the supported types.
<DT><code>CR_OUT_OF_MEMORY</code>
<DD>
Out of memory.
<DT><code>CR_UNKNOWN_ERROR</code>
<DD>
An unknown error occurred.
</DL>


<H4>Example</H4>

<P>
For the usage of <code>mysql_stmt_bind_param()</code>, refer to the Example from
section <A HREF="manual_MySQL_APIs.html#mysql_stmt_execute">21.2.7.10  <code>mysql_stmt_execute()</code></A>.

</P>



<H4><A NAME="mysql_stmt_bind_result" HREF="manual_toc.html#mysql_stmt_bind_result">21.2.7.5  <code>mysql_stmt_bind_result()</code></A></H4>

<P>
<A NAME="IDX2174"></A>

</P>
<P>
<code>my_bool mysql_stmt_bind_result(MYSQL_STMT *stmt, MYSQL_BIND *bind)</code>

</P>

<H4>Description</H4>

<P>
<code>mysql_stmt_bind_result()</code> is used to associate (bind) columns in the
result set to data buffers and length buffers. When
<code>mysql_stmt_fetch()</code> is
called to fetch data, the MySQL client/server protocol places the data for the
bound columns into the specified buffers.

</P>
<P>
All columns must be bound to buffers prior to calling
<code>mysql_stmt_fetch()</code>.
<code>bind</code> is the address of an array of <code>MYSQL_BIND</code> structures.
The client library expects the array to contain
an element for each column of the result set.
If you do not bind columns to <code>MYSQL_BIND</code> structures,
<code>mysql_stmt_fetch()</code> simply ignores
the data fetch. The buffers should be large enough to hold the
data values, because the protocol doesn't return data values in chunks.

</P>
<P>
A column can be bound or rebound at any time, even after a result set has been
partially retrieved.  The new binding takes effect the next time
<code>mysql_stmt_fetch()</code> is called. Suppose that an application binds
the columns in a result set and calls <code>mysql_stmt_fetch()</code>.
The client/server
protocol returns data in the bound buffers. Then suppose the application
binds the columns to a different set of buffers. The protocol does
not place data into the newly bound
buffers until the next call to <code>mysql_stmt_fetch()</code> occurs.

</P>
<P>
To bind a column, an application calls <code>mysql_stmt_bind_result()</code> and
passes the type, address, and the address of the length buffer.
The members of each <code>MYSQL_BIND</code> element that should be set are described
in section <A HREF="manual_MySQL_APIs.html#C_API_Prepared_statement_datatypes">21.2.5  C API Prepared Statement Data types</A>.

</P>
<P>
This function was added in MySQL 4.1.2.

</P>

<H4>Return Values</H4>

<P>
Zero if the bind was successful. Non-zero if an error occurred.

</P>

<H4>Errors</H4>

<DL COMPACT>

<DT><code>CR_UNSUPPORTED_PARAM_TYPE</code>
<DD>
The conversion is not supported. Possibly the <code>buffer_type</code> value is
illegal or is not one of the supported types.
<DT><code>CR_OUT_OF_MEMORY</code>
<DD>
Out of memory.
<DT><code>CR_UNKNOWN_ERROR</code>
<DD>
An unknown error occurred.
</DL>


<H4>Example</H4>

<P>
For the usage of <code>mysql_stmt_bind_result()</code>, refer to the Example from
section <A HREF="manual_MySQL_APIs.html#mysql_stmt_fetch">21.2.7.13  <code>mysql_stmt_fetch()</code></A>.

</P>



<H4><A NAME="mysql_stmt_close" HREF="manual_toc.html#mysql_stmt_close">21.2.7.6  <code>mysql_stmt_close()</code></A></H4>

<P>
<A NAME="IDX2175"></A>

</P>
<P>
<code>my_bool mysql_stmt_close(MYSQL_STMT *)</code>

</P>

<H4>Description</H4>

<P>
Closes the prepared statement. <code>mysql_stmt_close()</code> also
deallocates the statement handle pointed to by <code>stmt</code>. 

</P>
<P>
If the current statement has pending or unread results, this function
cancels them so that the next query can be executed.

</P>
<P>
This function was added in MySQL 4.1.0.

</P>

<H4>Return Values</H4>

<P>
Zero if the statement was freed successfully. Non-zero if an error occurred.

</P>

<H4>Errors</H4>

<DL COMPACT>

<DT><code>CR_SERVER_GONE_ERROR</code>
<DD>
The MySQL server has gone away.
<DT><code>CR_UNKNOWN_ERROR</code>
<DD>
An unknown error occurred.
</DL>


<H4>Example</H4>

<P>
For the usage of <code>mysql_stmt_close()</code>, refer to the Example from
section <A HREF="manual_MySQL_APIs.html#mysql_stmt_execute">21.2.7.10  <code>mysql_stmt_execute()</code></A>.

</P>



<H4><A NAME="mysql_stmt_data_seek" HREF="manual_toc.html#mysql_stmt_data_seek">21.2.7.7  <code>mysql_stmt_data_seek()</code></A></H4>

<P>
<A NAME="IDX2176"></A>

</P>
<P>
<code>void mysql_stmt_data_seek(MYSQL_STMT *stmt, my_ulonglong offset)</code>

</P>

<H4>Description</H4>
<P>
Seeks to an arbitrary row in a statement result set.  The <code>offset</code>
value is a row number and should be in the range from <code>0</code> to
<code>mysql_stmt_num_rows(stmt)-1</code>.

</P>
<P>
This function requires that the statement result set structure
contains the entire result of the last executed query, so
<code>mysql_stmt_data_seek()</code> may be used only in conjunction with
<code>mysql_stmt_store_result()</code>.

</P>
<P>
This function was added in MySQL 4.1.1.

</P>


<H4>Return Values</H4>

<P>
None.

</P>

<H4>Errors</H4>
<P>
None.

</P>



<H4><A NAME="mysql_stmt_errno" HREF="manual_toc.html#mysql_stmt_errno">21.2.7.8  <code>mysql_stmt_errno()</code></A></H4>

<P>
<A NAME="IDX2177"></A>

</P>
<P>
<code>unsigned int mysql_stmt_errno(MYSQL_STMT *stmt)</code>

</P>

<H4>Description</H4>

<P>
For the statement specified by <code>stmt</code>, <code>mysql_stmt_errno()</code>
returns the error code for the most recently invoked statement API
function that can succeed or fail. A return value of zero means that no
error occurred.  Client error
message numbers are listed in the MySQL <tt>`errmsg.h'</tt> header file.
Server error message numbers are listed in <tt>`mysqld_error.h'</tt>. In the
MySQL source distribution you can find a complete list of
error messages and error numbers in the file <tt>`Docs/mysqld_error.txt'</tt>.
The server error codes also are listed at section <A HREF="manual_Error-handling.html#Error-handling">23  Error Handling in MySQL</A>.

</P>
<P>
This function was added in MySQL 4.1.0.

</P>

<H4>Return Values</H4>

<P>
An error code value. Zero if no error occurred.

</P>

<H4>Errors</H4>

<P>
None.

</P>



<H4><A NAME="mysql_stmt_error" HREF="manual_toc.html#mysql_stmt_error">21.2.7.9  <code>mysql_stmt_error()</code></A></H4>

<P>
<A NAME="IDX2178"></A>

</P>
<P>
<code>const char *mysql_stmt_error(MYSQL_STMT *stmt)</code>

</P>

<H4>Description</H4>

<P>
For the statement specified by <code>stmt</code>, <code>mysql_stmt_error()</code>
returns a null-terminated string containing the error message for the most recently invoked statement API
function that can succeed or fail. An empty string (<code>""</code>) is returned
if no error occurred. This means the following two tests are equivalent:

</P>

<PRE>

if (mysql_stmt_errno(stmt))
{
  // an error occurred
}

if (mysql_stmt_error(stmt)[0])
{
  // an error occurred
}
</PRE>

<P>
The language of the client error messages may be changed by recompiling
the MySQL client library. Currently you can choose error messages in
several different languages.

</P>
<P>
This function was added in MySQL 4.1.0.

</P>

<H4>Return Values</H4>

<P>
A character string that describes the error. An empty string if no error
occurred.

</P>

<H4>Errors</H4>

<P>
None.

</P>



<H4><A NAME="mysql_stmt_execute" HREF="manual_toc.html#mysql_stmt_execute">21.2.7.10  <code>mysql_stmt_execute()</code></A></H4>

<P>
<A NAME="IDX2179"></A>

</P>
<P>
<code>int mysql_stmt_execute(MYSQL_STMT *stmt)</code>

</P>

<H4>Description</H4>

<P>
<code>mysql_stmt_execute()</code> executes the prepared query associated with the
statement handle. The currently bound parameter marker values are sent
to server during this call, and the server replaces the markers with this newly
supplied data.

</P>

<P>
If the statement is an <code>UPDATE</code>, <code>DELETE</code>, or <code>INSERT</code>,
the total number of
changed, deleted, or inserted rows can be found by calling
<code>mysql_stmt_affected_rows()</code>. If this is a result set query such as
<code>SELECT</code>, you
must call <code>mysql_stmt_fetch()</code> to fetch the data prior to calling any
other functions that result in query processing. For more information on
how to fetch the results, refer to
section <A HREF="manual_MySQL_APIs.html#mysql_stmt_fetch">21.2.7.13  <code>mysql_stmt_fetch()</code></A>.

</P>
<P>
This function was added in MySQL 4.1.2.

</P>

<H4>Return Values</H4>

<P>
Zero if execution was successful. Non-zero if an error occurred.

</P>

<H4>Errors</H4>

<DL COMPACT>

<DT><code>CR_COMMANDS_OUT_OF_SYNC</code>
<DD>
Commands were executed in an improper order. 
<DT><code>CR_OUT_OF_MEMORY</code>
<DD>
Out of memory. 
<DT><code>CR_SERVER_GONE_ERROR</code>
<DD>
The MySQL server has gone away. 
<DT><code>CR_SERVER_LOST</code>
<DD>
The connection to the server was lost during the query. 
<DT><code>CR_UNKNOWN_ERROR</code>
<DD>
An unknown error occurred. 
</DL>


<H4>Example</H4>

<P>
The following example demonstrates how to create and populate a table using
<code>mysql_stmt_init()</code>,
<code>mysql_stmt_prepare()</code>,
<code>mysql_stmt_param_count()</code>, <code>mysql_stmt_bind_param()</code>,
<code>mysql_stmt_execute()</code>,
and <code>mysql_stmt_affected_rows()</code>. The <code>mysql</code> variable is assumed
to be a valid connection handle.

</P>

<PRE>
#define STRING_SIZE 50

#define DROP_SAMPLE_TABLE "DROP TABLE IF EXISTS test_table"
#define CREATE_SAMPLE_TABLE "CREATE TABLE test_table(col1 INT,\
                                                 col2 VARCHAR(40),\
                                                 col3 SMALLINT,\
                                                 col4 TIMESTAMP)"
#define INSERT_SAMPLE "INSERT INTO test_table(col1,col2,col3) VALUES(?,?,?)"

MYSQL_STMT    *stmt;
MYSQL_BIND    bind[3];
my_ulonglong  affected_rows;
int           param_count;
short         small_data;
int           int_data;
char          str_data[STRING_SIZE];
unsigned long str_length;
my_bool       is_null;

if (mysql_query(mysql, DROP_SAMPLE_TABLE))
{
  fprintf(stderr, " DROP TABLE failed\n");
  fprintf(stderr, " %s\n", mysql_error(mysql));
  exit(0);
}

if (mysql_query(mysql, CREATE_SAMPLE_TABLE))
{
  fprintf(stderr, " CREATE TABLE failed\n");
  fprintf(stderr, " %s\n", mysql_error(mysql));
  exit(0);
}

/* Prepare an INSERT query with 3 parameters */
/* (the TIMESTAMP column is not named; the server */
/* will set it to the current date and time) */
stmt = mysql_stmt_init(mysql);
if (!stmt)
{
  fprintf(stderr, " mysql_stmt_init(), out of memory\n");
  exit(0);
}
if (mysql_stmt_prepare(stmt, INSERT_SAMPLE, strlen(INSERT_SAMPLE)))
{
  fprintf(stderr, " mysql_stmt_prepare(), INSERT failed\n");
  fprintf(stderr, " %s\n", mysql_stmt_error(stmt));
  exit(0);
}
fprintf(stdout, " prepare, INSERT successful\n");

/* Get the parameter count from the statement */
param_count= mysql_stmt_param_count(stmt);
fprintf(stdout, " total parameters in INSERT: %d\n", param_count);

if (param_count != 3) /* validate parameter count */
{
  fprintf(stderr, " invalid parameter count returned by MySQL\n");
  exit(0);
}

/* Bind the data for all 3 parameters */

memset(bind, 0, sizeof(bind));

/* INTEGER PARAM */
/* This is a number type, so there is no need to specify buffer_length */
bind[0].buffer_type= MYSQL_TYPE_LONG;
bind[0].buffer= (char *)&#38;int_data;
bind[0].is_null= 0;
bind[0].length= 0;

/* STRING PARAM */
bind[1].buffer_type= MYSQL_TYPE_STRING;
bind[1].buffer= (char *)str_data;
bind[1].buffer_length= STRING_SIZE;
bind[1].is_null= 0;
bind[1].length= &#38;str_length;

/* SMALLINT PARAM */
bind[2].buffer_type= MYSQL_TYPE_SHORT;
bind[2].buffer= (char *)&#38;small_data;       
bind[2].is_null= &#38;is_null;
bind[2].length= 0;

/* Bind the buffers */
if (mysql_stmt_bind_param(stmt, bind))
{
  fprintf(stderr, " mysql_stmt_bind_param() failed\n");
  fprintf(stderr, " %s\n", mysql_stmt_error(stmt));
  exit(0);
}

/* Specify the data values for the first row */
int_data= 10;             /* integer */
strncpy(str_data, "MySQL", STRING_SIZE); /* string  */
str_length= strlen(str_data);

/* INSERT SMALLINT data as NULL */
is_null= 1;

/* Execute the INSERT statement - 1*/
if (mysql_stmt_execute(stmt))
{
  fprintf(stderr, " mysql_stmt_execute(), 1 failed\n");
  fprintf(stderr, " %s\n", mysql_stmt_error(stmt));
  exit(0);
}

/* Get the total number of affected rows */   
affected_rows= mysql_stmt_affected_rows(stmt);
fprintf(stdout, " total affected rows(insert 1): %lu\n",
                (unsigned long) affected_rows);

if (affected_rows != 1) /* validate affected rows */
{
  fprintf(stderr, " invalid affected rows by MySQL\n");
  exit(0);
}

/* Specify data values for second row, then re-execute the statement */
int_data= 1000;             
strncpy(str_data, "The most popular Open Source database", STRING_SIZE); 
str_length= strlen(str_data);
small_data= 1000;         /* smallint */
is_null= 0;               /* reset */

/* Execute the INSERT statement - 2*/
if (mysql_stmt_execute(stmt))
{
  fprintf(stderr, " mysql_stmt_execute, 2 failed\n");
  fprintf(stderr, " %s\n", mysql_stmt_error(stmt));
  exit(0);
}

/* Get the total rows affected */   
affected_rows= mysql_stmt_affected_rows(stmt);
fprintf(stdout, " total affected rows(insert 2): %lu\n",
                (unsigned long) affected_rows);

if (affected_rows != 1) /* validate affected rows */
{
  fprintf(stderr, " invalid affected rows by MySQL\n");
  exit(0);
}

/* Close the statement */
if (mysql_stmt_close(stmt))
{
  fprintf(stderr, " failed while closing the statement\n");
  fprintf(stderr, " %s\n", mysql_stmt_error(stmt));
  exit(0);
}
</PRE>

<P>
<strong>Note</strong>: For complete examples on the use of prepared
statement functions, refer to the file <tt>`tests/client_test.c'</tt>.
This file can be obtained from a MySQL source distribution or from the
BitKeeper source repository.

</P>



<H4><A NAME="mysql_stmt_free_result" HREF="manual_toc.html#mysql_stmt_free_result">21.2.7.11  <code>mysql_stmt_free_result()</code></A></H4>

<P>
<A NAME="IDX2180"></A>

</P>
<P>
<code>my_bool mysql_stmt_free_result(MYSQL_STMT *stmt)</code>

</P>

<H4>Description</H4>

<P>
Releases memory associated with the result set produced by execution of
the prepared statement.

</P>
<P>
This function was added in MySQL 4.1.1.

</P>

<H4>Return Values</H4>

<P>
Zero if the result set was freed successfully.  Non-zero if an error occurred.

</P>

<H4>Errors</H4>



<H4><A NAME="mysql_stmt_insert_id" HREF="manual_toc.html#mysql_stmt_insert_id">21.2.7.12  <code>mysql_stmt_insert_id()</code></A></H4>

<P>
<A NAME="IDX2181"></A>

</P>
<P>
<code>my_ulonglong mysql_stmt_insert_id(MYSQL_STMT *stmt)</code>

</P>

<H4>Description</H4>

<P>
Returns the value generated for an <code>AUTO_INCREMENT</code> column by the
prepared <code>INSERT</code> or <code>UPDATE</code> statement. Use this function after
you have executed prepared <code>INSERT</code> statement into a table which 
contains an <code>AUTO_INCREMENT</code> field.

</P>
<P>
See section <A HREF="manual_MySQL_APIs.html#mysql_insert_id">21.2.3.33  <code>mysql_insert_id()</code></A> for more 
information.

</P>
<P>
This function was added in MySQL 4.1.2.

</P>

<H4>Return Values</H4>

<P>
Value for <code>AUTO_INCREMENT</code> column which was automatically generated or
explicitly set during execution of prepared statement, or value generated
by <code>LAST_INSERT_ID(<var>expr</var>)</code> function. Return value is undefined if statement 
does not set <code>AUTO_INCREMENT</code> value.

</P>


<H4>Errors</H4>

<P>
None.

</P>



<H4><A NAME="mysql_stmt_fetch" HREF="manual_toc.html#mysql_stmt_fetch">21.2.7.13  <code>mysql_stmt_fetch()</code></A></H4>

<P>
<A NAME="IDX2182"></A>

</P>
<P>
<code>int mysql_stmt_fetch(MYSQL_STMT *stmt)</code>

</P>

<H4>Description</H4>

<P>
<code>mysql_stmt_fetch()</code> returns the next row in the result set. It can
be called only while the result set exists, that is, after a call to
<code>mysql_stmt_execute()</code> that creates a result set or after
<code>mysql_stmt_store_result()</code>, which is called after
<code>mysql_stmt_execute()</code> to buffer the entire result set.

</P>
<P>
<code>mysql_stmt_fetch()</code> returns row data using the buffers bound by
<code>mysql_stmt_bind_result()</code>. It returns
the data in those buffers for all the columns in the current row
set and the lengths are returned to the <code>length</code> pointer.

</P>
<P>
All columns must be bound by the application before calling
<code>mysql_stmt_fetch()</code>.

</P>
<P>
If a fetched data value is a <code>NULL</code> value, the <code>*is_null</code>
value of the corresponding <code>MYSQL_BIND</code> structure contains TRUE
(1). Otherwise, the data and its length are returned in the <code>*buffer</code>
and <code>*length</code> elements based on the buffer type specified by the
application. Each numeric and temporal type has a fixed length,
as listed in the following table.
The length of the string types depends on the length of the actual data value,
as indicated by <code>data_length</code>.

</P>

<TABLE BORDER>
<TR><TD><strong>Type</strong> </TD><TD> <strong>Length</strong>
</TD></TR>
<TR><TD><code>MYSQL_TYPE_TINY</code> </TD><TD> 1
</TD></TR>
<TR><TD><code>MYSQL_TYPE_SHORT</code> </TD><TD> 2
</TD></TR>
<TR><TD><code>MYSQL_TYPE_LONG</code> </TD><TD> 4
</TD></TR>
<TR><TD><code>MYSQL_TYPE_LONGLONG</code> </TD><TD> 8
</TD></TR>
<TR><TD><code>MYSQL_TYPE_FLOAT</code> </TD><TD> 4
</TD></TR>
<TR><TD><code>MYSQL_TYPE_DOUBLE</code> </TD><TD> 8
</TD></TR>
<TR><TD><code>MYSQL_TYPE_TIME</code> </TD><TD> <code>sizeof(MYSQL_TIME)</code>
</TD></TR>
<TR><TD><code>MYSQL_TYPE_DATE</code> </TD><TD> <code>sizeof(MYSQL_TIME)</code>
</TD></TR>
<TR><TD><code>MYSQL_TYPE_DATETIME</code> </TD><TD> <code>sizeof(MYSQL_TIME)</code>
</TD></TR>
<TR><TD><code>MYSQL_TYPE_STRING</code> </TD><TD> <code>data length</code>
</TD></TR>
<TR><TD><code>MYSQL_TYPE_BLOB</code> </TD><TD> <code>data_length</code>
</TD></TR>
</TABLE>

<P>
This function was added in MySQL 4.1.2.

</P>

<H4>Return Values</H4>

<TABLE BORDER>
<TR><TD><strong>Return Value</strong> </TD><TD> <strong>Description</strong>
</TD></TR>
<TR><TD>0 </TD><TD> Successful, the data has been
fetched to application data buffers.
</TD></TR>
<TR><TD>1 </TD><TD> Error occurred. Error code and
message can be obtained by calling <code>mysql_stmt_errno()</code> and
<code>mysql_stmt_error()</code>.
</TD></TR>
<TR><TD><code>MYSQL_NO_DATA</code> </TD><TD> No more rows/data exists
</TD></TR>
<TR><TD><code>MYSQL_DATA_TRUNCATED</code> </TD><TD> Data truncation occurred
</TD></TR>
</TABLE>

<P>
<code>MYSQL_DATA_TRUNCATED</code> is not returned unless truncation reporting is
enabled with <code>mysql_options()</code>.  To determine which parameters were
truncated when this value is returned, check the <code>error</code> members of
the <code>MYSQL_BIND</code> parameter structures.

</P>


<H4>Errors</H4>
<DL COMPACT>

<DT><code>CR_COMMANDS_OUT_OF_SYNC</code>
<DD>
Commands were executed in an improper order. 
<DT><code>CR_OUT_OF_MEMORY</code>
<DD>
Out of memory. 
<DT><code>CR_SERVER_GONE_ERROR</code>
<DD>
The MySQL server has gone away. 
<DT><code>CR_SERVER_LOST</code>
<DD>
The connection to the server was lost during the query. 
<DT><code>CR_UNKNOWN_ERROR</code>
<DD>
An unknown error occurred. 
<DT><code>CR_UNSUPPORTED_PARAM_TYPE</code>
<DD>
The buffer type is
<code>MYSQL_TYPE_DATE</code>,
<code>MYSQL_TYPE_TIME</code>,
<code>MYSQL_TYPE_DATETIME</code>,
or
<code>MYSQL_TYPE_TIMESTAMP</code>,
but the data type is not <code>DATE</code>, <code>TIME</code>, <code>DATETIME</code>, or
<code>TIMESTAMP</code>.
<DT><code></code>
<DD>
All other unsupported conversion errors are returned from
<code>mysql_stmt_bind_result()</code>.
</DL>


<H4>Example</H4>

<P>
The following example demonstrates how to fetch data from a table using
 <code>mysql_stmt_result_metadata()</code>,
<code>mysql_stmt_bind_result()</code>, and <code>mysql_stmt_fetch()</code>.
(This example expects to retrieve the two rows inserted by the example shown
in section <A HREF="manual_MySQL_APIs.html#mysql_stmt_execute">21.2.7.10  <code>mysql_stmt_execute()</code></A>.)
The <code>mysql</code> variable is assumed to be a valid connection handle.

</P>

<PRE>
#define STRING_SIZE 50

#define SELECT_SAMPLE "SELECT col1, col2, col3, col4 FROM test_table"

MYSQL_STMT    *stmt;
MYSQL_BIND    bind[4];
MYSQL_RES     *prepare_meta_result;
MYSQL_TIME    ts;
unsigned long length[4];
int           param_count, column_count, row_count;
short         small_data;
int           int_data;
char          str_data[STRING_SIZE];
my_bool       is_null[4];

/* Prepare a SELECT query to fetch data from test_table */
stmt = mysql_stmt_init(mysql);
if (!stmt)
{
  fprintf(stderr, " mysql_stmt_init(), out of memory\n");
  exit(0);
}
if (mysql_stmt_prepare(stmt, SELECT_SAMPLE, strlen(SELECT_SAMPLE)))
{
  fprintf(stderr, " mysql_stmt_prepare(), SELECT failed\n");
  fprintf(stderr, " %s\n", mysql_stmt_error(stmt));
  exit(0);
}
fprintf(stdout, " prepare, SELECT successful\n");

/* Get the parameter count from the statement */
param_count= mysql_stmt_param_count(stmt);
fprintf(stdout, " total parameters in SELECT: %d\n", param_count);

if (param_count != 0) /* validate parameter count */
{
  fprintf(stderr, " invalid parameter count returned by MySQL\n");
  exit(0);
}

/* Fetch result set meta information */
prepare_meta_result = mysql_stmt_result_metadata(stmt);
if (!prepare_meta_result)
{
  fprintf(stderr,
         " mysql_stmt_result_metadata(), returned no meta information\n");
  fprintf(stderr, " %s\n", mysql_stmt_error(stmt));
  exit(0);
}

/* Get total columns in the query */
column_count= mysql_num_fields(prepare_meta_result);
fprintf(stdout, " total columns in SELECT statement: %d\n", column_count);

if (column_count != 4) /* validate column count */
{
  fprintf(stderr, " invalid column count returned by MySQL\n");
  exit(0);
}

/* Execute the SELECT query */
if (mysql_stmt_execute(stmt))
{
  fprintf(stderr, " mysql_stmt_execute(), failed\n");
  fprintf(stderr, " %s\n", mysql_stmt_error(stmt));
  exit(0);
}

/* Bind the result buffers for all 4 columns before fetching them */

memset(bind, 0, sizeof(bind));

/* INTEGER COLUMN */
bind[0].buffer_type= MYSQL_TYPE_LONG;
bind[0].buffer= (char *)&#38;int_data;
bind[0].is_null= &#38;is_null[0];
bind[0].length= &#38;length[0];

/* STRING COLUMN */
bind[1].buffer_type= MYSQL_TYPE_STRING;
bind[1].buffer= (char *)str_data;
bind[1].buffer_length= STRING_SIZE;
bind[1].is_null= &#38;is_null[1];
bind[1].length= &#38;length[1];

/* SMALLINT COLUMN */
bind[2].buffer_type= MYSQL_TYPE_SHORT;
bind[2].buffer= (char *)&#38;small_data;       
bind[2].is_null= &#38;is_null[2];
bind[2].length= &#38;length[2];

/* TIMESTAMP COLUMN */
bind[3].buffer_type= MYSQL_TYPE_TIMESTAMP;
bind[3].buffer= (char *)&#38;ts;       
bind[3].is_null= &#38;is_null[3];
bind[3].length= &#38;length[3];

/* Bind the result buffers */
if (mysql_stmt_bind_result(stmt, bind))
{
  fprintf(stderr, " mysql_stmt_bind_result() failed\n");
  fprintf(stderr, " %s\n", mysql_stmt_error(stmt));
  exit(0);
}

/* Now buffer all results to client */
if (mysql_stmt_store_result(stmt))
{
  fprintf(stderr, " mysql_stmt_store_result() failed\n");
  fprintf(stderr, " %s\n", mysql_stmt_error(stmt));
  exit(0);
}

/* Fetch all rows */
row_count= 0;
fprintf(stdout, "Fetching results ...\n");
while (!mysql_stmt_fetch(stmt))
{
  row_count++;
  fprintf(stdout, "  row %d\n", row_count);

  /* column 1 */
  fprintf(stdout, "   column1 (integer)  : ");
  if (is_null[0])
    fprintf(stdout, " NULL\n");
  else
    fprintf(stdout, " %d(%ld)\n", int_data, length[0]);

  /* column 2 */
  fprintf(stdout, "   column2 (string)   : ");
  if (is_null[1])
    fprintf(stdout, " NULL\n");
  else
    fprintf(stdout, " %s(%ld)\n", str_data, length[1]);

  /* column 3 */
  fprintf(stdout, "   column3 (smallint) : ");
  if (is_null[2])
    fprintf(stdout, " NULL\n");
  else
    fprintf(stdout, " %d(%ld)\n", small_data, length[2]);

  /* column 4 */
  fprintf(stdout, "   column4 (timestamp): ");
  if (is_null[3])
    fprintf(stdout, " NULL\n");
  else
    fprintf(stdout, " %04d-%02d-%02d %02d:%02d:%02d (%ld)\n",
									   ts.year, ts.month, ts.day,
									   ts.hour, ts.minute, ts.second,
									   length[3]);
  fprintf(stdout, "\n");
}

/* Validate rows fetched */
fprintf(stdout, " total rows fetched: %d\n", row_count);
if (row_count != 2)
{
  fprintf(stderr, " MySQL failed to return all rows\n");
  exit(0);
} 

/* Free the prepared result metadata */
mysql_free_result(prepare_meta_result);

/* Close the statement */
if (mysql_stmt_close(stmt))
{
  fprintf(stderr, " failed while closing the statement\n");
  fprintf(stderr, " %s\n", mysql_stmt_error(stmt));
  exit(0);
}
</PRE>



<H4><A NAME="mysql_stmt_fetch_column" HREF="manual_toc.html#mysql_stmt_fetch_column">21.2.7.14  <code>mysql_stmt_fetch_column()</code></A></H4>

<P>
<A NAME="IDX2183"></A>

</P>
<P>
<code>int mysql_stmt_fetch_column(MYSQL_STMT *stmt, MYSQL_BIND *bind, unsigned int column, unsigned long offset)</code>

</P>

<H4>Description</H4>

<P>
Fetch one column from the current result set row. <code>bind</code> provides the
buffer where data should be placed.  It should be set up the same way as for
<code>mysql_stmt_bind_result()</code>. <code>column</code> indicates which column to
fetch. The first column is numbered 0.  <code>offset</code> is the offset within the
data value at which to begin retrieving data.  This can be used for fetching
the data value in pieces. The beginning of the value is offset 0.

</P>
<P>
This function was added in MySQL 4.1.2.

</P>

<H4>Return Values</H4>

<P>
Zero if the value was fetched successfully.  Non-zero if an error occurred.

</P>

<H4>Errors</H4>

<DL COMPACT>

<DT><code>CR_INVALID_PARAMETER_NO</code>
<DD>
Invalid column number.
<DT><code>CR_NO_DATA</code>
<DD>
The end of the result set has already been reached.
</DL>



<H4><A NAME="mysql_stmt_field_count" HREF="manual_toc.html#mysql_stmt_field_count">21.2.7.15  <code>mysql_stmt_field_count()</code></A></H4>

<P>
<A NAME="IDX2184"></A>

</P>
<P>
<code>unsigned int mysql_stmt_field_count(MYSQL_STMT *stmt)</code>

</P>

<H4>Description</H4>

<P>
Returns the number of columns for the most recent statement for the statement
handler. This value will be zero for statements such as <code>INSERT</code> or
<code>DELETE</code> that do not produce result sets.

</P>
<P>
<code>mysql_stmt_field_count()</code> can be called after you have prepared a
statement by invoking <code>mysql_stmt_prepare()</code>.

</P>
<P>
This function was added in MySQL 4.1.3.

</P>

<H4>Return Values</H4>

<P>
An unsigned integer representing the number of columns in a result set.

</P>

<H4>Errors</H4>
<P>
None.

</P>



<H4><A NAME="mysql_stmt_init" HREF="manual_toc.html#mysql_stmt_init">21.2.7.16  <code>mysql_stmt_init()</code></A></H4>

<P>
<A NAME="IDX2185"></A>

</P>
<P>
<code>MYSQL_STMT *mysql_stmt_init(MYSQL *mysql)</code>

</P>

<H4>Description</H4>

<P>
Create a <code>MYSQL_STMT</code> handle.
The handle should be freed with <code>mysql_stmt_close(MYSQL_STMT *)</code>.

</P>
<P>
This function was added in MySQL 4.1.2.

</P>

<H4>Return values</H4>

<P>
A pointer to a <code>MYSQL_STMT</code> structure in case of success.
<code>NULL</code> if out of memory.

</P>

<H4>Errors</H4>

<DL COMPACT>

<DT><code>CR_OUT_OF_MEMORY</code>
<DD>
Out of memory.
</DL>



<H4><A NAME="mysql_stmt_num_rows" HREF="manual_toc.html#mysql_stmt_num_rows">21.2.7.17  <code>mysql_stmt_num_rows()</code></A></H4>

<P>
<A NAME="IDX2186"></A>

</P>
<P>
<code>my_ulonglong mysql_stmt_num_rows(MYSQL_STMT *stmt)</code>

</P>

<H4>Description</H4>

<P>
Returns the number of rows in the result set.

</P>
<P>
The use of <code>mysql_stmt_num_rows()</code> depends on whether or not you used
<code>mysql_stmt_store_result()</code> to buffer the entire result set in the
statement handle.

</P>
<P>
If you use <code>mysql_stmt_store_result()</code>, <code>mysql_stmt_num_rows()</code> may be
called immediately.

</P>

<P>
This function was added in MySQL 4.1.1.

</P>

<H4>Return Values</H4>

<P>
The number of rows in the result set.

</P>

<H4>Errors</H4>
<P>
None.

</P>



<H4><A NAME="mysql_stmt_param_count" HREF="manual_toc.html#mysql_stmt_param_count">21.2.7.18  <code>mysql_stmt_param_count()</code></A></H4>

<P>
<A NAME="IDX2187"></A>

</P>
<P>
<code>unsigned long mysql_stmt_param_count(MYSQL_STMT *stmt)</code>

</P>

<H4>Description</H4>

<P>
Returns the number of parameter markers present in the prepared statement.

</P>
<P>
This function was added in MySQL 4.1.2.

</P>

<H4>Return Values</H4>

<P>
An unsigned long integer representing the number of parameters in a
statement.

</P>

<H4>Errors</H4>

<P>
None.

</P>

<H4>Example</H4>

<P>
For the usage of <code>mysql_stmt_param_count()</code>, refer to the Example from
section <A HREF="manual_MySQL_APIs.html#mysql_stmt_execute">21.2.7.10  <code>mysql_stmt_execute()</code></A>.

</P>



<H4><A NAME="mysql_stmt_param_metadata" HREF="manual_toc.html#mysql_stmt_param_metadata">21.2.7.19  <code>mysql_stmt_param_metadata()</code></A></H4>

<P>
<A NAME="IDX2188"></A>

</P>
<P>
<code>MYSQL_RES *mysql_stmt_param_metadata(MYSQL_STMT *stmt)</code>

</P>
<P>
To be added.

</P>
<P>
This function was added in MySQL 4.1.2.

</P>

<H4>Description</H4>


<H4>Return Values</H4>


<H4>Errors</H4>



<H4><A NAME="mysql_stmt_prepare" HREF="manual_toc.html#mysql_stmt_prepare">21.2.7.20  <code>mysql_stmt_prepare()</code></A></H4>

<P>
<A NAME="IDX2189"></A>

</P>
<P>
<code>int mysql_stmt_prepare(MYSQL_STMT *stmt, const char *query, unsigned
long length)</code>

</P>

<H4>Description</H4>

<P>
Given the statement handle returned by <code>mysql_stmt_init()</code>,
prepares the SQL statement pointed to by the string
<code>query</code> and returns a status value.
The string length should be given by the <code>length</code> argument.
The string must consist of a single SQL statement. You should
not add a terminating semicolon (<samp>`;'</samp>) or <code>\g</code> to the statement.

</P>
<P>
The application can include one or more parameter markers in the SQL
statement by embedding question mark (<samp>`?'</samp>) characters into the SQL
string at the appropriate positions.

</P>
<P>
The markers are legal only in certain places in SQL statements. For
example, they are allowed in the <code>VALUES()</code> list of an <code>INSERT</code>
statement (to specify column values for a row), or in a comparison with a
column in a <code>WHERE</code> clause to specify a comparison value.
However, they are not allowed for identifiers (such as table or column
names), or to specify both
operands of a binary operator such as the <code>=</code> equal sign.
The latter restriction is necessary because it
would be impossible to determine the parameter type. In general,
parameters are legal only in Data Manipulation Languange (DML)
statements, and not in Data Defination Language (DDL) statements.

</P>
<P>
The parameter markers must be bound to application variables using
<code>mysql_stmt_bind_param()</code> before executing the statement.

</P>
<P>
This function was added in MySQL 4.1.2.

</P>


<H4>Return Values</H4>

<P>
Zero if the statement was prepared successfully.  Non-zero if an error occurred.

</P>

<H4>Errors</H4>

<DL COMPACT>

<DT><code>CR_COMMANDS_OUT_OF_SYNC</code>
<DD>
Commands were executed in an improper order.
<DT><code>CR_OUT_OF_MEMORY</code>
<DD>
Out of memory.
<DT><code>CR_SERVER_GONE_ERROR</code>
<DD>
The MySQL server has gone away.
<DT><code>CR_SERVER_LOST</code>
<DD>
The connection to the server was lost during the query
<DT><code>CR_UNKNOWN_ERROR</code>
<DD>
An unknown error occurred.
</DL>

<P>
If the prepare operation was unsuccessful (that is,
<code>mysql_stmt_prepare()</code> returns non-zero), the error message can be
obtained by calling <code>mysql_stmt_error()</code>.

</P>


<H4>Example</H4>

<P>
For the usage of <code>mysql_stmt_prepare()</code>, refer to the Example from
section <A HREF="manual_MySQL_APIs.html#mysql_stmt_execute">21.2.7.10  <code>mysql_stmt_execute()</code></A>.

</P>



<H4><A NAME="mysql_stmt_reset" HREF="manual_toc.html#mysql_stmt_reset">21.2.7.21  <code>mysql_stmt_reset()</code></A></H4>

<P>
<A NAME="IDX2190"></A>

</P>
<P>
<code>my_bool mysql_stmt_reset(MYSQL_STMT *stmt)</code>

</P>

<H4>Description</H4>

<P>
Reset prepared statement on client and server to state after prepare.
For now this is mainly used to reset data sent with
<code>mysql_stmt_send_long_data()</code>.

</P>
<P>
To re-prepare the statement with another query, use
<code>mysql_stmt_prepare()</code>.

</P>
<P>
This function was added in MySQL 4.1.1.

</P>

<H4>Return Values</H4>

<P>
Zero if the statement was reset successfully.  Non-zero if an error occurred.

</P>

<H4>Errors</H4>

<DL COMPACT>

<DT><code>CR_COMMANDS_OUT_OF_SYNC</code>
<DD>
Commands were executed in an improper order.
<DT><code>CR_SERVER_GONE_ERROR</code>
<DD>
The MySQL server has gone away.
<DT><code>CR_SERVER_LOST</code>
<DD>
The connection to the server was lost during the query
<DT><code>CR_UNKNOWN_ERROR</code>
<DD>
An unknown error occurred.
</DL>



<H4><A NAME="mysql_stmt_result_metadata" HREF="manual_toc.html#mysql_stmt_result_metadata">21.2.7.22  <code>mysql_stmt_result_metadata()</code></A></H4>

<P>
<A NAME="IDX2191"></A>

</P>
<P>
<code>MYSQL_RES *mysql_stmt_result_metadata(MYSQL_STMT *stmt)</code>

</P>

<H4>Description</H4>

<P>
If a statement passed to <code>mysql_stmt_prepare()</code> is one that produces a result
set,
<code>mysql_stmt_result_metadata()</code> returns the result set
metadata in the form of a pointer to a
<code>MYSQL_RES</code> structure that can be used to process the
meta information such as total number of fields and individual field
information. This result set pointer can be passed as an argument to
any of the field-based API functions that process result set metadata, such
as:

</P>

<UL>
<LI><code>mysql_num_fields()</code>

<LI><code>mysql_fetch_field()</code>

<LI><code>mysql_fetch_field_direct()</code>

<LI><code>mysql_fetch_fields()</code>

<LI><code>mysql_field_count()</code>

<LI><code>mysql_field_seek()</code>

<LI><code>mysql_field_tell()</code>

<LI><code>mysql_free_result()</code>

</UL>

<P>
The result set structure should be freed when you are done with it, which
you can do by passing it to <code>mysql_free_result()</code>. This is similar
to the way you free a result set obtained from a call to
<code>mysql_store_result()</code>.

</P>
<P>
The result set returned by <code>mysql_stmt_result_metadata()</code> contains only
metadata. It does not contain any row results. The rows are obtained by using
the statement handle with <code>mysql_stmt_fetch()</code>.

</P>
<P>
This function was added in MySQL 4.1.2.

</P>


<H4>Return Values</H4>

<P>
A <code>MYSQL_RES</code> result structure. <code>NULL</code> if no meta information exists
for the prepared query.

</P>


<H4>Errors</H4>

<DL COMPACT>

<DT><code>CR_OUT_OF_MEMORY</code>
<DD>
Out of memory.
<DT><code>CR_UNKNOWN_ERROR</code>
<DD>
An unknown error occurred.
</DL>


<H4>Example</H4>

<P>
For the usage of <code>mysql_stmt_result_metadata()</code>, refer to the
Example from section <A HREF="manual_MySQL_APIs.html#mysql_stmt_fetch">21.2.7.13  <code>mysql_stmt_fetch()</code></A>.

</P>



<H4><A NAME="mysql_stmt_row_seek" HREF="manual_toc.html#mysql_stmt_row_seek">21.2.7.23  <code>mysql_stmt_row_seek()</code></A></H4>

<P>
<A NAME="IDX2192"></A>

</P>
<P>
<code>MYSQL_ROW_OFFSET mysql_stmt_row_seek(MYSQL_STMT *stmt, MYSQL_ROW_OFFSET offset)</code>

</P>

<H4>Description</H4>
<P>
Sets the row cursor to an arbitrary row in a statement result set.
The <code>offset</code> value is a row offset that should be a value returned
from <code>mysql_stmt_row_tell()</code> or from <code>mysql_stmt_row_seek()</code>.
This value is not a row number; if you want to seek to a row within a
result set by number, use <code>mysql_stmt_data_seek()</code> instead.

</P>

<P>
This function requires that the result set structure contains the entire
result of the query, so <code>mysql_stmt_row_seek()</code> may be used only
in conjunction with <code>mysql_stmt_store_result()</code>.

</P>
<P>
This function was added in MySQL 4.1.1.

</P>

<H4>Return Values</H4>

<P>
The previous value of the row cursor.  This value may be passed to a
subsequent call to <code>mysql_stmt_row_seek()</code>.

</P>

<H4>Errors</H4>
<P>
None.

</P>



<H4><A NAME="mysql_stmt_row_tell" HREF="manual_toc.html#mysql_stmt_row_tell">21.2.7.24  <code>mysql_stmt_row_tell()</code></A></H4>

<P>
<A NAME="IDX2193"></A>

</P>
<P>
<code>MYSQL_ROW_OFFSET mysql_stmt_row_tell(MYSQL_STMT *stmt)</code>

</P>

<H4>Description</H4>

<P>
Returns the current position of the row cursor for the last
<code>mysql_stmt_fetch()</code>. This value can be used as an argument to
<code>mysql_stmt_row_seek()</code>.

</P>
<P>
You should use <code>mysql_stmt_row_tell()</code> only after <code>mysql_stmt_store_result()</code>.

</P>
<P>
This function was added in MySQL 4.1.1.

</P>

<H4>Return Values</H4>

<P>
The current offset of the row cursor.

</P>

<H4>Errors</H4>
<P>
None.

</P>



<H4><A NAME="mysql_stmt_send_long_data" HREF="manual_toc.html#mysql_stmt_send_long_data">21.2.7.25  <code>mysql_stmt_send_long_data()</code></A></H4>

<P>
<A NAME="IDX2194"></A>

</P>
<P>
<code>my_bool mysql_stmt_send_long_data(MYSQL_STMT *stmt, unsigned int
parameter_number, const char *data, unsigned long length)</code>

</P>

<H4>Description</H4>

<P>
Allows an application to send parameter data to the server in pieces
(or ``chunks'').
This function can be called multiple times to send the parts of a
character or binary data value for a column, which must be one of the
<code>TEXT</code> or <code>BLOB</code> data types.

</P>
<P>
<code>parameter_number</code> indicates which parameter to associate the data with.
Parameters are numbered beginning with 0.
<code>data</code> is a pointer to a buffer containing data to be sent, and
<code>length</code> indicates the number of bytes in the buffer.

</P>
<P>
<strong>Note</strong>: The next <code>mysql_stmt_execute()</code> call will ignore the
bind buffer for all parameters that have been used with
<code>mysql_stmt_send_long_data()</code> since last
<code>mysql_stmt_execute()</code> or <code>mysql_stmt_reset()</code>.

</P>
<P>
If you want to reset/forget the sent data, you can do it with
<code>mysql_stmt_reset()</code>. See section <A HREF="manual_MySQL_APIs.html#mysql_stmt_reset">21.2.7.21  <code>mysql_stmt_reset()</code></A>.

</P>
<P>
This function was added in MySQL 4.1.2.

</P>

<H4>Return Values</H4>

<P>
Zero if the data is sent successfully to server. Non-zero if an error
occurred.

</P>

<H4>Errors</H4>

<DL COMPACT>

<DT><code>CR_COMMANDS_OUT_OF_SYNC</code>
<DD>
Commands were executed in an improper order.
<DT><code>CR_SERVER_GONE_ERROR</code>
<DD>
The MySQL server has gone away.
<DT><code>CR_OUT_OF_MEMORY</code>
<DD>
Out of memory.
<DT><code>CR_UNKNOWN_ERROR</code>
<DD>
An unknown error occurred.
</DL>


<H4>Example</H4>
<P>
The following example demonstrates how to send the data for a
<code>TEXT</code> column in chunks.  It inserts the data value
<code>'MySQL - The most popular Open Source database'</code>
into the <code>text_column</code> column.
The <code>mysql</code> variable is assumed to be a valid connection handle.

</P>


<PRE>
#define INSERT_QUERY "INSERT INTO test_long_data(text_column) VALUES(?)"

MYSQL_BIND bind[1];
long       length;

smtt = mysql_stmt_init(mysql);
if (!stmt)
{
  fprintf(stderr, " mysql_stmt_init(), out of memory\n");
  exit(0);
}
if (mysql_stmt_prepare(stmt, INSERT_QUERY, strlen(INSERT_QUERY)))
{
  fprintf(stderr, "\n mysql_stmt_prepare(), INSERT failed");
  fprintf(stderr, "\n %s", mysql_stmt_error(stmt));
  exit(0);
}
 memset(bind, 0, sizeof(bind));
 bind[0].buffer_type= MYSQL_TYPE_STRING;
 bind[0].length= &#38;length;
 bind[0].is_null= 0;

/* Bind the buffers */
if (mysql_stmt_bind_param(stmt, bind))
{
  fprintf(stderr, "\n param bind failed");
  fprintf(stderr, "\n %s", mysql_stmt_error(stmt));
  exit(0);
}

 /* Supply data in chunks to server */
 if (!mysql_stmt_send_long_data(stmt,0,"MySQL",5))
{
  fprintf(stderr, "\n send_long_data failed");
  fprintf(stderr, "\n %s", mysql_stmt_error(stmt));
  exit(0);
}

 /* Supply the next piece of data */
 if (mysql_stmt_send_long_data(stmt,0," - The most popular Open Source database",40))
{
  fprintf(stderr, "\n send_long_data failed");
  fprintf(stderr, "\n %s", mysql_stmt_error(stmt));
  exit(0);
}

 /* Now, execute the query */
 if (mysql_stmt_execute(stmt))
{
  fprintf(stderr, "\n mysql_stmt_execute failed");
  fprintf(stderr, "\n %s", mysql_stmt_error(stmt));
  exit(0);
}
</PRE>



<H4><A NAME="mysql_stmt_sqlstate" HREF="manual_toc.html#mysql_stmt_sqlstate">21.2.7.26  <code>mysql_stmt_sqlstate()</code></A></H4>

<P>
<A NAME="IDX2195"></A>

</P>
<P>
<code>const char *mysql_stmt_sqlstate(MYSQL_STMT *stmt)</code>

</P>

<H4>Description</H4>

<P>
For the statement specified by <code>stmt</code>, <code>mysql_stmt_sqlstate()</code>
returns a null-terminated string containing the SQLSTATE error code for the
most recently invoked prepared statement API function that can succeed or fail.
The error code consists of five characters.
<code>"00000"</code> means ``no error.''
The values are specified by ANSI SQL and ODBC.
For a list of possible values, see section <A HREF="manual_Error-handling.html#Error-handling">23  Error Handling in MySQL</A>.

</P>
<P>
Note that not all MySQL errors are yet mapped to SQLSTATE's.
The value <code>"HY000"</code> (general error) is used
for unmapped errors.

</P>
<P>
This function was added to MySQL 4.1.1.

</P>

<H4>Return Values</H4>

<P>
A null-terminated character string containing the SQLSTATE error code.

</P>



<H4><A NAME="mysql_stmt_store_result" HREF="manual_toc.html#mysql_stmt_store_result">21.2.7.27  <code>mysql_stmt_store_result()</code></A></H4>

<P>
<A NAME="IDX2196"></A>

</P>
<P>
<code>int mysql_stmt_store_result(MYSQL_STMT *stmt)</code>

</P>

<H4>Description</H4>

<P>
You must call <code>mysql_stmt_store_result()</code> for every statement that
successfully produces a result set
(<code>SELECT</code>, <code>SHOW</code>, <code>DESCRIBE</code>, <code>EXPLAIN</code>), and only
if you want to buffer the complete result set by the client, so that the
subsequent <code>mysql_stmt_fetch()</code> call returns buffered data.

</P>
<P>
It is unnecessary to call <code>mysql_stmt_store_result()</code> for other
statements, but if you do, it will not harm or cause any notable performance
problem.
You can detect whether the statement produced a result set by checking
if <code>mysql_stmt_result_metadata()</code> returns <code>NULL</code>.
For more information, refer to section <A HREF="manual_MySQL_APIs.html#mysql_stmt_result_metadata">21.2.7.22  <code>mysql_stmt_result_metadata()</code></A>.

</P>
<P>
<strong>Note</strong>:
MySQL doesn't by default calculate <code>MYSQL_FIELD-&#62;max_length</code> for
all columns in <code>mysql_stmt_store_result()</code> because calculating this
would slow down <code>mysql_stmt_store_result()</code> considerably and most
applications doesn't need <code>max_length</code>.  If you want
<code>max_length</code> to be updated, you can call
<code>mysql_stmt_attr_set(MYSQL_STMT, STMT_ATTR_UPDATE_MAX_LENGTH, &#38;flag)</code>
to enable this. See section <A HREF="manual_MySQL_APIs.html#mysql_stmt_attr_set">21.2.7.3  <code>mysql_stmt_attr_set()</code></A>.

</P>
<P>
This function was added in MySQL 4.1.0.

</P>

<H4>Return Values</H4>

<P>
Zero if the results are buffered successfully.  Non-zero if an error occurred.

</P>

<H4>Errors</H4>

<DL COMPACT>

<DT><code>CR_COMMANDS_OUT_OF_SYNC</code>
<DD>
Commands were executed in an improper order. 
<DT><code>CR_OUT_OF_MEMORY</code>
<DD>
Out of memory. 
<DT><code>CR_SERVER_GONE_ERROR</code>
<DD>
The MySQL server has gone away. 
<DT><code>CR_SERVER_LOST</code>
<DD>
The connection to the server was lost during the query. 
<DT><code>CR_UNKNOWN_ERROR</code>
<DD>
An unknown error occurred. 
</DL>



<H3><A NAME="C_API_Prepared_statement_problems" HREF="manual_toc.html#C_API_Prepared_statement_problems">21.2.8  C API Prepared statement problems</A></H3>

<P>
Here follows a list of the currently known problems with prepared
statements:

</P>

<UL>
<LI>

<code>TIME</code>, <code>TIMESTAMP</code>, and <code>DATETIME</code> don't support sub seconds
(for example from <code>DATE_FORMAT()</code>.
<LI>

When converting an integer to string, <code>ZEROFILL</code> is honored with prepared
statements
in some cases where the MySQL server doesn't print the leading zeros.
(For example, with <code>MIN(number-with-zerofill)</code>).
<LI>

When converting a floating point number to a string in the client, the value
may be slightly different in the last digits.
</UL>



<H3><A NAME="C_API_multiple_queries" HREF="manual_toc.html#C_API_multiple_queries">21.2.9  C API Handling of Multiple Query Execution</A></H3>

<P>
From version 4.1, MySQL supports the execution of multiple statements
specified in a single query string. To use this capability with a given
connection, you must specify the <code>CLIENT_MULTI_STATEMENTS</code> option in
the flags parameter of <code>mysql_real_connect()</code>
when opening the connection.  You can also set this for an existing connection
by calling <code>mysql_set_server_option(MYSQL_OPTION_MULTI_STATEMENTS_ON)</code>

</P>
<P>
By default, <code>mysql_query()</code> and <code>mysql_real_query()</code> return
only the first query status and the subsequent queries status can
be processed using <code>mysql_more_results()</code> and
<code>mysql_next_result()</code>.

</P>

<PRE>

/* Connect to server with option CLIENT_MULTI_STATEMENTS */
mysql_real_connect(..., CLIENT_MULTI_STATEMENTS);

/* Now execute multiple queries */
mysql_query(mysql,"DROP TABLE IF EXISTS test_table;\
                   CREATE TABLE test_table(id INT);\
                   INSERT INTO test_table VALUES(10);\
                   UPDATE test_table SET id=20 WHERE id=10;\
                   SELECT * FROM test_table;\
                   DROP TABLE test_table");
do
{
  /* Process all results */
  ...
  printf("total affected rows: %lld", mysql_affected_rows(mysql));
  ...
  if (!(result= mysql_store_result(mysql)))
  {
     printf(stderr, "Got fatal error processing query\n");
     exit(1);
  }
  process_result_set(result);	/* client function */
  mysql_free_result(result);
} while (!mysql_next_result(mysql));

</PRE>



<H3><A NAME="C_API_date_handling" HREF="manual_toc.html#C_API_date_handling">21.2.10  C API Handling of Date and Time Values</A></H3>

<P>
The new binary protocol available in MySQL 4.1 and above allows you to
send and receive date and time values (<code>DATE</code>, <code>TIME</code>,
<code>DATETIME</code>, and <code>TIMESTAMP</code>), using
the <code>MYSQL_TIME</code> structure. The members of this structure are described
in section <A HREF="manual_MySQL_APIs.html#C_API_Prepared_statement_datatypes">21.2.5  C API Prepared Statement Data types</A>.

</P>
<P>
To send temporal data values, you create a prepared statement with
<code>mysql_stmt_prepare()</code>. Then, before calling
<code>mysql_stmt_execute()</code> to execute the statement, use the following
procedure to set up each temporal parameter:

</P>

<OL>

<LI>

In the <code>MYSQL_BIND</code> structure associated with the data value, set the
<code>buffer_type</code> member to the type that indicates what kind of temporal
value you're sending. For
<code>DATE</code>,
<code>TIME</code>,
<code>DATETIME</code>,
or
<code>TIMESTAMP</code>
values, set <code>buffer_type</code> to
<code>MYSQL_TYPE_DATE</code>,
<code>MYSQL_TYPE_TIME</code>,
<code>MYSQL_TYPE_DATETIME</code>,
or
<code>MYSQL_TYPE_TIMESTAMP</code>,
respectively.

<LI>

Set the <code>buffer</code> member of the <code>MYSQL_BIND</code> structure to the address
of the <code>MYSQL_TIME</code> structure in which you will pass the temporal value.

<LI>

Fill in the members of the <code>MYSQL_TIME</code> structure that are appropriate
for the type of temporal value you're passing.
</OL>

<P>
Use <code>mysql_stmt_bind_param()</code> to bind the parameter data to the statement.
Then you can call <code>mysql_stmt_execute()</code>.

</P>
<P>
To retrieve temporal values, the procedure is similar, except that you set
the <code>buffer_type</code> member to the type of value you expect to receive, and
the <code>buffer</code> member to the address of a <code>MYSQL_TIME</code> structure into
which the returned value should be placed.
Use <code>mysql_bind_results()</code> to bind the buffers to the statement after
calling <code>mysql_stmt_execute()</code> and before fetching the results.

</P>
<P>
Here is a simple example that inserts <code>DATE</code>, <code>TIME</code>, and
<code>TIMESTAMP</code> data.
The <code>mysql</code> variable is assumed to be a valid connection handle.

</P>

<PRE>

  MYSQL_TIME  ts;
  MYSQL_BIND  bind[3];
  MYSQL_STMT  *stmt;

  strmov(query, "INSERT INTO test_table(date_field, time_field,
                                        timestamp_field) VALUES(?,?,?");

  stmt = mysql_stmt_init(mysql);
  if (!stmt)
  {
    fprintf(stderr, " mysql_stmt_init(), out of memory\n");
    exit(0);
  }
  if (mysql_stmt_prepare(mysql, query, strlen(query)))
  {
    fprintf(stderr, "\n mysql_stmt_prepare(), INSERT failed");
    fprintf(stderr, "\n %s", mysql_stmt_error(stmt));
    exit(0);
  }

  /* set up input buffers for all 3 parameters */
  bind[0].buffer_type= MYSQL_TYPE_DATE;
  bind[0].buffer= (char *)&#38;ts;  
  bind[0].is_null= 0;
  bind[0].length= 0;
  ...
  bind[1]= bind[2]= bind[0];
  ...

  mysql_stmt_bind_param(stmt, bind);

  /* supply the data to be sent in the ts structure */
  ts.year= 2002;
  ts.month= 02;
  ts.day= 03;

  ts.hour= 10;
  ts.minute= 45;
  ts.second= 20;

  mysql_stmt_execute(stmt);
  .. 

</PRE>



<H3><A NAME="C_Thread_functions" HREF="manual_toc.html#C_Thread_functions">21.2.11  C API Threaded Function Descriptions</A></H3>

<P>
You need to use the following functions when you want to create a
threaded client. See section <A HREF="manual_MySQL_APIs.html#Threaded_clients">21.2.15  How to Make a Threaded Client</A>.

</P>



<H4><A NAME="my_init" HREF="manual_toc.html#my_init">21.2.11.1  <code>my_init()</code></A></H4>

<P>
<A NAME="IDX2197"></A>

</P>
<P>
<code>void my_init(void)</code>

</P>

<H4>Description</H4>

<P>
This function needs to be called once in the program before calling any
MySQL function.  This initializes some global variables that MySQL
needs.  If you are using a thread-safe client library, this will also
call <code>mysql_thread_init()</code> for this thread.

</P>
<P>
This is automatically called by <code>mysql_init()</code>,
<code>mysql_server_init()</code> and <code>mysql_connect()</code>.

</P>

<H4>Return Values</H4>

<P>
None.

</P>


<H4><A NAME="mysql_thread_init" HREF="manual_toc.html#mysql_thread_init">21.2.11.2  <code>mysql_thread_init()</code></A></H4>

<P>
<A NAME="IDX2198"></A>

</P>
<P>
<code>my_bool mysql_thread_init(void)</code>

</P>

<H4>Description</H4>

<P>
This function needs to be called for each created thread to initialize
thread-specific variables.

</P>
<P>
This is automatically called by <code>my_init()</code> and <code>mysql_connect()</code>.

</P>

<H4>Return Values</H4>

<P>
Zero if successful. Non-zero if an error occurred.

</P>


<H4><A NAME="mysql_thread_end" HREF="manual_toc.html#mysql_thread_end">21.2.11.3  <code>mysql_thread_end()</code></A></H4>

<P>
<A NAME="IDX2199"></A>

</P>
<P>
<code>void mysql_thread_end(void)</code>

</P>

<H4>Description</H4>

<P>
This function needs to be called before calling <code>pthread_exit()</code> to
free memory allocated by <code>mysql_thread_init()</code>.

</P>
<P>
Note that this function <strong>is not invoked automatically</strong> by the client
library.  It must be called explicitly to avoid a memory leak.

</P>

<H4>Return Values</H4>

<P>
None.

</P>


<H4><A NAME="mysql_thread_safe" HREF="manual_toc.html#mysql_thread_safe">21.2.11.4  <code>mysql_thread_safe()</code></A></H4>

<P>
<A NAME="IDX2200"></A>

</P>
<P>
<code>unsigned int mysql_thread_safe(void)</code>

</P>

<H4>Description</H4>

<P>
This function indicates whether the client is compiled as thread-safe.

</P>

<H4>Return Values</H4>

<P>
1 is the client is thread-safe, 0 otherwise.

</P>


<H3><A NAME="C_Embedded_Server_func" HREF="manual_toc.html#C_Embedded_Server_func">21.2.12  C API Embedded Server Function Descriptions</A></H3>

<P>
You must use the following functions if you want to allow your
application to be linked against the embedded MySQL server library.
See section <A HREF="manual_MySQL_APIs.html#libmysqld">21.2.16  libmysqld, the Embedded MySQL Server Library</A>.

</P>
<P>
If the program is linked with <code>-lmysqlclient</code> instead of
<code>-lmysqld</code>, these functions do nothing.  This makes it
possible to choose between using the embedded MySQL server and
a standalone server without modifying any code.

</P>



<H4><A NAME="mysql_server_init" HREF="manual_toc.html#mysql_server_init">21.2.12.1  <code>mysql_server_init()</code></A></H4>

<P>
<A NAME="IDX2201"></A>

</P>
<P>
<code>int mysql_server_init(int argc, char **argv, char **groups)</code>

</P>

<H4>Description</H4>

<P>
This function <strong>must</strong> be called once in the program using the
embedded server before calling any other MySQL function.  It starts
the server and initializes any subsystems (<code>mysys</code>, <code>InnoDB</code>, etc.) 
that the server uses.  If this function is not called, the next call to
<code>mysql_init()</code> executes <code>mysql_server_init()</code>.
If you are using the DBUG package that comes with MySQL, you should call
this after you have called <code>my_init()</code>.

</P>
<P>
The <code>argc</code> and <code>argv</code> arguments are analogous to the arguments
to <code>main()</code>.  The first element of <code>argv</code> is ignored (it
typically contains the program name).  For convenience, <code>argc</code> may
be <code>0</code> (zero) if there are no command-line arguments for the
server.  <code>mysql_server_init()</code> makes a copy of the arguments so
it's safe to destroy <code>argv</code> or <code>groups</code> after the call.

</P>
<P>
If you want to connect to an external server without starting the embedded
server, you have to specify a negative value for <code>argc</code>.

</P>
<P>
The <code>NULL</code>-terminated list of strings in <code>groups</code>
selects which groups in the option files will be active.
See section <A HREF="manual_Using_MySQL_Programs.html#Option_files">4.3.2  Using Option Files</A>.  For convenience, <code>groups</code> may be
<code>NULL</code>, in which case the <code>[server]</code> and <code>[emedded]</code> groups
will be active.

</P>

<H4>Example</H4>


<PRE>
#include &#60;mysql.h&#62;
#include &#60;stdlib.h&#62;

static char *server_args[] = {
  "this_program",       /* this string is not used */
  "--datadir=.",
  "--key_buffer_size=32M"
};
static char *server_groups[] = {
  "embedded",
  "server",
  "this_program_SERVER",
  (char *)NULL
};

int main(void) {
  if (mysql_server_init(sizeof(server_args) / sizeof(char *),
                        server_args, server_groups))
    exit(1);

  /* Use any MySQL API functions here */

  mysql_server_end();

  return EXIT_SUCCESS;
}
</PRE>


<H4>Return Values</H4>

<P>
0 if okay, 1 if an error occurred.

</P>


<H4><A NAME="mysql_server_end" HREF="manual_toc.html#mysql_server_end">21.2.12.2  <code>mysql_server_end()</code></A></H4>

<P>
<A NAME="IDX2202"></A>

</P>
<P>
<code>void mysql_server_end(void)</code>

</P>

<H4>Description</H4>

<P>
This function <strong>must</strong> be called once in the program after
all other MySQL functions.  It shuts down the embedded server.

</P>

<H4>Return Values</H4>

<P>
None.

</P>


<H3><A NAME="C_API_problems" HREF="manual_toc.html#C_API_problems">21.2.13  Common questions and problems when using the C API</A></H3>

<P>
<A NAME="IDX2203"></A>
<A NAME="IDX2204"></A>

</P>



<H4><A NAME="NULL_mysql_store_result" HREF="manual_toc.html#NULL_mysql_store_result">21.2.13.1  Why <code>mysql_store_result()</code> Sometimes Returns <code>NULL</code> After <code>mysql_query()</code> Returns Success</A></H4>

<P>
It is possible for <code>mysql_store_result()</code> to return <code>NULL</code>
following a successful call to <code>mysql_query()</code>.  When this happens, it
means one of the following conditions occurred:

</P>

<UL>
<LI>

There was a <code>malloc()</code> failure (for example, if the result set was too
large).

<LI>

The data couldn't be read (an error occurred on the connection).

<LI>

The query returned no data (for example, it was an <code>INSERT</code>,
<code>UPDATE</code>, or <code>DELETE</code>).
</UL>

<P>
You can always check whether the statement should have produced a
non-empty result by calling <code>mysql_field_count()</code>.  If
<code>mysql_field_count()</code> returns zero, the result is empty and the last
query was a statement that does not return values (for example, an
<code>INSERT</code> or a <code>DELETE</code>).  If <code>mysql_field_count()</code> returns a
non-zero value, the statement should have produced a non-empty result.
See the description of the <code>mysql_field_count()</code> function for an
example.

</P>
<P>
You can test for an error by calling <code>mysql_error()</code> or
<code>mysql_errno()</code>.

</P>


<H4><A NAME="Query_results" HREF="manual_toc.html#Query_results">21.2.13.2  What Results You Can Get from a Query</A></H4>

<P>
In addition to the result set returned by a query, you can also get the
following information:

</P>

<UL>
<LI>

<code>mysql_affected_rows()</code> returns the number of rows affected by the last
query when doing an <code>INSERT</code>, <code>UPDATE</code>, or <code>DELETE</code>. 

In MySQL 3.23, there is an exception when <code>DELETE</code> is used without
a <code>WHERE</code> clause. In this case, the table is re-created as an empty
table and <code>mysql_affected_rows()</code> returns zero for the number of
records affected.  In MySQL 4.0, <code>DELETE</code> always returns the correct
number of rows deleted. For a fast recreate, use <code>TRUNCATE TABLE</code>.

<LI>

<code>mysql_num_rows()</code> returns the number of rows in a result set.  With
<code>mysql_store_result()</code>, <code>mysql_num_rows()</code> may be called as soon as
<code>mysql_store_result()</code> returns.  With <code>mysql_use_result()</code>,
<code>mysql_num_rows()</code> may be called only after you have fetched all the
rows with <code>mysql_fetch_row()</code>.

<LI>

<code>mysql_insert_id()</code> returns the ID generated by the last
query that inserted a row into a table with an <code>AUTO_INCREMENT</code> index.
See section <A HREF="manual_MySQL_APIs.html#mysql_insert_id">21.2.3.33  <code>mysql_insert_id()</code></A>.

<LI>

Some queries (<code>LOAD DATA INFILE ...</code>, <code>INSERT INTO
... SELECT ...</code>, <code>UPDATE</code>) return additional information.  The result is
returned by <code>mysql_info()</code>.  See the description for <code>mysql_info()</code>
for the format of the string that it returns.  <code>mysql_info()</code> returns a
<code>NULL</code> pointer if there is no additional information.
</UL>



<H4><A NAME="Getting_unique_ID" HREF="manual_toc.html#Getting_unique_ID">21.2.13.3  How to Get the Unique ID for the Last Inserted Row</A></H4>

<P>
<A NAME="IDX2205"></A>
<A NAME="IDX2206"></A>
<A NAME="IDX2207"></A>
<A NAME="IDX2208"></A>

</P>
<P>
If you insert a record into a table that contains an <code>AUTO_INCREMENT</code>
column, you can obtain the value stored into that column by calling the
<code>mysql_insert_id()</code> function.

</P>
<P>
You can check from your C applications whether a value was stored into an
<code>AUTO_INCREMENT</code> column by executing the following code (which assumes
that you've already checked that the statement succeeded). It determines
whether the query was an <code>INSERT</code> with an <code>AUTO_INCREMENT</code> index:

</P>

<PRE>
if ((result = mysql_store_result(&#38;mysql)) == 0 &#38;&#38;
    mysql_field_count(&#38;mysql) == 0 &#38;&#38;
    mysql_insert_id(&#38;mysql) != 0)
{
    used_id = mysql_insert_id(&#38;mysql);
}
</PRE>

<P>
For more information, see section <A HREF="manual_MySQL_APIs.html#mysql_insert_id">21.2.3.33  <code>mysql_insert_id()</code></A>.

</P>
<P>
When a new <code>AUTO_INCREMENT</code> value has been generated, you can also
obtain it by executing a <code>SELECT LAST_INSERT_ID()</code> statement with
<code>mysql_query()</code> and retrieving the value from the result set returned
by the statement.

</P>
<P>
For <code>LAST_INSERT_ID()</code>,
the most recently generated ID is maintained in the server on a
per-connection basis.  It will not be changed by another client. It will not
even be changed if you update another <code>AUTO_INCREMENT</code> column with a
non-magic value (that is, a value that is not <code>NULL</code> and not <code>0</code>).

</P>
<P>
If you want to use the ID that was generated for one table and insert
it into a second table, you can use SQL statements like this:

</P>

<PRE>
INSERT INTO foo (auto,text)
    VALUES(NULL,'text');              # generate ID by inserting NULL
INSERT INTO foo2 (id,text)
    VALUES(LAST_INSERT_ID(),'text');  # use ID in second table
</PRE>

<P>
Note that <code>mysql_insert_id()</code> returns the value stored into an
<code>AUTO_INCREMENT</code> column, whether that value is automatically generated
by storing <code>NULL</code> or <code>0</code> or was specified as an explicit value.
<code>LAST_INSERT_ID()</code> returns only automatically generated
<code>AUTO_INCREMENT</code> values. If you store an explicit value other than
<code>NULL</code> or <code>0</code>, it does not affect the value returned by
<code>LAST_INSERT_ID()</code>.

</P>



<H4><A NAME="C_API_linking_problems" HREF="manual_toc.html#C_API_linking_problems">21.2.13.4  Problems Linking with the C API</A></H4>

<P>
<A NAME="IDX2209"></A>
<A NAME="IDX2210"></A>

</P>
<P>
When linking with the C API, the following errors may occur on some systems:

</P>

<PRE>
gcc -g -o client test.o -L/usr/local/lib/mysql -lmysqlclient -lsocket -lnsl

Undefined        first referenced
 symbol          in file
floor            /usr/local/lib/mysql/libmysqlclient.a(password.o)
ld: fatal: Symbol referencing errors. No output written to client
</PRE>

<P>
If this happens on your system, you must include the math library by
adding <code>-lm</code> to the end of the compile/link line.

</P>



<H3><A NAME="Building_clients" HREF="manual_toc.html#Building_clients">21.2.14  Building Client Programs</A></H3>

<P>
<A NAME="IDX2211"></A>
<A NAME="IDX2212"></A>
<A NAME="IDX2213"></A>
<A NAME="IDX2214"></A>

</P>
<P>
If you compile MySQL clients that you've written yourself or that
you obtain from a third-party, they must be linked using the
<code>-lmysqlclient -lz</code> option on the link command.  You may also need to
specify a <code>-L</code> option to tell the linker where to find the library.  For
example, if the library is installed in <tt>`/usr/local/mysql/lib'</tt>, use
<code>-L/usr/local/mysql/lib -lmysqlclient -lz</code> on the link command.

</P>
<P>
For clients that use MySQL header files, you may need to specify a
<code>-I</code> option when you compile them (for example,
<code>-I/usr/local/mysql/include</code>), so the compiler can find the header
files.

</P>
<P>
To make it simpler to compile MySQL programs on Unix, we have provided the
<code>mysql_config</code> script for you. See section <A HREF="manual_MySQL_APIs.html#mysql_config">21.1.2  <code>mysql_config</code>, Get compile options for compiling clients</A>.

</P>
<P>
You can use it to compile a MySQL client as follows:

</P>

<PRE>
CFG=/usr/local/mysql/bin/mysql_config
sh -c "gcc -o progname `$CFG --cflags` progname.c `$CFG --libs`"
</PRE>

<P>
The <code>sh -c</code> is needed to get the shell not to treat the output from
<code>mysql_config</code> as one word.

</P>


<H3><A NAME="Threaded_clients" HREF="manual_toc.html#Threaded_clients">21.2.15  How to Make a Threaded Client</A></H3>

<P>
<A NAME="IDX2215"></A>
<A NAME="IDX2216"></A>

</P>
<P>
The client library is almost thread-safe. The biggest problem is
that the subroutines in <tt>`net.c'</tt> that read from sockets are not
interrupt safe.  This was done with the thought that you might want to
have your own alarm that can break a long read to a server.  If you
install interrupt handlers for the <code>SIGPIPE</code> interrupt,
the socket handling should be thread-safe.

</P>
<P>
New in 4.0.16: To not abort the program when a connection terminates,
MySQL blocks <code>SIGPIPE</code> on the first call to
<code>mysql_server_init</code>(), <code>mysql_init()</code> or
<code>mysql_connect()</code>.  If you want to have your own <code>SIGPIPE</code>
handler, you should first call <code>mysql_server_init()</code> and then
install your handler. In older versions of MySQL <code>SIGPIPE</code> was blocked,
but only in the thread safe client library, for every call to
<code>mysql_init()</code>.

</P>
<P>
In the older binaries we distribute on our Web site
(<a HREF="http://www.mysql.com/">http://www.mysql.com/</a>), the client libraries are not normally
compiled with the thread-safe option (the Windows binaries are by
default compiled to be thread-safe). Newer binary distributions should
have both a normal and a thread-safe client library.

</P>
<P>
To get a threaded client where you can interrupt the client from other
threads and set timeouts when talking with the MySQL server, you should
use the <code>-lmysys</code>, <code>-lmystrings</code>, and <code>-ldbug</code> libraries and
the <code>net_serv.o</code> code that the server uses.

</P>
<P>
If you don't need interrupts or timeouts, you can just compile a
thread-safe client library <code>(mysqlclient_r)</code> and use this.  See section <A HREF="manual_MySQL_APIs.html#C">21.2  MySQL C API</A>.  In this case, you don't have to worry about the
<code>net_serv.o</code> object file or the other MySQL libraries.

</P>
<P>
When using a threaded client and you want to use timeouts and
interrupts, you can make great use of the routines in the
<tt>`thr_alarm.c'</tt> file.  If you are using routines from the
<code>mysys</code> library, the only thing you must remember is to call
<code>my_init()</code> first! See section <A HREF="manual_MySQL_APIs.html#C_Thread_functions">21.2.11  C API Threaded Function Descriptions</A>.

</P>
<P>
All functions except <code>mysql_real_connect()</code> are by default
thread-safe.  The following notes describe how to compile a thread-safe
client library and use it in a thread-safe manner.  (The notes below for
<code>mysql_real_connect()</code> actually apply to <code>mysql_connect()</code> as
well, but because <code>mysql_connect()</code> is deprecated, you should be
using <code>mysql_real_connect()</code> anyway.)

</P>
<P>
To make <code>mysql_real_connect()</code> thread-safe, you must recompile the
client library with this command:

</P>

<PRE>
shell&#62; ./configure --enable-thread-safe-client
</PRE>

<P>
This will create a thread-safe client library <code>libmysqlclient_r</code>.
(Assuming that your OS has a thread-safe <code>gethostbyname_r()</code> function.)
This library is thread-safe per connection.  You can let two threads
share the same connection with the following caveats:

</P>

<UL>
<LI>

Two threads can't send a query to the MySQL server at the same time on
the same connection.  In particular, you have to ensure that between a
<code>mysql_query()</code> and <code>mysql_store_result()</code> no other thread is using
the same connection.
<LI>

Many threads can access different result sets that are retrieved with
<code>mysql_store_result()</code>.
<LI>

If you use <code>mysql_use_result</code>, you have to ensure that no other thread
is using the same connection until the result set is closed.
However, it really is best for threaded clients that share the same
connection to use <code>mysql_store_result()</code>.
<LI>

If you want to use multiple threads on the same connection, you must
have a mutex lock around your <code>mysql_query()</code> and
<code>mysql_store_result()</code> call combination.  Once
<code>mysql_store_result()</code> is ready, the lock can be released and other
threads may query the same connection.
<LI>

If you program with POSIX threads, you can use
<code>pthread_mutex_lock()</code> and <code>pthread_mutex_unlock()</code> to
establish and release a mutex lock.
</UL>

<P>
You need to know the following if you have a thread that is calling
MySQL functions which did not create the connection to the
MySQL database:

</P>
<P>
When you call <code>mysql_init()</code> or <code>mysql_connect()</code>, MySQL will
create a thread-specific variable for the thread that is used by the
debug library (among other things).

</P>
<P>
If you call a MySQL function, before the thread has
called <code>mysql_init()</code> or <code>mysql_connect()</code>, the thread will
not have the necessary thread-specific variables in place and you are
likely to end up with a core dump sooner or later.

</P>
<P>
The get things to work smoothly you have to do the following:

</P>

<OL>
<LI>

Call <code>my_init()</code> at the start of your program if it calls
any other MySQL function before calling <code>mysql_real_connect()</code>.
<LI>

Call <code>mysql_thread_init()</code> in the thread handler before calling
any MySQL function.
<LI>

In the thread, call <code>mysql_thread_end()</code> before calling
<code>pthread_exit()</code>.  This will free the memory used by MySQL
thread-specific variables.
</OL>

<P>
You may get some errors because of undefined symbols when linking your
client with <code>libmysqlclient_r</code>. In most cases this is because you haven't
included the thread libraries on the link/compile line.

</P>


<H3><A NAME="libmysqld" HREF="manual_toc.html#libmysqld">21.2.16  libmysqld, the Embedded MySQL Server Library</A></H3>

<P>
<A NAME="IDX2217"></A>
<A NAME="IDX2218"></A>

</P>



<H4><A NAME="libmysqld_overview" HREF="manual_toc.html#libmysqld_overview">21.2.16.1  Overview of the Embedded MySQL Server Library</A></H4>

<P>
The embedded MySQL server library makes it possible to run a
full-featured MySQL server inside a client application.  The
main benefits are increased speed and more simple management for
embedded applications.

</P>
<P>
The embedded server library is based on the client/server version of MySQL,
which is written in C/C++. Consequently, the embedded server also
is written in C/C++. There is no embedded server available in other
languages.

</P>
<P>
The API is identical for the embedded MySQL version and the
client/server version.  To change an old threaded application to use the
embedded library, you normally only have to add calls to the following
functions:

</P>
<TABLE BORDER>
<TR><TD><strong>Function</strong> </TD><TD> <strong>When to Call</strong>
</TD></TR>
<TR><TD><code>mysql_server_init()</code> </TD><TD> Should be called before any other MySQL function is called, preferably early in the <code>main()</code> function.
</TD></TR>
<TR><TD><code>mysql_server_end()</code> </TD><TD> Should be called before your program exits.
</TD></TR>
<TR><TD><code>mysql_thread_init()</code> </TD><TD> Should be called in each thread you create that will access MySQL.
</TD></TR>
<TR><TD><code>mysql_thread_end()</code> </TD><TD> Should be called before calling <code>pthread_exit()</code>
</TD></TR>
</TABLE>

<P>
Then you must link your code with <tt>`libmysqld.a'</tt> instead of <tt>`libmysqlclient.a'</tt>.

</P>
<P>
The <code>mysql_server_<var>xxx</var>()</code> functions are also included in
<tt>`libmysqlclient.a'</tt> to allow you to change between the embedded and the
client/server version by just linking your application with the right
library. See section <A HREF="manual_MySQL_APIs.html#mysql_server_init">21.2.12.1  <code>mysql_server_init()</code></A>.

</P>



<H4><A NAME="libmysqld_compiling" HREF="manual_toc.html#libmysqld_compiling">21.2.16.2  Compiling Programs with <code>libmysqld</code></A></H4>

<P>
To get a <code>libmysqld</code> library you should configure MySQL with the
<code>--with-embedded-server</code> option.

</P>
<P>
When you link your program with <code>libmysqld</code>, you must also include
the system-specific <code>pthread</code> libraries and some libraries that
the MySQL server uses.  You can get the full list of libraries by executing
<code>mysql_config --libmysqld-libs</code>.

</P>
<P>
The correct flags for compiling and linking a threaded program
must be used, even if you do not directly call any thread
functions in your code.

</P>


<H4><A NAME="libmysqld_restrictions" HREF="manual_toc.html#libmysqld_restrictions">21.2.16.3  Restrictions when using the Embedded MySQL Server</A></H4>

<P>
The embedded server has the following limitations:

</P>

<UL>
<LI>

No support for <code>ISAM</code> tables. (This is mainly done to make the library smaller)
<LI>

No user-defined functions (UDFs).
<LI>

No stack trace on core dump.
<LI>

No internal RAID support. (This is not normally needed as most OS has
nowadays support for big files).
<LI>

You cannot set this up as a master or a slave (no replication).
<LI>

You can't connect to an embedded server from an outside process with
sockets or TCP/IP.
</UL>

<P>
Some of these limitations can be changed by editing the <tt>`mysql_embed.h'</tt>
include file and recompiling MySQL.

</P>


<H4><A NAME="libmysqld_options" HREF="manual_toc.html#libmysqld_options">21.2.16.4  Using Option Files with the Embedded Server</A></H4>

<P>
<A NAME="IDX2219"></A>

</P>
<P>
The following is the recommended way to use option files to make it easy
to switch between a client/server application and one where MySQL is
embedded. See section <A HREF="manual_Using_MySQL_Programs.html#Option_files">4.3.2  Using Option Files</A>.

</P>

<UL>
<LI>

Put common options in the <code>[server]</code> section. These will be read by
both MySQL versions.
<LI>

Put client/server-specific options in the <code>[mysqld]</code> section.
<LI>

Put embedded MySQL-specific options in the <code>[embedded]</code> section.
<LI>

Put application-specific options in a <code>[ApplicationName_SERVER]</code>
section.
</UL>



<H4><A NAME="libmysqld_TODO" HREF="manual_toc.html#libmysqld_TODO">21.2.16.5  Things left to do in Embedded Server (TODO)</A></H4>

<P>
<A NAME="IDX2220"></A>

</P>

<UL>
<LI>

We are going to provide options to leave out some parts of MySQL to make
the library smaller.
<LI>

There is still a lot of speed optimization to do.
<LI>

Errors are written to <code>stderr</code>.  We will add an option to specify a
filename for these.
<LI>

We have to change <code>InnoDB</code> to not be so verbose when using in the embedded
version.
</UL>



<H4><A NAME="libmysqld_example" HREF="manual_toc.html#libmysqld_example">21.2.16.6  A Simple Embedded Server Example</A></H4>

<P>
This example program and makefile should work without any
changes on a Linux or FreeBSD system.  For other operating
systems, minor changes will be needed.  This example is
designed to give enough details to understand the problem,
without the clutter that is a necessary part of a real
application.

</P>
<P>
To try out the example, create an <tt>`test_libmysqld'</tt> directory
at the same level as the mysql-4.0 source directory.  Save
the <tt>`test_libmysqld.c'</tt> source and the <tt>`GNUmakefile'</tt> in the
directory, and run GNU <tt>`make'</tt> from inside the <tt>`test_libmysqld'</tt>
directory.

</P>
<P>
<tt>`test_libmysqld.c'</tt>

<PRE>
/*
 * A simple example client, using the embedded MySQL server library
 */

#include &#60;mysql.h&#62;
#include &#60;stdarg.h&#62;
#include &#60;stdio.h&#62;
#include &#60;stdlib.h&#62;

MYSQL *db_connect(const char *dbname);
void db_disconnect(MYSQL *db);
void db_do_query(MYSQL *db, const char *query);

const char *server_groups[] = {
  "test_libmysqld_SERVER", "embedded", "server", NULL
};

int
main(int argc, char **argv)
{
  MYSQL *one, *two;

  /* mysql_server_init() must be called before any other mysql
   * functions.
   *
   * You can use mysql_server_init(0, NULL, NULL), and it will
   * initialize the server using groups = {
   *   "server", "embedded", NULL
   *  }.
   *
   * In your $HOME/.my.cnf file, you probably want to put:

[test_libmysqld_SERVER]
language = /path/to/source/of/mysql/sql/share/english

   * You could, of course, modify argc and argv before passing
   * them to this function.  Or you could create new ones in any
   * way you like.  But all of the arguments in argv (except for
   * argv[0], which is the program name) should be valid options
   * for the MySQL server.
   *
   * If you link this client against the normal mysqlclient
   * library, this function is just a stub that does nothing.
   */
  mysql_server_init(argc, argv, (char **)server_groups);

  one = db_connect("test");
  two = db_connect(NULL);

  db_do_query(one, "SHOW TABLE STATUS");
  db_do_query(two, "SHOW DATABASES");

  mysql_close(two);
  mysql_close(one);

  /* This must be called after all other mysql functions */
  mysql_server_end();

  exit(EXIT_SUCCESS);
}

static void
die(MYSQL *db, char *fmt, ...)
{
  va_list ap;
  va_start(ap, fmt);
  vfprintf(stderr, fmt, ap);
  va_end(ap);
  (void)putc('\n', stderr);
  if (db)
    db_disconnect(db);
  exit(EXIT_FAILURE);
}

MYSQL *
db_connect(const char *dbname)
{
  MYSQL *db = mysql_init(NULL);
  if (!db)
    die(db, "mysql_init failed: no memory");
  /*
   * Notice that the client and server use separate group names.
   * This is critical, because the server will not accept the
   * client's options, and vice versa.
   */
  mysql_options(db, MYSQL_READ_DEFAULT_GROUP, "test_libmysqld_CLIENT");
  if (!mysql_real_connect(db, NULL, NULL, NULL, dbname, 0, NULL, 0))
    die(db, "mysql_real_connect failed: %s", mysql_error(db));

  return db;
}

void
db_disconnect(MYSQL *db)
{
  mysql_close(db);
}

void
db_do_query(MYSQL *db, const char *query)
{
  if (mysql_query(db, query) != 0)
    goto err;

  if (mysql_field_count(db) &#62; 0)
  {
    MYSQL_RES   *res;
    MYSQL_ROW    row, end_row;
    int num_fields;

    if (!(res = mysql_store_result(db)))
      goto err;
    num_fields = mysql_num_fields(res);
    while ((row = mysql_fetch_row(res)))
    {
      (void)fputs("&#62;&#62; ", stdout);
      for (end_row = row + num_fields; row &#60; end_row; ++row)
        (void)printf("%s\t", row ? (char*)*row : "NULL");
      (void)fputc('\n', stdout);
    }
    (void)fputc('\n', stdout);
    mysql_free_result(res);
  }
  else
    (void)printf("Affected rows: %lld\n", mysql_affected_rows(db));

  return;

err:
  die(db, "db_do_query failed: %s [%s]", mysql_error(db), query);
}
</PRE>

<P>
<tt>`GNUmakefile'</tt>

<PRE>
# This assumes the MySQL software is installed in /usr/local/mysql
inc      := /usr/local/mysql/include/mysql
lib      := /usr/local/mysql/lib

# If you have not installed the MySQL software yet, try this instead
#inc      := $(HOME)/mysql-4.0/include
#lib      := $(HOME)/mysql-4.0/libmysqld

CC       := gcc
CPPFLAGS := -I$(inc) -D_THREAD_SAFE -D_REENTRANT
CFLAGS   := -g -W -Wall
LDFLAGS  := -static
# You can change -lmysqld to -lmysqlclient to use the
# client/server library
LDLIBS    = -L$(lib) -lmysqld -lz -lm -lcrypt

ifneq (,$(shell grep FreeBSD /COPYRIGHT 2&#62;/dev/null))
# FreeBSD
LDFLAGS += -pthread
else
# Assume Linux
LDLIBS += -lpthread
endif

# This works for simple one-file test programs
sources := $(wildcard *.c)
objects := $(patsubst %c,%o,$(sources))
targets := $(basename $(sources))

all: $(targets)

clean:
        rm -f $(targets) $(objects) *.core
</PRE>



<H4><A NAME="libmysqld_licensing" HREF="manual_toc.html#libmysqld_licensing">21.2.16.7  Licensing the Embedded Server</A></H4>

<P>
We encourage everyone to promote free software by releasing
code under the GPL or a compatible license.  For those who
are not able to do this, another option is to purchase a
commercial license for the MySQL code from MySQL AB.
For details, please see <a HREF="http://www.mysql.com/company/legal/licensing/">http://www.mysql.com/company/legal/licensing/</a>.

</P>



<H2><A NAME="PHP" HREF="manual_toc.html#PHP">21.3  MySQL PHP API</A></H2>

<P>
<A NAME="IDX2221"></A>

</P>
<P>
PHP is a server-side, HTML-embedded scripting language that may be used to
create dynamic Web pages.  It contains support for accessing several
databases, including MySQL.  PHP may be run as a separate program
or compiled as a module for use with the Apache Web server.

</P>
<P>
The distribution and documentation are available at the PHP Web site
(<a HREF="http://www.php.net/">http://www.php.net/</a>).

</P>



<H3><A NAME="PHP_problems" HREF="manual_toc.html#PHP_problems">21.3.1  Common Problems with MySQL and PHP</A></H3>


<UL>
<LI>Error: "Maximum Execution Time Exceeded"

This is a PHP limit; go into the <tt>`php.ini'</tt> file and set the maximum
execution time up from 30 seconds to something higher, as needed.
It is also not a bad idea to double the RAM allowed per script to 16MB instead of
8MB.
<LI>Error: "Fatal error: Call to unsupported or undefined function mysql_connect() in .."

This means that your PHP version isn't compiled with MySQL support.
You can either compile a dynamic MySQL module and load it into PHP or
recompile PHP with built-in MySQL support.  This is described in
detail in the PHP manual.
<LI>Error: "undefined reference to `uncompress'"

This means that the client library is compiled with support for a compressed
client/server protocol. The fix is to add <code>-lz</code> last when linking
with <code>-lmysqlclient</code>.
</UL>



<H2><A NAME="Perl" HREF="manual_toc.html#Perl">21.4  MySQL Perl API</A></H2>

<P>
<A NAME="IDX2222"></A>
<A NAME="IDX2223"></A>
<A NAME="IDX2224"></A>
<A NAME="IDX2225"></A>

</P>

<P>
The Perl <code>DBI</code> module provides a generic interface for database access.
You can write a DBI script that works with many different database engines
without change. To use DBI, you must install the <code>DBI</code> module, as well
as a DataBase Driver (DBD) module for each type of server you want to access.
For MySQL, this driver is the <code>DBD::mysql</code> module.

</P>
<P>
Perl DBI is now the recommended Perl interface. It replaces an older
interface called <code>mysqlperl</code>, which should be considered obsolete.

</P>
<P>
Installation instructions for Perl DBI support are given in
section <A HREF="manual_Installing.html#Perl_support">2.13  Perl Installation Notes</A>.

</P>
<P>
DBI information is available at the command line, online, or in printed form:

</P>

<UL>
<LI>

Once you have the <code>DBI</code> and <code>DBD::mysql</code> modules installed, you can
get information about them at the command line with the <code>perldoc</code> command:


<PRE>
shell&#62; perldoc DBI
shell&#62; perldoc DBI::FAQ
shell&#62; perldoc DBD::mysql
</PRE>

You can also use <code>pod2man</code>, <code>pod2html</code>, and so forth to translate
this information into other formats.

<LI>

For online information about Perl DBI, visit the DBI Web site,
<a HREF="http://dbi.perl.org/">http://dbi.perl.org/</a>. That site hosts a general DBI mailing list.
MySQL AB hosts a list specifically about <code>DBD::mysql</code>; see
section <A HREF="manual_Introduction.html#Mailing-list">1.4.1.1  The MySQL Mailing Lists</A>.

<LI>

For printed information, the official DBI book is <cite>Programming the Perl
DBI</cite> (Alligator Descartes and Tim Bunce, O'Reilly &#38; Associates, 2000).
Information about the book is available at the DBI Web site,
<a HREF="http://dbi.perl.org/">http://dbi.perl.org/</a>.

For information that focuses specifically on using DBI with MySQL, see
<cite>MySQL and Perl for the Web</cite> (Paul DuBois, New Riders, 2001). This
book's Web site is <a HREF="http://www.kitebird.com/mysql-perl/">http://www.kitebird.com/mysql-perl/</a>.

</UL>



<H2><A NAME="Cplusplus" HREF="manual_toc.html#Cplusplus">21.5  MySQL C++ API</A></H2>

<P>
<A NAME="IDX2226"></A>
<A NAME="IDX2227"></A>

</P>
<P>
<code>MySQL++</code> is the MySQL API for C++. More
information can be found at <a HREF="http://www.mysql.com/products/mysql++/">http://www.mysql.com/products/mysql++/</a>.

</P>



<H3><A NAME="Borland_C++" HREF="manual_toc.html#Borland_C++">21.5.1  Borland C++</A></H3>

<P>
<A NAME="IDX2228"></A>

</P>
<P>
You can compile the MySQL Windows source with Borland C++ 5.02.
(The Windows source includes only projects for Microsoft VC++, for
Borland C++ you have to do the project files yourself.)

</P>
<P>
One known problem with Borland C++ is that it uses a different structure
alignment than VC++.  This means that you will run into problems if you
try to use the default <code>libmysql.dll</code> libraries (that was compiled
with VC++) with Borland C++. To avoid this problem, only call
<code>mysql_init()</code> with <code>NULL</code> as an argument, not a pre-allocated
<code>MYSQL</code> structure.

</P>



<H2><A NAME="Python" HREF="manual_toc.html#Python">21.6  MySQL Python API</A></H2>

<P>
<A NAME="IDX2229"></A>

</P>
<P>
<code>MySQLdb</code> provides MySQL support for Python, compliant with the
Python DB API version 2.0. It can be found at
<a HREF="http://sourceforge.net/projects/mysql-python/">http://sourceforge.net/projects/mysql-python/</a>.

</P>



<H2><A NAME="Tcl" HREF="manual_toc.html#Tcl">21.7  MySQL Tcl API</A></H2>

<P>
<A NAME="IDX2230"></A>

</P>
<P>
<code>MySQLtcl</code> is a simple API for accessing a MySQL database server from the Tcl
programming language. It can be found at <a HREF="http://www.xdobry.de/mysqltcl/">http://www.xdobry.de/mysqltcl/</a>.

</P>


<H2><A NAME="Eiffel" HREF="manual_toc.html#Eiffel">21.8  MySQL Eiffel Wrapper</A></H2>

<P>
<A NAME="IDX2231"></A>
<A NAME="IDX2232"></A>

</P>
<P>
Eiffel MySQL is an interface to the MySQL database server using the Eiffel
programming language, written by Michael Ravits. It can be found at
<a HREF="http://efsa.sourceforge.net/archive/ravits/mysql.htm">http://efsa.sourceforge.net/archive/ravits/mysql.htm</a>.

</P>

<P><HR><P>
Go to the <A HREF="manual_Introduction.html">first</A>, <A HREF="manual_Triggers.html">previous</A>, <A HREF="manual_MySQL_Connectors.html">next</A>, <A HREF="manual_Concept_Index.html">last</A> section, <A HREF="manual_toc.html">table of contents</A>.
 </BODY>
 </HTML>
