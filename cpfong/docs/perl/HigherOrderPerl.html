<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
	"http://www.w3.org/TR/1998/REC-html40-19980424/loose.dtd">
<html>
<head><meta http-equiv="content-type" content="text/html; charset=UTF-8"><meta name="generator" content="ABBYY FineReader 15"><meta name="author" content="Ganesh Rao (Cepha (Imaging)"><meta name="description" content="TeX output 2005.07.19:1926"><title>T:\Inprocess\Elsevier\Dominus\FM.dvi</title>
<style type="text/css">
 table.main {}
 tr.row {}
 td.cell {}
 div.block {}
 div.paragraph {}
 .font0 { font:6pt Arial, sans-serif; }
 .font1 { font:7pt Arial, sans-serif; }
 .font2 { font:8pt Arial, sans-serif; }
 .font3 { font:10pt Arial, sans-serif; }
 .font4 { font:16pt Arial, sans-serif; }
 .font5 { font:48pt Arial, sans-serif; }
 .font6 { font:10pt Book Antiqua, serif; }
 .font7 { font:12pt Century Schoolbook, serif; }
 .font8 { font:7pt Courier New, monospace; }
 .font9 { font:8pt Garamond, serif; }
 .font10 { font:13pt Garamond, serif; }
 .font11 { font:8pt Lucida Sans Unicode, sans-serif; }
 .font12 { font:5pt Times New Roman, serif; }
 .font13 { font:6pt Times New Roman, serif; }
 .font14 { font:7pt Times New Roman, serif; }
 .font15 { font:8pt Times New Roman, serif; }
 .font16 { font:9pt Times New Roman, serif; }
 .font17 { font:10pt Times New Roman, serif; }
 .font18 { font:11pt Times New Roman, serif; }
 .font19 { font:12pt Times New Roman, serif; }
 .font20 { font:13pt Times New Roman, serif; }
 .font21 { font:14pt Times New Roman, serif; }
 .font22 { font:15pt Times New Roman, serif; }
 .font23 { font:16pt Times New Roman, serif; }
 .font24 { font:18pt Times New Roman, serif; }
 .font25 { font:19pt Times New Roman, serif; }
 .font26 { font:23pt Times New Roman, serif; }
 .font27 { font:24pt Times New Roman, serif; }
 .font28 { font:32pt Times New Roman, serif; }
 .font29 { font:40pt Times New Roman, serif; }
 .font30 { font:63pt Times New Roman, serif; }
 .font31 { font:90pt Times New Roman, serif; }

</style>
</head>
<body>
<p><span class="font6" style="font-weight:bold;font-style:italic;">Praise for</span><span class="font6" style="font-weight:bold;"> Higher-Order Perl. . .</span></p>
<p><span class="font16" style="font-style:italic;">As a programmer, your bookshelf is probably overflowing with books that did nothing to change the way you program... or think about programming.</span></p>
<p><span class="font16" style="font-style:italic;">You’re going to need a completely different shelf for this book.</span></p>
<p><span class="font16" style="font-style:italic;">While discussing caching techniques in Chapter 3, Mark Jason Dominus points out how a large enough increase in power can change the fundamental way you think about a technology. And that’s precisely what this entire book does for Perl.</span></p>
<p><span class="font16" style="font-style:italic;">It raids the deepest vaults and highest towers of Computer Science, and transforms the many arcane treasures it finds—recursion, iterators, filters, memoization, partitioning, numerical methods, higher-order functions, currying, cutsorting, grammar-based parsing, lazy evaluation, and constraint programming—into powerful and practical tools for real-world programming tasks: file system interactions, HTML processing, database access, web spidering, typesetting, mail processing, home finance, text outlining, and diagram generation.</span></p>
<p><span class="font16" style="font-style:italic;">Along the way it also scatters smaller (but equally invaluable) gems, like the elegant explanation of the difference between “scope” and “duration” in Chapter 3, or the careful exploration of how best to return error flags in Chapter 4. It even has practical tips for Perl evangelists.</span></p>
<p><span class="font16" style="font-style:italic;">Dominuspresents even the most complex ideas in simple, comprehensible ways, but never compromises on the precision and attention to detail for which he is so widely and justly admired.</span></p>
<p><span class="font16" style="font-style:italic;">His writing is—as always—lucid, eloquent, witty, and compelling.</span></p>
<p><span class="font16" style="font-style:italic;">Aptly named, this truly /is/ a Perl book of a higher order, and essential reading for every serious Perl programmer.</span></p>
<p><span class="font16">—Damian Conway, Co-designer of Perl 6</span></p>
<p><span class="font22">HIGHER-ORDER PERL</span></p><a name="caption1"></a>
<h2><a name="bookmark0"></a><span class="font27">HIGHER-ORDER PERL</span></h2>
<p><span class="font20">TRANSFORMING PROGRAMS WITH PROGRAMS</span></p>
<p><span class="font10" style="font-weight:bold;">Mark Jason Dominus</span></p>
<div><img src="HigherOrderPerl_files/HigherOrderPerl-1.png" alt="" style="width:50pt;height:44pt;">
</div><br clear="all">
<div>
<p><span class="font17" style="font-weight:bold;">ELSEVIER</span></p>
</div><br clear="all">
<p><span class="font15">AMSTERDAM • BOSTON • HEIDELBERG • LONDON NEW YORK • OXFORD • PARIS • SAN DIEGO SAN FRANCISCO • SINGAPORE • SYDNEY • TOKYO</span></p>
<p><span class="font15">Morgan Kaufmann Publishers is an imprint of Elsevier</span></p>
<div>
<p><span class="font15">Senior Editor</span></p>
<p><span class="font15">Publishing Services Manager Assistant Editor</span></p>
<p><span class="font15">Cover Design</span></p>
<p><span class="font15">Cover Illustration</span></p>
<p><span class="font15">Composition</span></p>
<p><span class="font15">Technical Illustration</span></p>
<p><span class="font15">Copyeditor</span></p>
<p><span class="font15">Proofreader Interior Printer Cover Printer</span></p>
</div><br clear="all">
<p><span class="font15">Tim Cox</span></p>
<p><span class="font15">Simon Crump</span></p>
<p><span class="font15">Richard Camp</span></p>
<p><span class="font15">Yvo Riezebos Design</span></p>
<p><span class="font15">Yvo Riezebos Design</span></p>
<p><span class="font15">Cepha Imaging Pvt. Ltd.</span></p>
<p><span class="font15">Dartmouth Publishing, Inc.</span></p>
<p><span class="font15">Eileen Kramer</span></p>
<p><span class="font15">Deborah Prato</span></p>
<p><span class="font15">The Maple-Vail Book Manufacturing Group Phoenix Color</span></p>
<p><span class="font15">Morgan Kaufmann Publishers is an imprint of Elsevier. 500 Sansome Street, Suite 400, San Francisco, CA 94111</span></p>
<p><span class="font15">This book is printed on acid-free paper.</span></p>
<p><span class="font15">© 2005 by Elsevier Inc. All rights reserved.</span></p>
<p><span class="font15">Designations used by companies to distinguish their products are often claimed as trademarks or registered trademarks. In all instances in which Morgan Kaufmann Publishers is aware of a claim, the product names appear in initial capital or all capital letters. Readers, however, should contact the appropriate companies for more complete information regarding trademarks and registration.</span></p>
<p><span class="font15">No part of this publication may be reproduced, stored in a retrieval system, or transmitted in any form or by any means—electronic, mechanical, photocopying, scanning, or otherwise—without prior written permission of the publisher.</span></p>
<p><span class="font15">Permissions may be sought directly from Elsevier’s Science &amp;&nbsp;Technology Rights Department in Oxford, UK: phone: (+44) 1865 843830, fax: (+44) 1865 853333, e-mail: </span><a href="mailto:permissions@elsevier.com.uk"><span class="font15" style="font-style:italic;">permissions@elsevier.com.uk</span></a><span class="font15" style="font-style:italic;">.</span><span class="font15"> You may also complete your request on-line via the Elsevier homepage </span><span class="font15" style="font-style:italic;">(</span><a href="http://elsevier.com"><span class="font15" style="font-style:italic;">http://elsevier.com</span></a><span class="font15" style="font-style:italic;">)</span><span class="font15"> by selecting “Customer Support” and then “Obtaining Permissions.”</span></p>
<p><span class="font15" style="font-weight:bold;">Library of Congress Cataloging-in-Publication Data Application submitted</span></p>
<p><span class="font15">ISBN: 1-55860-701-3</span></p>
<p><span class="font15">For information on all Morgan Kaufmann publications, visit our Web site at </span><a href="http://www.mkp.com"><span class="font15">www.mkp.com</span></a><span class="font15"> or </span><a href="http://www.books.elsevier.com"><span class="font15">www.books.elsevier.com</span></a></p>
<p><span class="font15">Printed in the United States of America</span></p>
<p><span class="font15">05 06 07 08 09 &nbsp;&nbsp;&nbsp;5 4 3 2 &nbsp;1</span></p>
<p><span class="font21">Working together to grow libraries in developing countries </span><a href="http://www.elsevier.com"><span class="font16">www.elsevier.com</span></a><span class="font16"> | </span><a href="http://www.bookaid.org"><span class="font16">www.bookaid.org</span></a><span class="font16"> | </span><a href="http://www.sabre.org"><span class="font16">www.sabre.org</span></a></p>
<p><span class="font18">ELSEVIER &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sabre Foundation</span></p>
<p><span class="font7" style="font-style:italic;">For Lorrie</span></p>
<h3><a name="bookmark1"></a><span class="font25">CONTENTS</span></h3>
<p><a href="#bookmark2"><span class="font18">Preface</span></a></p>
<p><a href="#bookmark3"><span class="font15" style="font-variant:small-caps;">chapter</span><span class="font15"> i &nbsp;</span><span class="font18">Recursion and Callbacks</span></a></p>
<ul style="list-style:none;"><li>
<p><a href="#bookmark4"><span class="font15">1.1 </span><span class="font15" style="font-variant:small-caps;">decimal to binary conversion</span><span class="font15"></span></a></p></li></ul>
<ul style="list-style:none;"><li>
<p><a href="#bookmark5"><span class="font15">1.2 </span><span class="font15" style="font-variant:small-caps;">factorial</span><span class="font15"></span></a></p></li></ul>
<ul style="list-style:none;"><li>
<p><a href="#bookmark6"><span class="font15">1.2.1 Why Private Variables Are Important</span></a></p></li></ul>
<ul style="list-style:none;"><li>
<p><a href="#bookmark7"><span class="font15">1.3 </span><span class="font15" style="font-variant:small-caps;">the tower of</span><span class="font15"> HANOI</span></a></p></li></ul>
<ul style="list-style:none;"><li>
<p><a href="#bookmark8"><span class="font15">1.4 </span><span class="font15" style="font-variant:small-caps;">hierarchical data</span><span class="font15"></span></a></p></li></ul>
<ul style="list-style:none;"><li>
<p><a href="#bookmark9"><span class="font15">1.5 </span><span class="font15" style="font-variant:small-caps;">applications and variations of directory walking</span><span class="font15"></span></a></p></li></ul>
<ul style="list-style:none;"><li>
<p><a href="#bookmark10"><span class="font15">1.6 </span><span class="font15" style="font-variant:small-caps;">functional versus object-oriented programming</span><span class="font15"></span></a></p></li></ul>
<ul style="list-style:none;"><li>
<p><a href="#bookmark11"><span class="font15">1.7 HTML</span></a></p></li></ul>
<ul style="list-style:none;"><li>
<p><a href="#bookmark12"><span class="font15">1.7.1 More Flexible Selection</span></a></p></li></ul>
<ul style="list-style:none;"><li>
<p><a href="#bookmark13"><span class="font15">1.8 </span><span class="font15" style="font-variant:small-caps;">when recursion blows up</span><span class="font15"></span></a></p></li></ul>
<ul style="list-style:none;"><li>
<p><a href="#bookmark14"><span class="font15">1.8.1 Fibonacci Numbers</span></a></p></li></ul>
<ul style="list-style:none;"><li>
<p><a href="#bookmark15"><span class="font15">1.8.2 Partitioning</span></a></p></li></ul>
<p><a href="#bookmark16"><span class="font15" style="font-variant:small-caps;">chapter</span><span class="font15"> 2 &nbsp;</span><span class="font18">Dispatch Tables</span></a></p>
<ul style="list-style:none;"><li>
<p><a href="#bookmark17"><span class="font15">2.1 </span><span class="font15" style="font-variant:small-caps;">configuration file handling</span><span class="font15"></span></a></p></li></ul>
<ul style="list-style:none;"><li>
<p><a href="#bookmark18"><span class="font15">2.1.1 Table-Driven Configuration</span></a></p></li></ul>
<ul style="list-style:none;"><li>
<p><a href="#bookmark19"><span class="font15">2.1.2 Advantages of Dispatch Tables</span></a></p></li></ul>
<ul style="list-style:none;"><li>
<p><a href="#bookmark20"><span class="font15">2.1.3 Dispatch Table Strategies</span></a></p></li></ul>
<ul style="list-style:none;"><li>
<p><a href="#bookmark21"><span class="font15">2.1.4 Default Actions</span></a></p></li></ul>
<ul style="list-style:none;"><li>
<p><a href="#bookmark22"><span class="font15">2.2 </span><span class="font15" style="font-variant:small-caps;">calculator</span><span class="font15"></span></a></p></li></ul>
<ul style="list-style:none;"><li>
<p><a href="#bookmark23"><span class="font15">2.2.1 HTML Processing Revisited</span></a></p></li></ul>
<p><a href="#bookmark24"><span class="font15" style="font-variant:small-caps;">chapter</span><span class="font15"> 3 &nbsp;</span><span class="font18">Caching and Memoization</span></a></p>
<ul style="list-style:none;"><li>
<p><a href="#bookmark25"><span class="font15">3.1 &nbsp;</span><span class="font15" style="font-variant:small-caps;">caching fixes recursion</span><span class="font15"></span></a></p></li></ul>
<ul style="list-style:none;"><li>
<p><a href="#bookmark26"><span class="font15">3.2 INLINE </span><span class="font15" style="font-variant:small-caps;">caching</span><span class="font15"></span></a></p></li></ul>
<ul style="list-style:none;"><li>
<p><a href="#bookmark27"><span class="font15">3.2.1 &nbsp;Static Variables</span></a></p></li></ul>
<ul style="list-style:none;"><li>
<p><a href="#bookmark28"><span class="font15">3.3 </span><span class="font15" style="font-variant:small-caps;">good ideas</span><span class="font15"></span></a></p></li></ul>
<ul style="list-style:none;"><li>
<p><a href="#bookmark29"><span class="font15">3.4 MEMOIZATION</span></a></p></li></ul>
<p><span class="font18">ix</span></p>
<ul style="list-style:none;"><li>
<p><a href="#bookmark30"><span class="font15">3.5 THE MEMOIZE MODULE</span></a></p></li></ul>
<ul style="list-style:none;"><li>
<p><a href="#bookmark31"><span class="font15">3.5.1 Scope and Duration</span></a></p></li></ul>
<p><a href="#bookmark32"><span class="font15">Scope</span></a></p>
<p><a href="#bookmark33"><span class="font15">Duration</span></a></p>
<ul style="list-style:none;"><li>
<p><a href="#bookmark34"><span class="font15">3.5.2 Lexical Closure</span></a></p></li></ul>
<ul style="list-style:none;"><li>
<p><a href="#bookmark35"><span class="font15">3.5.3 Memoization Again</span></a></p></li></ul>
<ul style="list-style:none;"><li>
<p><a href="#bookmark36"><span class="font15">3.6 </span><span class="font15" style="font-variant:small-caps;">caveats</span><span class="font15"></span></a></p></li></ul>
<ul style="list-style:none;"><li>
<p><span class="font15">3.6.1 Functions Whose Return Values Do Not Depend on Their</span></p></li></ul>
<p><a href="#bookmark37"><span class="font15">Arguments</span></a></p>
<ul style="list-style:none;"><li>
<p><a href="#bookmark38"><span class="font15">3.6.2 Functions with Side Effects</span></a></p></li></ul>
<ul style="list-style:none;"><li>
<p><a href="#bookmark39"><span class="font15">3.6.3 Functions That Return References</span></a></p></li></ul>
<ul style="list-style:none;"><li>
<p><a href="#bookmark40"><span class="font15">3.6.4 A Memoized Clock?</span></a></p></li></ul>
<ul style="list-style:none;"><li>
<p><a href="#bookmark41"><span class="font15">3.6.5 Very Fast Functions</span></a></p></li></ul>
<ul style="list-style:none;"><li>
<p><a href="#bookmark42"><span class="font15">3.7 </span><span class="font15" style="font-variant:small-caps;">key generation</span><span class="font15"></span></a></p></li></ul>
<ul style="list-style:none;"><li>
<p><span class="font15">3.7.1 More Applications of User-Supplied Key</span></p></li></ul>
<p><a href="#bookmark43"><span class="font15">Generators</span></a></p>
<ul style="list-style:none;"><li>
<p><a href="#bookmark44"><span class="font15">3.7.2 Inlined Cache Manager with Argument Normalizer</span></a></p></li></ul>
<ul style="list-style:none;"><li>
<p><a href="#bookmark45"><span class="font15">3.7.3 Functions with Reference Arguments</span></a></p></li></ul>
<ul style="list-style:none;"><li>
<p><a href="#bookmark46"><span class="font15">3.7.4 Partitioning</span></a></p></li></ul>
<ul style="list-style:none;"><li>
<p><a href="#bookmark47"><span class="font15">3.7.5 Custom Key Generation for Impure Functions</span></a></p></li></ul>
<ul style="list-style:none;"><li>
<p><a href="#bookmark48"><span class="font15">3.8 </span><span class="font15" style="font-variant:small-caps;">caching in object methods</span><span class="font15"></span></a></p></li></ul>
<ul style="list-style:none;"><li>
<p><a href="#bookmark49"><span class="font15">3.8.1 Memoization of Object Methods</span></a></p></li></ul>
<ul style="list-style:none;"><li>
<p><a href="#bookmark50"><span class="font15">3.9 </span><span class="font15" style="font-variant:small-caps;">persistent caches</span><span class="font15"></span></a></p></li></ul>
<ul style="list-style:none;"><li>
<p><a href="#bookmark51"><span class="font15">3.10 </span><span class="font15" style="font-variant:small-caps;">alternatives to memoization</span><span class="font15"></span></a></p></li></ul>
<ul style="list-style:none;"><li>
<p><a href="#bookmark52"><span class="font15">3.11 </span><span class="font15" style="font-variant:small-caps;">evangelism</span><span class="font15"></span></a></p></li></ul>
<ul style="list-style:none;"><li>
<p><a href="#bookmark53"><span class="font15">3.12 THE </span><span class="font15" style="font-variant:small-caps;">benefits of speed</span><span class="font15"></span></a></p></li></ul>
<ul style="list-style:none;"><li>
<p><a href="#bookmark54"><span class="font15">3.12.1 Profiling and Performance Analysis</span></a></p></li></ul>
<ul style="list-style:none;"><li>
<p><a href="#bookmark55"><span class="font15">3.12.2 Automatic Profiling</span></a></p></li></ul>
<ul style="list-style:none;"><li>
<p><a href="#bookmark56"><span class="font15">3.12.3 Hooks</span></a></p></li></ul>
<p><a href="#bookmark57"><span class="font15" style="font-variant:small-caps;">chapter</span><span class="font15"> 4 </span><span class="font18">Iterators</span></a></p>
<ul style="list-style:none;"><li>
<p><a href="#bookmark58"><span class="font15">4.1 </span><span class="font15" style="font-variant:small-caps;">introduction</span><span class="font15"></span></a></p></li></ul>
<ul style="list-style:none;"><li>
<p><a href="#bookmark59"><span class="font15">4.1.1 &nbsp;Filehandles Are Iterators</span></a></p></li></ul>
<ul style="list-style:none;"><li>
<p><a href="#bookmark60"><span class="font15">4.1.2 Iterators Are Objects</span></a></p></li></ul>
<ul style="list-style:none;"><li>
<p><a href="#bookmark61"><span class="font15">4.1.3 Other Common Examples of Iterators</span></a></p></li></ul>
<ul style="list-style:none;"><li>
<p><a href="#bookmark62"><span class="font15">4.2 </span><span class="font15" style="font-variant:small-caps;">homemade iterators</span><span class="font15"></span></a></p></li></ul>
<ul style="list-style:none;"><li>
<p><a href="#bookmark63"><span class="font15">4.2.1 A Trivial Iterator: </span><span class="font2">upto()</span></a></p></li></ul>
<p><a href="#bookmark64"><span class="font15">Syntactic Sugar for Manufacturing Iterators</span></a></p>
<ul style="list-style:none;"><li>
<p><a href="#bookmark65"><span class="font15">4.2.2 </span><span class="font2">dir_walk()</span></a></p></li></ul>
<ul style="list-style:none;"><li>
<p><a href="#bookmark66"><span class="font15">4.2.3 On Clever Inspirations</span></a></p></li></ul>
<ul style="list-style:none;"><li>
<p><a href="#bookmark67"><span class="font15">4.3 EXAMPLES</span></a></p></li></ul>
<ul style="list-style:none;"><li>
<p><a href="#bookmark68"><span class="font15">4.3.1 &nbsp;Permutations</span></a></p></li></ul>
<ul style="list-style:none;"><li>
<p><a href="#bookmark69"><span class="font15">4.3.2 Genomic Sequence Generator</span></a></p></li></ul>
<ul style="list-style:none;"><li>
<p><a href="#bookmark70"><span class="font15">4.3.3 Filehandle Iterators</span></a></p></li></ul>
<ul style="list-style:none;"><li>
<p><a href="#bookmark71"><span class="font15">4.3.4 A Flat-File Database</span></a></p></li></ul>
<p><a href="#bookmark72"><span class="font15">Improved Database</span></a></p>
<ul style="list-style:none;"><li>
<p><a href="#bookmark73"><span class="font15">4.3.5 Searching Databases Backwards</span></a></p></li></ul>
<p><a href="#bookmark74"><span class="font15">A Query Package That Transforms Iterators</span></a></p>
<p><a href="#bookmark75"><span class="font15">An Iterator That Reads Files Backwards</span></a></p>
<p><a href="#bookmark76"><span class="font15">Putting It Together</span></a></p>
<ul style="list-style:none;"><li>
<p><a href="#bookmark77"><span class="font15">4.3.6 Random Number Generation</span></a></p></li></ul>
<ul style="list-style:none;"><li>
<p><a href="#bookmark78"><span class="font15">4.4 FILTERS AND TRANSFORMS</span></a></p></li></ul>
<ul style="list-style:none;"><li>
<p><a href="#bookmark79"><span class="font15">4.4.1 </span><span class="font2">imap()</span></a></p></li></ul>
<ul style="list-style:none;"><li>
<p><a href="#bookmark80"><span class="font15">4.4.2 </span><span class="font2">igrep()</span></a></p></li></ul>
<ul style="list-style:none;"><li>
<p><a href="#bookmark81"><span class="font15">4.4.3 </span><span class="font2">list_iterator()</span></a></p></li></ul>
<ul style="list-style:none;"><li>
<p><a href="#bookmark82"><span class="font15">4.4.4 </span><span class="font2">append()</span></a></p></li></ul>
<ul style="list-style:none;"><li>
<p><a href="#bookmark83"><span class="font15">4.5 THE SEMIPREDICATE PROBLEM</span></a></p></li></ul>
<ul style="list-style:none;"><li>
<p><a href="#bookmark84"><span class="font15">4.5.1 Avoiding the Problem</span></a></p></li></ul>
<ul style="list-style:none;"><li>
<p><a href="#bookmark85"><span class="font15">4.5.2 Alternative </span><span class="font2">undef</span><span class="font15">s</span></a></p></li></ul>
<ul style="list-style:none;"><li>
<p><a href="#bookmark86"><span class="font15">4.5.3 Rewriting Utilities</span></a></p></li></ul>
<ul style="list-style:none;"><li>
<p><a href="#bookmark87"><span class="font15">4.5.4 Iterators That Return Multiple Values</span></a></p></li></ul>
<ul style="list-style:none;"><li>
<p><a href="#bookmark88"><span class="font15">4.5.5 Explicit Exhaustion Function</span></a></p></li></ul>
<ul style="list-style:none;"><li>
<p><a href="#bookmark89"><span class="font15">4.5.6 Four-Operation Iterators</span></a></p></li></ul>
<ul style="list-style:none;"><li>
<p><a href="#bookmark90"><span class="font15">4.5.7 Iterator Methods</span></a></p></li></ul>
<ul style="list-style:none;"><li>
<p><a href="#bookmark91"><span class="font15">4.6 ALTERNATIVE INTERFACES TO ITERATORS</span></a></p></li></ul>
<ul style="list-style:none;"><li>
<p><a href="#bookmark92"><span class="font15">4.6.1 Using </span><span class="font2">foreach </span><span class="font15">to Loop Over More Than One Array</span></a></p></li></ul>
<ul style="list-style:none;"><li>
<p><a href="#bookmark93"><span class="font15">4.6.2 An Iterator with an </span><span class="font2">each</span><span class="font15">-Like Interface</span></a></p></li></ul>
<ul style="list-style:none;"><li>
<p><a href="#bookmark94"><span class="font15">4.6.3 Tied Variable Interfaces</span></a></p></li></ul>
<p><a href="#bookmark95"><span class="font15">Summary of </span><span class="font2">tie</span></a></p>
<p><a href="#bookmark96"><span class="font15">Tied Scalars</span></a></p>
<p><a href="#bookmark97"><span class="font15">Tied Filehandles</span></a></p>
<ul style="list-style:none;"><li>
<p><a href="#bookmark98"><span class="font15">4.7 AN EXTENDED EXAMPLE: WEB SPIDERS</span></a></p></li></ul>
<ul style="list-style:none;"><li>
<p><a href="#bookmark99"><span class="font15">4.7.1 &nbsp;Pursuing Only Interesting Links</span></a></p></li></ul>
<ul style="list-style:none;"><li>
<p><a href="#bookmark100"><span class="font15">4.7.2 Referring URLs</span></a></p></li></ul>
<ul style="list-style:none;"><li>
<p><a href="#bookmark101"><span class="font15">4.7.3 </span><span class="font2">robots.txt</span></a></p></li></ul>
<ul style="list-style:none;"><li>
<p><a href="#bookmark102"><span class="font15">4.7.4 Summary</span></a></p></li></ul>
<p><a href="#bookmark103"><span class="font15" style="font-variant:small-caps;">chapter</span><span class="font15"> 5 </span><span class="font18">From Recursion to Iterators</span></a></p>
<ul style="list-style:none;"><li>
<p class="font15"><a href="#bookmark104">5.1 THE PARTITION PROBLEM REVISITED</a></p></li></ul>
<ul style="list-style:none;"><li>
<p class="font15"><a href="#bookmark105">5.1.1 Finding All Possible Partitions</a></p></li></ul>
<p><span class="font20">xii </span><span class="font15">CONTENTS</span></p>
<ul style="list-style:none;"><li>
<p><a href="#bookmark106"><span class="font15">5.1.2 Optimizations</span></a></p></li></ul>
<ul style="list-style:none;"><li>
<p><a href="#bookmark107"><span class="font15">5.1.3 Variations</span></a></p></li></ul>
<ul style="list-style:none;"><li>
<p><a href="#bookmark108"><span class="font15">5.2 HOW TO CONVERT A RECURSIVE FUNCTION TO AN ITERATOR</span></a></p></li></ul>
<ul style="list-style:none;"><li>
<p><a href="#bookmark109"><span class="font15">5.3 A GENERIC SEARCH ITERATOR</span></a></p></li></ul>
<ul style="list-style:none;"><li>
<p><a href="#bookmark110"><span class="font15">5.4 OTHER GENERAL TECHNIQUES FOR ELIMINATING RECURSION</span></a></p></li></ul>
<ul style="list-style:none;"><li>
<p><a href="#bookmark111"><span class="font15">5.4.1 Tail-Call Elimination</span></a></p></li></ul>
<p><a href="#bookmark112"><span class="font15">Someone Else’s Problem</span></a></p>
<ul style="list-style:none;"><li>
<p><a href="#bookmark113"><span class="font15">5.4.2 Creating Tail Calls</span></a></p></li></ul>
<ul style="list-style:none;"><li>
<p><a href="#bookmark114"><span class="font15">5.4.3 Explicit Stacks</span></a></p></li></ul>
<p><a href="#bookmark115"><span class="font15">Eliminating Recursion From </span><span class="font2">fib()</span></a></p>
<p><a href="#bookmark116"><span class="font15" style="font-variant:small-caps;">chapter</span><span class="font15"> 6 </span><span class="font18">Infinite Streams</span></a></p>
<ul style="list-style:none;"><li>
<p><a href="#bookmark117"><span class="font15">6.1 &nbsp;LINKED LISTS</span></a></p></li></ul>
<ul style="list-style:none;"><li>
<p><a href="#bookmark118"><span class="font15">6.2 LAZY LINKED LISTS</span></a></p></li></ul>
<ul style="list-style:none;"><li>
<p><a href="#bookmark119"><span class="font15">6.2.1 A Trivial Stream: </span><span class="font1">upto()</span></a></p></li></ul>
<ul style="list-style:none;"><li>
<p><a href="#bookmark120"><span class="font15">6.2.2 Utilities for Streams</span></a></p></li></ul>
<ul style="list-style:none;"><li>
<p><a href="#bookmark121"><span class="font15">6.3 RECURSIVE STREAMS</span></a></p></li></ul>
<ul style="list-style:none;"><li>
<p><a href="#bookmark122"><span class="font15">6.3.1 Memoizing Streams</span></a></p></li></ul>
<ul style="list-style:none;"><li>
<p><a href="#bookmark123"><span class="font15">6.4 THE HAMMING PROBLEM</span></a></p></li></ul>
<ul style="list-style:none;"><li>
<p><a href="#bookmark124"><span class="font15">6.5 REGEX STRING GENERATION</span></a></p></li></ul>
<ul style="list-style:none;"><li>
<p><a href="#bookmark125"><span class="font15">6.5.1 Generating Strings in Order</span></a></p></li></ul>
<ul style="list-style:none;"><li>
<p><a href="#bookmark126"><span class="font15">6.5.2 Regex Matching</span></a></p></li></ul>
<ul style="list-style:none;"><li>
<p><a href="#bookmark127"><span class="font15">6.5.3 Cutsorting</span></a></p></li></ul>
<p><a href="#bookmark128"><span class="font15">Log Files</span></a></p>
<ul style="list-style:none;"><li>
<p><a href="#bookmark129"><span class="font15">6.6 THE NEWTON-RAPHSON METHOD</span></a></p></li></ul>
<ul style="list-style:none;"><li>
<p><a href="#bookmark130"><span class="font15">6.6.1 Approximation Streams</span></a></p></li></ul>
<ul style="list-style:none;"><li>
<p><a href="#bookmark131"><span class="font15">6.6.2 Derivatives</span></a></p></li></ul>
<ul style="list-style:none;"><li>
<p><a href="#bookmark132"><span class="font15">6.6.3 The Tortoise and the Hare</span></a></p></li></ul>
<ul style="list-style:none;"><li>
<p><a href="#bookmark133"><span class="font15">6.6.4 Finance</span></a></p></li></ul>
<ul style="list-style:none;"><li>
<p><a href="#bookmark134"><span class="font15">6.7 </span><span class="font15" style="font-variant:small-caps;">power series</span><span class="font15"></span></a></p></li></ul>
<ul style="list-style:none;"><li>
<p><a href="#bookmark135"><span class="font15">6.7.1 Derivatives</span></a></p></li></ul>
<ul style="list-style:none;"><li>
<p><a href="#bookmark136"><span class="font15">6.7.2 Other Functions</span></a></p></li></ul>
<ul style="list-style:none;"><li>
<p><a href="#bookmark137"><span class="font15">6.7.3 Symbolic Computation</span></a></p></li></ul>
<p><a href="#bookmark138"><span class="font15" style="font-variant:small-caps;">chapter</span><span class="font15"> 7 </span><span class="font18">Higher-Order Functions and Currying</span></a></p>
<ul style="list-style:none;"><li>
<p><a href="#bookmark139"><span class="font15">7.1 CURRYING</span></a></p></li></ul>
<ul style="list-style:none;"><li>
<p><a href="#bookmark140"><span class="font15">7.2 COMMON HIGHER-ORDER FUNCTIONS</span></a></p></li></ul>
<ul style="list-style:none;"><li>
<p><a href="#bookmark141"><span class="font15">7.2.1 Automatic Currying</span></a></p></li></ul>
<ul style="list-style:none;"><li>
<p><a href="#bookmark142"><span class="font15">7.2.2 Prototypes</span></a></p></li></ul>
<p><a href="#bookmark143"><span class="font15">Prototype Problems</span></a></p>
<ul style="list-style:none;"><li>
<p><a href="#bookmark144"><span class="font15">7.2.3 More Currying</span></a></p></li></ul>
<ul style="list-style:none;"><li>
<p><a href="#bookmark145"><span class="font15">7.2.4 Yet More Currying</span></a></p></li></ul>
<ul style="list-style:none;"><li>
<p><a href="#bookmark146"><span class="font15">7.3 </span><span class="font2">reduce() </span><span class="font15" style="font-variant:small-caps;">and</span><span class="font2"> combine()</span></a></p></li></ul>
<ul style="list-style:none;"><li>
<p><a href="#bookmark147"><span class="font15">7.3.1 Boolean Operators</span></a></p></li></ul>
<ul style="list-style:none;"><li>
<p><a href="#bookmark148"><span class="font15">7.4 </span><span class="font15" style="font-variant:small-caps;">databases</span><span class="font15"></span></a></p></li></ul>
<ul style="list-style:none;"><li>
<p><a href="#bookmark149"><span class="font15">7.4.1 Operator Overloading</span></a></p></li></ul>
<p><a href="#bookmark150"><span class="font15" style="font-variant:small-caps;">chapter</span><span class="font15"> 8 </span><span class="font18">Parsing</span></a></p>
<ul style="list-style:none;"><li>
<p><a href="#bookmark151"><span class="font15">8.1 &nbsp;</span><span class="font15" style="font-variant:small-caps;">lexers</span><span class="font15"></span></a></p></li></ul>
<ul style="list-style:none;"><li>
<p><a href="#bookmark152"><span class="font15">8.1.1 Emulating the </span><span class="font18">&lt;&gt;&nbsp;</span><span class="font15">Operator</span></a></p></li></ul>
<ul style="list-style:none;"><li>
<p><a href="#bookmark153"><span class="font15">8.1.2 Lexers More Generally</span></a></p></li></ul>
<ul style="list-style:none;"><li>
<p><a href="#bookmark154"><span class="font15">8.1.3 Chained Lexers</span></a></p></li></ul>
<ul style="list-style:none;"><li>
<p><a href="#bookmark155"><span class="font15">8.1.4 Peeking</span></a></p></li></ul>
<ul style="list-style:none;"><li>
<p><a href="#bookmark156"><span class="font15">8.2 </span><span class="font15" style="font-variant:small-caps;">parsing in general</span><span class="font15"></span></a></p></li></ul>
<ul style="list-style:none;"><li>
<p><a href="#bookmark157"><span class="font15">8.2.1 Grammars</span></a></p></li></ul>
<ul style="list-style:none;"><li>
<p><a href="#bookmark158"><span class="font15">8.2.2 Parsing Grammars</span></a></p></li></ul>
<ul style="list-style:none;"><li>
<p><a href="#bookmark159"><span class="font15">8.3 </span><span class="font15" style="font-variant:small-caps;">recursive-descent parsers</span><span class="font15"></span></a></p></li></ul>
<ul style="list-style:none;"><li>
<p><a href="#bookmark160"><span class="font15">8.3.1 Very Simple Parsers</span></a></p></li></ul>
<ul style="list-style:none;"><li>
<p><a href="#bookmark161"><span class="font15">8.3.2 Parser Operators</span></a></p></li></ul>
<ul style="list-style:none;"><li>
<p><a href="#bookmark162"><span class="font15">8.3.3 Compound Operators</span></a></p></li></ul>
<ul style="list-style:none;"><li>
<p><a href="#bookmark163"><span class="font15">8.4 </span><span class="font15" style="font-variant:small-caps;">arithmetic expressions</span><span class="font15"></span></a></p></li></ul>
<ul style="list-style:none;"><li>
<p><a href="#bookmark164"><span class="font15">8.4.1 A Calculator</span></a></p></li></ul>
<ul style="list-style:none;"><li>
<p><a href="#bookmark165"><span class="font15">8.4.2 Left Recursion</span></a></p></li></ul>
<ul style="list-style:none;"><li>
<p><a href="#bookmark166"><span class="font15">8.4.3 A Variation on </span><span class="font2">star()</span></a></p></li></ul>
<ul style="list-style:none;"><li>
<p><a href="#bookmark167"><span class="font15">8.4.4 Generic-Operator Parsers</span></a></p></li></ul>
<ul style="list-style:none;"><li>
<p><a href="#bookmark168"><span class="font15">8.4.5 Debugging</span></a></p></li></ul>
<ul style="list-style:none;"><li>
<p><a href="#bookmark169"><span class="font15">8.4.6 The Finished Calculator</span></a></p></li></ul>
<ul style="list-style:none;"><li>
<p><a href="#bookmark170"><span class="font15">8.4.7 Error Diagnosis and Recovery</span></a></p></li></ul>
<p><a href="#bookmark171"><span class="font15">Error-Recovery Parsers</span></a></p>
<p><a href="#bookmark172"><span class="font15">Exceptions</span></a></p>
<ul style="list-style:none;"><li>
<p><a href="#bookmark173"><span class="font15">8.4.8 Big Numbers</span></a></p></li></ul>
<ul style="list-style:none;"><li>
<p><a href="#bookmark174"><span class="font15">8.5 </span><span class="font15" style="font-variant:small-caps;">parsing regexes</span><span class="font15"></span></a></p></li></ul>
<ul style="list-style:none;"><li>
<p><a href="#bookmark175"><span class="font15">8.6 </span><span class="font15" style="font-variant:small-caps;">outlines</span><span class="font15"></span></a></p></li></ul>
<ul style="list-style:none;"><li>
<p><a href="#bookmark176"><span class="font15">8.7 </span><span class="font15" style="font-variant:small-caps;">database-query parsing</span><span class="font15"></span></a></p></li></ul>
<ul style="list-style:none;"><li>
<p><a href="#bookmark177"><span class="font15">8.7.1 The Lexer</span></a></p></li></ul>
<ul style="list-style:none;"><li>
<p><a href="#bookmark178"><span class="font15">8.7.2 The Parser</span></a></p></li></ul>
<ul style="list-style:none;"><li>
<p><a href="#bookmark179"><span class="font15">8.8 </span><span class="font15" style="font-variant:small-caps;">backtracking parsers</span><span class="font15"></span></a></p></li></ul>
<ul style="list-style:none;"><li>
<p><a href="#bookmark180"><span class="font15">8.8.1 Continuations</span></a></p></li></ul>
<ul style="list-style:none;"><li>
<p><a href="#bookmark181"><span class="font15">8.8.2 Parse Streams</span></a></p></li></ul>
<ul style="list-style:none;"><li>
<p><a href="#bookmark182"><span class="font15">8.9 </span><span class="font15" style="font-variant:small-caps;">overloading</span><span class="font15"></span></a></p></li></ul>
<p><span class="font20">XiV </span><span class="font15">CONTENTS</span></p>
<p><a href="#bookmark183"><span class="font15" style="font-variant:small-caps;">chapter</span><span class="font15"> 9 </span><span class="font18">Declarative Programming</span></a></p>
<ul style="list-style:none;"><li>
<p><a href="#bookmark184"><span class="font15">9.1 </span><span class="font15" style="font-variant:small-caps;">constraint systems</span><span class="font15"></span></a></p></li></ul>
<ul style="list-style:none;"><li>
<p><a href="#bookmark185"><span class="font15">9.2 </span><span class="font15" style="font-variant:small-caps;">local propagation networks</span><span class="font15"></span></a></p></li></ul>
<ul style="list-style:none;"><li>
<p><a href="#bookmark186"><span class="font15">9.2.1 Implementing a Local Propagation Network</span></a></p></li></ul>
<ul style="list-style:none;"><li>
<p><a href="#bookmark187"><span class="font15">9.2.2 Problems with Local Propagation</span></a></p></li></ul>
<ul style="list-style:none;"><li>
<p><a href="#bookmark188"><span class="font15">9.3 </span><span class="font15" style="font-variant:small-caps;">linear equations</span><span class="font15"></span></a></p></li></ul>
<ul style="list-style:none;"><li>
<p><a href="#bookmark189"><span class="font15">9.4 </span><span class="font2">linogram: </span><span class="font15" style="font-variant:small-caps;">a drawing system</span><span class="font15"></span></a></p></li></ul>
<ul style="list-style:none;"><li>
<p><a href="#bookmark190"><span class="font15">9.4.1 Equations</span></a></p></li></ul>
<p><a href="#bookmark191"><span class="font2">ref($base) || $base</span></a></p>
<p><a href="#bookmark192"><span class="font15">Solving Equations</span></a></p>
<p><a href="#bookmark193"><span class="font15">Constraints</span></a></p>
<ul style="list-style:none;"><li>
<p><a href="#bookmark194"><span class="font15">9.4.2 Values</span></a></p></li></ul>
<p><a href="#bookmark195"><span class="font15">Constant Values</span></a></p>
<p><a href="#bookmark196"><span class="font15">Tuple Values</span></a></p>
<p><a href="#bookmark197"><span class="font15">Feature Values</span></a></p>
<p><a href="#bookmark198"><span class="font15">Intrinsic Constraints</span></a></p>
<p><a href="#bookmark199"><span class="font15">Synthetic Constraints</span></a></p>
<p><a href="#bookmark200"><span class="font15">Feature-Value Methods</span></a></p>
<ul style="list-style:none;"><li>
<p><a href="#bookmark201"><span class="font15">9.4.3 Feature Types</span></a></p></li></ul>
<p><a href="#bookmark202"><span class="font15">Scalar Types</span></a></p>
<p><a href="#bookmark203"><span class="font2">Type </span><span class="font15">Methods</span></a></p>
<ul style="list-style:none;"><li>
<p><a href="#bookmark204"><span class="font15">9.4.4 The Parser</span></a></p></li></ul>
<p><a href="#bookmark205"><span class="font15">Parser Extensions</span></a></p>
<p><a href="#bookmark206"><span class="font2">%TYPES</span></a></p>
<p><a href="#bookmark207"><span class="font15">Programs</span></a></p>
<p><a href="#bookmark208"><span class="font15">Definitions</span></a></p>
<p><a href="#bookmark209"><span class="font15">Declarations</span></a></p>
<p><a href="#bookmark210"><span class="font15">Expressions</span></a></p>
<ul style="list-style:none;"><li>
<p><a href="#bookmark211"><span class="font15">9.4.5 Missing Features</span></a></p></li></ul>
<ul style="list-style:none;"><li>
<p><a href="#bookmark212"><span class="font15">9.5 </span><span class="font15" style="font-variant:small-caps;">conclusion</span><span class="font15"></span></a></p></li></ul>
<p><a href="#bookmark213"><span class="font18">Index</span></a></p>
<p><a href="#bookmark214"><span class="font18">Function Index</span></a></p>
<h3><a name="bookmark2"></a><span class="font25">PREFACE</span></h3>
<p><span class="font17">A well-known saying in the programming racket is that a good Fortran programmer can write Fortran programs in any language. The sad truth, though, is that Fortran programmers write Fortran programs in any language whether they mean to or not. Similarly, we, as Perl programmers, have been writing C programs in Perl whether we meant to or not. This is a shame, because Perl is a much more expressive language than C. We could be doing a lot better, using Perl in ways undreamt of by C programmers, but we’re not.</span></p>
<p><span class="font17">How did this happen? Perl was originally designed as a replacement for C on the one hand and Unix scripting languages like Bourne Shell and </span><span class="font2">awk </span><span class="font17">on the other. Perl’s first major proponents were Unix system administrators, people familiar with C and with Unix scripting languages; they naturally tended to write Perl programs that resembled C and </span><span class="font2">awk </span><span class="font17">programs. Perl’s inventor, Larry Wall, came from this sysadmin community, as did Randal Schwartz, his coauthor on </span><span class="font17" style="font-style:italic;">Programming Perl,</span><span class="font17"> the first and still the most important Perl reference work. Other important early contributors include Tom Christiansen, also a C-and-Unix expert from way back. Even when Perl programmers didn’t come from the Unix sysadmin community, they were trained by people who did, or by people who were trained by people who did.</span></p>
<p><span class="font17">Around 1993 I started reading books about Lisp, and I discovered something important: Perl is much more like Lisp than it is like C. If you pick up a good book about Lisp, there will be a section that describes Lisp’s good features. For example, the book </span><span class="font17" style="font-style:italic;">Paradigms of Artificial Intelligence Programming,</span><span class="font17"> by Peter Norvig, includes a section titled </span><span class="font17" style="font-style:italic;">What Makes Lisp Different?</span><span class="font17"> that describes seven features of Lisp. Perl shares six of these features; C shares none of them. These are big, important features, features like first-class functions, dynamic access to the symbol table, and automatic storage management. Lisp programmers have been using these features since 1957. They know a lot about how to use these language features in powerful ways. If Perl programmers can find out the things that Lisp programmers already know, they will learn a lot of things that will make their Perl programming jobs easier.</span></p>
<p><span class="font17">This is easier said than done. Hardly anyone wants to listen to Lisp programmers. Perl folks have a deep suspicion of Lisp, as demonstrated by Larry Wall’s famous remark that Lisp has all the visual appeal of oatmeal with fingernail</span></p>
<p><span class="font18">xv </span><span class="font17">clippings mixed in. Lisp programmers go around making funny noises like ‘cons’ and ‘cooder,’ and they talk about things like the PC loser-ing problem, whatever that is. They believe that Lisp is better than other programming languages, and they say so, which is irritating. But now it is all okay, because now you do not have to listen to the Lisp folks. You can listen to me instead. I will make soothing noises about hashes and stashes and globs, and talk about the familiar and comforting soft reference and variable suicide problems. Instead of telling you how wonderful Lisp is, I will tell you how wonderful Perl is, and at the end you will not have to know any Lisp, but you will know a lot more about Perl.</span></p>
<p><span class="font17">Then you can stop writing C programs in Perl. I think that you will find it to be a nice change. Perl is much better at being Perl than it is at being a slow version of C. You will be surprised at what you can get done when you write Perl programs instead of C.</span></p>
<p><span class="font17">WEB SITE</span></p>
<p><span class="font17">All the code examples in this book are available from my web site at:</span></p>
<p><a href="http://perl.plover.com/hop/"><span class="font2">http://perl.plover.com/hop/</span></a></p>
<p><span class="font17">When the notation in the margin is labeled with the tag </span><span class="font2">some-example</span><span class="font17">, the code may be downloaded from:</span></p>
<p><a href="http://perl.plover.com/hop/Examples/some-example"><span class="font2">http://perl.plover.com/hop/Examples/some-example</span></a></p>
<p><span class="font17">The web site will also carry the complete text, an errata listing, and other items of interest. Should you wish to send me email about the book, please send your message to </span><a href="mailto:mjd-hop@plover.com"><span class="font2">mjd-hop@plover.com</span></a><span class="font17">.</span></p>
<p><span class="font17">ACKNOWLEDGMENTS</span></p>
<p><span class="font17">Every acknowledgments section begins with a statement to the effect that “without the untiring support and assistance from my editor, Tim Cox, this book would certainly never have been written”. Until you write a book, you will never realize how true this is. Words fail me here; saying that the book would not have been written without Tim’s untiring support and assistance doesn’t begin to do justice to his contributions, his kindness, and his vast patience. Thank you, Tim.</span></p>
<p><span class="font17">This book was a long time in coming, and Tim went through three assistants while I was working on it. All these people were helpful and competent, so my thanks to Brenda Modliszewksi, Stacie Pierce, and Richard Camp. “Competent” may sound faint, but I consider it the highest praise.</span></p>
<p><span class="font17">Many thanks to Troy Lilly and Simon Crump, the production managers, who were not only competent but also fun to work with.</span></p>
<p><span class="font17">Shortly before the book went into production, I started writing tests for the example code. I realized with horror that hardly any of the programs worked properly. There were numerous small errors (and some not so small), inconsistencies between the code and the output, typos, and so on. Thanks to the heroic eleVenth-hour efforts of Robert Spier, I think most of these errors haVe been caught. Robert was not only unfailingly competent, helpful, and productiVe, but also unfailingly cheerful, too. If any of the example programs in this book work as they should, you can thank Robert. (If they don’t, you should blame me, not Robert.) Robert was also responsible for naming the MOD document preparation system that I used to prepare the manuscript.</span></p>
<p><span class="font17">The contributions of my wife, Lorrie Kim, are too large and perVasiVe to note indiVidually. It is to her that this book is dedicated.</span></p>
<p><span class="font17">A large number of other people contributed to this book, but many of them were not aware of it at the time. I was fortunate to haVe a series of excellent teachers, whose patience I must sometimes haVe tried terribly. Thanks to Mark Foster, Patrick X. Gallagher, Joan Livingston, Cal Lobel (who first taught me to program), Harry McLaughlin, David A. J. Meyer, Bruce Piper, Ronnie Rabassa, Michael Tempel, and Johan Tysk. Mark Foster also arrived from nowhere in the nick of time to suggest the title for this book just when I thought all was lost.</span></p>
<p><span class="font17">This book was directly inspired by two earlier books: </span><span class="font17" style="font-style:italic;">ML for the Working Programmer,</span><span class="font17"> by Lawrence Paulson, and </span><span class="font17" style="font-style:italic;">Structure and Interpretation of Computer Programs,</span><span class="font17"> by Harold Abelson and Gerald Jay Sussman. Other important influences were </span><span class="font17" style="font-style:italic;">Introduction to Functional Programming,</span><span class="font17"> by Richard Bird and Philip Wadler, and </span><span class="font17" style="font-style:italic;">Paradigms of Artificial Intelligence Programming,</span><span class="font17"> by Peter Norvig.</span></p>
<p><span class="font17">The official technical reviewers had a less rewarding job than they might have on other projects. This book took a long time to write, and although I wanted to have long conversations with the reviewers about every little thing, I was afraid that if I did that, I would never ever finish. So I rarely corresponded with the reviewers, and they probably thought that I was just filing their suggestions in the shredder. But I wasn’t; I pored over all their comments with the utmost care, and agonized over most of them. My thanks to the reviewers: Sean Burke, Damian Conway, Kevin Lenzo, Peter Norvig, Dan Schmidt, Kragen Sitaker, Michael Scott, and Adam Turoff</span></p>
<p><span class="font17">While I was writing, I ran a mailing list for people who were interested in the book, and sent advance chapters to the mailing list. This was tremendously</span></p>
<p><span class="font17">helpful, and I’d recommend the practice to anyone else. The six hundred and fifty wonderful members of my mailing list are too numerous to list here. All were helpful and supportive, and the book is much better for their input. A few stand out as having contributed a particularly large amount of concrete material: Roland Young, Damien Warman, David “Novalis” Turner, Iain “Spoon” Truskett, Steve Tolkin, Ben Tilly, Rob Svirskas, Roses Longin Odounga, Luc St-Louis, Jeff Mitchell, Steffen Muller, Abhijit Menon-Sen, Walt Mankowski, Wolfgang Laun, Paul Kulchenko, Daniel Koo, Andy Lester, David Landgren, Robin Houston, Torsten Hofmann, Douglas Hunter, Francesc Guasch, Kenneth Graves, Jeff Goff, Michael Fischer, Simon Cozens, David Combs, Stas Bekman, Greg Bacon, Darius Bacon, and Peter Allen. My apologies to the many many helpful contributors whom I have deliberately omitted from this list in the interests of space, and even more so to the several especially helpful contributors whom I have accidentally omitted.</span></p>
<p><span class="font17">Wolfgang Laun and Per Westerlund were particularly assiduous in helping me correct errors for the second printing.</span></p>
<p><span class="font17">Before I started writing, I received valuable advice about choosing a publisher from Philip Greenspun, Brian Kernighan, and Adam Turoff. Damian Conway and Abigail gave me helpful advice and criticism about my proposal.</span></p>
<p><span class="font17">Sean Burke recorded my Ivory Tower talk, cut CDs and sent them to me, and also supplied RTF-related consulting at the last minute. He also sent me periodic mail to remind me how wonderful my book was, which often arrived at times when I wasn’t so sure.</span></p>
<p><span class="font17">Several specific ideas in Chapter 4 were suggested by other people. Meng Wong suggested the clever and apt “odometer” metaphor. Randal Schwartz helped me with the “append” function. Eric Roode suggested the multiple list iterator.</span></p>
<p><span class="font17">When I needed to read out-of-print books by Paul Graham, A. E. Sundstrom lent them to me. When I needed a copy of volume 2 of </span><span class="font17" style="font-style:italic;">The Art of Computer Programming,</span><span class="font17"> Hildo Biersma and Morgan Stanley bought it for me. When I needed money, B. B. King lent me some. Thanks to all of you.</span></p>
<p><span class="font17">The constraint system drawing program of Chapter 9 was a big project, and I was stuck on it for a long time. Without the timely assistance of Wm Leler, I might still be stuck.</span></p>
<p><span class="font17">Tom Christiansen, Jon Orwant, and Nat Torkington played essential and irreplaceable roles in integrating me into the Perl community.</span></p>
<p><span class="font17">Finally, the list of things “without which this book could not have been written” cannot be complete without thanking Larry Wall for writing Perl and for founding the Perl community, without which this book could not have been written.</span></p>
<p><span class="font14">CHAPTER</span></p>
<h3><a name="bookmark3"></a><span class="font25">RECURSION AND</span></h3>
<h3><span class="font25">CALLBACKS</span></h3>
<p><span class="font17">The first “advanced” technique we’ll see is recursion. </span><span class="font17" style="font-style:italic;">Recursion</span><span class="font17"> is a method of solving a problem by reducing it to a simpler problem of the same type.</span></p>
<p><span class="font17">Unlike most of the techniques in this book, recursion is already well known and widely understood. But it will underlie several of the later techniques, and so we need to have a good understanding of its fine points.</span></p>
<ul style="list-style:none;"><li>
<h5><a name="bookmark4"></a><span class="font18">1.1 DECIMAL TO BINARY CONVERSION</span></h5></li></ul>
<p><span class="font17">Until the release of Perl 5.6.0, there was no good way to generate a binary numeral in Perl. Starting in 5.6.0, you can use </span><span class="font2">sprintf(&quot;%b&quot;, $num)</span><span class="font17">, but before that the question of how to do this was Frequently Asked.</span></p>
<p><span class="font17">Any whole number has the form </span><span class="font17" style="font-style:italic;">2k</span><span class="font3"> + </span><span class="font17" style="font-style:italic;">b,</span><span class="font17"> where </span><span class="font17" style="font-style:italic;">k</span><span class="font17"> is some smaller whole number and </span><span class="font17" style="font-style:italic;">b</span><span class="font17"> is either 0 or 1. </span><span class="font17" style="font-style:italic;">b</span><span class="font17"> is the final bit of the binary expansion. It’s easy to see whether this final bit is 0 or 1; just look to see whether the input number is even or odd. The rest of the number is 2</span><span class="font17" style="font-style:italic;">k</span><span class="font17">, whose binary expansion is the same as that of </span><span class="font17" style="font-style:italic;">k,</span><span class="font17"> but shifted left one place. For example, consider the number 37 </span><span class="font3">= </span><span class="font17">2 </span><span class="font3">• </span><span class="font17">18 </span><span class="font3">+ </span><span class="font17">1; here </span><span class="font17" style="font-style:italic;">k</span><span class="font17"> is 18 and </span><span class="font17" style="font-style:italic;">b</span><span class="font17"> is 1, so the binary expansion of 37 (100101) is the same as that of 18 (10010), but with an extra 1 on the end.</span></p>
<p><span class="font17">How did I compute the expansion for 37? It is an odd number, so the final bit must be 1; the rest of the expansion will be the same as the expansion of 18. How can I compute the expansion of 18? 18 is even, so its final bit is 0, and the rest of the expansion is the same as the expansion of 9. What is the binary expansion for 9? 9 is odd, so its final bit is 1, and the rest of its binary expansion is</span></p>
<div>
<p><span class="font20">2 </span><span class="font15">CHAPTER</span></p>
</div><br clear="all">
<div>
<p><span class="font9" style="font-weight:bold;">CODE LIBRARY</span></p>
</div><br clear="all">
<div>
<p><span class="font0">binary</span></p>
</div><br clear="all">
<p><span class="font15">i Recursion and Callbacks</span></p>
<p><span class="font17">the same as the binary expansion of 4. We can continue in this way, until finally we ask about the binary expansion of 1, which of course is 1.</span></p>
<p><span class="font17">This procedure will work for any number. To compute the binary expansion of a number </span><span class="font17" style="font-style:italic;">n</span><span class="font17"> we proceed as follows:</span></p>
<ul style="list-style:none;"><li>
<p><span class="font17">1. &nbsp;If </span><span class="font17" style="font-style:italic;">n</span><span class="font17"> is 1, its binary expansion is 1, and we may ignore the rest of the procedure.</span></p></li></ul>
<p><span class="font17">Similarly, if </span><span class="font17" style="font-style:italic;">n</span><span class="font17"> is 0, the expansion is simply 0. Otherwise:</span></p>
<ul style="list-style:none;"><li>
<p><span class="font17">2. &nbsp;Compute </span><span class="font17" style="font-style:italic;">k</span><span class="font17"> and </span><span class="font17" style="font-style:italic;">b</span><span class="font17"> so that </span><span class="font17" style="font-style:italic;">n = 2k</span><span class="font3"> + </span><span class="font17" style="font-style:italic;">b</span><span class="font17"> and </span><span class="font17" style="font-style:italic;">b =</span><span class="font17"> 0 or 1. To do this, simply divide </span><span class="font17" style="font-style:italic;">n</span><span class="font17"> by 2; </span><span class="font17" style="font-style:italic;">k</span><span class="font17"> is the quotient, and </span><span class="font17" style="font-style:italic;">b</span><span class="font17"> is the remainder, 0 if </span><span class="font17" style="font-style:italic;">n</span><span class="font17"> was even, and 1 if </span><span class="font17" style="font-style:italic;">n</span><span class="font17"> was odd.</span></p></li>
<li>
<p><span class="font17">3. &nbsp;Compute the binary expansion of </span><span class="font17" style="font-style:italic;">k,</span><span class="font17"> using this same method. Call the result </span><span class="font17" style="font-style:italic;">E.</span></p></li>
<li>
<p><span class="font17">4. &nbsp;The binary expansion for </span><span class="font17" style="font-style:italic;">n</span><span class="font17"> is </span><span class="font17" style="font-style:italic;">Eb</span><span class="font17">.</span></p></li></ul>
<p><span class="font17">Let’s build a function called </span><span class="font2">binary() </span><span class="font17">that calculates the expansion. Here is the preamble, and step 1:</span></p>
<p><span class="font2">sub binary {</span></p>
<p><span class="font2">my ($n) = @_;</span></p>
<p><span class="font2">return $n if $n == 0 || $n == 1;</span></p>
<p><span class="font17">Here is step 2:</span></p>
<p><span class="font2">my $k = int($n/2);</span></p>
<p><span class="font2">my $b = $n % 2;</span></p>
<p><span class="font17">For the third step, we need to compute the binary expansion of </span><span class="font17" style="font-style:italic;">k</span><span class="font17">. How can we do that? It’s easy, because we have a handy function for computing binary expansions, called </span><span class="font2">binary() —</span><span class="font17">or we will once we’ve finished writing it. We’ll call </span><span class="font2">binary() </span><span class="font17">with </span><span class="font17" style="font-style:italic;">k</span><span class="font17"> as its argument:</span></p>
<p><span class="font2">my $E = binary($k);</span></p>
<p><span class="font17">Now the final step is a string concatenation:</span></p>
<p><span class="font2">return $E . $b;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">This works. For example, if you invoke </span><span class="font2">binary(37)</span><span class="font17">, you get the string </span><span class="font2">100101</span><span class="font17">. The essential technique here was to reduce the problem to a simpler case.</span></p>
<p><span class="font17">We were supposed to find the binary expansion of a number </span><span class="font17" style="font-style:italic;">n;</span><span class="font17"> we discovered that this binary expansion was the concatenation of the binary expansion of a smaller number </span><span class="font17" style="font-style:italic;">k</span><span class="font17"> and a single bit </span><span class="font17" style="font-style:italic;">b.</span><span class="font17"> Then to solve the simpler case of the same problem, we used the function </span><span class="font2">binary() </span><span class="font17">in its own definition. When we invoke </span><span class="font2">binary() </span><span class="font17">with some number as an argument, it needs to compute </span><span class="font2">binary() </span><span class="font17">for a different, smaller argument, which in turn computes </span><span class="font2">binary() </span><span class="font17">for an even smaller argument. Eventually, the argument becomes 1, and </span><span class="font2">binary() </span><span class="font17">computes the trivial binary representation of 1 directly.</span></p>
<p><span class="font17">This final step, called the </span><span class="font17" style="font-style:italic;">base case</span><span class="font17"> of the recursion, is important. If we don’t consider it, our function might never terminate. If, in the definition of </span><span class="font2">binary()</span><span class="font17">, we had omitted the line:</span></p>
<p><span class="font2">return $n if $n == 0 || $n == 1;</span></p>
<p><span class="font17">then </span><span class="font2">binary() </span><span class="font17">would have computed forever, and would never have produced an answer for any argument.</span></p>
<ul style="list-style:none;"><li>
<h5><a name="bookmark5"></a><span class="font18">1.2 FACTORIAL</span></h5></li></ul>
<p><span class="font17">Suppose you have a list of </span><span class="font17" style="font-style:italic;">n</span><span class="font17"> different items. For concreteness, we’ll suppose that these items are letters of the alphabet. How many different orders are there for such a list? Obviously, the answer depends on </span><span class="font17" style="font-style:italic;">n</span><span class="font17">, so it is a function of </span><span class="font17" style="font-style:italic;">n</span><span class="font17">. This function is called the </span><span class="font17" style="font-style:italic;">factorial function.</span><span class="font17"> The factorial of </span><span class="font17" style="font-style:italic;">n</span><span class="font17"> is the number of different orders for a list of </span><span class="font17" style="font-style:italic;">n</span><span class="font17"> different items. Mathematicians usually write it as a postfix (!) mark, so that the factorial of </span><span class="font17" style="font-style:italic;">n</span><span class="font17"> is </span><span class="font17" style="font-style:italic;">n</span><span class="font17">!. They also call the different orders </span><span class="font17" style="font-style:italic;">permutations.</span></p>
<p><span class="font17">Let’s compute some factorials. Evidently, there’s only one way to order a list of one item, so 1! </span><span class="font3">= </span><span class="font17">1. There are two permutations of a list of two items: </span><span class="font2">A-B </span><span class="font17">and </span><span class="font2">B-A</span><span class="font17">, so 2! </span><span class="font3">= </span><span class="font17">2. A little pencil work will reveal that there are six permutations of three items:</span></p>
<p><span class="font2">C AB &nbsp;&nbsp;&nbsp;C BA</span></p>
<p><span class="font2">A C B &nbsp;&nbsp;&nbsp;B C A</span></p>
<p><span class="font2">AB C &nbsp;&nbsp;&nbsp;BA C</span></p>
<p><span class="font17">How can we be sure we didn’t omit anything from the list? It’s not hard to come up with a method that constructs every possible ordering, and in Chapter 4 we will see a program to list them all. Here is one way to do it. We can make any list of three items by adding a new item to a list of two items. We have two choices</span></p>
<p><span class="font15" style="font-variant:small-caps;">chapter</span><span class="font15"> I Recursion and Callbacks</span></p>
<p><span class="font17">for the two-item list we start with: </span><span class="font2">AB </span><span class="font17">and </span><span class="font2">BA</span><span class="font17">. In each case, we have three choices about where to put the </span><span class="font2">C</span><span class="font17">: at the beginning, in the middle, or at the end. There are 2 </span><span class="font3">• </span><span class="font17">3 </span><span class="font3">= </span><span class="font17">6 ways to make the choices together, and since each choice leads to a different list of three items, there must be six such lists. The preceding left column shows all the lists we got by inserting the </span><span class="font2">C </span><span class="font17">into </span><span class="font2">AB</span><span class="font17">, and the right column shows the lists we got by inserting the </span><span class="font2">C </span><span class="font17">into </span><span class="font2">BA</span><span class="font17">, so the display is complete.</span></p>
<p><span class="font17">Similarly, if we want to know how many permutations there are of four items, we can figure it out the same way. There are six different lists of three items, and there are four positions where we could insert the fourth item into each of the lists, for a total of 6 </span><span class="font3">• </span><span class="font17">4 </span><span class="font3">= </span><span class="font17">24 total orders:</span></p>
<table border="1">
<tr><td>
<p><span class="font2">D ABC</span></p></td><td>
<p><span class="font2">D ACB</span></p></td><td>
<p><span class="font2">D BAC</span></p></td><td>
<p><span class="font2">D BCA</span></p></td><td>
<p><span class="font2">D CAB</span></p></td><td>
<p><span class="font2">D CBA</span></p></td></tr>
<tr><td style="vertical-align:bottom;">
<p><span class="font2">A D BC</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">A D CB</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">B D AC</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">B D CA</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">C D AB</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">C D BA</span></p></td></tr>
<tr><td style="vertical-align:bottom;">
<p><span class="font2">AB D C</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">AC D B</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">BA D C</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">BC D A</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">CA D B</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">CB D A</span></p></td></tr>
<tr><td style="vertical-align:bottom;">
<p><span class="font2">ABC D</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">ACB D</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">BAC D</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">BCA D</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">CAB D</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">CBA D</span></p></td></tr>
</table>
<p><span class="font17">Now we’ll write a function to compute, for any </span><span class="font17" style="font-style:italic;">n,</span><span class="font17"> how many permutations there are of a list of </span><span class="font17" style="font-style:italic;">n</span><span class="font17"> elements.</span></p>
<p><span class="font17">We’ve just seen that if we know the number of possible permutations of </span><span class="font17" style="font-style:italic;">n —</span><span class="font17"> 1 things, we can compute the number of permutations of </span><span class="font17" style="font-style:italic;">n</span><span class="font17"> things. To make a list of </span><span class="font17" style="font-style:italic;">n</span><span class="font17"> things, we take one of the (</span><span class="font17" style="font-style:italic;">n</span><span class="font3"> — </span><span class="font17">1)! lists of </span><span class="font17" style="font-style:italic;">n —</span><span class="font17"> 1 things and insert the </span><span class="font17" style="font-style:italic;">n</span><span class="font17">th thing into one of the </span><span class="font17" style="font-style:italic;">n</span><span class="font17"> available positions in the list. Therefore, the total number of permutations of </span><span class="font17" style="font-style:italic;">n</span><span class="font17"> items is (</span><span class="font17" style="font-style:italic;">n</span><span class="font3"> — </span><span class="font17">1)</span><span class="font3">! • </span><span class="font17" style="font-style:italic;">n</span><span class="font17">:</span></p>
<p><span class="font2">sub factorial { my ($n) = @_; return factorial($n-1) * $n;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">Oops, this function is broken; it never produces a result for any input, because we left out the termination condition. To compute </span><span class="font2">factorial(2)</span><span class="font17">, it first tries to compute </span><span class="font2">factorial(1)</span><span class="font17">. To compute </span><span class="font2">factorial(1)</span><span class="font17">, it first tries to compute </span><span class="font2">factorial(0)</span><span class="font17">. To compute </span><span class="font2">factorial(0)</span><span class="font17">, it first tries to compute </span><span class="font2">factorial(-1)</span><span class="font17">. This process continues forever. We can fix it by telling the function explicitly what 0! is so that when it gets to 0 it doesn’t need to make a recursive call:</span></p>
<div>
<p><span class="font9" style="font-weight:bold;">CODE LIBRARY</span></p>
</div><br clear="all">
<div>
<p><span class="font0">factorial</span></p>
</div><br clear="all">
<p><span class="font2">sub factorial { my ($n) = @_; return 1 if $n == 0;</span></p>
<p><span class="font2">return factorial($n-1) * $n;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font15">1.2 FACTORIAL</span></p>
<p><span class="font17">Now the function works properly.</span></p>
<p><span class="font17">It may not be immediately apparent why the factorial of 0 is 1. Let’s return to the definition. </span><span class="font2">factorial($n) </span><span class="font17">is the number of different orders of a given list of </span><span class="font2">$n </span><span class="font17">elements. </span><span class="font2">factorial(2) </span><span class="font17">is 2, because there are two ways to order a list of two elements: </span><span class="font2">('A', 'B') </span><span class="font17">and </span><span class="font2">('B', 'A')</span><span class="font17">. </span><span class="font2">factorial(l) </span><span class="font17">is 1, because there is only one way to order a list of one element: </span><span class="font2">('A')</span><span class="font17">. </span><span class="font2">factorial(0) </span><span class="font17">is 1, because there is only one way to order a list of zero elements: </span><span class="font2">()</span><span class="font17">. Sometimes people are tempted to argue that 0! should be 0, but the example of </span><span class="font2">() </span><span class="font17">shows clearly that it isn’t.</span></p>
<p><span class="font17">Getting the base case right is vitally important in recursive functions, because if you get it wrong, it will throw off all the other results from the function. If we were to erroneously replace </span><span class="font2">return 1 </span><span class="font17">in the preceding function with </span><span class="font2">return 0</span><span class="font17">, it would no longer be a function for computing factorials; instead, it would be a function for computing zero.</span></p>
<ul style="list-style:none;"><li>
<h5><a name="bookmark6"></a><span class="font19">1.2.1 Why Private Variables Are Important</span></h5></li></ul>
<p><span class="font17">Let’s spend a little while looking at what happens if we leave out the </span><span class="font2">my</span><span class="font17">. The following version of </span><span class="font2">factorial() </span><span class="font17">is identical to the previous version, except that it is missing the </span><span class="font2">my </span><span class="font17">declaration on </span><span class="font2">$n</span><span class="font17">:</span></p>
<p><span class="font2">sub factorial {</span></p>
<div>
<p><span class="font9" style="font-weight:bold;">CODE LIBRARY</span></p>
</div><br clear="all">
<div>
<p><span class="font0">factorial-broken</span></p>
</div><br clear="all">
<p><span class="font2">($n) = @_;</span></p>
<p><span class="font2">return 1 if $n == 0;</span></p>
<p><span class="font2">return factorial($n-1) * $n; }</span></p>
<p><span class="font17">Now </span><span class="font2">$n </span><span class="font17">is a global variable, because all Perl variables are global unless they are declared with </span><span class="font2">my</span><span class="font17">. This means that even though several copies of </span><span class="font2">factorial() </span><span class="font17">might be executing simultaneously, they are all using the same global variable </span><span class="font2">$n</span><span class="font17">. What effect does this have on the function’s behavior?</span></p>
<p><span class="font17">Let’s consider what happens when we call </span><span class="font2">factorial(1)</span><span class="font17">. Initially, </span><span class="font2">$n </span><span class="font17">is set to 1, and the test on the second line fails, so the function makes a recursive call to </span><span class="font2">factorial(0)</span><span class="font17">. The invocation of </span><span class="font2">factorial(1) </span><span class="font17">waits around for the new function call to complete. When </span><span class="font2">factorial(0) </span><span class="font17">is entered, </span><span class="font2">$n </span><span class="font17">is set to 0. This time the test on the second line is true, and the function returns immediately, yielding 1.</span></p>
<p><span class="font17">The invocation of </span><span class="font2">factorial(1) </span><span class="font17">that was waiting for the answer to </span><span class="font2">factorial(0) </span><span class="font17">can now continue; the result from </span><span class="font2">factorial(0) </span><span class="font17">is 1. </span><span class="font2">factorial(1) </span><span class="font17">takes this 1, multiplies it by the value of </span><span class="font2">$n</span><span class="font17">, and returns the result. But </span><span class="font2">$n </span><span class="font17">is now 0, because </span><span class="font2">factorial(0) </span><span class="font17">set it to 0, so the result is 1 </span><span class="font3">• </span><span class="font17">0 </span><span class="font3">= </span><span class="font17">0. This is the final, incorrect return value of </span><span class="font2">factorial(1)</span><span class="font17">. It should have been 1, not 0.</span></p>
<p><span class="font15" style="font-variant:small-caps;">chapter</span><span class="font15"> I Recursion and Callbacks</span></p>
<p><span class="font17">Similarly, </span><span class="font2">factorial(2) </span><span class="font17">returns 0 instead of 2, </span><span class="font2">factorial(3) </span><span class="font17">returns 0 instead of 6, and so on.</span></p>
<p><span class="font17">In order to work properly, each invocation of </span><span class="font2">factorial() </span><span class="font17">needs to have its own private copy of </span><span class="font2">$n </span><span class="font17">that the other invocations won’t interfere with, and that’s exactly what </span><span class="font2">my </span><span class="font17">does. Each time </span><span class="font2">factorial() </span><span class="font17">is invoked, a new variable is created for that invocation to use as its </span><span class="font2">$n</span><span class="font17">.</span></p>
<p><span class="font17">Other languages that support recursive functions all have variables that work something like Perl’s </span><span class="font2">my </span><span class="font17">variables, where a new one is created each time the function is invoked. For example, in C, variables declared inside functions have this behavior by default, unless declared otherwise. (In C, such variables are called </span><span class="font17" style="font-style:italic;">auto</span><span class="font17"> variables, because they are automatically allocated and deallocated.) Using global variables or some other kind of storage that isn’t allocated for each invocation of a function usually makes it impossible to call that function recursively; such a function is called </span><span class="font17" style="font-style:italic;">non-reentrant.</span><span class="font17"> Non-reentrant functions were once quite common in the days when people used languages like Fortran (which didn’t support recursion until 1990) and became less common as languages with private variables, such as C, became popular.</span></p>
<p><span class="font18">1.3 the tower OF HANOI</span></p>
<p><span class="font17">Both our examples so far have not actually required recursion; they could both be rewritten as simple loops.</span></p>
<p><span class="font17">This sort of rewriting is always possible, because after all, the machine language in your computer probably doesn’t support recursion, so in some sense it must be inessential. For the factorial function, the rewriting is easy, but this isn’t always so. Here’s an example. It’s a puzzle that was first proposed by Edouard Lucas in 1883, called the Tower of Hanoi.</span></p>
<p><span class="font17">The puzzle has three pegs, called </span><span class="font17" style="font-style:italic;">A, B,</span><span class="font17"> and </span><span class="font17" style="font-style:italic;">C</span><span class="font17">. On peg </span><span class="font17" style="font-style:italic;">A</span><span class="font17"> is a tower of disks of graduated sizes, with the largest on the bottom and the smallest on the top (see Figure 1.1).</span></p>
<p><span class="font17">The puzzle is to move the entire tower from </span><span class="font17" style="font-style:italic;">A</span><span class="font17"> to </span><span class="font17" style="font-style:italic;">C</span><span class="font17"> , subject to the following restrictions: you may move only one disk at a time, and no disk may ever rest atop a smaller disk. The number of disks varies depending on who is posing the problem, but it is traditionally 64. We will try to solve the problem in the general case, for </span><span class="font17" style="font-style:italic;">n</span><span class="font17"> disks.</span></p>
<p><span class="font17">Let’s consider the largest of the </span><span class="font17" style="font-style:italic;">n</span><span class="font17"> disks, which is the one on the bottom. We’ll call this disk “the Big Disk.” The Big Disk starts on peg </span><span class="font17" style="font-style:italic;">A</span><span class="font17">, and we want it to end on peg </span><span class="font17" style="font-style:italic;">C</span><span class="font17">. If any other disks are on peg </span><span class="font17" style="font-style:italic;">A</span><span class="font17">, they are on top of the Big Disk, so we will not be able to move it. If any other disks are on peg </span><span class="font17" style="font-style:italic;">C</span><span class="font17"> , we will not be able to move the Big Disk to </span><span class="font17" style="font-style:italic;">C</span><span class="font17"> because then it would be atop a smaller disk. So if</span></p><img src="HigherOrderPerl_files/HigherOrderPerl-2.jpg" alt="" style="width:212pt;height:114pt;">
<p><span class="font14">FIGURE l.l </span><span class="font16">The initial configuration of the Tower of Hanoi.</span></p><img src="HigherOrderPerl_files/HigherOrderPerl-3.jpg" alt="" style="width:212pt;height:114pt;">
<p><span class="font14">FIGURE 1.2 </span><span class="font16">An intermediate stage of the Tower of Hanoi.</span></p>
<p><span class="font17">we want to move the Big Disk from </span><span class="font17" style="font-style:italic;">A</span><span class="font17"> to </span><span class="font17" style="font-style:italic;">C</span><span class="font17">, all the other disks must be heaped up on peg </span><span class="font17" style="font-style:italic;">B,</span><span class="font17"> in size order, with the smallest one on top (see Figure 1.2).</span></p>
<p><span class="font17">This means that to solve this problem, we have a subgoal: we have to move the entire tower of disks, except for the Big Disk, from </span><span class="font17" style="font-style:italic;">A</span><span class="font17"> to </span><span class="font17" style="font-style:italic;">B</span><span class="font17">. Only then we can transfer the Big Disk from </span><span class="font17" style="font-style:italic;">A</span><span class="font17"> to </span><span class="font17" style="font-style:italic;">C</span><span class="font17">. After we’ve done that, we will be able to move the rest of the tower from </span><span class="font17" style="font-style:italic;">B</span><span class="font17"> to </span><span class="font17" style="font-style:italic;">C</span><span class="font17"> ; this is another subgoal.</span></p>
<p><span class="font17">Fortunately, when we move the smaller tower, we can ignore the Big Disk; it will never get in our way no matter where it is. This means that we can apply the same logic to moving the smaller tower. At the bottom of the smaller tower is a large disk; we will move the rest of the tower out of the way, move this bottom disk to the right place, and then move the rest of the smaller tower on top of it. How do we move the rest of the smaller tower? The same way.</span></p>
<p><span class="font17">The process bottoms out when we have to worry about moving a smaller tower that contains only one disk, which will be the smallest disk in the whole set. In that case our subgoals are trivial, and we just put the little disk wherever we need to. We know that there will never be anything on top of it (because that</span></p>
<div>
<p><span class="font20">8 </span><span class="font15">CHAPTER</span></p>
</div><br clear="all">
<div>
<p><span class="font15">i Recursion and Callbacks</span></p>
</div><br clear="all">
<p><span class="font17">would be illegal) and we know that we can always move it wherever we like; it’s the smallest, so it is impossible to put it atop anything smaller.</span></p>
<p><span class="font17">Our strategy for moving the original tower looks like this:</span></p>
<p><span class="font17">To move a tower of </span><span class="font17" style="font-style:italic;">n</span><span class="font17"> disks from the start peg to the end peg,</span></p>
<ul style="list-style:none;"><li>
<p><span class="font17">1. &nbsp;If the “tower” is actually only one disk high, just move it. Otherwise:</span></p></li>
<li>
<p><span class="font17">2. &nbsp;Move all the disks except for disk </span><span class="font17" style="font-style:italic;">n</span><span class="font17"> (the Big Disk) from the start peg to the extra peg, using this method.</span></p></li>
<li>
<p><span class="font17">3. &nbsp;Move disk </span><span class="font17" style="font-style:italic;">n</span><span class="font17"> (the Big Disk) from the start peg to the end peg.</span></p></li>
<li>
<p><span class="font17">4. &nbsp;Move all the other disks from the extra peg to the end peg, using this method.</span></p></li></ul>
<p><span class="font17">It’s easy to translate this into code:</span></p>
<div>
<p><span class="font9" style="font-weight:bold;">CODE LIBRARY</span></p>
</div><br clear="all">
<ul style="list-style:none;"><li>
<p><span class="font2"># hanoi(N, start, end, extra)</span></p>
<div>
<p><span class="font0">hanoi</span></p>
</div><br clear="all"></li>
<li>
<p><span class="font2"># Solve Tower of Hanoi problem for a tower of N disks,</span></p></li>
<li>
<p><span class="font2"># of which the largest is disk #N. Move the entire tower from</span></p></li>
<li>
<p><span class="font2"># peg 'start' to peg 'end', using peg 'extra' as a work space</span></p></li></ul>
<p><span class="font2">sub hanoi {</span></p>
<p><span class="font2">my ($n, $start, $end, $extra) = @_;</span></p>
<p><span class="font2">if ($n == 1) {</span></p>
<table border="1">
<tr><td>
<p><span class="font2">print &quot;Move</span></p></td><td>
<p><span class="font2">disk #1</span></p></td><td>
<p><span class="font2">from $start to</span></p></td><td>
<p><span class="font2">$end.\n&quot;;</span></p></td><td>
<p><span class="font2">#</span></p></td><td>
<p><span class="font2">Step</span></p></td><td>
<p><span class="font2">1</span></p></td></tr>
<tr><td style="vertical-align:bottom;">
<p><span class="font2">else {</span></p></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td style="vertical-align:bottom;">
<p><span class="font2">hanoi($n-1,</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">$start,</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">$extra, $end);</span></p></td><td></td><td style="vertical-align:bottom;">
<p><span class="font2">#</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">Step</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">2</span></p></td></tr>
<tr><td>
<p><span class="font2">print &quot;Move</span></p></td><td>
<p><span class="font2">disk #$n</span></p></td><td>
<p><span class="font2">from $start to</span></p></td><td>
<p><span class="font2">$end.\n&quot;;</span></p></td><td>
<p><span class="font2">#</span></p></td><td>
<p><span class="font2">Step</span></p></td><td>
<p><span class="font2">3</span></p></td></tr>
<tr><td style="vertical-align:bottom;">
<p><span class="font2">hanoi($n-1,</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">$extra,</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">$end, $start);</span></p></td><td></td><td style="vertical-align:bottom;">
<p><span class="font2">#</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">Step</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">4</span></p></td></tr>
</table>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">This function prints a series of instructions for how to move the tower. For example, to ask it for instructions for moving a tower of three disks, we call it like this:</span></p>
<p><span class="font2">hanoi(3, 'A', 'C', 'B');</span></p>
<p><span class="font17">Its output is:</span></p>
<table border="1">
<tr><td>
<p><span class="font2">Move disk #1</span></p></td><td>
<p><span class="font2">from</span></p></td><td>
<p><span class="font2">A</span></p></td><td>
<p><span class="font2">to</span></p></td><td>
<p><span class="font2">C</span></p></td></tr>
<tr><td>
<p><span class="font2">Move disk #2</span></p></td><td>
<p><span class="font2">from</span></p></td><td>
<p><span class="font2">A</span></p></td><td>
<p><span class="font2">to</span></p></td><td>
<p><span class="font2">B</span></p></td></tr>
<tr><td style="vertical-align:bottom;">
<p><span class="font2">Move disk #1</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">from</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">C</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">to</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">B</span></p></td></tr>
<tr><td style="vertical-align:bottom;">
<p><span class="font2">Move disk #3</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">from</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">A</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">to</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">C</span></p></td></tr>
</table>
<p><span class="font2">Move disk #1 from B to A.</span></p>
<p><span class="font2">Move disk #2 from B to C.</span></p>
<p><span class="font2">Move disk #1 from A to C.</span></p>
<p><span class="font17">If we wanted a graphic display of moving disks instead of a simple printout of instructions, we could replace the </span><span class="font2">print </span><span class="font17">statements with something fancier. But we can make the software more flexible almost for free by parametrizing the output behavior. Instead of having a </span><span class="font2">print </span><span class="font17">statement hardwired in, </span><span class="font2">hanoi() </span><span class="font17">will accept an extra argument that is a function that will be called each time </span><span class="font2">hanoi() </span><span class="font17">wants to move a disk. This function will print an instruction, or update a graphical display, or do whatever else we want. The function will be passed the number of the disk, and the source and destination pegs. The code is almost exactly the same:</span></p>
<p><span class="font2">sub hanoi {</span></p>
<p><span class="font2" style="font-weight:bold;">my (Sn, Sstart, Send, Sextra, Smove_disk) = @_;</span></p>
<p><span class="font2">if ($n == 1) {</span></p>
<p><span class="font2" style="font-weight:bold;">Smove_disk-&gt;(1, Sstart, Send);</span></p>
<p><span class="font2">} else {</span></p>
<p><span class="font2">hanoi($n-1, $start, $extra, $end, $move_disk);</span></p>
<p><span class="font2" style="font-weight:bold;">Smove_disk-&gt;(Sn, $start, Send);</span></p>
<p><span class="font2">hanoi($n-1, $extra, $end, $start, $move_disk);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">To get the behavior of the original version, we now invoke </span><span class="font2">hanoi() </span><span class="font17">like this:</span></p>
<p><span class="font2">sub print_instruction {</span></p>
<p><span class="font2">my ($disk, $start, $end) = @_;</span></p>
<p><span class="font2">print &quot;Move disk #$disk from $start to $end.\n&quot;;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">hanoi(3, 'A', 'C', 'B', \&amp;print_instruction);</span></p>
<p><span class="font17">The </span><span class="font2">\&amp;print_instruction </span><span class="font17">expression generates a </span><span class="font17" style="font-style:italic;">code reference,</span><span class="font17"> which is a scalar value that represents the function. You can store the code reference in a scalar variable just like any other scalar, or pass it as an argument just like any other scalar, and you can also use the reference to invoke the function that it represents. To do that, you write:</span></p>
<p><span class="font2">$code_reference-&gt;(arguments...);</span></p>
<div>
<p><span class="font20">10</span></p>
</div><br clear="all">
<p><span class="font15" style="font-variant:small-caps;">chapter</span><span class="font15"> I Recursion and Callbacks</span></p>
<p><span class="font17">This invokes the function with the specified arguments.<a name="footnote1"></a><sup><a href="#bookmark215">1</a></sup><sup></sup> Code references are often referred to as </span><span class="font17" style="font-style:italic;">coderefs.</span></p>
<p><span class="font17">The coderef argument to </span><span class="font2">hanoi() </span><span class="font17">is called a </span><span class="font17" style="font-style:italic;">callback,</span><span class="font17"> because it is a function supplied by the caller of </span><span class="font2">hanoi() </span><span class="font17">that will be “called back” to when </span><span class="font2">hanoi() </span><span class="font17">needs help. We sometimes also say that the </span><span class="font2">Smove_disk </span><span class="font17">argument of </span><span class="font2">hanoi() </span><span class="font17">is a </span><span class="font17" style="font-style:italic;">hook,</span><span class="font17"> because it provides a place where additional functionality may easily be hung.</span></p>
<p><span class="font17">Now that we have a generic version of </span><span class="font2">hanoi()</span><span class="font17">, we can test the algorithm by passing in a </span><span class="font2">Smove_disk </span><span class="font17">function that keeps track of where the disks are and checks to make sure we aren’t doing anything illegal:</span></p>
<div>
<p><span class="font9" style="font-weight:bold;">CODE LIBRARY</span></p>
</div><br clear="all">
<p><span class="font2">©position = ('', ('A') x 3); # Disks are all initially on peg A</span></p>
<p><span class="font0">check-move</span></p>
<p><span class="font2">sub check_move {</span></p>
<p><span class="font2">my Si;</span></p>
<p><span class="font2">my (Sdisk, Sstart, Send) = ©_;</span></p>
<p><span class="font17">The </span><span class="font2">check_move() </span><span class="font17">function maintains an array, </span><span class="font2">©position</span><span class="font17">, that records the current position of every disk. Initially, every disk is on peg </span><span class="font17" style="font-style:italic;">A.</span><span class="font17"> Here we assume that there are only three disks, so we set </span><span class="font2">Sposition[1]</span><span class="font17">, </span><span class="font2">Sposition[2]</span><span class="font17">, and </span><span class="font2">Sposition[3] </span><span class="font17">to </span><span class="font2">&quot;A&quot;</span><span class="font17">. </span><span class="font2">Sposition[0] </span><span class="font17">is a dummy element that is never used because there is no disk 0. Each time the main </span><span class="font2">hanoi() </span><span class="font17">function wants to move a disk, it calls </span><span class="font2">check_move()</span><span class="font17">.</span></p>
<p><span class="font2">if (Sdisk &lt;&nbsp;1 || Sdisk &gt;&nbsp;S#position) {</span></p>
<p><span class="font2">die &quot;Bad disk number Sdisk. Should be 1..S#position.\n&quot;; }</span></p>
<p><span class="font17">This is a trivial check to make sure that </span><span class="font2">hanoi() </span><span class="font17">doesn’t try to move a nonexistent disk.</span></p>
<p><span class="font2">unless (Sposition[Sdisk] eq Sstart) {</span></p>
<p><span class="font2">die &quot;Tried to move disk Sdisk from Sstart, but it is on peg Sposition[Sdisk].\n&quot;;</span></p>
<p><span class="font15">1.3 THE TOWER OF HANOI</span></p>
<div>
<p><span class="font20">11</span></p>
</div><br clear="all">
<p><span class="font17">Here the function checks to make sure that </span><span class="font2">hanoi() </span><span class="font17">is not trying to move a disk from a peg where it does not reside. If the start peg does not match </span><span class="font2">check_move()</span><span class="font17">’s notion of the current position of the disk, the function signals an error.</span></p>
<p><span class="font2">for Si (1 .. Sdisk-1) {</span></p>
<p><span class="font2">if (Sposition[Si] eq Sstart) {</span></p>
<p><span class="font2">die &quot;Can't move disk Sdisk from Sstart because Si is on top of it.\n&quot;;</span></p>
<p><span class="font2">} elsif (Sposition[Si] eq Send) {</span></p>
<p><span class="font2">die &quot;Can't move disk Sdisk to Send because Si is already there.\n&quot;;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">This is the really interesting check. The function loops over all the disks that are smaller than the one </span><span class="font2">hanoi() </span><span class="font17">is trying to move, and makes sure that the smaller disks aren’t in the way. The first </span><span class="font2">if </span><span class="font17">branch makes sure that each smaller disk is not on top of the one </span><span class="font2">hanoi() </span><span class="font17">wants to move, and the second branch makes sure that </span><span class="font2">hanoi() </span><span class="font17">is not trying to move the current disk onto the smaller disk.</span></p>
<p><span class="font2">print &quot;Moving disk Sdisk from Sstart to Send.\n&quot;;</span></p>
<p><span class="font2">Sposition[Sdisk] = Send;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">Finally, the function has determined that there is nothing wrong with the move, so it prints out a message as before, and adjusts the </span><span class="font2">©position </span><span class="font17">array to reflect the new position of the disk.</span></p>
<p><span class="font17">Running:</span></p>
<p><span class="font2">hanoi(3, 'A', 'C', 'B', \&amp;check_move);</span></p>
<p><span class="font17">yields the same output as before, and no errors — </span><span class="font2">hanoi() </span><span class="font17">is not doing anything illegal.</span></p>
<p><span class="font17">This example demonstrates a valuable technique we’ll see over and over again: by parametrizing some part of a function to call some other function instead of hardwiring the behavior, we can make it more flexible. This added flexibility will pay off when we want the function to do something a little different, such as performing an automatic self-check. Instead of having to clutter up the function with a lot of optional self-testing code, we can separate the testing part from the main algorithm. The algorithm remains as clear and simple as ever, and we can enable or disable the self-checking code at run time if we want to, by passing a different coderef argument.</span></p>
<div>
<h4><a name="bookmark216"></a><span class="font20">12</span></h4>
</div><br clear="all">
<div>
<p><span class="font15">CHAPTER I</span></p>
</div><br clear="all">
<div>
<p><span class="font15">Recursion and Callbacks</span></p>
</div><br clear="all">
<ul style="list-style:none;"><li>
<h5><a name="bookmark8"></a><span class="font18">1.4 HIERARCHICAL DATA</span></h5></li></ul>
<p><span class="font17">The examples we’ve seen give the flavor of what a recursive procedure looks like, but they miss an important point. In introducing the Tower of Hanoi problem, I said that recursion is useful when you want to solve a problem that can be reduced to simpler cases of the same problem. But it might not be clear that such problems are common.</span></p>
<p><span class="font17">Most recursive functions are built to deal with recursive data structures. A recursive data structure is one like a list, tree, or heap that is defined in terms of simpler instances of the same data structure. The most familiar example is probably a file system directory structure. A file is either:</span></p>
<ul style="list-style:none;"><li>
<p><span class="font17">• &nbsp;&nbsp;a plain file, which contains some data, or</span></p></li>
<li>
<p><span class="font17">• &nbsp;&nbsp;a directory, which contains a list of files</span></p></li></ul>
<p><span class="font17">A file might be a directory, which contains a list of files, some of which might be directories, which in turn contain more lists of files, and so on. The most effective way of dealing with such a structure is with a recursive procedure. Conceptually, each call to such a procedure handles a single file. The file might be a plain file, or it might be a directory, in which case the procedure makes recursive calls to itself to handle any subfiles that the directory has. If the subfiles are themselves directories, the procedure will make more recursive calls.</span></p>
<p><span class="font17">Here’s an example of a function that takes the name of a directory as its argument and computes the total size of all the files contained in it, and in its subdirectories, and in their subdirectories, and so on:</span></p>
<div>
<p><span class="font9" style="font-weight:bold;">CODE LIBRARY</span></p>
</div><br clear="all">
<div>
<p><span class="font0">total-size-broken</span></p>
</div><br clear="all">
<p><span class="font2">sub total_size { my (Stop) = @_;</span></p>
<p><span class="font2">my Stotal = -s Stop;</span></p>
<p><span class="font17">When we first call the function, it’s with an argument </span><span class="font2">Stop</span><span class="font17">, which is the name of the file or directory we want to examine. The first thing the function does is use the Perl </span><span class="font2">-s </span><span class="font17">operator to find the size of this file or directory itself. This operator yields the size of the file, in bytes. If the file is a directory, it says how much space the directory itself takes up on the disk, apart from whatever files the directory may contain — the directory is a list of files, remember, and the list takes up some space too. If the top file is actually a directory, the function will add the sizes of its contents to a running total that it will keep in </span><span class="font2">Stotal</span><span class="font17">.</span></p>
<p><span class="font2">return Stotal if -f Stop;</span></p>
<p><span class="font2">unless (opendir DIR, Stop) { warn &quot;Couldn’t open directory Stop: $!; skipping.\n&quot;; return Stotal;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">The </span><span class="font2">-f </span><span class="font17">operator checks to see if the argument is a plain file; if so, the function can return the total immediately. Otherwise, it assumes that the top file is actually a directory, and tries to open it with </span><span class="font2">opendir()</span><span class="font17">. If the directory can’t be opened, the function issues a warning message and returns the total so far, which includes the size of the directory itself, but not its contents.</span></p>
<p><span class="font2">my Sfile;</span></p>
<p><span class="font2">while (Sfile = readdir DIR) {</span></p>
<p><span class="font2">next if Sfile eq '.' || Sfile eq '..';</span></p>
<p><span class="font2">Stotal += total_size(&quot;Stop/Sfile&quot;);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">The next block, the </span><span class="font2">while </span><span class="font17">loop, is the heart of the function. It reads filenames from the directory one at a time, calls itself recursively on each one, and adds the result to the running total.</span></p>
<p><span class="font2">closedir DIR;</span></p>
<p><span class="font2">return Stotal;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">At the end of the loop, the function closes the directory and returns the total.</span></p>
<p><span class="font17">In the loop, the function skips over the names </span><span class="font2">. </span><span class="font17">and </span><span class="font2">..</span><span class="font17">, which are aliases for the directory itself and for its parent; if it didn’t do this, it would never finish, because it would try to compute the total sizes of a lot of files with names like </span><span class="font2">././././././fred </span><span class="font17">and </span><span class="font2">dir/../dir/../dir/../dir/fred</span><span class="font17">.</span></p>
<p><span class="font17">This function has a gigantic bug, and in fact it doesn’t work at all. The problem is that directory handles, like </span><span class="font2">DIR</span><span class="font17">, are global, and so our function is not reentrant. The function fails for essentially the same reason that the </span><span class="font2">my</span><span class="font17">-less version of </span><span class="font2">factorial() </span><span class="font17">failed. The first call goes ahead all right, but if </span><span class="font2">total_size() </span><span class="font17">calls itself recursively, the second invocation will open the same dirhandle </span><span class="font2">DIR</span><span class="font17">. Eventually, the second invocation will reach the end of its directory, close </span><span class="font2">DIR</span><span class="font17">, and return. When this happens, the first invocation will try to continue, find that </span><span class="font2">DIR </span><span class="font17">has been closed, and exit the </span><span class="font2">while </span><span class="font17">loop without having read all the filenames from the top directory. The second invocation will have the same problem if it makes any recursive calls itself.</span></p>
<p><span class="font17">The result is that the function, as written, looks down only the first branch of the directory tree. If the directory hierarchy has a structure like this:</span></p><img src="HigherOrderPerl_files/HigherOrderPerl-4.jpg" alt="" style="width:99pt;height:84pt;">
<p><span class="font17">then our function will go down the </span><span class="font17" style="font-style:italic;">top-a-d</span><span class="font17">path, see files </span><span class="font17" style="font-style:italic;">j</span><span class="font17"> and </span><span class="font17" style="font-style:italic;">k,</span><span class="font17"> and report the total size of </span><span class="font17" style="font-style:italic;">top</span><span class="font3"> + </span><span class="font17" style="font-style:italic;">a</span><span class="font3"> + </span><span class="font17" style="font-style:italic;">d</span><span class="font3"> + </span><span class="font17" style="font-style:italic;">j</span><span class="font3"> + </span><span class="font17" style="font-style:italic;">k,</span><span class="font17"> without ever noticing </span><span class="font17" style="font-style:italic;">b, c, e, f, g, h, i,</span><span class="font17"> or </span><span class="font17" style="font-style:italic;">l.</span></p>
<p><span class="font17">To fix it, we need to make the directory handle </span><span class="font2">DIR </span><span class="font17">a private variable, like </span><span class="font2">Stop </span><span class="font17">and </span><span class="font2">Stotal</span><span class="font17">. Instead of </span><span class="font2">opendir DIR, Stop</span><span class="font17">, we’ll use </span><span class="font2">opendir Sdir, Stop</span><span class="font17">, where </span><span class="font2">Sdir </span><span class="font17">is a private variable. When the first argument to </span><span class="font2">opendir </span><span class="font17">is an undefined variable, </span><span class="font2">opendir </span><span class="font17">will create a new, anonymous dirhandle and store it into </span><span class="font2">Sdir</span><span class="font17">.<a name="footnote2"></a><sup><a href="#bookmark217">2</a></sup><sup></sup></span></p>
<p><span class="font17">Instead of doing this:</span></p>
<p><span class="font2">opendir DIR, Ssomedir;</span></p>
<p><span class="font2">print (readdir DIR);</span></p>
<p><span class="font2">closedir DIR;</span></p>
<p><span class="font17">we can get the same effect by doing this instead:</span></p>
<p><span class="font2">my Sdir;</span></p>
<p><span class="font2">opendir Sdir, Ssomedir;</span></p>
<p><span class="font2">print (readdir Sdir);</span></p>
<p><span class="font2">closedir Sdir;</span></p>
<p><span class="font17">The big difference is that </span><span class="font2">DIR </span><span class="font17">is a global dirhandle, and can be read or closed by any other part of the program; the dirhandle in </span><span class="font2">Sdir </span><span class="font17">is private, and can be read</span></p>
<div>
<p><span class="font15">I.4 HIERARCHICAL DATA</span></p>
</div><br clear="all">
<div>
<h4><a name="bookmark218"></a><span class="font20">15</span></h4>
</div><br clear="all">
<p><span class="font17">or closed only by the function that creates it, or by some other function that is explicitly passed the value of </span><span class="font2">Sdir</span><span class="font17">.</span></p>
<p><span class="font17">With this new technique, we can rewrite the </span><span class="font2">total_size() </span><span class="font17">function so that it works properly:</span></p>
<p><span class="font2">sub total_size { my (Stop) = @_;</span></p>
<div>
<p><span class="font9" style="font-weight:bold;">CODE LIBRARY</span></p>
</div><br clear="all">
<div>
<p><span class="font0">total-size</span></p>
</div><br clear="all">
<p><span class="font2">my Stotal = -s Stop;</span></p>
<p><span class="font2" style="font-weight:bold;">my SDIR;</span></p>
<p><span class="font2">return Stotal if -f Stop;</span></p>
<p><span class="font2" style="font-weight:bold;">unless (opendir SDIR, Stop) {</span></p>
<p><span class="font2">warn &quot;Couldn’t open directory Stop: S!; skipping.\n&quot;; return Stotal;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">my Sfile;</span></p>
<p><span class="font2" style="font-weight:bold;">while (Sfile = readdir SDIR) {</span></p>
<p><span class="font2">next if Sfile eq '.' || Sfile eq '..';</span></p>
<p><span class="font2">Stotal += total_size(&quot;Stop/Sfile&quot;);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2" style="font-weight:bold;">closedir SDIR;</span></p>
<p><span class="font2">return Stotal;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">Actually, the </span><span class="font2">closedir </span><span class="font17">here is unnecessary, because dirhandles created with this method close automatically when the variables that contain them go out of scope. When </span><span class="font2">total_size() </span><span class="font17">returns, its private variables are destroyed, including </span><span class="font2">SDIR</span><span class="font17">, which contains the last reference to the dirhandle object we opened. Perl then destroys the dirhandle object, and in the process, closes the dirhandle. We will omit the explicit </span><span class="font2">closedir </span><span class="font17">in the future.</span></p>
<p><span class="font17">This function still has some problems: it doesn’t handle symbolic links correctly, and if a file has two names in the same directory, it gets counted twice. Also, on Unix systems, the space actually taken up by a file on disk is usually different from the length reported by </span><span class="font2">-s</span><span class="font17">, because disk space is allocated in blocks of 1024 bytes at a time. But the function is good enough to be useful, and we might want to apply it to some other tasks as well. If we do decide to fix these problems, we will need to fix them only in this one place, instead of fixing the same problems in fifty slightly different directory-walking functions in fifty different applications.</span></p>
<p><span class="font20">16 </span><span class="font15">CHAPTER I Recursion and Callbacks</span></p>
<ul style="list-style:none;"><li>
<h5><a name="bookmark9"></a><span class="font18">1.5 APPLICATIONS AND VARIATIONS OF DIRECTORY WALKING</span></h5></li></ul>
<p><span class="font17">Having a function that walks a directory tree is useful, and we might like to use it for all sorts of things. For example, if we want to write a recursive file lister that works like the Unix </span><span class="font2">Is -R </span><span class="font17">command, we’ll need to walk the directory tree. We might want our function to behave more like the Unix </span><span class="font2">du </span><span class="font17">command, which prints out the total size of every subdirectory, as well as the total for all the files it found. We might want our function to search for dangling symbolic links; that is, links that point to nonexistent files. A frequently asked question in the Perl newsgroups and IRC channels is how to walk a directory tree and rename each file or perform some other operation on each file.</span></p>
<p><span class="font17">We could write many different functions to do these tasks, each one a little different. But the core part of each one is the recursive directory walker, and we’d like to abstract that out so that we can use it as a tool. If we can separate the walker, we can put it in a library, and then anyone who needs a directory walker can use ours.</span></p>
<p><span class="font17">An important change of stance occurred in the last paragraph. Starting from here, and for most of the rest of the book, we are going to take a point of view that you may not have seen before: we are no longer interested in developing a complete program that we or someone else might use entirely. Instead, we are going to try to write our code so that it is useful to </span><span class="font17" style="font-style:italic;">another programmer</span><span class="font17"> who might want to re-use it in another program. Instead of writing a program, we are now writing a library or module that will be used by other programs.</span></p>
<p><span class="font17">One direction that we could go from here would be to show how to write a </span><span class="font17" style="font-style:italic;">user interface</span><span class="font17"> for the </span><span class="font2">total_size() </span><span class="font17">function, which might prompt the user for a directory name, or read a directory name from the command line or from a graphical widget, and then would display the result somehow. We are not going to do this. It is not hard to add code to prompt the user for a directory name or to read the command-line arguments. For the rest of this book, we are not going to be concerned with user interfaces; instead, we are going to look at </span><span class="font17" style="font-style:italic;">programmer interfaces.</span><span class="font17"> The rest of the book will talk about “the user,” but it’s not the usual user. Instead, the user is another programmer who wants to use our code when writing their own programs. Instead of asking how we can make our entire program simple and convenient for an end-user, we will look at ways to make our functions and libraries simple and convenient for other programmers to use in their own programs.</span></p>
<p><span class="font17">There are two good reasons for doing this. One is that if our functions are well designed for easy re-use, we will be able to re-use them ourselves and save time and trouble. Instead of writing similar code over and over, we’ll plug a familiar directory-walking function into every program that needs one. When we improve the directory-walking function in one program, it will be automatically improved in all our other programs as well. Over time, we’ll develop a toolkit of useful functions and libraries that will make us more productive, and we’ll have more fun programming.</span></p>
<p><span class="font17">But more importantly, if our functions are well designed for re-use, other programmers will be able to use them, and they will get the same benefits that we do. And being useful to other people is the reason we’re here in the first place.<a name="footnote3"></a><sup><a href="#bookmark219">3</a></sup><sup></sup></span></p>
<p><span class="font17">With that change of stance clearly in mind, let’s go on. We had written a function, </span><span class="font2">total_size()</span><span class="font17">, which contained useful functionality: it walked a directory tree recursively. If we could cleanly separate the directory-walking part of the code from the total-size-computing part, then we might be able to re-use the directory-walking part in many other projects for many other purposes. How can we separate the two functionalities?</span></p>
<p><span class="font17">As in the Tower of Hanoi program, the key here is to pass an additional parameter to our function. The parameter will itself be a function that tells </span><span class="font2">total_size() </span><span class="font17">what we want it to do. The code will look like this:</span></p>
<p><span class="font2">sub dir_walk {</span></p>
<div>
<p><span class="font9" style="font-weight:bold;">CODE LIBRARY</span></p>
</div><br clear="all">
<div>
<p><span class="font0">dir-walk-simple</span></p>
</div><br clear="all">
<p><span class="font2">my (Stop, Scode) = @_; my SDIR;</span></p>
<p><span class="font2">Scode-&gt;(Stop);</span></p>
<p><span class="font2">if (-d Stop) {</span></p>
<p><span class="font2">my Sfile;</span></p>
<p><span class="font2">unless (opendir SDIR, Stop) {</span></p>
<p><span class="font2">warn &quot;Couldn’t open directory Stop: S!; skipping.\n&quot;; return;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">while (Sfile = readdir SDIR) {</span></p>
<p><span class="font2">next if Sfile eq '.' || Sfileeq '..';</span></p>
<p><span class="font2">dir_walk(&quot;Stop/Sfile&quot;, Scode);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">This function, which I’ve renamed </span><span class="font2">dir_walk() </span><span class="font17">to honor its new generality, gets two arguments. The first, </span><span class="font2">$top</span><span class="font17">, is the name of the file or directory that we want it to start searching in, as before. The second, </span><span class="font2">$code</span><span class="font17">, is new. It’s a coderef that tells </span><span class="font2">dir_walk </span><span class="font17">what we want to do for each file or directory that we discover in the file tree. Each time </span><span class="font2">dir_walk() </span><span class="font17">discovers a new file or directory, it will invoke our code with the filename as the argument.</span></p>
<p><span class="font17">Now whenever we meet another programmer who asks us, “How do I do </span><span class="font17" style="font-style:italic;">X </span><span class="font17">for every file in a directory tree?” we can answer, “Use this </span><span class="font2">dir_walk() </span><span class="font17">function, and give it a reference to a function that does </span><span class="font17" style="font-style:italic;">X</span><span class="font17">.” The </span><span class="font2">$code </span><span class="font17">argument is a callback.</span></p>
<p><span class="font17">For example, to get a program that prints out a list of all the files and directories below the current directory, we can use:</span></p>
<p><span class="font2">sub print_dir { print $_[0], &quot;\n&quot;;</span></p>
<p><span class="font2">} dir_walk('.', \&amp;print_dir );</span></p>
<p><span class="font17">This prints out something like this:</span></p>
<p><span class="font2">./a</span></p>
<p><span class="font2">./a/a1</span></p>
<p><span class="font2">./a/a2</span></p>
<p><span class="font2">./b</span></p>
<p><span class="font2">./b/b1</span></p>
<p><span class="font2">./c</span></p>
<p><span class="font2">./c/c1</span></p>
<p><span class="font2">./c/c2</span></p>
<p><span class="font2">./c/c3</span></p>
<p><span class="font2">./c/d</span></p>
<p><span class="font2">./c/d/d1</span></p>
<p><span class="font2">./c/d/d2</span></p>
<p><span class="font17">(The current directory contains three subdirectories, named </span><span class="font2">a</span><span class="font17">, </span><span class="font2">b</span><span class="font17">, and </span><span class="font2">c</span><span class="font17">. Subdirectory </span><span class="font2">c </span><span class="font17">contains a sub-subdirectory, named </span><span class="font2">d</span><span class="font17">.)</span></p>
<p><span class="font2">print_dir </span><span class="font17">is so simple that it’s a shame to have to waste time thinking of a name for it. It would be convenient if we could simply write the function without having to write a name for it, analogous to the way we can write:</span></p>
<p><span class="font2">$weekly_pay = 40 * $hourly_pay;</span></p>
<p><span class="font17">without having to name the 40 or store it in a variable. Perl does provide a syntax for this:</span></p>
<p><span class="font2">dir_walk('.', sub { print $_[0], &quot;\n&quot; } );</span></p>
<p><span class="font17">The </span><span class="font2">sub { ... } </span><span class="font17">introduces an </span><span class="font17" style="font-style:italic;">anonymous function;</span><span class="font17"> that is, a function with no name. The value of the </span><span class="font2">sub { ... } </span><span class="font17">construction is a coderef that can be used to call the function. We can store this coderef in a scalar variable or pass it as an argument to a function like any other reference. This one line does the same thing as our more verbose version with the named </span><span class="font2">print_dir </span><span class="font17">function.</span></p>
<p><span class="font17">If we want the function to print out sizes along with filenames, we need only make a small change to the coderef argument:</span></p>
<p><span class="font2">dir_walk('.', sub { printf &quot;%6d %s\n&quot;, -s $_[0], $_[0] } );</span></p>
<p><span class="font2">4096 .</span></p>
<p><span class="font2">4096 ./a</span></p>
<p><span class="font2">261 ./a/a1</span></p>
<p><span class="font2">171 ./a/a2</span></p>
<p><span class="font2">4096 ./b</span></p>
<p><span class="font2">348 ./b/b1</span></p>
<p><span class="font2">4096 ./c</span></p>
<p><span class="font2">658 ./c/c1</span></p>
<p><span class="font2">479 ./c/c2</span></p>
<p><span class="font2">889 ./c/c3</span></p>
<p><span class="font2">4096 ./c/d</span></p>
<p><span class="font2">568 ./c/d/d1</span></p>
<p><span class="font2">889 ./c/d/d2</span></p>
<p><span class="font17">If we want the function to locate dangling symbolic links, it’s just as easy:</span></p>
<p><span class="font2">dir_walk('.', sub { print $_[0], &quot;\n&quot; if -l $_[0] &amp;&amp;&nbsp;! -e $_[0] });</span></p>
<p><span class="font2">-l </span><span class="font17">tests the current file to see if it’s a symbolic link, and </span><span class="font2">-e </span><span class="font17">tests to see if the file that the link points at exists.</span></p>
<p><span class="font17">But my promises fall a little short. There’s no simple way to get the new </span><span class="font2">dir_walk() </span><span class="font17">function to aggregate the sizes of all the files it sees. </span><span class="font2">Scode </span><span class="font17">is invoked for only one file at a time, so it never gets a chance to aggregate. If the aggregation is sufficiently simple, we can accomplish it with a variable defined outside the callback:</span></p>
<p><span class="font2">my STOTAL = 0; dir_walk('.', sub { STOTAL += -s $_[0] });</span></p>
<p><span class="font2">print &quot;Total size is STOTAL.\n&quot;;</span></p>
<p><span class="font17">There are two drawbacks to this approach. One is that the callback function must reside in the scope of the </span><span class="font2">STOTAL </span><span class="font17">variable, as must any code that plans to use </span><span class="font2">STOTAL</span><span class="font17">. Often this isn’t a problem, as in this case, but if the callback were a complicated function in a library somewhere, it might present difficulties. We’ll see a solution to this problem in Section 2.1.</span></p>
<p><span class="font17">The other drawback is that it works well only when the aggregation is extremely simple, as it is here. Suppose instead of accumulating a single total size, we wanted to build a hash structure of filenames and sizes, like this one:</span></p>
<p><span class="font2">{</span></p>
<p><span class="font2">'a' =&gt; {</span></p>
<p><span class="font2">'al' =&gt; '261',</span></p>
<p><span class="font2">'a2' =&gt; '171'</span></p>
<p><span class="font2">},</span></p>
<p><span class="font2">'b' =&gt; {</span></p>
<p><span class="font2">'bl' =&gt; '348'</span></p>
<p><span class="font2">},</span></p>
<p><span class="font2">'c' =&gt; {</span></p>
<p><span class="font2">'cl' =&gt; '658',</span></p>
<p><span class="font2">'c2' =&gt; '479',</span></p>
<p><span class="font2">'c3' =&gt; '889',</span></p>
<p><span class="font2">'d' =&gt; {</span></p>
<p><span class="font2">'dl' =&gt; '568',</span></p>
<p><span class="font2">'d2' =&gt; '889'</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">Here the keys are file and directory names. The value for a filename is the size of the file, and the value for a directory name is a hash with keys and values that represent the contents of the directory. It may not be clear how we could adapt the simple </span><span class="font2">STOTAL</span><span class="font17">-aggregating callback to produce a complex structure like this one.</span></p>
<p><span class="font17">Our </span><span class="font2">dir_walk </span><span class="font17">function is not general enough. We need it to perform some computation involving the files it examines, such as computing their total size, and to return the result of this computation to its caller. The caller might be the main program, or it might be another invocation of </span><span class="font2">dir_walk()</span><span class="font17">, which can then use the value it receives as part of the computation it is performing for </span><span class="font17" style="font-style:italic;">its</span><span class="font17"> caller.</span></p>
<p><span class="font17">How can </span><span class="font2">dir_walk() </span><span class="font17">know how to perform the computation? In </span><span class="font2">total_size()</span><span class="font17">, the addition computation was hardwired into the function. We would like </span><span class="font2">dir_walk() </span><span class="font17">to be more generally useful.</span></p>
<p><span class="font17">What we need is to supply two functions: one for plain files and one for directories. </span><span class="font2">dir_walk() </span><span class="font17">will call the plain-file function when it needs to compute its result for a plain file, and it will call the directory function when it needs to compute its result for a directory. </span><span class="font2">dir_walk() </span><span class="font17">won’t know anything about how to do these computations itself; all it knows is that is should delegate the actual computing to these two functions.</span></p>
<p><span class="font17">Each of the two functions will get a filename argument, and will compute the value of interest, such as the size, for the file named by its argument. Since a directory is a list of files, the directory function will also receive a list of the values that were computed for each of its members; it may need these values when it computes the value for the entire directory. The directory function will know how to aggregate these values to produce a new value for the entire directory.</span></p>
<p><span class="font17">With this change, we’ll be able to do our </span><span class="font2">total_size </span><span class="font17">operation. The plain-file function will simply return the size of the file it’s asked to look at. The directory function will get a directory name and a list of the sizes of each file that it contains, add them all up, and return the result. The generic framework function looks like this:</span></p>
<p><span class="font2">sub dir_walk {</span></p>
<div>
<p><span class="font9" style="font-weight:bold;">CODE LIBRARY</span></p>
</div><br clear="all">
<p><span class="font2" style="font-weight:bold;">my (Stop, Sfilefunc, Sdirfunc) = ©_; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="font0">dir-naU-dj</span></p>
<p><span class="font2">my SDIR;</span></p>
<p><span class="font2">if (-d Stop) {</span></p>
<p><span class="font2">my Sfile;</span></p>
<p><span class="font2">unless (opendir SDIR, Stop) {</span></p>
<p><span class="font2">warn &quot;Couldn’t open directory Scode: $!; skipping.\n&quot;;</span></p>
<p><span class="font2">return;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2" style="font-weight:bold;">my ©results;</span></p>
<p><span class="font2">while (Sfile = readdir SDIR) {</span></p>
<p><span class="font2">next if Sfile eq '.' || Sfileeq '..';</span></p>
<p><span class="font2" style="font-weight:bold;">push ©results, dir_walk(&quot;$top/$file&quot;, Sfilefunc, Sdirfunc);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2" style="font-weight:bold;">return $dirfunc-&gt;($top, ©results);</span></p>
<p><span class="font2" style="font-weight:bold;">} else {</span></p>
<p><span class="font2" style="font-weight:bold;">return $filefunc-&gt;($top);</span></p>
<p><span class="font2" style="font-weight:bold;">}</span></p>
<p><span class="font2">}</span></p>
<h6><a name="bookmark220"></a><span class="font17">To compute the total size of the current directory, we will use this:</span></h6>
<p><span class="font2">sub file_size { -s S_[0] }</span></p>
<p><span class="font2">sub dir_size {</span></p>
<p><span class="font2">my Sdir = shift;</span></p>
<p><span class="font2">my Stotal = -s Sdir;</span></p>
<p><span class="font2">my Sn;</span></p>
<p><span class="font2">for Sn (@_) { Stotal += Sn } return Stotal;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">Stotal_size = dir_walk('.', \&amp;file_size, \&amp;dir_size);</span></p>
<p><span class="font17">The </span><span class="font2">file_size() </span><span class="font17">function says how to compute the size of a plain file, given its name, and the </span><span class="font2">dir_size() </span><span class="font17">function says how to compute the size of a directory, given the directory name and the sizes of its contents.</span></p>
<p><span class="font17">If we want the program to print out the size of every subdirectory, the way the </span><span class="font2">du </span><span class="font17">command does, we add one line:</span></p>
<p><span class="font2">sub file_size { -s S_[0] } sub dir_size {</span></p>
<p><span class="font2">my Sdir = shift;</span></p>
<p><span class="font2">my Stotal = -s Sdir;</span></p>
<p><span class="font2">my Sn;</span></p>
<p><span class="font2">for Sn (@_) { Stotal += Sn }</span></p>
<p><span class="font2" style="font-weight:bold;">printf &quot;%6d %s</span><span class="font2">\</span><span class="font2" style="font-weight:bold;">n&quot;, Stotal, $dir;</span></p>
<p><span class="font2">return Stotal;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">Stotal_size = dir_walk('.', \&amp;file_size, \&amp;dir_size);</span></p>
<p><span class="font17">This produces an output like this:</span></p>
<table border="1">
<tr><td>
<p><span class="font2">4528</span></p></td><td>
<p><span class="font2">./a</span></p></td></tr>
<tr><td style="vertical-align:bottom;">
<p><span class="font2">4444</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">./b</span></p></td></tr>
<tr><td style="vertical-align:bottom;">
<p><span class="font2">5553</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">./c/d</span></p></td></tr>
<tr><td style="vertical-align:bottom;">
<p><span class="font2">11675</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">./c</span></p></td></tr>
<tr><td style="vertical-align:bottom;">
<p><span class="font2">24743</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">.</span></p></td></tr>
</table>
<p><span class="font17">To get the function to produce the hash structure we saw earlier, we can supply the following pair of callbacks:</span></p>
<div>
<p><span class="font9" style="font-weight:bold;">CODE LIBRARY</span></p>
</div><br clear="all">
<p><span class="font2">sub file { my Sfile = shift; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="font0">chr-waU-s^hash</span></p>
<p><span class="font2">[short(Sfile), -s Sfile]; } sub short { my Spath = shift; Spath =- s{.*/}{}; Spath; }</span></p>
<p><span class="font17">The file callback returns an array with the abbreviated name of the file (no full path) and the file size. The aggregation is, as before, performed in the directory callback: </span><span class="font2">sub dir { my (Sdir, @subdirs) = @_; my %new_hash; for (@subdirs) { my (Ssubdir_name, Ssubdir_structure) = @S_; Snew_hash{Ssubdir_name} = Ssubdir_structure; } return [short(Sdir), \%new_hash]; }</span></p>
<p><span class="font17">The directory callback gets the name of the current directory, and a list of namevalue pairs that correspond to the subfiles and subdirectories. It merges these pairs into a hash, and returns a new pair with the short name of the current directory and the newly constructed hash for the current directory.</span></p>
<p><span class="font17">The simpler functions that we wrote before are still easy. Here’s the recursive file lister. We use the same function for files and for directories:</span></p>
<p><span class="font2">sub print_filename { print S_[0], &quot;\n&quot; } dir_walk('.', \&amp;print_filename, \&amp;print_filename);</span></p>
<p><span class="font17">Here’s the dangling symbolic link detector:</span></p>
<p><span class="font2">sub dangles { my Sfile = shift;</span></p>
<div>
<p><span class="font20">24</span></p>
</div><br clear="all">
<p><span class="font15">CHAPTER I Recursion and Callbacks</span></p>
<p><span class="font2">print &quot;Sfile\n&quot; if -l Sfile &amp;&amp;&nbsp;! -e Sfile; } dir_walk('.', \&amp;dangles, sub {});</span></p>
<p><span class="font17">We know that a directory can’t possibly be a dangling symbolic link, so our directory function is the </span><span class="font17" style="font-style:italic;">null function</span><span class="font17"> that returns immediately without doing anything. If we had wanted, we could have avoided this oddity, and its associated function-call overhead, as follows:</span></p>
<div>
<p><span class="font9" style="font-weight:bold;">CODE LIBRARY</span></p>
</div><br clear="all">
<div>
<p><span class="font0">dir-walk-cb-def</span></p>
</div><br clear="all">
<p><span class="font2">sub dir_walk {</span></p>
<p><span class="font2">my (Stop, Sfilefunc, Sdirfunc) = @_;</span></p>
<p><span class="font2">my SDIR;</span></p>
<p><span class="font2">if (-d Stop) {</span></p>
<p><span class="font2">my Sfile;</span></p>
<p><span class="font2">unless (opendir SDIR, Stop) {</span></p>
<p><span class="font2">warn &quot;Couldn’t open directory Stop: S!; skipping.\n&quot;; return;</span></p>
<p><span class="font2">} my @results;</span></p>
<p><span class="font2">while (Sfile = readdir SDIR) {</span></p>
<p><span class="font2">next if Sfile eq '.' || Sfile eq '..';</span></p>
<p><span class="font2">push@results, dir_walk(&quot;Stop/Sfile&quot;, Sfilefunc, Sdirfunc);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2" style="font-weight:bold;">return Sdirfunc ? Sdirfunc-&gt;(Stop, ©results) : () ;</span></p>
<p><span class="font2">} else {</span></p>
<p><span class="font2" style="font-weight:bold;">return Sfilefunc ? Sfilefunc-&gt;(Stop): () ;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">This allows us to write </span><span class="font2">dir_walk('.', \&amp;dangles) </span><span class="font17">instead of </span><span class="font2">dir_walk('.', \&amp;dangles, sub {})</span><span class="font17">.</span></p>
<p><span class="font17">As a final example, let’s use </span><span class="font2">dir_walk() </span><span class="font17">in a slightly different way, to manufacture a list of all the plain files in a file tree, without printing anything:</span></p>
<p><span class="font2">@all_plain_files =</span></p>
<p><span class="font2">dir_walk('.', sub { S_[0] }, sub { shift; return @_ });</span></p>
<p><span class="font17">The file function returns the name of the file it’s invoked on. The directory function throws away the directory name and returns the list of the files it contains. What if a directory contains no files at all? Then it returns an empty list to</span></p>
<p><span class="font15">1.6 FUNCTIONAL VERSUS OBJECT-ORIENTED P R O G R A M M I N G</span></p>
<div>
<p><span class="font20">25</span></p>
</div><br clear="all">
<p><span class="font2">dir_walk()</span><span class="font17">, and this empty list will be merged into the result list for the other directories at the same level.</span></p>
<ul style="list-style:none;"><li>
<h5><a name="bookmark10"></a><span class="font18">1.6 FUNCTIONAL VERSUS OBJECT-ORIENTED PROGRAMMING</span></h5></li></ul>
<p><span class="font17">Now let’s back up a moment and look at what we did. We had a useful function, </span><span class="font2">total_size()</span><span class="font17">, which contained code for walking a directory structure that was going to be useful in other applications. So we made </span><span class="font2">total_size() </span><span class="font17">more general by pulling out all the parts that related to the computation of sizes, and replacing them with calls to arbitrary user-specified functions. The result was </span><span class="font2">dir_walk()</span><span class="font17">. Now, for any program that needs to walk a directory structure and do something, </span><span class="font2">dir_walk() </span><span class="font17">handles the walking part, and the argument functions handle the “do something” part. By passing the appropriate pair of functions to </span><span class="font2">dir_walk()</span><span class="font17">, we can make it do whatever we want it to. We’ve gained flexibility and the chance to re-use the </span><span class="font2">dir_walk() </span><span class="font17">code by factoring out the useful part and parametrizing it with two functional arguments. This is the heart of the functional style of programming.</span></p>
<p><span class="font17">Object-oriented (OO) programming style gets a lot more press these days. The goals of the OO style are the same as those of the functional style: we want to increase the re-usability of software components by separating them into generally useful parts.</span></p>
<p><span class="font17">In an OO system, we could have transformed </span><span class="font2">total_size() </span><span class="font17">analogously, but the result would have looked different. We would have made </span><span class="font2">total_size() </span><span class="font17">into an abstract base class of directory-walking objects, and these objects would have had a method, </span><span class="font2">dir_walk()</span><span class="font17">, which in turn would make calls to two undefined virtual methods called </span><span class="font2">file </span><span class="font17">and </span><span class="font2">directory</span><span class="font17">. (In C++ jargon, these are called </span><span class="font17" style="font-style:italic;">pure virtual methods.)</span><span class="font17"> Such a class wouldn’t have been useful by itself, because the </span><span class="font2">file </span><span class="font17">and </span><span class="font2">directory </span><span class="font17">methods would be missing. To use the class, you would create a subclass that defined the </span><span class="font2">file </span><span class="font17">and </span><span class="font2">directory </span><span class="font17">methods, and then create objects in the subclass. These objects would all inherit the same </span><span class="font2">dir_walk </span><span class="font17">method.</span></p>
<p><span class="font17">In this case, I think the functional style leads to a lighter-weight solution that is easier to use, and that keeps the parameter functions close to the places they are used instead of stuck off in a class file. But the important point is that although the styles are different, the decomposition of the original function into useful components has exactly the same structure. Where the functional style uses functional arguments, the object-oriented style uses pure virtual methods. Although the rest of this book is about the functional style of programming, many of the techniques will be directly applicable to object-oriented programming styles also.</span></p>
<ul style="list-style:none;"><li>
<h5><a name="bookmark11"></a><span class="font18">1.7 HTML</span></h5></li></ul>
<p><span class="font17">I promised that recursion was useful for operating on hierarchically defined data structures, and I used the file system as an example. But it’s a slightly peculiar example of a data structure, since we normally think of data structures as being in memory, not on the disk.</span></p>
<p><span class="font17">What gave rise to the tree structure in the file system was the presence of directories, each of which contains a list of other files. Any domain that has items that include lists of other items will contain tree structures. An excellent example is HTML data.</span></p>
<p><span class="font17">HTML data is a sequence of elements and plain text. Each element has some content, which is a sequence of more elements and more plain text. This is a recursive description, analogous to the description of the file system, and the structure of an HTML document is analogous to the structure of the file system.</span></p>
<p><span class="font17">Elements are tagged with a </span><span class="font17" style="font-style:italic;">start tag,</span><span class="font17"> which looks like this:</span></p>
<p><span class="font2">&lt;font&gt;</span></p>
<p><span class="font17">and a corresponding </span><span class="font17" style="font-style:italic;">end tag,</span><span class="font17"> like this:</span></p>
<p><span class="font2">&lt;/font&gt;</span></p>
<p><span class="font17">The start tag may have a set of </span><span class="font17" style="font-style:italic;">attribute-value pairs,</span><span class="font17"> in which case it might look something like this instead:</span></p>
<p><span class="font2">font size=3 color=&quot;red&quot;&gt;</span></p>
<p><span class="font17">The end tag is the same in any case. It never has any attribute-value pairs.</span></p>
<p><span class="font17">In between the start and end tags can be any sequence of HTML text, including more elements, and also plain text. Here’s a simple example of an HTML document:</span></p>
<p><span class="font2">&lt;h1&gt;What Junior Said Next&lt;/h1&gt;</span></p>
<p><span class="font2">&lt;p&gt;But I don’t font size=3 color=&quot;red&quot;&gt;want&lt;/font&gt; to go to bed now!&lt;/p&gt;</span></p>
<p><span class="font17">This document’s structure is shown in Figure 1.3.</span></p><img src="HigherOrderPerl_files/HigherOrderPerl-5.jpg" alt="" style="width:258pt;height:111pt;">
<p><span class="font14" style="font-variant:small-caps;">figure 1.3 </span><span class="font16">An HTML document.</span></p>
<p><span class="font17">The main document has three components: the </span><span class="font2">&lt;h1&gt; </span><span class="font17">element, with its contents; the </span><span class="font2">&lt;p&gt; </span><span class="font17">element, with its contents; and the blank space in between. The </span><span class="font2">&lt;p&gt; </span><span class="font17">element, in turn, has three components: the untagged text before the </span><span class="font2">&lt;font&gt; </span><span class="font17">element; the </span><span class="font2">&lt;font&gt; </span><span class="font17">element, with its contents; and the untagged text after the </span><span class="font2">&lt;font&gt; </span><span class="font17">element. The </span><span class="font2">&lt;h1&gt; </span><span class="font17">element has one component, which is the untagged text </span><span class="font2">What Junior Said Next</span><span class="font17">.</span></p>
<p><span class="font17">In Chapter 8, we’ll see how to build parsers for languages like HTML. In the meantime, we’ll look at a semi-standard module, </span><span class="font2">HTML::TreeBuilder</span><span class="font17">, which converts an HTML document into a tree structure.</span></p>
<p><span class="font17">Let’s suppose that the HTML data is already in a variable, say </span><span class="font2">$html</span><span class="font17">. The following code uses </span><span class="font2">HTML::TreeBuilder </span><span class="font17">to transform the text into an explicit tree structure:</span></p>
<p><span class="font2">use HTML::TreeBuilder;</span></p>
<p><span class="font2">my $tree = HTML::TreeBuilder-&gt;new;</span></p>
<p><span class="font2">$tree-&gt;ignore_ignorable_whitespace(0);</span></p>
<p><span class="font2">$tree-&gt;parse($html);</span></p>
<p><span class="font2">$tree-&gt;eof();</span></p>
<p><span class="font17">The </span><span class="font2">ignore_ignorable_whitespace() </span><span class="font17">method tells </span><span class="font2">HTML::TreeBuilder </span><span class="font17">that it’s not allowed to discard certain whitespace, such as the newlines after the </span><span class="font2">&lt;h1&gt; </span><span class="font17">element, that are normally ignorable.</span></p>
<p><span class="font17">Now </span><span class="font2">$tree </span><span class="font17">represents the tree structure. It’s a tree of hashes; each hash is a node in the tree and represents one element. Each hash has a </span><span class="font2">_tag </span><span class="font17">key whose value is its tag name, and a </span><span class="font2">_content </span><span class="font17">key whose value is a list of the element’s contents, in order; each item in the </span><span class="font2">_content </span><span class="font17">list is either a string, representing tagless text, or another hash, representing another element. If the tag also has attribute-value pairs, they’re stored in the hash directly, with attributes as hash keys and the corresponding values as hash values.</span></p>
<div>
<p><span class="font20">28</span></p>
</div><br clear="all">
<p><span class="font15" style="font-variant:small-caps;">chapter</span><span class="font15"> I Recursion and Callbacks</span></p>
<p><span class="font17">So for example, the tree node that corresponds to the </span><span class="font2">&lt;font&gt; </span><span class="font17">element in the example looks like this:</span></p>
<p><span class="font2">{ _tag =&gt; &quot;font&quot;, _content =&gt; [ &quot;want&quot; ], color =&gt; &quot;red&quot;, size =&gt; 3,</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">The tree node that corresponds to the </span><span class="font2">&lt;p&gt; </span><span class="font17">element contains the </span><span class="font2">&lt;font&gt; </span><span class="font17">node, and looks like this:</span></p>
<p><span class="font2">{ _tag =&gt; &quot;p&quot;,</span></p>
<p><span class="font2">_content =&gt; [ &quot;But I don't &quot;,</span></p>
<p><span class="font2">{ _tag =&gt; &quot;font&quot;,</span></p>
<p><span class="font2">_content =&gt; [ &quot;want&quot; ],</span></p>
<p><span class="font2">color =&gt; &quot;red&quot;,</span></p>
<p><span class="font2">size =&gt; 3,</span></p>
<p><span class="font2">},</span></p>
<p><span class="font2">&quot; to go to bed now!&quot;,</span></p>
<p><span class="font2">],</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">It’s not hard to build a function that walks one of these HTML trees and “untags” all the text, stripping out the tags. For each item in a </span><span class="font2">_content </span><span class="font17">list, we can recognize it as an element with the </span><span class="font2">ref() </span><span class="font17">function, which will yield true for elements (which are hash references) and false for plain strings:</span></p>
<div>
<p><span class="font9" style="font-weight:bold;">CODE LIBRARY</span></p>
</div><br clear="all">
<div>
<p><span class="font0">untag-html</span></p>
</div><br clear="all">
<p><span class="font2">sub untag_html {</span></p>
<p><span class="font2">my ($html) = @_;</span></p>
<p><span class="font2">return $html unless ref $html; # It’s a plain string</span></p>
<p><span class="font2">my $text = '';</span></p>
<p><span class="font2">for my $item (@{$html-&gt;{_content}}) {</span></p>
<p><span class="font2">$text .= untag_html($item);</span></p>
<p><span class="font2">} return $text;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">The function checks to see if the HTML item passed in is a plain string, and if so the function returns it immediately. If it’s not a plain string, the function assumes that it is a tree node, as described above, and iterates over its content, recursively converting each item to plain text, accumulating the resulting strings, and returning the result. For our example, this is:</span></p>
<p><span class="font2">What Junior Said Next But I don't want to go to bed now!</span></p>
<p><span class="font17">Sean Burke, the author of </span><span class="font2">HTML::TreeBuilder</span><span class="font17">, tells me that accessing the internals of the </span><span class="font2">HTML::TreeBuilder </span><span class="font17">objects this way is naughty, because he might change them in the future. Robust programs should use the accessor methods that the module provides. In these examples, we will continue to access the internals directly.</span></p>
<p><span class="font17">We can learn from </span><span class="font2">dir_walk() </span><span class="font17">and make this function more useful by separating it into two parts: the part that processes an HTML tree, and the part that deals with the specific task of assembling plain text:</span></p>
<p><span class="font2">sub walk_html {</span></p>
<div>
<p><span class="font9" style="font-weight:bold;">CODE LIBRARY</span></p>
</div><br clear="all">
<div>
<p><span class="font0">walk-html</span></p>
</div><br clear="all">
<p><span class="font2">my ($html, $textfunc, $elementfunc) = @_;</span></p>
<p><span class="font2">return $textfunc-&gt;($html) unless ref $html; # It’s a plain string</span></p>
<p><span class="font2">my @results;</span></p>
<p><span class="font2">for my $item (@{$html-&gt;{_content}}) {</span></p>
<p><span class="font2">push @results, walk_html($item, $textfunc, $elementfunc);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">return $elementfunc-&gt;($html, @results);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">This function has exactly the same structure as </span><span class="font2">dir_walk()</span><span class="font17">. It gets two auxiliary functions as arguments: a </span><span class="font2">$textfunc </span><span class="font17">that computes some value of interest for a plain text string, and an </span><span class="font2">$elementfunc </span><span class="font17">that computes the corresponding value for an element, given the element and the values for the items in its content. </span><span class="font2">$textfunc </span><span class="font17">is analogous to the </span><span class="font2">$filefunc </span><span class="font17">from </span><span class="font2">dir_walk()</span><span class="font17">, and </span><span class="font2">$elementfunc </span><span class="font17">is analogous to the </span><span class="font2">$dirfunc</span><span class="font17">.</span></p>
<p><span class="font17">Now we can write our untagger like this:</span></p>
<p><span class="font2">walk_html($tree, sub { $_[0] }, sub { shift; join '', @_ });</span></p>
<p><span class="font17">The </span><span class="font2">$textfunc </span><span class="font17">argument is a function that returns its argument unchanged. The </span><span class="font2">$elementfunc </span><span class="font17">argument is a function that throws away the element itself, then concatenates the texts that were computed for its contents, and returns the concatenation. The output is identical to that of </span><span class="font2">untag_html()</span><span class="font17">.</span></p>
<div>
<p><span class="font20">30</span></p>
</div><br clear="all">
<p><span class="font15" style="font-variant:small-caps;">chapter</span><span class="font15"> I Recursion and Callbacks</span></p>
<p><span class="font17">Suppose we want a document summarizer that prints out the text that is inside of </span><span class="font2">&lt;h1&gt; </span><span class="font17">tags and throws away everything else:</span></p>
<p><span class="font2">sub print_if_h1tag {</span></p>
<p><span class="font2">my Selement = shift;</span></p>
<p><span class="font2">my Stext = join '', @_;</span></p>
<p><span class="font2">print Stext if Selement-&gt;{_tag} eq 'hl';</span></p>
<p><span class="font2">return Stext;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">walk_html(Stree, sub { S_[0] }, \&amp;print_if_h1tag);</span></p>
<p><span class="font17">This is essentially the same as </span><span class="font2">untag_html()</span><span class="font17">, except that when the element function sees that it is processing an </span><span class="font2">&lt;h1&gt; </span><span class="font17">element, it prints out the untagged text.</span></p>
<p><span class="font17">If we want the function to </span><span class="font17" style="font-style:italic;">return</span><span class="font17"> the header text instead of printing it out, we have to get a little trickier. Consider an example like this:</span></p>
<p><span class="font2">&lt;h1&gt;Junior&lt;/h1&gt;</span></p>
<div>
<p><span class="font9" style="font-weight:bold;">CODE LIBRARY</span></p>
</div><br clear="all">
<p><span class="font2">Is a naughty boy.</span></p>
<p><span class="font17">We would like to throw away the text </span><span class="font2">Is a naughty boy</span><span class="font17">, so that it doesn’t appear in the result. But to </span><span class="font2">walk_html()</span><span class="font17">, it is just another plain text item, which looks exactly the same as </span><span class="font2">Junior</span><span class="font17">, which we </span><span class="font17" style="font-style:italic;">don’t</span><span class="font17"> want to throw away. It might seem that we should simply throw away everything that appears inside a non-header tag, but that doesn’t work:</span></p>
<p><span class="font2">&lt;h1&gt;The story of &lt;b&gt;Junior&lt;/b&gt;&lt;/h1&gt;</span></p>
<p><span class="font17">We mustn’t throw away </span><span class="font2">Junior </span><span class="font17">here, just because he’s inside a </span><span class="font2">&lt;b&gt; </span><span class="font17">tag, because that </span><span class="font2">&lt;b&gt; </span><span class="font17">tag is itself inside an </span><span class="font2">&lt;h1&gt; </span><span class="font17">tag, and we want to keep it.</span></p>
<p><span class="font17">We could solve this problem by passing information about the current tag context from each invocation of </span><span class="font2">walk_html() </span><span class="font17">to the next, but it turns out to be simpler to pass information back the other way. Each text in the file is either a “keeper,” because we know it’s inside an </span><span class="font2">&lt;h1&gt; </span><span class="font17">element, or a “maybe,” because we don’t. Whenever we process an </span><span class="font2">&lt;h1&gt; </span><span class="font17">element, we’ll promote all the “maybes” that it contains to “keepers.” At the end, we’ll print the keepers and throw away the maybes:</span></p>
<p class="font2">@tagged_texts = walk_html(Stree, sub { ['MAYBE', S_[0]] },</p>
<p><span class="font0"><sup>extract-header</sup>s &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="font2">\&amp;promote_if_h1tag);</span></p>
<p><span class="font2">sub promote_if_h1tag {</span></p>
<p><span class="font15">1.7 HTML </span><span class="font20">31</span></p>
<p><span class="font2">my $element = shift;</span></p>
<p><span class="font2">if ($element-&gt;{_tag} eq 'hl') {</span></p>
<p><span class="font2">return ['KEEPER', join '', map {$_-&gt;[1]} ©_];</span></p>
<p><span class="font2">} else {</span></p>
<p><span class="font2">return @_;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">The return value from </span><span class="font2">walk_html() </span><span class="font17">will be a list of labeled text items. Each text item is an anonymous array whose first element is either </span><span class="font2">MAYBE </span><span class="font17">or </span><span class="font2">KEEPER</span><span class="font17">, and whose second item is a string. The plain text function simply labels its argument as a </span><span class="font2">MAYBE</span><span class="font17">. For the string </span><span class="font2">Junior</span><span class="font17">, it returns the labeled item </span><span class="font2">['MAYBE', 'Junior']</span><span class="font17">; for the string </span><span class="font2">Is a naughty boy.</span><span class="font17">, it returns </span><span class="font2">['MAYBE', 'Is a naughty boy.']</span><span class="font17">.</span></p>
<p><span class="font17">The element function is more interesting. It gets an element and a list of labeled text items. If the element represents an </span><span class="font2">&lt;h1&gt; </span><span class="font17">tag, the function extracts all the texts from its other arguments, joins them together, and labels the result as a </span><span class="font2">KEEPER</span><span class="font17">. If the element is some other kind, the function returns its tagged texts unchanged. These texts will be inserted into the list of labeled texts that are passed to the element function call for the element that is one level up; compare this with the final example of </span><span class="font2">dir_walk() </span><span class="font17">in Section 1.5, which returned a list of filenames in a similar way.</span></p>
<p><span class="font17">Since the final return value from </span><span class="font2">walk_html() </span><span class="font17">is a list of labeled texts, we need to filter them and throw away the ones that are still marked </span><span class="font2">MAYBE</span><span class="font17">. This final pass is unavoidable. Since the function treats an untagged text item differently at the top level than it does when it is embedded inside an </span><span class="font2">&lt;h1&gt; </span><span class="font17">tag, there must be some part of the process that understands when something is at the top level. </span><span class="font2">walk_html() </span><span class="font17">can’t do that because it does the same thing at every level. So we must build one final function to handle the top-level processing:</span></p>
<p><span class="font2">sub extract_headers {</span></p>
<p><span class="font2">my Stree = shift;</span></p>
<p><span class="font2">my @tagged_texts = walk_html($tree, sub { ['MAYBE', $_[0]] }, \&amp;promote_if_h1tag);</span></p>
<p><span class="font2">my ©keepers = grep { $_-&gt;[0] eq 'KEEPER'} @tagged_texts;</span></p>
<p><span class="font2">my ©keeper_text = map { $_-&gt;[1] } ©keepers;</span></p>
<p><span class="font2">my $header_text = join '', ©keeper_text;</span></p>
<p><span class="font2">return $header_text;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">Or we could write it more compactly:</span></p>
<p><span class="font2">sub extract_headers { my $tree = shift;</span></p>
<div>
<h4><a name="bookmark221"></a><span class="font20">32</span></h4>
</div><br clear="all">
<div>
<p><span class="font15">CHAPTER I Recursion and Callbacks</span></p>
</div><br clear="all">
<div>
<p><span class="font2">my @tagged_texts = walk_html($tree, sub { ['MAYBE', $_[0]] }, \&amp;promote_if_h1tag);</span></p>
<p><span class="font2">join '', map { $_-&gt;[1] } grep { $_-&gt;[0] eq 'KEEPER'} @tagged_texts; }</span></p>
</div><br clear="all">
<div>
<h5><a name="bookmark12"></a><span class="font19">1.7.1 More Flexible Selection</span></h5>
</div><br clear="all">
<div>
<p><span class="font17">We just saw how to extract all the </span><span class="font2">&lt;h1&gt;</span><span class="font17">-tagged text in an HTML document. The essential procedure was </span><span class="font2">promote_if_h1tag()</span><span class="font17">. But we might come back next time and want to extract a more detailed summary, which included all the text from </span><span class="font2">&lt;h1&gt;</span><span class="font17">, </span><span class="font2">&lt;h2&gt;</span><span class="font17">, </span><span class="font2">&lt;h3&gt;</span><span class="font17">, and any other </span><span class="font2">&lt;h&gt; </span><span class="font17">tags present. To get this, we’d need to make a small change to </span><span class="font2">promote_if_h1tag() </span><span class="font17">and turn it into a new function:</span></p>
<p><span class="font2">sub promote_if_h1tag {</span></p>
<p><span class="font2">my $element = shift;</span></p>
<p><span class="font2" style="font-weight:bold;">if ($element-&gt;{_tag} =</span><span class="font2">- </span><span class="font2" style="font-weight:bold;">/</span><span class="font1"><sup>A</sup></span><span class="font2" style="font-weight:bold;">h\d+$/) {</span></p>
<p><span class="font2">return ['KEEPER', join '', map {$_-&gt;[1]} @_];</span></p>
<p><span class="font2">} else {</span></p>
<p><span class="font2">return @_;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
</div><br clear="all">
<div>
<p><span class="font17">But if </span><span class="font2">promote_if_h1tag </span><span class="font17">is more generally useful than we first realized, it will be a good idea to factor out the generally useful part. We can do that by parametrizing the part that varies:</span></p>
</div><br clear="all">
<div>
<p><span class="font9" style="font-weight:bold;">CODE LIBRARY</span></p>
</div><br clear="all">
<div>
<p><span class="font0">promote-if</span></p>
</div><br clear="all">
<div>
<p><span class="font2">sub promote_if {</span></p>
<p><span class="font2" style="font-weight:bold;">my $is_interesting = shift;</span></p>
<p><span class="font2">my $element = shift;</span></p>
<p><span class="font2" style="font-weight:bold;">if ($is_interesting-&gt;($element-&gt;{_tag}) {</span></p>
<p><span class="font2">return ['KEEPER', join '', map {$_-&gt;[1]} @_];</span></p>
<p><span class="font2">} else {</span></p>
<p><span class="font2">return @_;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
</div><br clear="all">
<div>
<p><span class="font17">Now instead of writing a special function, </span><span class="font2">promote_if_h1tag()</span><span class="font17">, we can express the same behavior as a special case of </span><span class="font2">promote_if()</span><span class="font17">. Instead of the following:</span></p>
</div><br clear="all">
<div>
<p><span class="font2">my @tagged_texts = walk_html($tree, sub { ['maybe', $_[0]] }, \&amp;promote_if_h1tag);</span></p>
</div><br clear="all">
<p><span class="font15">1.8 WHEN RECURSION BLOWS UP </span><span class="font20">33 </span><span class="font17">we can use this:</span></p>
<p><span class="font2">my @tagged_texts = walk_html($tree,</span></p>
<p><span class="font2">sub { ['maybe', $_[0]] },</span></p>
<p><span class="font2">sub { promote_if(</span></p>
<p><span class="font2">sub { $_[0] eq 'h1'},</span></p>
<p><span class="font2">$_[0])</span></p>
<p><span class="font2">});</span></p>
<p><span class="font17">We’ll see a tidier way to do this in Chapter 7.</span></p>
<ul style="list-style:none;"><li>
<h5><a name="bookmark13"></a><span class="font18">1.8 WHEN RECURSION BLOWS UP</span></h5></li></ul>
<p><span class="font17">Sometimes a problem appears to be naturally recursive, and then the recursive solution is grossly inefficient. A very simple example arises when you want to compute Fibonacci numbers. This is a rather unrealistic example, but it has the benefit of being very simple. We’ll see a more practical example of the same thing in Section 3.7.</span></p>
<ul style="list-style:none;"><li>
<h5><a name="bookmark14"></a><span class="font19">1.8.1 Fibonacci Numbers</span></h5></li></ul>
<p><span class="font17" style="font-style:italic;">Fibonacci numbers</span><span class="font17"> are named for Leonardo of Pisa, whose nickname was Fibonacci, who discussed them in the 13th century in connection with a mathematical problem about rabbits. Initially, you have one pair of baby rabbits. Baby rabbits grow to adults in one month, and the following month they produce a new pair of baby rabbits, making two pairs:</span></p>
<table border="1">
<tr><td></td><td>
<p><span class="font17">Pairs of</span></p></td><td>
<p><span class="font17">Pairs of</span></p></td><td>
<p><span class="font17">Total</span></p></td></tr>
<tr><td style="vertical-align:bottom;">
<p><span class="font17">Month</span></p></td><td style="vertical-align:bottom;">
<p><span class="font17">baby rabbits</span></p></td><td style="vertical-align:bottom;">
<p><span class="font17">adult rabbits</span></p></td><td style="vertical-align:bottom;">
<p><span class="font17">pairs</span></p></td></tr>
<tr><td>
<p><span class="font17">1</span></p></td><td>
<p><span class="font17">1</span></p></td><td>
<p><span class="font17">0</span></p></td><td>
<p><span class="font17">1</span></p></td></tr>
<tr><td style="vertical-align:bottom;">
<p><span class="font17">2</span></p></td><td style="vertical-align:bottom;">
<p><span class="font17">0</span></p></td><td style="vertical-align:bottom;">
<p><span class="font17">1</span></p></td><td style="vertical-align:bottom;">
<p><span class="font17">1</span></p></td></tr>
<tr><td style="vertical-align:bottom;">
<p><span class="font17">3</span></p></td><td style="vertical-align:bottom;">
<p><span class="font17">1</span></p></td><td style="vertical-align:bottom;">
<p><span class="font17">1</span></p></td><td style="vertical-align:bottom;">
<p><span class="font17">2</span></p></td></tr>
</table>
<p><span class="font17">The following month, the baby rabbits grow up and the adults produce a new pair of babies:</span></p>
<ul style="list-style:none;"><li>
<p><span class="font17">4 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3</span></p></li></ul>
<p><span class="font17">The month after that, the babies grow up, and the two pairs of adults each produce a new pair of babies:</span></p>
<ul style="list-style:none;"><li>
<p><span class="font17">5 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5</span></p>
<div>
<h4><a name="bookmark222"></a><span class="font20">34</span></h4>
</div><br clear="all">
<div>
<p><span class="font15" style="font-variant:small-caps;">chapter</span><span class="font15"> I Recursion and Callbacks</span></p>
</div><br clear="all">
<div>
<p><span class="font17">Assuming no rabbits die, and rabbit production continues, how many pairs of rabbits are there in each month?</span></p>
<p><span class="font17">Let </span><span class="font17" style="font-style:italic;">A(n)</span><span class="font17"> be the number of pairs of adults alive in month </span><span class="font17" style="font-style:italic;">n</span><span class="font17"> and </span><span class="font17" style="font-style:italic;">B(n)</span><span class="font17"> be the number of pairs of babies alive in month </span><span class="font17" style="font-style:italic;">n</span><span class="font17">. The total number of pairs of rabbits alive in month </span><span class="font17" style="font-style:italic;">n</span><span class="font17">, which we’ll call </span><span class="font17" style="font-style:italic;">T(n),</span><span class="font17"> is therefore </span><span class="font17" style="font-style:italic;">A</span><span class="font17">(</span><span class="font17" style="font-style:italic;">n</span><span class="font17">) </span><span class="font3">+ </span><span class="font17" style="font-style:italic;">B</span><span class="font17">(</span><span class="font17" style="font-style:italic;">n</span><span class="font17">):</span></p>
</div><br clear="all">
<div>
<p><span class="font17" style="font-style:italic;">T (n) = A(n)</span><span class="font3"> + </span><span class="font17" style="font-style:italic;">B</span><span class="font17">(</span><span class="font17" style="font-style:italic;">n</span><span class="font17">)</span></p>
</div><br clear="all">
<div>
<p><span class="font17">It’s not hard to see that the number of baby rabbits in one month is equal to the number of adult rabbits the previous month, because each pair of adults gives birth to one pair of babies. In symbols, this is </span><span class="font17" style="font-style:italic;">B</span><span class="font17">(</span><span class="font17" style="font-style:italic;">n</span><span class="font17">) </span><span class="font3">= </span><span class="font17" style="font-style:italic;">A(n —</span><span class="font17"> 1). Substituting into our formula, we have:</span></p>
</div><br clear="all">
<div>
<p><span class="font17" style="font-style:italic;">T</span><span class="font17"> (</span><span class="font17" style="font-style:italic;">n</span><span class="font17">) </span><span class="font3">= </span><span class="font17" style="font-style:italic;">A</span><span class="font17">(</span><span class="font17" style="font-style:italic;">n</span><span class="font17">) </span><span class="font3">+ </span><span class="font17" style="font-style:italic;">A(n —</span><span class="font17"> 1)</span></p>
<p><span class="font17">Each month the number of adult rabbits is equal to the total number of rabbits from the previous month, because the babies from the previous month grow up and the adults from the previous month are still alive. In symbols, this is </span><span class="font17" style="font-style:italic;">A</span><span class="font17">(</span><span class="font17" style="font-style:italic;">n</span><span class="font17">) </span><span class="font3">= </span><span class="font17" style="font-style:italic;">T(n —</span><span class="font17"> 1). Substituting into the previous equation, we get:</span></p>
<p><span class="font17" style="font-style:italic;">T</span><span class="font17"> (</span><span class="font17" style="font-style:italic;">n</span><span class="font17">) </span><span class="font3">= </span><span class="font17" style="font-style:italic;">T (n —</span><span class="font17"> 1) </span><span class="font3">+ </span><span class="font17" style="font-style:italic;">T (n —</span><span class="font17"> 2)</span></p>
<p><span class="font17">So the total number of rabbits in month </span><span class="font17" style="font-style:italic;">n</span><span class="font17"> is the sum of the number of rabbits in months </span><span class="font17" style="font-style:italic;">n —</span><span class="font17"> 1 and </span><span class="font17" style="font-style:italic;">n —</span><span class="font17"> 2. Armed with this formula, we can write down the function to compute the Fibonacci numbers:</span></p>
</div><br clear="all">
<div>
<p><span class="font9" style="font-weight:bold;">CODE LIBRARY</span></p>
</div><br clear="all">
<div>
<p><span class="font0">fib</span></p>
</div><br clear="all">
<div>
<p><span class="font2"># Compute the number of pairs of rabbits alive in month n sub fib {</span></p>
<p><span class="font2">my ($month) = @_;</span></p>
<p><span class="font2">if ($month &lt;&nbsp;2) { 1 }</span></p>
<p><span class="font2">else {</span></p>
<p><span class="font2">fib($month-1) + fib($month-2);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
</div><br clear="all"></li></ul>
<p><span class="font17">This is perfectly straightforward, but it has a problem: except for small arguments, it takes forever.<a name="footnote4"></a><sup><a href="#bookmark223">4</a></sup><sup></sup> If you ask for </span><span class="font2">fib(2 5)</span><span class="font17">, for example, it needs to make recursive calls to compute </span><span class="font2">fib(24) </span><span class="font17">and </span><span class="font2">fib(23)</span><span class="font17">. But the call to </span><span class="font2">fib(24) </span><span class="font17" style="font-style:italic;">also</span><span class="font17"> makes a recursive call to </span><span class="font2">fib(23)</span><span class="font17">, as well as another to compute </span><span class="font2">fib(22)</span><span class="font17">. Both calls to </span><span class="font2">fib(23) </span><span class="font17">will </span><span class="font17" style="font-style:italic;">also</span><span class="font17"> call </span><span class="font2">fib(22)</span><span class="font17">, for a total of three times. It turns out that </span><span class="font2">fib(21) </span><span class="font17">is computed 5 times, </span><span class="font2">fib(20) </span><span class="font17">is computed 8 times, and </span><span class="font2">fib(19) </span><span class="font17">is computed 13 times.</span></p>
<p><span class="font17">All this computing and recomputing has a heavy price. On my small computer, it takes about four seconds to compute </span><span class="font2">fib(2 5)</span><span class="font17">; it makes 242,785 recursive calls while doing so. It takes about 6.5 seconds to compute </span><span class="font2">fib(26)</span><span class="font17">, and makes 392,835 recursive calls, and about 10.5 seconds to make the 635,621 recursive calls for </span><span class="font2">fib(27)</span><span class="font17">. It takes as long to compute </span><span class="font2">fib(27) </span><span class="font17">as to compute </span><span class="font2">fib(25) </span><span class="font17">and </span><span class="font2">fib(26) </span><span class="font17">put together, and so the running time of the function increases rapidly, more than doubling every time the argument increases by 2.<a name="footnote5"></a><sup><a href="#bookmark224">5</a></sup><sup></sup></span></p>
<p><span class="font17">The running time blows up really fast, and it’s all caused by our repeated computation of things that we already computed. Recursive functions occasionally have this problem, but there’s an easy solution for it, which we’ll see in Chapter 3.</span></p>
<ul style="list-style:none;"><li>
<h5><a name="bookmark15"></a><span class="font19">1.8.2 Partitioning</span></h5></li></ul>
<p><span class="font17">Fibonacci numbers are rather abstruse, and it’s hard to find simple realistic examples of programs that need to compute them.</span></p>
<p><span class="font17">Here’s a somewhat more realistic example. We have some valuable items, which we’ll call “treasures,” and we want to divide them evenly between two people. We know the value of each item, and we would like to ensure that both people get collections of items whose total value is the same. Or, to recast the problem in a more mundane light: we know the weight of each of the various groceries you bought today, and since you’re going to carry them home with one bag in each hand, you want to distribute the weight evenly.</span></p>
<p><span class="font17">To convince yourself that this can be a tricky problem, try dividing up a set of ten items that have these dollar values:</span></p>
<p><span class="font17">$9, $12, $14, $17, $23, $32, $34, $40, $42, and $49</span></p>
<div>
<p><span class="font20">36</span></p>
</div><br clear="all">
<p><span class="font15" style="font-variant:small-caps;">chapter</span><span class="font15"> I Recursion and Callbacks</span></p>
<p><span class="font17">Since the total value of the items is $272, each person will have to receive items totalling $136. Then try:</span></p>
<p><span class="font17">$9, $12, $14, $17, $23, $32, $34, &nbsp;$40, $38, and $49</span></p>
<p><span class="font17">Here I replaced the $42 item with a $38 item, so each person will have to receive items totalling $134.</span></p>
<p><span class="font17">This problem is called the </span><span class="font17" style="font-style:italic;">partition problem.</span><span class="font17"> We’ll generalize the problem a little: instead of trying to divide a list of treasures into two equal parts, we’ll try to find some share of the treasures whose total value is a given target amount. Finding an even division of the treasures is the same as finding a share whose value is half of the total value of all the treasures; then the other share is the rest of the treasures, whose total value is the same.</span></p>
<p><span class="font17">If there is no share of treasures that totals the target amount, our function will return </span><span class="font2">undef</span><span class="font17">:</span></p>
<div>
<p><span class="font9" style="font-weight:bold;">CODE LIBRARY</span></p>
</div><br clear="all">
<div>
<p><span class="font0">find-share</span></p>
</div><br clear="all">
<p><span class="font2">sub find_share {</span></p>
<p><span class="font2">my (Starget, Streasures) = @_;</span></p>
<p><span class="font2">return [] if Starget == 0;</span></p>
<p><span class="font2">return if Starget &lt;&nbsp;0 || @Streasures == 0;</span></p>
<p><span class="font17">We take care of some trivial cases first. If the target amount is exactly zero, then it’s easy to produce a list of treasures that total the target amount: the empty list is sure to have value zero, so we return that right away.</span></p>
<p><span class="font17">If the target amount is less than zero, we can’t possibly hit it, because treasures are assumed to have positive value. In this case no solution can be found and the function can immediately return failure. If there are no treasures, we know we can’t make the target, since we already know the target is larger than zero; we fail immediately.</span></p>
<p><span class="font17">Otherwise, the target amount is positive, and we will have to do some real work:</span></p>
<p><span class="font2">my (Sfirst, @rest) = @Streasures;</span></p>
<p><span class="font2">my Ssolution = find_share(Starget-Sfirst, \@rest);</span></p>
<p><span class="font2">return [Sfirst, @Ssolution] if Ssolution;</span></p>
<p><span class="font2">return &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;find_share(Starget &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;, \@rest);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">Here we copy the list of treasures, and then remove the first treasure from the list. This is because we’re going to consider the simpler problem of how to divide up the treasures without the first treasure. There are two possible divisions: either this first treasure is in the share we’re computing, or it isn’t. If it is, then we have to find a subset of the rest of the treasures whose total value is </span><span class="font2">$target -$first</span><span class="font17">. If it isn’t, then we have to find a subset of the rest of the treasures whose total value is </span><span class="font2">$target</span><span class="font17">. The rest of the code makes recursive calls to </span><span class="font2">find_share </span><span class="font17">to investigate these two cases. If the first one works out, the function returns a solution that includes the first treasure; if the second one works out, it returns a solution that omits the first treasure; if neither works out, it returns </span><span class="font2">undef</span><span class="font17">.</span></p>
<p><span class="font17">Here’s a trace of a sample run. We’ll call </span><span class="font2">find_share(5, [1, 2, 4, 8])</span><span class="font17">:</span></p>
<p><span class="font17">Total &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Remaining</span></p>
<p><span class="font17">Share so far &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;so far &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Target &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;treasures</span></p>
<p><span class="font17">0 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1248</span></p>
<p><span class="font17">None of the trivial cases apply — the target is neither negative nor zero, and the remaining treasure list is not empty — so the function tries allocating the first item, 1, to the share; it then looks for some set of the remaining items that can be made to add up to 4:</span></p>
<p><span class="font17">1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;248</span></p>
<p><span class="font17">The function will continue investigating this situation until it is forced to give up.</span></p>
<p><span class="font17">The function then allocates the first remaining item, 2, toward the share of</span></p>
<p><span class="font17">4, and makes a recursive call to find some set of the last 2 elements that add up to 2:</span></p>
<p><span class="font17">12 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;48</span></p>
<p><span class="font17">Let’s call this “situation </span><span class="font17" style="font-style:italic;">a</span><span class="font17">.” The function will continue investigating this situation until it concludes that situation </span><span class="font17" style="font-style:italic;">a</span><span class="font17"> is hopeless. It tries allocating the 4 to the share, but that overshoots the target total:</span></p>
<p><span class="font17">124 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="font3">-</span><span class="font17">2 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8</span></p>
<p><span class="font17">so it backs up and tries continuing from situation </span><span class="font17" style="font-style:italic;">a without</span><span class="font17"> allocating the 4 to the share:</span></p>
<p><span class="font17">The share is still wanting, so the function allocates the next item, 8, to the share, which obviously overshoots:</span></p>
<p><span class="font17">128 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;11 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="font3">-</span><span class="font17">6</span></p>
<p><span class="font17">Here we have </span><span class="font2">$target &lt;&nbsp;0</span><span class="font17">, so the function fails, and tries omitting 8 instead. This doesn’t work either, as it leaves the share short by 2 of the target, with no</span></p>
<div>
<h4><a name="bookmark225"></a><span class="font20">38</span></h4>
</div><br clear="all">
<div>
<p><span class="font15" style="font-variant:small-caps;">chapter</span><span class="font15"> I Recursion and Callbacks</span></p>
</div><br clear="all">
<div>
<p><span class="font17">items left to allocate:</span></p>
</div><br clear="all">
<div>
<table border="1">
<tr><td></td><td style="vertical-align:bottom;">
<p><span class="font17">Total &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Remaining</span></p></td></tr>
<tr><td>
<p><span class="font17">Share so far</span></p></td><td>
<p><span class="font17">so far &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Target &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;treasures</span></p></td></tr>
<tr><td style="vertical-align:bottom;">
<p><span class="font17">1 2</span></p></td><td style="vertical-align:bottom;">
<p><span class="font17">3 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2</span></p></td></tr>
</table>
</div><br clear="all">
<div>
<p><span class="font17">This is the </span><span class="font2">if (@$treasures == 0) { return undef } </span><span class="font17">case.</span></p>
<p><span class="font17">The function has tried every possible way of making situation </span><span class="font17" style="font-style:italic;">a</span><span class="font17"> work; they all failed. It concludes that allocating both 1 and 2 to the share doesn’t work, and backs up and tries omitting 2 instead:</span></p>
<p><span class="font17">114 &nbsp;48</span></p>
<p><span class="font17">It now tries allocating 4 to the share:</span></p>
<p><span class="font17">1 4 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8</span></p>
</div><br clear="all">
<div>
<p><span class="font17">Now the function has </span><span class="font2">Starget == 0</span><span class="font17">, so it returns success. The allocated treasures are 1 and 4, which add up to the target 5.</span></p>
<p><span class="font17">The idea of ignoring the first treasure and looking for a solution among the remaining treasures, thus reducing the problem to a simpler case, is natural. A solution without recursion would probably end up duplicating the underlying machinery of the recursive solution, and simulating the behavior of the functioncall stack manually.</span></p>
<p><span class="font17">Now solving the partition problem is easy; it’s a call to </span><span class="font2">find_share()</span><span class="font17">, which finds the first share, and then some extra work to compute the elements of the original array that are not included in the first share:</span></p>
</div><br clear="all">
<div>
<p><span class="font9" style="font-weight:bold;">CODE LIBRARY</span></p>
</div><br clear="all">
<div>
<p><span class="font0">partition</span></p>
</div><br clear="all">
<div>
<p><span class="font2">sub partition { my Stotal = 0; my Sshare_2;</span></p>
<p><span class="font2">for my Streasure (@_) { Stotal += Streasure;</span></p>
<p><span class="font2">}</span></p>
</div><br clear="all">
<div>
<p><span class="font2">my Sshare_1 = find_share(Stotal/2, [@_]);</span></p>
<p><span class="font2">return unless defined Sshare_1;</span></p>
<p><span class="font17">First the function computes the total value of all the treasures. Then it asks </span><span class="font2">find_share() </span><span class="font17">to compute a subset of the original treasures whose total value is exactly half. If </span><span class="font2">find_share() </span><span class="font17">returns an undefined value, there was no equal division, so </span><span class="font2">partition() </span><span class="font17">returns failure immediately. Otherwise, it will set about</span></p>
</div><br clear="all">
<p><span class="font15">1.8 WHEN RECURSION BLOWS UP </span><span class="font20">39</span></p>
<p><span class="font17">computing the list of treasures that are </span><span class="font17" style="font-style:italic;">not</span><span class="font17"> in </span><span class="font2">Sshare_1</span><span class="font17">, and this will be the second share:</span></p>
<p><span class="font2">my %in_share_1;</span></p>
<p><span class="font2">for my Streasure (@$share_1) {</span></p>
<p><span class="font2">++$in_share_1{$treasure};</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">for my Streasure (@_) {</span></p>
<p><span class="font2">if (Sin_share_1{Streasure}) {</span></p>
<p><span class="font2">--Sin_share_1{Streasure};</span></p>
<p><span class="font2">} else {</span></p>
<p><span class="font2">push @Sshare_2, Streasure;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">The function uses a hash to count up the number of occurrences of each value in the first share, and then looks at the original list of treasures one at a time. If it saw that a treasure was in the first share, it checks it off; otherwise, it put the treasure into the list of treasures that make up share 2.</span></p>
<p><span class="font2">return (Sshare_1, Sshare_2);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">When it’s done, it returns the two lists of treasures.</span></p>
<p><span class="font17">There’s a lot of code here, but it mostly has to do with splitting up a list of numbers. The key line is the call to </span><span class="font2">find_share()</span><span class="font17">, which actually computes the solution; this is </span><span class="font2">Sshare_1</span><span class="font17">. The rest of the code is all about producing a list of treasures that </span><span class="font17" style="font-style:italic;">aren’t</span><span class="font17"> in </span><span class="font2">Sshare_1</span><span class="font17">; this is </span><span class="font2">Sshare_2</span><span class="font17">.</span></p>
<p><span class="font17">The </span><span class="font2">find_share </span><span class="font17">function, however, has a problem: it takes much too long to run, especially if there is no solution. It has essentially the same problem as </span><span class="font2">fib </span><span class="font17">did: it repeats the same work over and over. For example, suppose it is trying to find a division of </span><span class="font2">1 2 3 4 5 6 7 </span><span class="font17">with target sum 14. It might be investigating shares that contain 1 and 3, and then look to see if it can make </span><span class="font2">5 6 7 </span><span class="font17">hit the target sum of 10. It can’t, so it will look for other solutions. Later on, it might investigate shares that contain 4, and again look to see if it can make </span><span class="font2">5 6 7 </span><span class="font17">hit the target sum of 10. This is a waste of time; </span><span class="font2">find_share </span><span class="font17">should remember that </span><span class="font2">5 6 7 </span><span class="font17">cannot hit a target sum of 10 from the first time it investigated that.</span></p>
<p><span class="font17">We will see in Chapter 3 how to fix this.</span></p>
<p><span class="font14">CHAPTER</span></p>
<h3><a name="bookmark226"></a><span class="font25">DISPATCH TABLES</span></h3>
<p><span class="font17">In Chapter 1, we saw how to make functions more flexible by parametrizing their behaviors in terms of other functions. For example, instead of hardwiring the </span><span class="font2">hanoi() </span><span class="font17">function to print a certain message every time it wanted to move a disk, we had it call a secondary function that was passed in from outside. By supplying an appropriate secondary function, we could make </span><span class="font2">hanoi() </span><span class="font17">print out a list of instructions, or check its own moves, or generate a graphic display, without recoding the basic algorithm. Similarly, we were able to abstract the directory-walking behavior away from the file-size-computing behavior of our </span><span class="font2">total_size() </span><span class="font17">function to get a more useful and generally applicable </span><span class="font2">dir_walk() </span><span class="font17">function that could be used to do all sorts of different things.</span></p>
<p><span class="font17">To abstract behavior out of </span><span class="font2">hanoi() </span><span class="font17">and </span><span class="font2">dir_walk()</span><span class="font17">, we made use of code references. We passed </span><span class="font2">hanoi() </span><span class="font17">and </span><span class="font2">dir_walk() </span><span class="font17">additional functions as arguments, effectively treating the secondary functions as pieces of data. Code references make this possible.</span></p>
<p><span class="font17">Now we’ll leave recursion for awhile and go off in a different direction that shows another use of code references.</span></p>
<ul style="list-style:none;"><li>
<h5><a name="bookmark17"></a><span class="font18">2.1 CONFIGURATION FILE HANDLING</span></h5></li></ul>
<p><span class="font17">Let’s suppose that we have an application that reads in a configuration file in the following format:</span></p>
<p><span class="font2">VERBOSITY &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8</span></p>
<p><span class="font2">CHDIR &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/usr/local/app</span></p>
<p><span class="font2">LOGFILE &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;log</span></p>
<p><span class="font17">We would like to read in this configuration file and take an appropriate action for each directive. For example, for the </span><span class="font2">VERBOSITY </span><span class="font17">directive, we just want to set a global variable. But for the </span><span class="font2">LOGFILE </span><span class="font17">directive, we want to immediately redirect the program’s diagnostic messages to the specified file. For </span><span class="font2">CHDIR </span><span class="font17">we might like the program to </span><span class="font2">chdir </span><span class="font17">to the specified directory so that subsequent file operations are relative to the new directory. This means that in the preceding example the </span><span class="font2">LOGFILE </span><span class="font17">is </span><span class="font2">/usr/local/app/log</span><span class="font17">, and not the </span><span class="font2">log </span><span class="font17">file in whatever directory the user happened to be in at the time the program was run.</span></p>
<p><span class="font17">Many programmers would see this problem and immediately envision a function with a giant </span><span class="font2">if-else </span><span class="font17">switch in it, perhaps something like this:</span></p>
<p><span class="font2">sub read_config {</span></p>
<p><span class="font2">my ($filename) = @_;</span></p>
<p><span class="font2">open my($CF), $filename or return; # Failure</span></p>
<p><span class="font2">while (&lt;$CF&gt;) {</span></p>
<p><span class="font2">chomp;</span></p>
<p><span class="font2">my ($directive, $rest) = split /\s+/, $_, 2;</span></p>
<p><span class="font2">if ($directive eq 'CHDIR') {</span></p>
<p><span class="font2">chdir($rest) or die &quot;Couldn’t chdir to '$rest': $!; aborting&quot;;</span></p>
<p><span class="font2">} elsif ($directive eq 'LOGFILE') {</span></p>
<p><span class="font2">open STDERR, &quot;&gt;&gt;&quot;, $rest</span></p>
<p><span class="font2">or die &quot;Couldn’t open log file '$rest': $!; aborting&quot;;</span></p>
<p><span class="font2">} elsif ($directive eq 'VERBOSITY') {</span></p>
<p><span class="font2">$VERBOSITY = $rest;</span></p>
<p><span class="font2">} elsif ($directive eq ...) {</span></p>
<p><span class="font2">...</span></p>
<p><span class="font2">} ...</span></p>
<p><span class="font2">} else {</span></p>
<p><span class="font2">die &quot;Unrecognized directive $directive on line $. of $filename; aborting&quot;;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">return 1; # Success</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">This function is in two parts. The first part opens the file and reads lines from it one at a time. It separates each line into a </span><span class="font2">$directive </span><span class="font17">part (the first word) and a </span><span class="font2">$rest </span><span class="font17">part (the rest). The </span><span class="font2">$rest </span><span class="font17">part contains the arguments to the directive, such as the name of the log file to open when supplied with the </span><span class="font2">LOGFILE </span><span class="font17">directive. The second part of the function is a big </span><span class="font2">if-else </span><span class="font17">tree that checks the </span><span class="font2">$directive </span><span class="font17">variable to see which directive it is, and aborts the program if the directive is unrecognized.</span></p>
<p><span class="font17">This sort of function can get very large, because of the many alternatives in the </span><span class="font2">if-else </span><span class="font17">tree. Each time someone wants to add another directive, they change the function by adding another </span><span class="font2">elsif </span><span class="font17">clause. The contents of the branches of the </span><span class="font2">if-else </span><span class="font17">tree don’t have much to do with each other, except for the inessential fact that they’re all configurable. Such a function violates an important law of programming: Related things should be kept together; unrelated things should be separated.</span></p>
<p><span class="font17">Following this law suggests a different structure for this function: The part that reads and parses the file should be separate from the actions that are performed when the configuration directives are recognized. Moreover, the code for implementing the various unrelated directives should not be lumped together into a single function.</span></p>
<ul style="list-style:none;"><li>
<h5><a name="bookmark18"></a><span class="font19">2.1.1 Table-Driven Configuration</span></h5></li></ul>
<p><span class="font17">We can do better by separating the code for opening, reading, and parsing the configuration file from the unrelated segments that implement the various directives. Dividing the program into two halves like this will give us better flexibility to modify each of the halves, and to separate the code for the directives.</span></p>
<p><span class="font17">Here’s a replacement for </span><span class="font2">read_config()</span><span class="font17">:</span></p>
<p><span class="font2">sub read_config {</span></p>
<div>
<p><span class="font9" style="font-weight:bold;">CODE LIBRARY</span></p>
</div><br clear="all">
<div>
<p><span class="font0">rdconfig-tabular</span></p>
</div><br clear="all">
<p><span class="font2">my ($filename, $actions) = @_;</span></p>
<p><span class="font2">open my(SCF), Sfilename or return; # Failure</span></p>
<p><span class="font2">while (&lt;$CF&gt;) {</span></p>
<p><span class="font2">chomp;</span></p>
<p><span class="font2">my (Sdirective, $rest) = split /\s+/, $_, 2;</span></p>
<p><span class="font2">if (exists $actions-&gt;{$directive}) {</span></p>
<p><span class="font2">$actions-&gt;{$directive}-&gt;($rest);</span></p>
<p><span class="font2">} else {</span></p>
<p><span class="font2">die &quot;Unrecognized directive $directive on line $. of $filename; aborting&quot;; }</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">return 1; # Success</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">We open, read, and parse the configuration file exactly as before. But we dispense with the giant </span><span class="font2">if-else </span><span class="font17">switch. Instead, this version of </span><span class="font2">read_config </span><span class="font17">receives an extra argument, </span><span class="font2">$actions</span><span class="font17">, which is a table of actions; each time </span><span class="font2">read_config() </span><span class="font17">reads a configuration directive, it will perform one of these actions. This table is called a </span><span class="font17" style="font-style:italic;">dispatch table,</span><span class="font17"> because it contains the functions to which </span><span class="font2">read_config() </span><span class="font17">will dispatch control as it reads the file. The </span><span class="font2">$rest </span><span class="font17">variable has the same meaning as before, but now it is passed to the appropriate action function as an argument.</span></p>
<p><span class="font17">A typical dispatch table might look like this:</span></p>
<p><span class="font2">$dispatch_table =</span></p>
<p><span class="font2">{ CHDIR &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&gt; \&amp;change_dir,</span></p>
<p><span class="font2">LOGFILE &nbsp;&nbsp;&nbsp;=&gt; \&amp;open_log_file,</span></p>
<p><span class="font2">VERBOSITY &nbsp;=&gt; \&amp;set_verbosity,</span></p>
<p><span class="font2">... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&gt; &nbsp;&nbsp;...,</span></p>
<p><span class="font2">};</span></p>
<p><span class="font17">The dispatch table is a hash, whose keys (generically called </span><span class="font17" style="font-style:italic;">tags)</span><span class="font17"> are directive names, and whose values are </span><span class="font17" style="font-style:italic;">actions,</span><span class="font17"> references to subroutines that are invoked when the appropriate directive name is recognized. Action functions expect to receive the </span><span class="font2">$rest </span><span class="font17">variable as an argument; typical actions look like these:</span></p>
<p><span class="font2">sub change_dir { my ($dir) = @_;</span></p>
<p><span class="font2">chdir($dir)</span></p>
<p><span class="font2">or die &quot;Couldn’t chdir to '$dir': $!; aborting&quot;;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">sub open_log_file {</span></p>
<p><span class="font2">open STDERR, &quot;&gt;&gt;&quot;, $_[0]</span></p>
<p><span class="font2">or die &quot;Couldn’t open log file '$_[0]': $!; aborting&quot;;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">sub set_verbosity {</span></p>
<p><span class="font2">$VERBOSITY = shift</span></p>
<p><span class="font2">}</span></p>
<h6><a name="bookmark227"></a><span class="font17">If the actions are small, we can put them directly into the dispatch table:</span></h6>
<p><span class="font2">Sdispatch_table =</span></p>
<p><span class="font2">{ CHDIR =&gt; sub { my (Sdir) = @_;</span></p>
<p><span class="font2">chdir(Sdir) or</span></p>
<p><span class="font2">die &quot;Couldn’t chdir to 'Sdir': $!; aborting&quot;;</span></p>
<p><span class="font2">},</span></p>
<p><span class="font2">LOGFILE =&gt; sub { open STDERR, &quot;&gt;&gt;&quot;, $_[0] or</span></p>
<p><span class="font2">die &quot;Couldn’t open log file 'S_[0]': $!; aborting&quot;;</span></p>
<p><span class="font2">},</span></p>
<p><span class="font2">VERBOSITY =&gt; sub { SVERBOSITY = shift },</span></p>
<p><span class="font2">■ ■■ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="font2" style="font-style:italic;">^~'^&gt;</span><span class="font2"> ■ ■■,</span></p>
<p><span class="font2">};</span></p>
<p><span class="font17">By switching to a dispatch table, we’ve eliminated the huge </span><span class="font2">if-else </span><span class="font17">tree, but in return we’ve gotten a table that is only a little smaller. That might not seem like a big win. But the table provides several benefits.</span></p>
<ul style="list-style:none;"><li>
<h5><a name="bookmark19"></a><span class="font19">2.1.2 Advantages of Dispatch Tables</span></h5></li></ul>
<p><span class="font17">The dispatch table is data, instead of code, so it can be modified at run time.</span></p>
<p><span class="font17">You can insert new directives into the table whenever you want to. Suppose the table has:</span></p>
<p><span class="font2">'DEFINE' =&gt; \&amp;define_config_directive,</span></p>
<p><span class="font17">where </span><span class="font2">define_config_directive() </span><span class="font17">is:</span></p>
<p><span class="font2">sub define_config_directive {</span></p>
<div>
<p><span class="font9" style="font-weight:bold;">CODE LIBRARY</span></p>
</div><br clear="all">
<div>
<p><span class="font0">def-conf-dir</span></p>
</div><br clear="all">
<p><span class="font2">my Srest = shift;</span></p>
<p><span class="font2">Srest =- s/</span><span class="font1"><sup>A</sup></span><span class="font2">\s+//;</span></p>
<p><span class="font2">my (Snew_directive, Sdef_txt) = split /\s+/, Srest, 2;</span></p>
<p><span class="font2">if (exists SCONFIG_DIRECTIVE_TABLE{Snew_directive}) { warn &quot;Snew_directive already defined; skippingAn&quot;; return;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">my Sdef = eval &quot;sub { Sdef_txt }&quot;;</span></p>
<p><span class="font2">if (not defined $def) {</span></p>
<p><span class="font2">warn &quot;Could not compile definition for '$new_directive': $@; skipping.\n&quot;; return;</span></p>
<p><span class="font2">} $CONFIG_DIRECTIVE_TABLE{$new_directive} = $def;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">The configurator now accepts directives like this:</span></p>
<p><span class="font2">DEFINE HOME &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;chdir('/usr/local/app');</span></p>
<p><span class="font2">define_config_directive() </span><span class="font17">puts </span><span class="font2">HOME </span><span class="font17">into </span><span class="font2">$new_directive </span><span class="font17">and </span><span class="font2">chdir('/usr/local/app'); </span><span class="font17">into </span><span class="font2">$def_txt</span><span class="font17">. It uses </span><span class="font2">eval </span><span class="font17">to compile the definition text into a subroutine, and installs the new subroutine into a master configuration table, </span><span class="font2">%CONFIG_DIRECTIVE_TABLE</span><span class="font17">, using </span><span class="font2">HOME </span><span class="font17">as the key. If </span><span class="font2">%CONFIG_DIRECTIVE_TABLE </span><span class="font17">were in fact the dispatch table that was passed to </span><span class="font2">read_config() </span><span class="font17">in the first place, then </span><span class="font2">read_config() </span><span class="font17">will see the new definition, and will have an action associated with </span><span class="font2">HOME </span><span class="font17">if it sees the </span><span class="font2">HOME </span><span class="font17">directive on a later line of the input file. Now a config file can say:</span></p>
<p><span class="font2">DEFINE HOME chdir('/usr/local/app');</span></p>
<p><span class="font2">CHDIR /some/directory</span></p>
<p><span class="font2">...</span></p>
<p><span class="font2">HOME</span></p>
<p><span class="font17">The directives in </span><span class="font2">... </span><span class="font17">are invoked in the directory </span><span class="font2">/some/directory. </span><span class="font17">When the processor reaches </span><span class="font2">HOME</span><span class="font17">, it returns to its home directory. We can also define a more robust version of the same thing:</span></p>
<p><span class="font2">DEFINE PUSHDIR use Cwd; push @dirs, cwd(); chdir($_[0])</span></p>
<p><span class="font2">DEFINE POPDIR chdir(pop @dirs)</span></p>
<p><span class="font2">PUSHDIR </span><span class="font17" style="font-style:italic;">dir</span><span class="font17"> uses the </span><span class="font2">cwd() </span><span class="font17">function provided by the standard </span><span class="font2">Cwd </span><span class="font17">module to figure out the name of the current directory. It saves the name of the current directory in the variable </span><span class="font2">@dirs</span><span class="font17">, and then changes to </span><span class="font17" style="font-style:italic;">dir.</span><span class="font2"> POPDIR </span><span class="font17">undoes the effect of the last </span><span class="font2">PUSHDIR:</span></p>
<p><span class="font2">PUSHDIR /tmp</span></p>
<p><span class="font2">A</span></p>
<p><span class="font2">PUSHDIR /usr/local/app</span></p>
<p><span class="font2">B</span></p>
<p><span class="font2">POPDIR</span></p>
<p><span class="font2">C</span></p>
<p><span class="font2">POPDIR</span></p>
<p><span class="font17">The program changes to </span><span class="font2">/tmp</span><span class="font17">, then executes directive A. Then it changes to </span><span class="font2">/usr/local/app </span><span class="font17">and executes directive B. The following </span><span class="font2">POPDIR </span><span class="font17">returns the program to </span><span class="font2">/tmp</span><span class="font17">, where it executes directive C; finally the second </span><span class="font2">POPDIR </span><span class="font17">returns it to wherever it started out.</span></p>
<p><span class="font17">In order for </span><span class="font2">DEFINE </span><span class="font17">to modify the configuration table, we had to store it in a global variable. It’s probably better if we pass the table to </span><span class="font2">define_config_ directive </span><span class="font17">explicitly. To do that we need to make a small change to </span><span class="font2">read_config</span><span class="font17">:</span></p>
<div>
<p><span class="font9" style="font-weight:bold;">CODE LIBRARY</span></p>
</div><br clear="all">
<p><span class="font2">sub read_config { my ($filename, $actions) = @_; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="font0"><sup>rdc</sup>on<sup>fig</sup>-t<sup>ablearg</sup></span></p>
<p><span class="font2">open my($CF), $filename or return; # Failure while (&lt;$CF&gt;) { chomp; my ($directive, $rest) = split /\s+/, $_, 2; if (exists $actions-&gt;{$directive}) { </span><span class="font2" style="font-weight:bold;">$actions-&gt;{$directive}-&gt;($rest, $actions); </span><span class="font2">} else { die &quot;Unrecognized directive $directive on line $. of $filename; aborting&quot;; } } return 1; # Success }</span></p>
<p class="font17">Now <span class="font2">define_config_directive </span><span class="font17">can look like this: </span><span class="font2">sub define_config_directive {</span></p>
<div>
<p><span class="font9" style="font-weight:bold;">CODE LIBRARY</span></p>
</div><br clear="all">
<p><span class="font2" style="font-weight:bold;">my ($rest, $dispatch_table) = @_; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="font0"><sup>def-cdir-tablearg</sup></span></p>
<p><span class="font2">$rest =- s/</span><span class="font1"><sup>A</sup></span><span class="font2">\s+//; my ($new_directive, $def_txt) = split /\s+/, $rest, 2;</span></p>
<p><span class="font2" style="font-weight:bold;">if (exists $dispatch_table-&gt;{$new_directive}) { </span><span class="font2">warn &quot;$new_directive already defined; skipping.\n&quot;; return; }</span></p>
<p><span class="font2">my $def = eval &quot;sub { $def_txt }&quot;;</span></p>
<p><span class="font2">if (not defined $def) {</span></p>
<p><span class="font2">warn &quot;Could not compile definition for '$new_directive': $@; skipping.\n&quot;; return;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2" style="font-weight:bold;">$dispatch_table-&gt;{$new_directive} = $def;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">With this change, we can add a really useful configuration directive:</span></p>
<p><span class="font2">DEFINE INCLUDE read_config(@_);</span></p>
<p><span class="font17">This installs a new entry into the dispatch table that looks like this:</span></p>
<p><span class="font2">INCLUDE =&gt; sub { read_config(@_) }</span></p>
<p><span class="font17">Now, when we write this in the configuration file:</span></p>
<p><span class="font2">INCLUDE extra.conf</span></p>
<p><span class="font17">the main </span><span class="font2">read_config() </span><span class="font17">will invoke the action, passing it two arguments. The first argument will be the </span><span class="font2">$rest </span><span class="font17">from the configuration file; in this case the filename </span><span class="font2">extra.conf</span><span class="font17">. The second argument to the action will be the dispatch table again. These two arguments will be passed directly to a recursive call of </span><span class="font2">read_config</span><span class="font17">. </span><span class="font2">read_config </span><span class="font17">will read </span><span class="font2">extra.conf</span><span class="font17">, and when it’s finished it will return control to the main invocation of </span><span class="font2">read_config</span><span class="font17">, which will continue with the main configuration file, picking up where it left off.</span></p>
<p><span class="font17">In order for the recursive call to work properly, </span><span class="font2">read_config() </span><span class="font17">must be reentrant. The easiest way to break reentrancy is to use a global variable, for example by using a global filehandle instead of the lexical filehandle we did use. If we had used a global filehandle, the recursive call to </span><span class="font2">read_config() </span><span class="font17">would open </span><span class="font2">extra.conf </span><span class="font17">with the same filehandle that was being used by the main invocation; this would close the main configuration file. When the recursive call returned, </span><span class="font2">read_config() </span><span class="font17">would be unable to read the rest of the main file, because its filehandle would have been closed.</span></p>
<p><span class="font17">The </span><span class="font2">INCLUDE </span><span class="font17">definition was very simple and very useful. But it was also ingenious, and it might not have occurred to us when we were writing </span><span class="font2">read_config</span><span class="font17">. It would have been easy to say “Oh, </span><span class="font2">read_config </span><span class="font17">doesn’t need to be reentrant.” But if we had written </span><span class="font2">read_config </span><span class="font17">in a nonreentrant way, the useful </span><span class="font2">INCLUDE </span><span class="font17">definition wouldn’t have worked. There’s an important lesson to learn here: make functions reentrant by default, because sometimes the usefulness of being able to call a function recursively will be a surprise.</span></p>
<p><span class="font15">2.1 CONFIGURATION FILE HA</span></p>
<p><span class="font17">Reentrant functions exhibit a simpler and more predictable behavior than nonreentrant functions. They are more flexible because they can be called recursively. Our </span><span class="font2">INCLUDE </span><span class="font17">example shows that we might not always anticipate all the reasons why someone might want to invoke a function recursively. It’s better and safer to make everything reentrant if possible.</span></p>
<p><span class="font17">Another advantage of the dispatch table over hardwired code in </span><span class="font2">read_config() </span><span class="font17">is that we can use the same </span><span class="font2">read_config </span><span class="font17">function to process two unrelated files that have totally different directives, just by passing a different dispatch table to </span><span class="font2">read_config() </span><span class="font17">each time. We can put the program into “beginner mode” by passing a stripped-down dispatch table to </span><span class="font2">read_config()</span><span class="font17">. Or we can re-use </span><span class="font2">read_config() </span><span class="font17">to process a different file with the same basic syntax by passing it a table with a different set of directives; an example of this appears in Section 2.1.4.</span></p>
<ul style="list-style:none;"><li>
<h5><a name="bookmark20"></a><span class="font19">2.1.3 Dispatch Table Strategies</span></h5></li></ul>
<p><span class="font17">In our implementation of </span><span class="font2">PUSHDIR </span><span class="font17">and </span><span class="font2">POPDIR</span><span class="font17">, the action functions used a global variable, </span><span class="font2">@dirs</span><span class="font17">, to maintain the stack of pushed directories. This is unfortunate. We can get around this, and make the system more flexible, by having </span><span class="font2">read_config() </span><span class="font17">support a </span><span class="font17" style="font-style:italic;">user parameter.</span><span class="font17"> This is an argument, supplied by the caller of </span><span class="font2">read_config()</span><span class="font17">, which is passed verbatim to the actions:</span></p>
<p><span class="font2">sub read_config {</span></p>
<p><span class="font2" style="font-weight:bold;">my ($filename, $actions, $user_param) = @_;</span></p>
<p><span class="font2">open my($CF), $filename or return; # Failure</span></p>
<p><span class="font2">while (&lt;$CF&gt;) {</span></p>
<p><span class="font2">my ($directive, $rest) = split /\s+/, $_, 2;</span></p>
<p><span class="font2">if (exists $actions-&gt;{$directive}) {</span></p>
<p><span class="font2" style="font-weight:bold;">$actions-&gt;{$directive}-&gt;($rest, $user_param, $actions);</span></p>
<p><span class="font2">} else {</span></p>
<p><span class="font2">die &quot;Unrecognized directive $directive on line $. of $filename }</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">return 1; # Success</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">This eliminates the global variable, because we can now define </span><span class="font2">PUSHDIR </span><span class="font17">and </span><span class="font2">POPDIR </span><span class="font17">like this:</span></p>
<p><span class="font2">DEFINE PUSHDIR use Cwd; push @{$_[1]}, cwd(); chdir($_[0])</span></p>
<p><span class="font2">DEFINE POPDIR chdir(pop @{$_[1])</span></p>
<div>
<p><span class="font15" style="font-variant:small-caps;">ndling</span><span class="font20"> 49</span></p>
</div><br clear="all">
<div>
<p><span class="font9" style="font-weight:bold;">CODE LIBRARY</span></p>
</div><br clear="all">
<div>
<p><span class="font0">rdconfig-uparam</span></p>
</div><br clear="all">
<div>
<p><span class="font2">aborting&quot;;</span></p>
</div><br clear="all">
<div>
<p><span class="font20">50</span></p>
</div><br clear="all">
<p><span class="font15">CHAPTER 2 Dispatch Tables</span></p>
<p><span class="font17">The </span><span class="font2">$_[1] </span><span class="font17">parameter refers to the user-parameter argument that is passed to </span><span class="font2">read_config()</span><span class="font17">. If </span><span class="font2">read_config() </span><span class="font17">is called with:</span></p>
<table border="1">
<tr><td></td><td>
<p><span class="font2">read_config($filename, $dispatch_table, \@dirs);</span></p>
<p><span class="font17">then </span><span class="font2">PUSHDIR </span><span class="font17">and </span><span class="font2">POPDIR </span><span class="font17">will use the array </span><span class="font2">@dirs </span><span class="font17">as their stack; if it is called with:</span></p>
<p><span class="font2">read_config($filename, $dispatch_table, []);</span></p>
<p><span class="font17">then they will use a fresh, anonymous array as the stack.</span></p>
<p><span class="font17">It’s often useful to pass an action callback the name of the tag on whose behalf it was invoked. To do this, we change </span><span class="font2">read_config() </span><span class="font17">like this:</span></p></td></tr>
<tr><td>
<p><span class="font9" style="font-weight:bold;text-decoration:underline;">CODE LIBRARY </span><span class="font0">rdconfig-tagarg</span></p></td><td>
<p><span class="font1">sub read_config { my (Sfilename, $actions, $user_param) = @_; open my($CF), Sfilename or return; # Failure while (&lt;$CF&gt;) {</span></p>
<p><span class="font1">my ($directive, $rest) = split /</span><span class="font2">\</span><span class="font1">s+/, $_, 2; if (exists $actions-&gt;{$directive}) {</span></p>
<p><span class="font1" style="font-weight:bold;">$actions-&gt;{$directive}-&gt;($directive, $rest, Sactions, $user_param);</span></p>
<p><span class="font1">} else { die &quot;Unrecognized directive $directive on line $. of $filename; aborting&quot;;</span></p>
<p><span class="font1">} } return 1; # Success }</span></p>
<p><span class="font17">Why is this useful? Consider the action we defined for the </span><span class="font2">VERBOSITY </span><span class="font17">directive:</span></p>
<p><span class="font2">VERBOSITY =&gt; sub { $VERBOSITY = shift },</span></p>
<p><span class="font17">It’s easy to imagine that there might be several configuration directives that all follow this general pattern:</span></p>
<p><span class="font2">VERBOSITY =&gt; sub { $VERBOSITY = shift }, TABLESIZE =&gt; sub { $TABLESIZE = shift }, PERLPATH =&gt; sub { $PERLPATH = shift }, ... etc ...</span></p>
<p><span class="font17">We would like to merge the three similar actions into a single function that does the work of all three. To do that, the function needs to know the name of the</span></p></td></tr>
</table>
<p><span class="font17">directive so that it can set the appropriate global variable:</span></p>
<p><span class="font2">VERBOSITY =&gt; \&amp;set_var, TABLESIZE =&gt; \&amp;set_var, PERLPATH =&gt; \&amp;set_var, ... etc ...</span></p>
<p><span class="font2">sub set_var {</span></p>
<p><span class="font2">my ($var, $val) = @_;</span></p>
<p><span class="font2">$$var = $val;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">Or, if you don’t like a bunch of global variables running around loose, you can store configuration information in a hash, and pass a reference to the hash as the user parameter:</span></p>
<p><span class="font2">sub set_var {</span></p>
<p><span class="font2">my ($var, $val, undef, $config_hash) = @_;</span></p>
<p><span class="font2">$config_hash-&gt;{$var} = $val;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">In this example, not much is saved, because the action is so simple. But there might be several configuration directives that need to share a more complicated function. Here’s a slightly more complicated example:</span></p>
<p><span class="font2">sub open_input_file {</span></p>
<p><span class="font2">my ($handle, $filename) = @_;</span></p>
<p><span class="font2">unless (open $handle, $filename) {</span></p>
<p><span class="font2">warn &quot;Couldn’t open $handle file '$filename': $!; ignoring.\n&quot;;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">This </span><span class="font2">open_input_file() </span><span class="font17">function can be shared by many configuration directives. For example, suppose a program has three sources of input: a history file, a template file, and a pattern file. We would like the locations of all three files to be configurable in the configuration file; this requires three entries in the dispatch table. But the three entries can all share the same </span><span class="font2">open_input_file() </span><span class="font17">function:</span></p>
<p><span class="font2">HISTORY =&gt; \&amp;open_input_file,</span></p>
<p><span class="font2">TEMPLATE =&gt; \&amp;open_input_file,</span></p>
<div>
<p><span class="font20">52 </span><span class="font15">CHAPTER</span></p>
</div><br clear="all">
<div>
<p><span class="font9" style="font-weight:bold;">CODE LIBRARY</span></p>
</div><br clear="all">
<div>
<p><span class="font0">rdconfig-default</span></p>
</div><br clear="all">
<p><span class="font15">2 Dispatch Tables</span></p>
<p><span class="font2">PATTERN =&gt; \&amp;open_input_file,</span></p>
<p><span class="font2">...</span></p>
<h6><a name="bookmark228"></a><span class="font17">Now suppose the configuration file says:</span></h6>
<p><span class="font2">HISTORY &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/usr/local/app/history</span></p>
<p><span class="font2">TEMPLATE &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/usr/local/app/templates/main.tmpl</span></p>
<p><span class="font2">PATTERN &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/home/bill/app/patterns/default.pat</span></p>
<p><span class="font2">read_config() </span><span class="font17">will see the first line and dispatch to the </span><span class="font2">open_input_file() </span><span class="font17">function, passing it the argument list </span><span class="font2">('HISTORY', '/usr/local/app/history')</span><span class="font17">. </span><span class="font2">open_input_file() </span><span class="font17">will take the </span><span class="font2">HISTORY </span><span class="font17">argument as a filehandle name, and open the </span><span class="font2">HISTORY </span><span class="font17">filehandle to come from the </span><span class="font2">/usr/local/app/history </span><span class="font17">file. On the second line, </span><span class="font2">read_config() </span><span class="font17">will dispatch to the </span><span class="font2">open_input_file() </span><span class="font17">again, this time passing it </span><span class="font2">('TEMPLATE', '/usr/local/app/templates/main.tmpl')</span><span class="font17">. This time, </span><span class="font2">open_input_file() </span><span class="font17">will open the </span><span class="font2">TEMPLATE </span><span class="font17">filehandle instead of the </span><span class="font2">HISTORY </span><span class="font17">filehandle.</span></p>
<ul style="list-style:none;"><li>
<h5><a name="bookmark21"></a><span class="font19">2.1.4 Default Actions</span></h5></li></ul>
<p><span class="font17">Our example </span><span class="font2">read_config() </span><span class="font17">function dies when it encounters an unrecognized directive. This behavior is hardwired in. It would be better if the dispatch table itself carried around the information about what to do for an unrecognized directive. It’s easy to add this feature:</span></p>
<p><span class="font1">sub read_config {</span></p>
<p><span class="font1">my (Sfilename, $actions, $userparam) = @_;</span></p>
<p><span class="font1">open my($CF), Sfilename or return; # Failure</span></p>
<p><span class="font1">while (&lt;$CF&gt;) {</span></p>
<p><span class="font1">chomp;</span></p>
<p><span class="font1">my ($directive, $rest) = split /</span><span class="font2">\</span><span class="font1">s+/, $_, 2;</span></p>
<p><span class="font1" style="font-weight:bold;">my Saction = Sactions-&gt;{Sdirective} || Sactions-&gt;{_DEFAULT_};</span></p>
<p><span class="font1" style="font-weight:bold;">if (Saction) {</span></p>
<p><span class="font1" style="font-weight:bold;">Saction-&gt;(Sdirective, Srest, Sactions, Suserparam);</span></p>
<p><span class="font1">} else {</span></p>
<p><span class="font1">die &quot;Unrecognized directive $directive on line $. of $filename; aborting&quot;;</span></p>
<p><span class="font1">}</span></p>
<p><span class="font1">}</span></p>
<p><span class="font1">return 1; # Success</span></p>
<p><span class="font1">}</span></p>
<p><span class="font15">2.1 CONFIGURATION FILE HANDLING</span></p>
<div>
<p><span class="font20">53</span></p>
</div><br clear="all">
<p><span class="font17">Here the function looks in the action table for the specified directive; if it isn’t there, if looks for a </span><span class="font2">_DEFAULT_ </span><span class="font17">action, and dies only if there is no default specified in the dispatch table. Here’s a typical </span><span class="font2">_DEFAULT_ </span><span class="font17">action:</span></p>
<p><span class="font2">sub no_such_directive {</span></p>
<p><span class="font2">my (Sdirective) = @_;</span></p>
<p><span class="font2">warn &quot;Unrecognized directive Sdirective at line $.; ignoring.\n&quot;;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">Since the directive name is passed as the first argument to the action function, the default action knows what unrecognized directive it was called on behalf of. Since the </span><span class="font2">no_such_directive() </span><span class="font17">function also gets passed the entire dispatch table, it can extract the real directive names and do some pattern matching to figure out what might have been meant. Here </span><span class="font2">no_such_directive() </span><span class="font17">uses a hypothetical </span><span class="font2">score_match() </span><span class="font17">function to decide which table entries are good matches for the unrecognized directive:</span></p>
<p><span class="font2">sub no_such_directive {</span></p>
<p><span class="font2">my (Sbad, Srest, Stable) = @_;</span></p>
<p><span class="font2">my (Sbest_match, Sbest_score);</span></p>
<p><span class="font2">for my Sgood (keys %Stable) {</span></p>
<p><span class="font2">my Sscore = score_match(Sbad, Sgood);</span></p>
<p><span class="font2">if (Sscore &gt;&nbsp;Sbest_score) {</span></p>
<p><span class="font2">Sbest_score = Sscore;</span></p>
<p><span class="font2">Sbest_match = Sgood;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">warn &quot;Unrecognized directive Sbad at line S.;\n&quot;;</span></p>
<p><span class="font2">warn &quot;\t(perhaps you meant Sbest_match?)\n&quot;;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">The system we have now has only a little code, but it’s extremely flexible. Suppose our program is also going to read a list of user IDs and email addresses in the following format:</span></p>
<p><span class="font2">fred &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="mailto:fred@example.com"><span class="font2">fred@example.com</span></a></p>
<p><span class="font2">bill &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="mailto:bvoehno@plover.com"><span class="font2">bvoehno@plover.com</span></a></p>
<p><span class="font2">warez &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="mailto:warez-admin@plover.com"><span class="font2">warez-admin@plover.com</span></a></p>
<div>
<p><span class="font20">54 </span><span class="font15">CH</span></p>
</div><br clear="all">
<p><span class="font15">APTER 2 Dispatch Tables</span></p>
<p><span class="font17">We can re-use </span><span class="font2">read_config() </span><span class="font17">and have it read and parse this file, by supplying the appropriate dispatch table:</span></p>
<p><span class="font2">$address_actions =</span></p>
<p><span class="font2">{ _DEFAULT_ =&gt; sub { my ($id, $addr, $act, $aref) = @_;</span></p>
<p><span class="font2">push @$aref, [$id, $addr];</span></p>
<p><span class="font2">},</span></p>
<p><span class="font2">};</span></p>
<p><span class="font2">read_config($ADDRESS_FILE, $address_actions, \@address_array);</span></p>
<p><span class="font17">Here we’ve given </span><span class="font2">read_config() </span><span class="font17">a very small dispatch table; all it has is a </span><span class="font2">_DEFAULT_ </span><span class="font17">entry. </span><span class="font2">read_config() </span><span class="font17">will call this default entry once for each line in the address file, passing it the “directive name” (which is actually the user ID) and the address (which is the </span><span class="font2">$rest </span><span class="font17">value). The default action will take this information and add it to </span><span class="font2">@address_array</span><span class="font17">, which can be used later by the program.</span></p>
<ul style="list-style:none;"><li>
<h5><a name="bookmark22"></a><span class="font18">2.2 CALCULATOR</span></h5></li></ul>
<p><span class="font17">Let’s get away from the configuration file example for a while. Obviously, dispatch tables are going to make sense in many similar situations. For example, a conversational program that must process commands from a user can use a dispatch table to dispatch the user’s commands. We’ll look at a different example, a very simple calculator.</span></p>
<p><span class="font17">The input to this calculator is a string that contains an arithmetic expression in </span><span class="font17" style="font-style:italic;">reverse Polish notation</span><span class="font17"> (RPN). Conventional arithmetic notation is ambiguous. If you write 2 </span><span class="font3">+ </span><span class="font17">3 </span><span class="font3">• </span><span class="font17">4, it’s not immediately clear whether we do the addition or the multiplication first. We have to have special conventions to say that multiplication always happens before addition, or we have to disambiguate the expression by inserting parentheses, for example, (2 </span><span class="font3">+ </span><span class="font17">3) </span><span class="font3">• </span><span class="font17">4.</span></p>
<p><span class="font17">Reverse Polish notation solves the problem in a different way. Instead of putting the operator symbols in between the arguments that they operate on, RPN puts the operators after their arguments. For example, instead of 2 </span><span class="font3">+ </span><span class="font17">3 we write </span><span class="font2">2 3 +</span><span class="font17">. Instead of (2 </span><span class="font3">+ </span><span class="font17">3) </span><span class="font3">• </span><span class="font17">4, we write </span><span class="font2">2 3 + 4*</span><span class="font17">. The </span><span class="font2">+ </span><span class="font17">follows </span><span class="font2">2 </span><span class="font17">and </span><span class="font2">3</span><span class="font17">, so the 2 and 3 are added; the </span><span class="font2">* </span><span class="font17">says to multiply the two preceding expressions, which are </span><span class="font2">2 3+ </span><span class="font17">and </span><span class="font2">4</span><span class="font17">. To express 2 </span><span class="font3">+ </span><span class="font17">(3 </span><span class="font3">• </span><span class="font17">4) in RPN, we would write </span><span class="font2">2 3 4 *+</span><span class="font17">. The </span><span class="font2">+ </span><span class="font17">applies to the two preceding arguments; the first of these is </span><span class="font2">2 </span><span class="font17">and the second is </span><span class="font2">3 4*</span><span class="font17">. Because the operator always follows its arguments, such expressions are said to be in </span><span class="font17" style="font-style:italic;">postfix form;</span><span class="font17"> this is to contrast them with the usual form, where the operators are in between their arguments, which is called </span><span class="font17" style="font-style:italic;">infix form.</span></p>
<p><span class="font17">It’s easy to compute the value of an expression in RPN. To do this, we maintain a stack, and read the expression from left to right. When we see a number, we push it on the stack. When we see an operator, we pop the top two elements off the stack, operate on them, and push the result back on the stack. For example, to evaluate </span><span class="font2">2 3 + 4 *</span><span class="font17">, we first push 2 and then 3, and then when we see the </span><span class="font2">+ </span><span class="font17">we pop them off and push back the sum, 5. Then we push 4 on top of the 5, and then the </span><span class="font2">* </span><span class="font17">tells us to pop the 4 and the 5 and push back the final answer, 20. To evaluate </span><span class="font2">2 3 4 *+ </span><span class="font17">we push 2, then 3, then 4. The </span><span class="font2">* </span><span class="font17">tells us to pop back the 3 and the 4 and push the product 12; the </span><span class="font2">+ </span><span class="font17">tells us to pop the 12 and the 2 and push the sum, 14, which is the final answer.</span></p>
<p><span class="font17">Here’s a small calculator program that evaluates the RPN expression supplied in its command-line argument:</span></p>
<p><span class="font2">my Sresult = evaluate(SARGV[0]);</span></p>
<div>
<p><span class="font9" style="font-weight:bold;">CODE LIBRARY</span></p>
</div><br clear="all">
<div>
<p><span class="font0">rpn-ifelse</span></p>
</div><br clear="all">
<p><span class="font2">print &quot;Result: Sresult\n&quot;;</span></p>
<p><span class="font2">sub evaluate {</span></p>
<p><span class="font2">my @stack;</span></p>
<p><span class="font2">my (Sexpr) = @_;</span></p>
<p><span class="font2">my ©tokens = split /\s+/, Sexpr;</span></p>
<p><span class="font2">for my Stoken (©tokens) {</span></p>
<p><span class="font2">if (Stoken =- /</span><span class="font1"><sup>A</sup></span><span class="font2">\d+S/) { # It's a number push ©stack, Stoken;</span></p>
<p><span class="font2">} elsif (Stoken eq '+') { push ©stack, pop(©stack) + pop(©stack);</span></p>
<p><span class="font2">} elsif (Stoken eq '-') { my Ss = pop(©stack);</span></p>
<p><span class="font2">push ©stack, pop(©stack) - Ss</span></p>
<p><span class="font2">} elsif (Stoken eq '*') { push ©stack, pop(©stack) * pop(©stack);</span></p>
<p><span class="font2">} elsif (Stoken eq '/') { my Ss = pop(©stack);</span></p>
<p><span class="font2">push ©stack, pop(©stack) / Ss</span></p>
<p><span class="font2">} else { die &quot;Unrecognized token 'Stoken'; aborting&quot;;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">return pop(©stack);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">The function splits the argument on whitespace into </span><span class="font17" style="font-style:italic;">tokens,</span><span class="font17"> which are the smallest meaningful portions of the input. Then the function loops over the tokens one</span></p>
<div>
<p><span class="font20">56</span></p>
</div><br clear="all">
<p><span class="font15">CHAPTER 2 Dispatch Tables</span></p>
<p><span class="font17">at a time, from left to right. If a token matches </span><span class="font2">/<sup>A</sup>\d+S/</span><span class="font17">, then it is a number, so the function pushes it onto the stack. Otherwise, it’s an operator, so the function pops two values off the stack, operates on them, and pushes the result back onto the stack. The auxiliary </span><span class="font2">Ss </span><span class="font17">variable in the code for subtraction is there because </span><span class="font2">5 3- </span><span class="font17">should yield 2, not </span><span class="font3">-</span><span class="font17">2. If we had used:</span></p>
<p><span class="font2">push @stack, pop(©stack) - pop(©stack);</span></p>
<p><span class="font17">then for </span><span class="font2">5 3 - </span><span class="font17">the first </span><span class="font2">pop </span><span class="font17">would pop the 3, the second would pop the 5, and the result would have been </span><span class="font3">-</span><span class="font17">2. There is similar code in the division branch for the same reason. For multiplication and addition, the order of the operands doesn’t matter.</span></p>
<p><span class="font17">When the function runs out of tokens, it pops the top value off the stack; this is the final result. This code ignores the possibility that the stack might finish with several values; this would mean that the argument contained more than one expression. </span><span class="font2">10 2 * 3 4 + </span><span class="font17">leaves 20 and 7 on the stack, in that order. It also ignores the possibility that the stack might become empty. For example, </span><span class="font2">2 * </span><span class="font17">and </span><span class="font2">2 3 + * </span><span class="font17">are invalid expressions, because in each, the </span><span class="font2">* </span><span class="font17">has only one argument instead of two. In evaluating these, the function finds itself doing an operation when the stack is empty. It should signal an error in that case, but I omitted the error handling to keep the example small.</span></p>
<p><span class="font17">We can make the example simpler and more flexible by replacing the large </span><span class="font2">if-else </span><span class="font17">switch with a dispatch table:</span></p>
<div>
<p><span class="font9" style="font-weight:bold;">CODE LIBRARY</span></p>
</div><br clear="all">
<div>
<p><span class="font0">rpn-table</span></p>
</div><br clear="all">
<p><span class="font2">my @stack;</span></p>
<p><span class="font2">my Sactions = {</span></p>
<p><span class="font2">'+' =&gt; sub { push @stack, pop(©stack) + pop(©stack) },</span></p>
<p><span class="font2">'*' =&gt; sub { push @stack, pop(@stack) * pop(@stack) },</span></p>
<p><span class="font2">'-' =&gt; sub { my Ss = pop(@stack); push @stack, pop(@stack) - Ss },</span></p>
<p><span class="font2">'/' =&gt; sub { my Ss = pop(@stack); push @stack, pop(@stack) / Ss },</span></p>
<p><span class="font2">'NUMBER' =&gt; sub { push @stack, S_[0] }, '_DEFAULT_' =&gt; sub { die &quot;Unrecognized token 'S_[0]'; aborting&quot; } };</span></p>
<p><span class="font2">my Sresult = evaluate(SARGV[0], Sactions);</span></p>
<p><span class="font2">print &quot;Result: Sresult\n&quot;;</span></p>
<p><span class="font2">sub evaluate {</span></p>
<p><span class="font2">my (Sexpr, Sactions) = @_;</span></p>
<p><span class="font2">my ©tokens = split /\s+/, Sexpr; for my Stoken (©tokens) {</span></p>
<p><span class="font2">my Stype;</span></p>
<p><span class="font2">if (Stoken =- /</span><span class="font1"><sup>A</sup></span><span class="font2">\d+S/) { # It’s a number Stype = 'NUMBER';</span></p>
<p><span class="font2">} my Saction = Sactions-&gt;{Stype}</span></p>
<p><span class="font2">|| Sactions-&gt;{Stoken}</span></p>
<p><span class="font2">|| Sactions-&gt;{_DEFAULT_};</span></p>
<p><span class="font2">Saction-&gt;(Stoken, Stype, Sactions);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">return pop(@stack);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">The main driver, </span><span class="font2">evaluate()</span><span class="font17">, is now much smaller and more general. It selects an action based on the token’s “type,” if it has one; otherwise, the action is based on the value of the token itself, and if there is no such action, a default action is used. The </span><span class="font2">evaluate() </span><span class="font17">function does a pattern match on the token to try to determine a token type, and if the token looks like a number, the selected type is </span><span class="font2">NUMBER</span><span class="font17">. We can add a new operator by adding an entry to the </span><span class="font2">%actions </span><span class="font17">dispatch table:</span></p>
<p><span class="font2">'sqrt' =&gt; sub { push @stack, sqrt(pop(@stack)) },</span></p>
<p><span class="font17">Again, because of the dispatch table construction, we can get a different behavior from the evaluator by supplying a different dispatch table. Instead of reducing the expression to a number, the evaluator will compile it into an </span><span class="font17" style="font-style:italic;">abstract syntax tree</span><span class="font17"> (AST) if we supply this dispatch table:</span></p>
<p><span class="font2">my Sactions = {</span></p>
<p><span class="font2">'NUMBER' &nbsp;&nbsp;&nbsp;=&gt; sub { push @stack, S_[0] },</span></p>
<p><span class="font2">'_DEFAULT_' =&gt; sub { my Ss = pop(@stack);</span></p>
<p><span class="font2">push @stack,</span></p>
<p><span class="font2">[ S_[0], pop(@stack), Ss ]</span></p>
<p><span class="font2">},</span></p>
<p><span class="font2">};</span></p>
<p><span class="font17">The result of compiling </span><span class="font2">2 3 + 4 * </span><span class="font17">is the abstract syntax tree </span><span class="font2">[ '*', [ ' + ', 2, 3 ], 4 ]</span><span class="font17">, which we can also represent as in Figure 2.1.</span></p>
<div><img src="HigherOrderPerl_files/HigherOrderPerl-6.jpg" alt="" style="width:46pt;height:61pt;">
</div><br clear="all">
<p><span class="font14">FIGURE 2.1 </span><span class="font16">The AST for the expression </span><span class="font2">2 3 + 4 *</span><span class="font16">.</span></p>
<p><span class="font17">This is the most useful internal form for an expression because all the structure is represented directly. An expression is either a number, or it has an operator and two operands; the two operands are also expressions. An abstract syntax tree is either a number, or a list of an operator and two other ASTs. Once we have an AST, it’s easy to write a function to process it. For example, here is a function to convert an AST to a string:</span></p>
<div>
<p><span class="font9" style="font-weight:bold;">CODE LIBRARY</span></p>
</div><br clear="all">
<p><span class="font2">sub AST_to_string {</span></p>
<div>
<p><span class="font0">AST-to-string</span></p>
</div><br clear="all">
<p><span class="font2">my ($tree) = @_;</span></p>
<p><span class="font2">if (ref $tree) {</span></p>
<p><span class="font2">my ($op, $a1, $a2) = @$tree;</span></p>
<p><span class="font2">my ($s1, $s2) = (AST_to_string($a1), AST_to_string($a2));</span></p>
<p><span class="font2">&quot;($s1 $op $s2)&quot;;</span></p>
<p><span class="font2">} else {</span></p>
<p><span class="font2">$tree;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">Given the tree of Figure 2.1, the </span><span class="font2">AST_to_string() </span><span class="font17">function produces the string </span><span class="font2">&quot;((2 + 3) * 4)&quot;</span><span class="font17">. The function first checks to see if the tree is trivial; if it is not a reference, then it must be a number, and the string version is just that number. Otherwise, the string has three parts: an operator symbol, which is stored in </span><span class="font2">$op</span><span class="font17">, and two arguments, which are ASTs. The function calls itself recursively to convert the two argument trees to strings </span><span class="font2">$s1 </span><span class="font17">and </span><span class="font2">$s2</span><span class="font17">, and then produces a new string that has </span><span class="font2">$s1 </span><span class="font17">and </span><span class="font2">$s2 </span><span class="font17">with the appropriate operator symbol in between, surrounded by parentheses to avoid ambiguity. We have just written a system to convert postfix expressions to infix expressions, because we can feed the original postfix expression to </span><span class="font2">evaluate() </span><span class="font17">to generate an AST, and then give the AST to </span><span class="font2">AST_to_string() </span><span class="font17">to generate an infix expression.</span></p>
<p><span class="font17">The </span><span class="font2">AST_to_string() </span><span class="font17">function is recursive because the definition of an AST is recursive; the definition of an AST is recursive because the structure of an expression is recursive. The structure of </span><span class="font2">AST_to_string() </span><span class="font17">directly reflects the structure of an expression.</span></p>
<div>
<p><span class="font15">2.2 CALCULATOR </span><span class="font20">59</span></p>
</div><br clear="all">
<ul style="list-style:none;"><li>
<h5><a name="bookmark23"></a><span class="font19">2.2.1 HTML Processing Revisited</span></h5></li></ul>
<p><span class="font17">In Chapter 1 we saw </span><span class="font2">walk_html()</span><span class="font17">, a recursive HTML processor. The HTML processor got two functional arguments: </span><span class="font2">Stextfunc</span><span class="font17">, a function to call for a section of untagged text, and </span><span class="font2">Selementfunc</span><span class="font17">, a function to call for an HTML element. But “HTML element” is vague because there are many sorts of elements, and we might want our function to do something different for each kind of element.</span></p>
<p><span class="font17">We’ve seen several ways to accomplish this already. The most straightforward is for the user to simply put a giant </span><span class="font2">if-else </span><span class="font17">switch into </span><span class="font2">Selementfunc</span><span class="font17">. As we’ve already seen, that has some disadvantages. The user might like to supply a dispatch table to the </span><span class="font2">Selementfunc </span><span class="font17">instead. The structure of such a dispatch table is easy to see: the keys of the table will be tag names, and the values will be actions performed for each kind of element. Instead of supplying a single </span><span class="font2">Selementfunc </span><span class="font17">that knows how to deal with every possible element, the user will supply a dispatch table that provides one action for each kind of element, and also a generic </span><span class="font2">Selementfunc </span><span class="font17">that dispatches the appropriate action.</span></p>
<p><span class="font17">The </span><span class="font2">Selementfunc </span><span class="font17">might get access to the dispatch table in any of several ways. The dispatch table might be hardwired into the element function:</span></p>
<p><span class="font2">sub elementfunc {</span></p>
<p><span class="font2">my Stable = { hl &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&gt; sub { shift; my $text = join '', @_;</span></p>
<p><span class="font2">print Stext; return Stext ;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">_DEFAULT_ =&gt; sub { shift; my Stext = join '', @_; return Stext ;</span></p>
<p><span class="font2">};</span></p>
<p><span class="font2">my (Selement) = @_;</span></p>
<p><span class="font2">my Stag = Selement-&gt;{_tag};</span></p>
<p><span class="font2">my Saction = Stable-&gt;{Stag} || Stable{_DEFAULT_};</span></p>
<p><span class="font2">return Saction-&gt;(@_);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">Alternatively, we could build dispatch table support directly into </span><span class="font2">walk_html()</span><span class="font17">, so that instead of passing a single </span><span class="font2">Selementfunc</span><span class="font17">, the user passes the dispatch table directly to </span><span class="font2">walk_html()</span><span class="font17">. In that case, </span><span class="font2">walk_html() </span><span class="font17">would look something like this:</span></p>
<p><span class="font2">sub walk_html {</span></p>
<div>
<p><span class="font9" style="font-weight:bold;">CODE LIBRARY</span></p>
</div><br clear="all">
<div>
<p><span class="font0">walk-html-disp</span></p>
</div><br clear="all">
<p><span class="font2" style="font-weight:bold;">my ($html, Stextfunc, Selementfunc_table) = @_;</span></p>
<p><span class="font2">return Stextfunc-&gt;(Shtml) unless ref Shtml; # It’s a plain string</span></p>
<p><span class="font2">my (Sitem, ©results);</span></p>
<p><span class="font2">for Sitem (©{Shtml-&gt;{_content}}) {</span></p>
<p><span class="font2">push ©results, walk_html(Sitem, Stextfunc, Selementfunc_table);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2" style="font-weight:bold;">my Stag = Shtml-&gt;{_tag};</span></p>
<p><span class="font2" style="font-weight:bold;">my Selementfunc = Selementfunc_table-&gt;{Stag}</span></p>
<p><span class="font2" style="font-weight:bold;">|| Selementfunc_table-&gt;{_DEFAULT_}</span></p>
<p><span class="font2" style="font-weight:bold;">|| die &quot;No function defined for tag 'Stag'&quot;;</span></p>
<p><span class="font2">return Selementfunc-&gt;(Shtml, ©results);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">Yet another option is to change </span><span class="font2">walk_html() </span><span class="font17">to pass a user parameter to the </span><span class="font2">Stextfunc </span><span class="font17">and </span><span class="font2">Selementfunc</span><span class="font17">. Then the user could have the dispatch table passed to the </span><span class="font2">Selementfunc </span><span class="font17">via the user parameter mechanism:</span></p>
<div>
<p><span class="font9" style="font-weight:bold;">CODE LIBRARY</span></p>
</div><br clear="all">
<p><span class="font2">sub walk_html {</span></p>
<div>
<p><span class="font0">walk-html-uparam</span></p>
</div><br clear="all">
<p><span class="font2" style="font-weight:bold;">my (Shtml, Stextfunc, Selementfunc, Suserparam) = @_;</span></p>
<p><span class="font2" style="font-weight:bold;">return Stextfunc-&gt;(Shtml, Suserparam) unless ref Shtml;</span></p>
<p><span class="font2">my (Sitem, ©results);</span></p>
<p><span class="font2">for Sitem (©{Shtml-&gt;{_content}}) {</span></p>
<p><span class="font2" style="font-weight:bold;">push @results, walk_html(Sitem, Stextfunc, Selementfunc, Suserparam);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2" style="font-weight:bold;">return Selementfunc-&gt;(Shtml, Suserparam, @results);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">Now it is up to the users to design their </span><span class="font2">Selementfunc</span><span class="font17">s to process the dispatch table appropriately.</span></p>
<p><span class="font17">One important and subtle point here: notice that we passed the user parameter to the </span><span class="font2">Stextfunc </span><span class="font17">as well as to the </span><span class="font2">Selementfunc</span><span class="font17">. If the user parameter is a tag dispatch table, it is probably not useful to the </span><span class="font2">Stextfunc</span><span class="font17">. Why did we pass it, then? Because it might not be a tag dispatch table; it might be something else. For example, the user might have called </span><span class="font2">walk_html() </span><span class="font17">like this:</span></p>
<p><span class="font2">walk_html(Shtml_text,</span></p>
<ul style="list-style:none;"><li>
<p><span class="font2"># Stextfunc</span></p></li></ul>
<p><span class="font2">sub { my (Stext, Saref) = ©_;</span></p>
<p><span class="font2">push ©Saref, Stext },</span></p>
<ul style="list-style:none;"><li>
<p><span class="font2"># Selementfunc does nothing</span></p></li></ul>
<p><span class="font2">sub { },</span></p>
<p><span class="font2"># user parameter \@text_array</span></p>
<p><span class="font2">);</span></p>
<p><span class="font17">Now </span><span class="font2">walk_html() </span><span class="font17">will walk the HTML tree and push all the untagged plain text into the array </span><span class="font2">@text_array</span><span class="font17">. The user parameter is the reference to </span><span class="font2">@text_array</span><span class="font17">; it is passed to the </span><span class="font2">Stextfunc</span><span class="font17">, which pushes the text onto the referred-to array. The </span><span class="font2">Selementfunc </span><span class="font17">doesn’t use the user parameter at all. Since we, the authors of </span><span class="font2">walk_html()</span><span class="font17">, don’t know in advance which sort of user parameter the user will require, we had better pass it to both the </span><span class="font2">Stextfunc </span><span class="font17">and the </span><span class="font2">Selementfunc</span><span class="font17">; a function that doesn’t need the user parameter is free to ignore it.</span></p>
<div>
<p><span class="font14">CHAPTER</span></p>
</div><br clear="all">
<h3><a name="bookmark24"></a><span class="font25">CACHING AND MEMOIZATION</span></h3>
<p><span class="font17">We saw in Section 1.8 that a natural recursive function can sometimes perform extremely badly. An easy and general solution to many of these performance problems, as well as some that arise in nonrecursive contexts, is </span><span class="font17" style="font-style:italic;">caching.</span></p>
<p><span class="font17">Let’s consider a program that converts images from one format to another. Specifically, let’s imagine that the input is in the popular GIF format, and that the output is something we’re going to send to the printer. The printer is not the little machine that sits on your desk; it’s a big company with giant printing presses that will print one million copies of some magazine by Thursday afternoon.</span></p>
<p><span class="font17">The printer wants the images in a special CMYK format. CMYK stands for “Cyan-Magenta-Yellow-Black,” which are the four colors of the special printer’s inks that the printer uses to print the magazines.<a name="footnote6"></a><sup><a href="#bookmark229">6</a></sup><sup></sup> However, the colors in the GIF image are specified as RGB values, which are the intensities of red, green, and blue light that will be emitted by our computer monitor when it displays the image. We need to convert the RGB values that are suitable for the monitor into CMYK values that are appropriate for printing.</span></p>
<p><span class="font17">The conversion is just a matter of simple arithmetic:</span></p>
<p><span class="font2">sub RGB_to_CMYK {</span></p>
<div>
<p><span class="font9" style="font-weight:bold;">CODE LIBRARY</span></p>
</div><br clear="all">
<p><span class="font2">my ($r, $g, $b) = @_;</span></p>
<p><span class="font2">my ($c, $m, $y) = (255-$r, 255-$g, 255-$b);</span></p>
<p><span class="font2">my $k = $c &lt;&nbsp;$m ? ($c &lt;&nbsp;$y ? $c : $y)</span></p>
<p><span class="font2">: ($m &lt;&nbsp;$y ? $m : $y); &nbsp;# Minimum</span></p>
<div>
<p><span class="font0">RGB-CMYK</span></p>
</div><br clear="all">
<p><span class="font2">for ($c, $m, $y) { $_ -= $k }</span></p>
<div>
<p><span class="font18">63</span></p>
</div><br clear="all">
<p><span class="font2">[$c, $m, $y, $k];</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">Now we write the rest of the program, which opens the GIF file, reads the pixels one at a time, </span><span class="font2">calls RGB_to_CMYK() </span><span class="font17">for each pixel, and writes out the resulting CMYK values in the appropriate format.</span></p>
<p><span class="font17">There’s a minor problem here. Let’s suppose that the GIF image is 1024 pixels wide and 768 pixels high, for a total of 786,432 pixels. We will have made 786,432 calls to </span><span class="font2">RGB_to_CMYK()</span><span class="font17">. That seems all right, except for one thing: Because of the way the GIF format is defined, no GIF image ever contains more than 256 different colors. That means that at least 786,176 of our 786,432 calls were a waste of time, because we were doing the same computations that we had already done before. If we could figure out how to save the results of our </span><span class="font2">RGB_to_CMYK() </span><span class="font17">computations and recover them when appropriate, we might win back some performance.</span></p>
<p><span class="font17">In Perl, whenever we consider the problem of checking whether we’ve seen something already, the solution will almost always involve a hash. This is no exception. If we can use the RGB value as a hash key, we can make a hash that records whether we have seen a particular set of RGB values before, and if so, what the corresponding CMYK value was. Then our program logic will go something like this: To convert a set of RGB values to a set of CMYK values, first look up the RGB values in the hash. If they’re not there, do the calculation as before, store the result in the hash, and return it as usual. If the values are in the hash, then just get the CMYK values from the hash and return them without doing the calculation a second time.</span></p>
<p><span class="font17">The code will look something like this:</span></p>
<div>
<p><span class="font9" style="font-weight:bold;">CODE LIBRARY</span></p>
</div><br clear="all">
<div>
<p><span class="font2">my %cache;</span></p>
</div><br clear="all">
<div>
<p><span class="font0">RGB-CMYK-caching</span></p>
</div><br clear="all">
<p><span class="font2">sub RGB_to_CMYK { my ($r, $g, $b) = @_; </span><span class="font2" style="font-weight:bold;">my $key = join ',', $r, $g, $b; return $cache{$key} if exists $cache{$key}; </span><span class="font2">my ($c, $m, $y) = (255-$r, 255-$g, 255-$b);</span></p>
<p><span class="font2">my $k = $c &lt;&nbsp;$m ? ($c &lt;&nbsp;$y ? $c : $y)</span></p>
<p><span class="font2">: ($m &lt;&nbsp;$y ? $m : $y); # Minimum</span></p>
<p><span class="font2">for ($c, $m, $y) { $_ -= $k } </span><span class="font2" style="font-weight:bold;">return $cache{$key} = [$c, $m, $y, $k];</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">Suppose we call </span><span class="font2">RGB_to_CMYK() </span><span class="font17">with arguments </span><span class="font2">128,0,64</span><span class="font17">. The first time we do this, the function will look in the </span><span class="font2">%cache </span><span class="font17">hash under the key </span><span class="font2">'128,0,64'</span><span class="font17">; there won’t be anything there, so it will continue through the function, performing the calculation as usual, and, on the last line, store the result into </span><span class="font2">$cache{'128,0,64'}</span><span class="font17">, and return the result. The second time we call the function with the same arguments, it computes the same key, and returns the value of </span><span class="font2">$cache{'128,0,64'} </span><span class="font17">without doing any extra calculation. When we find the value we need in the cache without further calculation, that is called a </span><span class="font17" style="font-style:italic;">cache hit; </span><span class="font17">when we compute the right key but find that no value is yet cached under that key, it is called a </span><span class="font17" style="font-style:italic;">cache miss.</span></p>
<p><span class="font17">Of course there’s a possibility that the extra program logic and the hash lookups will eat up the gains that we got from avoiding the computation. Whether this is true depends on how time-consuming the original computation was and on the likelihood of cache hits. When the original computation takes a long time, caching is more likely to be a benefit. To be sure, we should run a careful benchmark of both versions of the function. But to help develop an intuition for the kinds of tradeoffs to expect, we will look briefly at the theory.</span></p>
<p><span class="font17">Suppose the typical call to the real function takes time </span><span class="font17" style="font-style:italic;">f.</span><span class="font17"> The average time taken by the memoized version will depend on two additional parameters: </span><span class="font17" style="font-style:italic;">K, </span><span class="font17">the cache management overhead, and </span><span class="font17" style="font-style:italic;">h</span><span class="font17">, the probability of getting a cache hit on any particular call. In the extreme case where we never get a cache hit, </span><span class="font17" style="font-style:italic;">h</span><span class="font17"> is zero; as the likelihood of cache hits increases, </span><span class="font17" style="font-style:italic;">h</span><span class="font17"> approaches 1.</span></p>
<p><span class="font17">For a memoized function, the average time per call will be at least </span><span class="font17" style="font-style:italic;">K,</span><span class="font17"> since every call must check the cache, plus an additional </span><span class="font17" style="font-style:italic;">f</span><span class="font17"> if there is a cache miss, for a total of </span><span class="font17" style="font-style:italic;">K</span><span class="font3"> + </span><span class="font17">(1 </span><span class="font3">— </span><span class="font17" style="font-style:italic;">h</span><span class="font17">)</span><span class="font17" style="font-style:italic;">f</span><span class="font17">. The unmemoized version of the function, of course, always takes time </span><span class="font17" style="font-style:italic;">f,</span><span class="font17"> so the difference is simply </span><span class="font17" style="font-style:italic;">hf — K</span><span class="font17"> .If </span><span class="font17" style="font-style:italic;">K &lt;&nbsp;hf</span><span class="font17">, the memoized version of the function will be faster than the unmemoized version. To speed up the memoized version, we can increase the cache hit rate </span><span class="font17" style="font-style:italic;">h</span><span class="font17">, or decrease the cache management overhead </span><span class="font17" style="font-style:italic;">K.</span><span class="font17"> When </span><span class="font17" style="font-style:italic;">f</span><span class="font17"> is large, it is easier to achieve </span><span class="font17" style="font-style:italic;">K &lt;&nbsp;hf</span><span class="font17">, so caching is more likely to be effective when the original function takes a long time to run. In the worst case, we never get any cache hits, and </span><span class="font17" style="font-style:italic;">h =</span><span class="font17"> 0, so the “speedup” is actually a slowdown of </span><span class="font3">— </span><span class="font17" style="font-style:italic;">K</span><span class="font17">.</span></p>
<ul style="list-style:none;"><li>
<h5><a name="bookmark25"></a><span class="font18">3.1 CACHING FIXES RECURSION</span></h5></li></ul>
<p><span class="font17">We saw in Section 1.8 that recursive functions sometimes blow up and take much too long, even on simple inputs, and that the Fibonacci function is an example of this problem:</span></p>
<p><span class="font2"># Compute the number of pairs of rabbits alive in month n sub fib {</span></p>
<p><span class="font2">my ($month) = @_;</span></p>
<p><span class="font2">if ($month &lt;&nbsp;2) { 1 }</span></p>
<p><span class="font2">else {</span></p>
<p><span class="font2">fib($month-1) + fib($month-2);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">As we saw in Section 1.8, this function runs slowly for most arguments, because it wastes time recomputing results it has already computed. For example, </span><span class="font2">fib(20) </span><span class="font17">needs to compute </span><span class="font2">fib(19) </span><span class="font17">and </span><span class="font2">fib(18)</span><span class="font17">, but </span><span class="font2">fib(19) </span><span class="font17" style="font-style:italic;">also</span><span class="font17"> computes </span><span class="font2">fib(18)</span><span class="font17">, as well as </span><span class="font2">fib(17)</span><span class="font17">, which is also computed once by each of the calls to </span><span class="font2">fib(18)</span><span class="font17">. This is a common problem with recursive functions, and it is fixed by caching. If we add caching to </span><span class="font2">fib</span><span class="font17">, then instead of recomputing </span><span class="font2">fib(18) </span><span class="font17">over again from scratch the second time it is needed, </span><span class="font2">fib </span><span class="font17">will simply retrieve the cached result of the first computation of </span><span class="font2">fib(18)</span><span class="font17">. It won’t matter that we try to compute </span><span class="font2">fib(17) </span><span class="font17">three times or </span><span class="font2">fib(16) </span><span class="font17">five times because the work will be done only once, and the cached results will be retrieved quickly when they are needed again.</span></p>
<ul style="list-style:none;"><li>
<h5><a name="bookmark26"></a><span class="font18">3.2 INLINE CACHING</span></h5></li></ul>
<p><span class="font17">The most straightforward way to add caching to a function is to give the function a private hash. In this example, we could use an array instead of a hash, since the argument to </span><span class="font2">fib() </span><span class="font17">is always a non-negative integer. But in general, we will need to use a hash, so that’s what we’ll see here:</span></p>
<div>
<p><span class="font9" style="font-weight:bold;">CODE LIBRARY</span></p>
</div><br clear="all">
<p><span class="font2"># Compute the number of pairs of rabbits alive in month n</span></p>
<div>
<p><span class="font0">fib-cached</span></p>
</div><br clear="all">
<p><span class="font2">{ my %cache;</span></p>
<p><span class="font2">sub fib {</span></p>
<p><span class="font2">my ($month) = @_;</span></p>
<p><span class="font2">unless (exists $cache{$month}) {</span></p>
<p><span class="font2">if ($month &lt;&nbsp;2) { $cache{$month} = 1 }</span></p>
<p><span class="font2">else {</span></p>
<p><span class="font2">$cache{$month} = fib($month-1) + fib($month-2);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">return $cache{$month};</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">Here </span><span class="font2">fib </span><span class="font17">gets the same argument as before. But instead of going into the recursive Fibonacci calculation immediately, it checks the cache first. The cache is a hash, </span><span class="font2">%cache</span><span class="font17">. When the function computes a Fibonacci number </span><span class="font2">fib($month)</span><span class="font17">, it will store the value in </span><span class="font2">$cache{$month}</span><span class="font17">. Later calls to </span><span class="font2">fib() </span><span class="font17">will check to see if there is a value in the cache hash. This is the purpose of the </span><span class="font2">exists $cache{$month} </span><span class="font17">test. If the cache element is absent, the function has never been called before for this particular value of </span><span class="font2">$month</span><span class="font17">. The code inside the </span><span class="font2">unless </span><span class="font17">block is just the ordinary Fibonacci computation, including recursive calls if necessary. However, once the function has computed the answer, it doesn’t return it immediately; instead, it inserts the value into the cache hash in the appropriate place. For example, </span><span class="font2">$cache{$month} = 1 </span><span class="font17">takes care of populating the cache when </span><span class="font2">$month &lt;&nbsp;2 </span><span class="font17">is true.</span></p>
<p><span class="font17">At the end of the function, </span><span class="font2">return $cache{$month} </span><span class="font17">returns the cached value, whether the function just inserted it or it was there to begin with.</span></p>
<p><span class="font17">With these changes, the </span><span class="font2">fib </span><span class="font17">function is fast. The excessive recursion problem we saw in Chapter 1 simply goes away. The problem was caused by the repeated recomputation of results; adding caching behavior prevents any recomputation from occurring. When the function tries to recompute a result it has computed already, it immediately gets the value from the cache instead.</span></p>
<ul style="list-style:none;"><li>
<h5><a name="bookmark27"></a><span class="font19">3.2.1 Static Variables</span></h5></li></ul>
<p><span class="font17">Why is </span><span class="font2">%cache </span><span class="font17">outside of </span><span class="font2">fib </span><span class="font17">instead of inside, and why is there a bare block around </span><span class="font2">%cache </span><span class="font17">and </span><span class="font2">fib</span><span class="font17">?</span></p>
<p><span class="font17">If </span><span class="font2">%cache </span><span class="font17">were declared inside of </span><span class="font2">fib</span><span class="font17">, like this:</span></p>
<p><span class="font2">sub fib { my %cache;</span></p>
<p><span class="font17">then the cache would not work, because a new, fresh </span><span class="font2">%cache </span><span class="font17">variable would be created on every call to </span><span class="font2">fib</span><span class="font17">, and thrown away when </span><span class="font2">fib </span><span class="font17">returned. By declaring </span><span class="font2">%cache </span><span class="font17">outside of any function, we tell Perl that we want only one instance of </span><span class="font2">%cache</span><span class="font17">, created when the program is first compiled and destroyed only when the program is finished. This allows </span><span class="font2">%cache </span><span class="font17">to accumulate values and retain them in between calls to </span><span class="font2">fib</span><span class="font17">. A variable like </span><span class="font2">%cache </span><span class="font17">that has been declared outside all the functions is called a </span><span class="font17" style="font-style:italic;">static variable</span><span class="font17"> because its value stays the same unless it is explicitly changed, and also because a similar feature of the C language is activated with the keyword </span><span class="font2">static</span><span class="font17">.</span></p>
<p><span class="font2">%cache </span><span class="font17">has been declared with </span><span class="font2">my</span><span class="font17">, so it is lexically scoped. By default, its scope will continue to the end of the file. If we had defined any functions after </span><span class="font2">fib</span><span class="font17">, they would also be able to see and modify the cache. But this isn’t what we want; we want the cache to be completely private to </span><span class="font2">fib</span><span class="font17">. Enclosing both </span><span class="font2">%cache </span><span class="font17">and </span><span class="font2">fib </span><span class="font17">in a separate block accomplishes this. The scope of </span><span class="font2">%cache </span><span class="font17">extends only to the end of the block, which contains only </span><span class="font2">fib </span><span class="font17">and nothing else.</span></p>
<ul style="list-style:none;"><li>
<h5><a name="bookmark28"></a><span class="font18">3.3 GOOD IDEAS</span></h5></li></ul>
<p><span class="font17">There aren’t too many ideas that are both good and simple. The few that we have are used everywhere. Caching is one of these. Your web browser caches the documents it retrieves from the network. When you ask for the same document a second time, the browser retrieves the cached copy from local disk or memory, which is fast, instead of downloading it again. Your domain name server caches the responses that it receives from remote servers. When you look up the same name a second time, the local server has the answer ready and doesn’t have to carry on another possibly time-consuming network conversation. When your operating system reads data from the disks, it probably caches the data in memory, in case it’s read again; when your CPU fetches data from memory, it caches the data in a special cache memory that is faster than the regular main memory.</span></p>
<p><span class="font17">Caching comes up over and over in real programs. Almost any program will contain functions where caching might yield a performance win. But the best property of caching is that it’s </span><span class="font17" style="font-style:italic;">mechanical.</span><span class="font17"> If you have a function, and you would like to speed it up, you might rewrite the function, or introduce a better data structure, or a more sophisticated algorithm. This might require ingenuity, which is always in short supply. But adding caching is a no-brainer; the caching transformation is always pretty much the same. This:</span></p>
<p><span class="font2">sub some_function {</span></p>
<p><span class="font2">Sresult = </span><span class="font2" style="font-style:italic;">some computation involving @_;</span></p>
<p><span class="font2">return Sresult;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">turns into this:</span></p>
<p><span class="font2">{ my %cache;</span></p>
<p><span class="font2">sub some_function_with_caching { my Skey = join ',', @_;</span></p>
<p><span class="font2">return Scache{Skey} if exists Scache{Skey};</span></p>
<p><span class="font2">Sresult = </span><span class="font2" style="font-style:italic;">the same computation involving @_;</span></p>
<div>
<p><span class="font15">3.4 MEMOIZATION</span></p>
</div><br clear="all">
<div>
<h4><a name="bookmark230"></a><span class="font20">69</span></h4>
</div><br clear="all">
<p><span class="font2">return Scache{Skey} = Sresult; }</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">The transformation is almost exactly the same for every function. The only part that needs to vary is the </span><span class="font2">join ',', @_ </span><span class="font17">line. This line is intended to turn the function’s argument array into a string, suitable for a hash key. Turning arbitrary values into strings like this is called </span><span class="font17" style="font-style:italic;">serialization</span><span class="font17"> or </span><span class="font17" style="font-style:italic;">marshalling.<a name="footnote7"></a><sup><a href="#bookmark231">7</a></sup><sup> <a name="footnote8"></a><a href="#bookmark232">8</a></sup></span><span class="font17">&nbsp;The preceding </span><span class="font2">join ',', @_ </span><span class="font17">example works only for functions whose arguments are numbers or strings that do not contain commas. We will look at the generation of cache keys in greater detail later on.</span></p>
<ul style="list-style:none;"><li>
<h5><a name="bookmark29"></a><span class="font18">3.4 MEMOIZATION</span></h5></li></ul>
<p><span class="font17">Adding the caching code to functions is not very much trouble. And as we saw, the changes required are the same for almost any function. Why not, then, get the computer to do it for us? We would like to tell Perl that we want caching behavior enabled on a function. Perl should be able to perform the required transformation automatically. Such automatic transformation of a function to add caching behavior is called </span><span class="font17" style="font-style:italic;">memoization</span><span class="font17"> and the function is said to be </span><span class="font17" style="font-style:italic;">memoized?</span></p>
<p><span class="font17">The standard </span><span class="font2">Memoize </span><span class="font17">module, which I wrote, does this. If the </span><span class="font2">Memoize </span><span class="font17">module is available, we do not need to rewrite the </span><span class="font2">fib </span><span class="font17">code at all. We simply add two lines at the top of our program:</span></p>
<p><span class="font2" style="font-weight:bold;">use Memoize;</span></p>
<div>
<p><span class="font9" style="font-weight:bold;">CODE LIBRARY</span></p>
</div><br clear="all">
<div>
<p><span class="font0">fib-automemo</span></p>
</div><br clear="all">
<p><span class="font2" style="font-weight:bold;">memoize 'fib';</span></p>
<p><span class="font2"># Compute the number of pairs of rabbits alive in month n sub fib {</span></p>
<p><span class="font2">my (Smonth) = @_;</span></p>
<p><span class="font2">if (Smonth &lt;&nbsp;2) { 1 }</span></p>
<p><span class="font2">else {</span></p>
<p><span class="font2">fib(Smonth-l) + fib(Smonth-2);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
<div>
<p><span class="font20">70</span></p>
</div><br clear="all">
<p><span class="font15">CHAPTER 3 Caching and Memoization</span></p>
<p><span class="font2">fib </span><span class="font17">now exhibits the caching behavior. The code is exactly the same as our original slow version, but the function is no longer slow.</span></p>
<ul style="list-style:none;"><li>
<h5><a name="bookmark30"></a><span class="font18">3.5 THE MEMOIZE MODULE</span></h5></li></ul>
<p><span class="font17">This book isn’t about the internals of Perl modules, but some of the techniques used internally by </span><span class="font2">Memoize </span><span class="font17">are directly relevant to things we’ll be doing later on, so we’ll have a short excursion now.</span></p>
<p><span class="font2">Memoize </span><span class="font17">gets a function name (or reference) as its argument. It manufactures a new function that maintains a cache and looks up its arguments in the cache. If the new function finds the arguments in the cache, it returns the cached value; if not, it calls the original function, saves the return value in the cache, and returns it to the original caller.</span></p>
<p><span class="font17">Having manufactured this new function, </span><span class="font2">Memoize </span><span class="font17">then installs it into the Perl symbol table in place of the original function so that when you think you’re calling the original function, you actually get the new cache manager function instead.</span></p>
<p><span class="font17">Rather than looking into the innards of the real </span><span class="font2">Memoize </span><span class="font17">module, which is a 350-line monster, we’ll see a tiny, stripped-down memoizer. The most important thing we’ll get rid of is the part of the code that deals with the Perl symbol table. (We’ll do this manually.) Instead, we’ll have a</span><span class="font2">memoize </span><span class="font17">function whose argument is a reference to the subroutine we want to memoize, and which returns a reference to the memoized version — that is, to the cache manager function:</span></p>
<div>
<p><span class="font9" style="font-weight:bold;">CODE LIBRARY</span></p>
</div><br clear="all">
<div>
<p><span class="font0">memoize</span></p>
</div><br clear="all">
<p><span class="font2">sub memoize {</span></p>
<p><span class="font2">my ($func) = @_;</span></p>
<p><span class="font2">my %cache;</span></p>
<p><span class="font2">my $stub = sub {</span></p>
<p><span class="font2">my $key = join ',', @_;</span></p>
<p><span class="font2">$cache{$key} = $func-&gt;(@_) unless exists $cache{$key}; return $cache{$key};</span></p>
<p><span class="font2">};</span></p>
<p><span class="font2">return $stub;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">To call this, we first use:</span></p>
<p><span class="font2">Sfastfib = memoize(\&amp;fib); </span><span class="font17">Now </span><span class="font2">$fastfib </span><span class="font17">is the memoized version of </span><span class="font2">fib()</span><span class="font17">. To install the memoized version of </span><span class="font2">fib() </span><span class="font17">in the symbol table in place of the original, we would write </span><span class="font2">*fib = memoize(\&amp;fib)</span><span class="font17">. In this example, the installation is necessary if we want to calculate Fibonacci numbers quickly. Just creating a memoized version of </span><span class="font2">fib() </span><span class="font17">isn’t enough, because the recursive calls inside of </span><span class="font2">fib() </span><span class="font17">are calling the function named </span><span class="font2">fib()</span><span class="font17">, and until we do the </span><span class="font2">*fib </span><span class="font17">assignment, this is still the old, slow, unmemoized version.</span></p>
<p><span class="font17">How does </span><span class="font2">memoize </span><span class="font17">work? We pass it a reference to </span><span class="font2">fib</span><span class="font17">, and </span><span class="font2">memoize </span><span class="font17">sets up a private </span><span class="font2">%cache </span><span class="font17">variable to hold cached data. Then it manufactures a </span><span class="font17" style="font-style:italic;">stub function, </span><span class="font17">temporarily stored in </span><span class="font2">$stub</span><span class="font17">, which it returns to its caller. This stub function is actually the memoized version of </span><span class="font2">fib</span><span class="font17">; the caller of </span><span class="font2">memoize </span><span class="font17">gets back a reference to it, which we stored in </span><span class="font2">$fastfib </span><span class="font17">in the preceding example.</span></p>
<p><span class="font17">When we invoke </span><span class="font2">$fastfib</span><span class="font17">, we actually get the stub function that was previously manufactured by </span><span class="font2">memoize</span><span class="font17">. The stub function assembles a hash key by joining the function arguments together with commas; then it looks in the cache to see if the key is a familiar one. If so, the stub returns the cached value immediately.</span></p>
<p><span class="font17">If the hash key isn’t found in the hash, the stub function invokes the original function via </span><span class="font2">$func-&gt;(@_)</span><span class="font17">, gets the result, stores it in the cache, and returns it (see Figure 3.1).</span></p>
<ul style="list-style:none;"><li>
<h5><a name="bookmark31"></a><span class="font19">3.5.1 Scope and Duration</span></h5></li></ul>
<p><span class="font17">There are some subtleties here. First, suppose we call </span><span class="font2">memoize(\&amp;fib) </span><span class="font17">and get back </span><span class="font2">$fastfib</span><span class="font17">. Then we call </span><span class="font2">$fastfib</span><span class="font17">, which makes use of </span><span class="font2">$func</span><span class="font17">. A common question is why </span><span class="font2">$func </span><span class="font17">didn’t go out of scope when </span><span class="font2">memoize </span><span class="font17">returned.</span></p>
<p><span class="font17">This question betrays a common misconception about scope. A variable has two parts: a name and a value.<a name="footnote9"></a><sup><a href="#bookmark233">9</a></sup><sup></sup> When you associate a name with a value, you get a variable. Such an association is called a </span><span class="font17" style="font-style:italic;">binding,</span><span class="font17"> we also say that the name is </span><span class="font17" style="font-style:italic;">bound</span><span class="font17"> to its value.</span></p>
<p><span class="font17">There are two things that might go wrong with our attempt to use </span><span class="font2">$func </span><span class="font17">after </span><span class="font2">memoize </span><span class="font17">returns: The value might have been destroyed, or the binding might have changed, so that the name refers to the wrong value, or to nothing at all.</span></p><img src="HigherOrderPerl_files/HigherOrderPerl-7.jpg" alt="" style="width:269pt;height:250pt;">
<p><span class="font14">FIGURE 3.1 </span><span class="font16">Calling a memoized function.</span></p>
<p><span class="font17">SCOPE</span></p>
<p><span class="font17" style="font-style:italic;">scope</span><span class="font17"> is the part of the program’s source code in which a certain binding is in force. Inside the scope of a binding, the name and value are associated; outside this scope, the binding is </span><span class="font17" style="font-style:italic;">out of scope</span><span class="font17"> and the name and value are no longer associated. The name might mean something else, or nothing at all.</span></p>
<p><span class="font17">When </span><span class="font2">memoize </span><span class="font17">is entered, the </span><span class="font2">my $func </span><span class="font17">declaration creates a new, fresh scalar value and binds the name </span><span class="font2">$func </span><span class="font17">to it. The scope of the name declared with </span><span class="font2">my</span><span class="font17">, such as </span><span class="font2">$func</span><span class="font17">, begins on the statement following the </span><span class="font2">my </span><span class="font17">declaration, and ends at the end of the smallest enclosing block. In this case, the smallest enclosing block is the one labeled </span><span class="font2">sub memoize</span><span class="font17">. Inside this block, </span><span class="font2">$func </span><span class="font17">refers to the lexical variable just created; outside, it refers to something else, probably the unrelated global variable </span><span class="font2">$func</span><span class="font17">. Since the stub that uses </span><span class="font2">$func </span><span class="font17">is inside this block, there’s no scope problem; </span><span class="font2">$func </span><span class="font17">is in scope inside of the stub, and the name </span><span class="font2">$func </span><span class="font17">retains its binding.</span></p>
<p><span class="font17">Outside the </span><span class="font2">sub memoize </span><span class="font17">block, </span><span class="font2">$func </span><span class="font17">means something different, but the stub is inside the block, not outside. Scope is </span><span class="font17" style="font-style:italic;">lexical,</span><span class="font17"> which means that</span></p>
<p><span class="font17">it’s a property of the static program text, not a property of the order in which things execute. The fact that the stub is </span><span class="font17" style="font-style:italic;">called</span><span class="font17"> from outside the </span><span class="font2">sub memoize </span><span class="font17">block is irrelevant; its code is “physically within” the scope of the </span><span class="font2">$func </span><span class="font17">binding.</span></p>
<p><span class="font17">The situation is the same for </span><span class="font2">%cache</span><span class="font17">.</span></p>
<p><span class="font17">DURATION</span></p>
<p><span class="font17">Most people who ask whether </span><span class="font2">$func </span><span class="font17">is out of scope are worried about a different problem, which is not a scope issue, but instead concerns something quite different, called </span><span class="font17" style="font-style:italic;">duration.</span><span class="font17"> The duration of a value is the period of time during the program’s execution in which the value is valid for use. In Perl, when a value’s duration is up, it is destroyed, and the garbage collector makes its memory available for re-use.</span></p>
<p><span class="font17">The important thing to know about duration is that it is almost completely unrelated to issues of names. In Perl, a value’s duration lasts until there are no outstanding references to it. If the value is stored in a named variable, that counts as a reference, but there are other kinds of references. For example:</span></p>
<p><span class="font2">my $x;</span></p>
<p><span class="font2">{</span></p>
<p><span class="font2">$x = 3;</span></p>
<p><span class="font2">my $r = \$x;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">Here there is a scalar with the value 3. At the end of the block, there are two references to it:</span></p>
<p><span class="font2">pad</span></p><img src="HigherOrderPerl_files/HigherOrderPerl-8.jpg" alt="" style="width:96pt;height:32pt;">
<p><span class="font17">The </span><span class="font17" style="font-style:italic;">pad</span><span class="font17"> is the data structure that Perl uses internally to represent bindings of </span><span class="font2">my </span><span class="font17">variables. (A different structure is used for global variables.) One reference to the 3 is from the pad itself, because the name </span><span class="font2">$x </span><span class="font17">is bound to the value 3. The other reference to the 3 is from the reference value that is bound to </span><span class="font2">$r</span><span class="font17">.</span></p>
<p><span class="font17">When control leaves the block, </span><span class="font2">$r </span><span class="font17">goes out of scope, so the binding of </span><span class="font2">$r </span><span class="font17">to its value is dissolved. Internally, Perl deletes the </span><span class="font2">$r </span><span class="font17">binding from the pad:</span></p>
<div>
<p><span class="font2">pad</span></p><img src="HigherOrderPerl_files/HigherOrderPerl-9.jpg" alt="" style="width:96pt;height:32pt;">
</div><br clear="all">
<p><span class="font17">Now there’s no reference to the reference value that used to be stored in </span><span class="font2">$r</span><span class="font17">. Since nothing refers to it anymore, its duration is over and Perl destroys it immediately:</span></p>
<div>
<p><span class="font11">pad</span></p>
<table border="1">
<tr><td style="vertical-align:middle;">
<p><span class="font11">$x</span></p></td><td></td></tr>
</table>
</div><br clear="all">
<div><img src="HigherOrderPerl_files/HigherOrderPerl-10.jpg" alt="" style="width:26pt;height:20pt;">
</div><br clear="all">
<p><span class="font17">This is typical: A variable’s name goes out of scope, and its value is destroyed immediately after. Much of the confusion between scope and duration is probably caused by the ubiquity of this simple example. But scope and duration are not always so closely joined, as the next example will show:</span></p>
<p><span class="font2">my $r;</span></p>
<p><span class="font2">{</span></p>
<p><span class="font2">my $x = 3;</span></p>
<p><span class="font2">$r = \$x;</span></p>
<p><span class="font2">}</span></p>
<div><img src="HigherOrderPerl_files/HigherOrderPerl-11.jpg" alt="" style="width:96pt;height:33pt;">
</div><br clear="all">
<p><span class="font17">When control leaves the block, the binding of </span><span class="font2">$x </span><span class="font17">is dissolved and </span><span class="font2">$x </span><span class="font17">is deleted from the pad:</span></p>
<div>
<p><span class="font2">pad</span></p><img src="HigherOrderPerl_files/HigherOrderPerl-12.jpg" alt="" style="width:96pt;height:33pt;">
</div><br clear="all">
<p><span class="font17">Unlike in the previous example, the unbound value persists indefinitely because it is still referred to by the reference bound to </span><span class="font2">$r</span><span class="font17">. Its duration will not be over until this reference is gone.</span></p>
<p><span class="font17">This separation of scope and duration is an essential property of Perl variables. For example, a common pattern in Perl object-oriented constructor functions is:</span></p>
<p><span class="font2">sub new {</span></p>
<p><span class="font2">my %self;</span></p>
<p><span class="font2">■ ■■</span></p>
<p><span class="font2">return \%self;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">This constructor manufactures a hash, which is the object itself; then it returns a reference to the hash. Even though the name </span><span class="font2">%self </span><span class="font17">has gone out of scope, the object persists as long as the caller holds a reference to it. The analogous code in C is erroneous, because in C, the duration of an auto variable ends with its scope:</span></p>
<p><span class="font2">/* This is C */</span></p>
<p><span class="font2">struct st_object *new(...) {</span></p>
<p><span class="font2">struct st_object self;</span></p>
<p><span class="font2">■■■</span></p>
<p><span class="font2">return &amp;self; /* expect a core dump */</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">Now let’s return to </span><span class="font2">memoize</span><span class="font17">. When </span><span class="font2">memoize </span><span class="font17">returns, </span><span class="font2">$func </span><span class="font17">does indeed go out of scope. But the value is not destroyed, because there is still an outstanding reference from the stub. To really understand what is going on, we need to take a peek into Perl’s internals (see Figure 3.2).</span></p>
<p><span class="font17">The stub is represented by the double box at the top center of the diagram. In Perl jargon, this box is called a </span><span class="font17" style="font-style:italic;">CV,</span><span class="font17"> for “code value”; it is the internal representation of a coderef. (The coderef bound to </span><span class="font2">$func </span><span class="font17">is visible on the right-hand side of the diagram.) A CV is essentially a pair of pointers: one points to the code for the subroutine, and the other points to the pad that was active at the moment that the subroutine was defined. The binding of </span><span class="font2">$func </span><span class="font17">won’t be destroyed until the pad it’s in is destroyed. The pad won’t be destroyed because there is a reference to it from the CV. The CV won’t be destroyed because the caller stored it in the caller’s pad by assigning it to </span><span class="font2">$fastfib</span><span class="font17">.</span></p>
<p><span class="font17">Perl knows that the stub might someday be invoked, and if it is, it might examine the value of </span><span class="font2">$func</span><span class="font17">. As long as the stub exists, the value of </span><span class="font2">$func </span><span class="font17">must be</span></p>
<p><span class="font2">caller's pad &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stub &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stub's pad</span></p><img src="HigherOrderPerl_files/HigherOrderPerl-13.jpg" alt="" style="width:267pt;height:160pt;">
<p><span class="font14">FIGURE 3.2 </span><span class="font16">The data structure manufactured by </span><span class="font2">memoize</span><span class="font16">.</span></p>
<p><span class="font17">preserved intact. There is a reference to the stub stored in </span><span class="font2">$fastfib</span><span class="font17">, and as long as the reference is there, the stub must be preserved. Similarly, the cache </span><span class="font2">%cache </span><span class="font17">persists as long as the stub does.</span></p>
<ul style="list-style:none;"><li>
<h5><a name="bookmark34"></a><span class="font19">3.5.2 Lexical Closure</span></h5></li></ul>
<p><span class="font17">Now another point might be worrying you. Since the value of </span><span class="font2">$func </span><span class="font17">persists as long as the stub does, what happens if we call </span><span class="font2">memoize </span><span class="font17">a second time, while the first stub is still extant? Will the assignment to </span><span class="font2">$func </span><span class="font17">in the second call clobber the value that the first stub was using?</span></p>
<p><span class="font17">The answer is no; everything works perfectly. This is because Perl’s anonymous functions have a property called </span><span class="font17" style="font-style:italic;">lexical closure.</span><span class="font17"> When an anonymous function is created, Perl packages up its pad, including all the bindings that are in scope, and attaches them to the CV. A function packaged up with an environment in this way is called a </span><span class="font17" style="font-style:italic;">closure</span><span class="font17">.</span></p>
<p><span class="font17">When the stub is invoked, the original environment is temporarily reinstated, and the stub function code is run in the environment that was in force at the time the stub was defined. Lexical closure means that an anonymous function carries its native environment wherever it goes, just like some tourists I have met.</span></p>
<p><span class="font17">The first time we call </span><span class="font2">memoize</span><span class="font17">, to memoize </span><span class="font2">fib()</span><span class="font17">, a new pad is set up for the bindings of </span><span class="font2">%cache </span><span class="font17">and </span><span class="font2">$func</span><span class="font17">, new storage is allocated for these new variables, and </span><span class="font2">$func </span><span class="font17">is initialized. Then the stub is created; the pad is attached to the CV for the stub, and the CV (let’s call it </span><span class="font2">fastfib()</span><span class="font17">) is returned back to the caller.</span></p>
<div>
<p><span class="font11">fastfib</span></p><img src="HigherOrderPerl_files/HigherOrderPerl-14.jpg" alt="" style="width:194pt;height:143pt;">
<p><span class="font2">stub function code</span></p>
</div><br clear="all">
<p><span class="font14" style="font-variant:small-caps;">figure 3.3 </span><span class="font16">After two calls to </span><span class="font2">memoize</span><span class="font16">.</span></p>
<p><span class="font17">Now let’s call </span><span class="font2">memoize </span><span class="font17">a second time, this time to memoize </span><span class="font2">quib() </span><span class="font17">instead of </span><span class="font2">fib() </span><span class="font17">(see Figure 3.3). Once again, a new pad is created and fresh </span><span class="font2">%cache </span><span class="font17">and </span><span class="font2">$func </span><span class="font17">variables are bound into it. A CV is created (which we’ll call </span><span class="font2">fastquib()</span><span class="font17">) that contains a pointer to the new pad. The new pad is completely unrelated to the pad that was attached to </span><span class="font2">fastfib()</span><span class="font17">.</span></p>
<p><span class="font17">When we invoke </span><span class="font2">fastfib</span><span class="font17">, </span><span class="font2">fastfib</span><span class="font17">’s pad is temporarily reinstated, and </span><span class="font2">fastfib</span><span class="font17">’s code is executed. The code makes use of variables named </span><span class="font2">%cache </span><span class="font17">and </span><span class="font2">$func</span><span class="font17">, and these are looked up in </span><span class="font2">fastfib</span><span class="font17">’s pad. Perhaps some data is stored into </span><span class="font2">%cache </span><span class="font17">at this time. Eventually, </span><span class="font2">fastfib </span><span class="font17">returns, and the old pad comes back into force.</span></p>
<p><span class="font17">Then we invoke </span><span class="font2">fastquib</span><span class="font17">, and almost the same thing happens. </span><span class="font2">fastquib</span><span class="font17">’s pad is reinstated, with its own notion of </span><span class="font2">%cache </span><span class="font17">and </span><span class="font2">$func</span><span class="font17">. </span><span class="font2">fastquib</span><span class="font17">’s code is run, and it too makes use of variables named </span><span class="font2">%cache </span><span class="font17">and </span><span class="font2">$func</span><span class="font17">. These are looked up in </span><span class="font2">fastquib</span><span class="font17">’s pad, which has no connection to </span><span class="font2">fastfib</span><span class="font17">’s pad. Data stored into </span><span class="font2">fastfib</span><span class="font17">’s </span><span class="font2">%cache </span><span class="font17">is completely inaccessible to </span><span class="font2">fastquib</span><span class="font17">.</span></p>
<p><span class="font17">Because the code part of the CV is read-only, it is shared between several CVs. This saves memory. When a CV’s duration is over, its pad is garbage-collected.</span></p>
<p><span class="font17">Figure 3.4 shows a simpler example.</span></p>
<p><span class="font2">sub make_counter {</span></p>
<div>
<p><span class="font9" style="font-weight:bold;">CODE LIBRARY</span></p>
</div><br clear="all">
<div>
<p><span class="font0">closure-example</span></p>
</div><br clear="all">
<p><span class="font2">my $n = shift;</span></p>
<p><span class="font2">return sub { print &quot;n is &quot;, $n++ }; } my $x = make_counter(7);</span></p>
<p><span class="font2">my $y = make_counter(20);</span></p>
<p><span class="font11">$x</span></p><img src="HigherOrderPerl_files/HigherOrderPerl-15.jpg" alt="" style="width:149pt;height:107pt;">
<p><span class="font14" style="font-variant:small-caps;">figure 3.4 </span><span class="font16">After two calls to </span><span class="font2">make_counter</span><span class="font16">.</span></p>
<p><span class="font2">$x-&gt;();</span></p>
<h6><a name="bookmark234"></a><span class="font2">$x </span><span class="font17">now contains a closure whose code is </span><span class="font2">print &quot;n is &quot;</span><span class="font17">, </span><span class="font2">$n++ </span><span class="font17">and whose environment contains a variable </span><span class="font2">$n</span><span class="font17">, set to 7. If we invoke </span><span class="font2">$x </span><span class="font17">a few times:</span></h6>
<p><span class="font2">$x-&gt;(); $x-&gt;(); $x-&gt;();</span></p>
<h6><a name="bookmark235"></a><span class="font17">the result is</span></h6>
<p><span class="font2">n is 7</span></p>
<p><span class="font2">n is 8</span></p>
<p><span class="font2">n is 9</span></p>
<h6><a name="bookmark236"></a><span class="font17">The new picture is shown in Figure 3.5.</span></h6>
<p><span class="font11">$x</span></p><img src="HigherOrderPerl_files/HigherOrderPerl-16.jpg" alt="" style="width:149pt;height:107pt;">
<p><span class="font14" style="font-variant:small-caps;">figure 3.5</span></p>
<p><span class="font11">$x</span></p><img src="HigherOrderPerl_files/HigherOrderPerl-17.jpg" alt="" style="width:148pt;height:107pt;">
<p><span class="font14">FIGURE 3.6</span></p>
<p><span class="font17">Now let’s run </span><span class="font2">$y </span><span class="font17">a few times:</span></p>
<p><span class="font17">The same code runs, but this time the name </span><span class="font2">$n </span><span class="font17">is looked up in </span><span class="font2">$y</span><span class="font17">’s pad instead of in </span><span class="font2">$x</span><span class="font17">’s pad:</span></p>
<p><span class="font2">n is 20</span></p>
<p><span class="font2">n is 21</span></p>
<p><span class="font2">n is 22</span></p>
<p><span class="font17">The new picture is shown inFigure 3.6.</span></p>
<p><span class="font17">Now let’s run </span><span class="font2">$x </span><span class="font17">again:</span></p>
<p><span class="font2">n is 10</span></p>
<p><span class="font17">The </span><span class="font2">$n </span><span class="font17">here is the same variable as it was the first three times we invoked </span><span class="font2">$x</span><span class="font17">, and it has retained its value.</span></p>
<ul style="list-style:none;"><li>
<h5><a name="bookmark35"></a><span class="font19">3.5.3 Memoization Again</span></h5></li></ul>
<p><span class="font17">All of the foregoing discussion was by way of explaining just why our </span><span class="font2">memoize </span><span class="font17">function worked. While it’s tempting to dismiss this as a triviality— “Of course it worked!” — it’s worth noticing that in many languages it won’t work and can’t be made to work. Several important and complex features had to operate together: delayed garbage collection, bindings, generation of anonymous subroutines, and lexical closure. If you tried to implement a function like </span><span class="font2">memoize </span><span class="font17">in C, for</span></p>
<p><span class="font17">example, you would get stuck, because C doesn’t have any of those features. (See Section 3.11.)</span></p>
<ul style="list-style:none;"><li>
<h5><a name="bookmark36"></a><span class="font18">3.6 CAVEATS</span></h5></li></ul>
<p><span class="font17">(That’s Latin for “warnings.”)</span></p>
<p><span class="font17">Clearly, memoization is not a suitable solution for all performance problems. It is not even applicable to all functions. There are several kinds of functions that should not be memoized.</span></p>
<ul style="list-style:none;"><li>
<h5><a name="bookmark37"></a><span class="font19">3.6.1 Functions Whose Return Values Do Not Depend on</span></h5></li></ul>
<h5><a name="bookmark237"></a><span class="font19">Their Arguments</span></h5>
<p><span class="font17">Memoization is most suitable for functions whose return values depend only on their arguments. Imagine the foolishness of memoizing a time-of-day function: The first time you called it, you would get the time of day; subsequent calls would return the </span><span class="font17" style="font-style:italic;">same</span><span class="font17"> time. Similarly, imagine the perversity of a memoized random number generator.</span></p>
<p><span class="font17">Or imagine a function whose return value indicates a success or failure of some sort. You do not want such a function to be memoized and return the same value every time it is called.</span></p>
<p><span class="font17">However, memoization is suitable for some such functions. For example, it might be useful to memoize a function whose result depends on the current hour of the day, if the program will run for a long time. (See Section 3.7 for details about how to handle this.)</span></p>
<ul style="list-style:none;"><li>
<h5><a name="bookmark38"></a><span class="font19">3.6.2 &nbsp;Functions with Side Effects</span></h5></li></ul>
<p><span class="font17">Many functions are called not for their return values but for their side effects. Suppose you have written a program that formats a computer uptime report and delivers the report to the printer to be printed. Probably the return value is not interesting, and caching it is silly. Even if the return value is interesting, memoization is still inappropriate. The function might complete much more quickly after the first run, because of the memoization, but your boss would not be impressed, because it would have returned the old cached return value immediately, without bothering to actually print the report.<a name="footnote10"></a><sup><a href="#bookmark238">10</a></sup><sup></sup></span></p>
<p><span class="font15">3.6 CAVLATS </span><span class="font20">81</span></p>
<ul style="list-style:none;"><li>
<h5><a name="bookmark39"></a><span class="font19">3.6.3 Functions That Return References</span></h5></li></ul>
<p><span class="font17">This problem is a little more subtle. Functions that return references to values that may be modified by their callers must not be memoized.</span></p>
<p><span class="font17">To see the potential problem, consider this example:</span></p>
<p><span class="font2">use Memoize;</span></p>
<p><span class="font2">sub iota {</span></p>
<p><span class="font2">my $n = shift;</span></p>
<p><span class="font2">return [1 .. $n];</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">memoize 'iota';</span></p>
<p><span class="font2">$i10 = iota(10);</span></p>
<p><span class="font2">$j10 = iota(10);</span></p>
<p><span class="font2">pop @$i10;</span></p>
<p><span class="font2">print @$j10;</span></p>
<p><span class="font17">The first call to </span><span class="font2">iota(10) </span><span class="font17">generates a new, fresh anonymous array of the numbers from 1 to 10, and returns a reference to this array. This reference is automatically placed in the cache, and is also stored into </span><span class="font2">$i10</span><span class="font17">. The second call to </span><span class="font2">iota(10) </span><span class="font17">fetches the same reference from the cache and stores it into </span><span class="font2">$j10</span><span class="font17">. Both </span><span class="font2">$i10 </span><span class="font17">and </span><span class="font2">$j10 </span><span class="font17">now refer to the same array — we say that they are </span><span class="font17" style="font-style:italic;">aliases</span><span class="font17"> for the array.</span></p>
<p><span class="font17">When we change thevalue ofthe array via the </span><span class="font2">$i10 </span><span class="font17">alias, the change affects the value that is stored in </span><span class="font2">$j10 </span><span class="font17">! This was probably not what the caller was expecting, and it would not have happened if we had not memoized </span><span class="font2">iota</span><span class="font17">. Memoization is supposed to be an optimization. This means it is supposed to speed up the program without changing its behavior.</span></p>
<p><span class="font17">The prohibition on memoizing functions that return references to values that may be modified by the caller probably applies most commonly to object-oriented constructor methods. Consider:</span></p>
<p><span class="font2">package Octopus;</span></p>
<p><span class="font2">sub new {</span></p>
<p><span class="font2">my ($class, %args) = @_;</span></p>
<p><span class="font2">$args{tentacles} = 8;</span></p>
<p><span class="font2">bless \%args =&gt; $class;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">sub name {</span></p>
<div>
<p><span class="font20">82 </span><span class="font15" style="font-variant:small-caps;">ch</span></p>
</div><br clear="all">
<p><span class="font15">APTER 3 Caching and Memoization</span></p>
<p><span class="font2">my Sself = shift;</span></p>
<p><span class="font2">if (©_) { Sself-&gt;{name} = shift }</span></p>
<p><span class="font2">Sself-&gt;{name};</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">my Sjunko = Octopus-&gt;new(favorite_food =&gt; &quot;crab cakes&quot;);</span></p>
<p><span class="font2">$junko-&gt;name(&quot;Junko&quot;);</span></p>
<p><span class="font2">my Sfenchurch = Octopus-&gt;new(favorite_food =&gt; &quot;crab cakes&quot;);</span></p>
<p><span class="font2">$fenchurch-&gt;name(&quot;Fenchurch&quot;);</span></p>
<p><span class="font2"># This prints &quot;Fenchurch&quot; -- oops!</span></p>
<p><span class="font2">print &quot;The name of the FIRST octopus is &quot;, Sjunko-&gt;name, &quot;\n&quot;;</span></p>
<p><span class="font17">Here the programmer is expecting to manufacture two different octopuses, one named “Junko” and the other “Fenchurch.” Both octopuses enjoy crab cakes. Unfortunately, someone has foolishly decided to memoize </span><span class="font2">new()</span><span class="font17">, and since the arguments to it are the same on the second call, the memoization stub returns the cached return value from the first call, which is a reference to the “Junko” object. The programmer thinks that there are two octopuses, but really there is only one, masquerading as two.</span></p>
<p><span class="font17">Functions whose return values depend only on their arguments, and which do not have side effects, and which never return references are called </span><span class="font17" style="font-style:italic;">pure functions.</span><span class="font17"> Caching techniques are most suitable for use with pure functions, although they can sometimes be used even with impure functions.</span></p>
<ul style="list-style:none;"><li>
<h5><a name="bookmark40"></a><span class="font19">3.6.4 A Memoized Clock?</span></h5></li></ul>
<p><span class="font17">A simple and instructive example of a cached impure function is provided by Perl’s </span><span class="font2">S'T </span><span class="font17">variable. Perl provides several convenient operators for files, such as </span><span class="font2">-M Sfilename</span><span class="font17">, which returns the amount of time, in days, since the file named by its argument was last modified. To compute this, Perl asks the operating system for the last-modification time, subtracts this from the current time, and converts to days. Since </span><span class="font2">-M </span><span class="font17">may be performed very frequently, it is important that it be fast: Consider:</span></p>
<p><span class="font2">©result = sort { -M Sa &lt;=&gt; -M Sb } @files;</span></p>
<p><span class="font17">which sorts a list of files by their last modification time. It’s already expensive to look up the last-modified times for many files, and there’s no need to make thousands of calls to the </span><span class="font2">time() </span><span class="font17">function on top of that cost. Even worse, the OS</span></p>
<p><span class="font17">may track the time to an accuracy of only one second, and if the system clock happens to advance during the execution of the </span><span class="font2">sort()</span><span class="font17">, the result list might be in the wrong order!</span></p>
<p><span class="font17">To avoid these problems, Perl does not look up the current time whenever a </span><span class="font2">-M </span><span class="font17">operation is performed. Instead, when the program is first run, Perl caches the current time in the special </span><span class="font2">$&quot;T </span><span class="font17">variable, and uses that as the current time whenever </span><span class="font2">-M </span><span class="font17">is invoked. Most programs are short-lived, and most don’t need exact accuracy in the results from </span><span class="font2">-M</span><span class="font17">, so this is usually a good idea. Certain long-running programs need to periodically refresh </span><span class="font2">$&quot;T </span><span class="font17">by doing </span><span class="font2">$&quot;T = time()</span><span class="font17">, to prevent the </span><span class="font2">-M </span><span class="font17">results from getting too far out of date. When caching an impure function, it is usually a good idea to provide an expiration regime, in which old cached values are eventually discarded and refreshed. It is also prudent to allow the programmer a way to flush the entire cache. The </span><span class="font2">Memoize </span><span class="font17">module provides the opportunity to plug in a cache expiry manager.</span></p>
<ul style="list-style:none;"><li>
<h5><a name="bookmark41"></a><span class="font19">3.6.5 Very Fast Functions</span></h5></li></ul>
<p><span class="font17">I once talked to a programmer who complained that when he memoized his function, it got slower instead of faster. It turned out that the function he was trying to speed up was:</span></p>
<p><span class="font2">sub square { $_[0] * $_[0] }</span></p>
<p><span class="font17">Caching, like all techniques, is a tradeoff. The potential benefit is that you make fewer calls to the original function. The cost is that your program must examine the cache on every call. Earlier, we saw the formula </span><span class="font17" style="font-style:italic;">hf — K</span><span class="font17">, which expresses the amount of time saved by memoization. If </span><span class="font17" style="font-style:italic;">hf &lt;&nbsp;K</span><span class="font17">, then the memoized version will be slower than the unmemoized version. </span><span class="font17" style="font-style:italic;">h</span><span class="font17"> is the cache hit rate and is between 0 and 1. </span><span class="font17" style="font-style:italic;">f</span><span class="font17"> is the original running time of the function, and </span><span class="font17" style="font-style:italic;">K</span><span class="font17">is the average time needed to check the cache. If </span><span class="font17" style="font-style:italic;">f</span><span class="font17"> is smaller than </span><span class="font17" style="font-style:italic;">K</span><span class="font17">, </span><span class="font17" style="font-style:italic;">hf &lt;&nbsp;K</span><span class="font17"> will be inevitable. If the cost of examining the cache is larger than the cost of calling the original function, memoization does not make sense. You can’t save time by eliminating “unnecessary” calls because it takes longer to find out that the call is unnecessary than it does to make the call in the first place.</span></p>
<p><span class="font17">In our </span><span class="font2">square </span><span class="font17">example, the function is doing a single multiplication. Checking a cache requires a hash lookup; this includes computation of a hash value (many multiplications and additions), then indexing into the hash bucket array, and possibly a search of a linked list. There is no way this is going to beat a single multiplication. In fact, almost nothing beats a single multiplication. You can’t</span></p>
<p><span class="font17">speed up the </span><span class="font2">square </span><span class="font17">function, by memoization or any other technique, because it is already almost as fast as any function can possibly be.</span></p>
<ul style="list-style:none;"><li>
<h5><a name="bookmark42"></a><span class="font18">3.7 KEY GENERATION</span></h5></li></ul>
<p><span class="font17">The memoizer we saw earlier has at least one serious problem. It needs to turn the function arguments into a hash key, and the way it does that is with </span><span class="font2">join</span><span class="font17">:</span></p>
<p><span class="font2">my $key = join ',', @_;</span></p>
<p><span class="font17">This works for functions with only one argument, and it works for functions whose arguments never contain commas, including all functions whose arguments are numbers. But if the function arguments may contain commas, it might fail, because the same key is computed for these two calls:</span></p>
<p><span class="font2">func(&quot;x,&quot;, &quot;y&quot;);</span></p>
<p><span class="font2">func(&quot;x&quot;, &quot;,y&quot;);</span></p>
<p><span class="font17">When the first call is made, the return value will be stored in the cache under the key </span><span class="font2">&quot;x„y&quot;</span><span class="font17">. When the second call is made, the true function will not be consulted. Instead the cached value from the first call will be returned. But the function might have wanted to return a different value — the memoization code has confused these two argument lists, resulting in a false cache hit.</span></p>
<p><span class="font17">Since this can fail only for functions whose arguments may contain commas, it may not be a consideration. Even if the function arguments may contain commas, it’s possible that there is some other character that they will never contain. The Perl special variable </span><span class="font2">$; </span><span class="font17">is sometimes used here. It normally contains character </span><span class="font2">#28</span><span class="font17">, which is the control-backslash character. If the key generator uses </span><span class="font2">join $; , @_</span><span class="font17">, it will fail only when the function arguments contain controlbackslash; it is often possible to be sure this will never occur. But often we have a function whose argument could contain absolutely anything, and one of these partial hacks won’t work reliably.</span></p>
<p><span class="font17">This can be fixed, because there’s always a way to turn any data structure, such as an argument list, into a string in a faithful way, so that different structures become different strings.<a name="footnote11"></a><sup><a href="#bookmark239">11</a></sup><sup></sup></span></p>
<p><span class="font15">3.7 KEY GEN</span></p>
<div>
<p><span class="font15" style="font-variant:small-caps;">eration</span><span class="font20"> 85</span></p>
</div><br clear="all">
<p><span class="font17">One strategy would be to use the </span><span class="font2">Storable </span><span class="font17">or </span><span class="font2">FreezeThaw </span><span class="font17">module to turn the argument list into a string. A much more efficient strategy is to use escape sequences:</span></p>
<p><span class="font2">my @args = @_;</span></p>
<p><span class="font2">s/([\\,])/\\$1/g for @args;</span></p>
<p><span class="font2">my $key = join &quot;,&quot;, @args;</span></p>
<p><span class="font17">Here we insert a backslash character before every comma or backslash in the original arguments, then join the results together with unbackslashed commas. The problem calls we saw earlier are no longer problems, because the two argument lists are transformed to different keys: one to </span><span class="font2">'x\,,y' </span><span class="font17">and the other to </span><span class="font2">'x,\,y'</span><span class="font17">. (An exercise: Why is it necessary to put a backslash before every backslash character as well as before every comma?)</span></p>
<p><span class="font17">However, correctness has been bought at a stiff performance price. The escape character code is much slower than the simple </span><span class="font2">join — </span><span class="font17">about ten times slower even for a simple argument list such as </span><span class="font2">(1,2) — </span><span class="font17">and it must be performed on </span><span class="font17" style="font-style:italic;">every</span><span class="font17"> call to the function. Normally, we laugh at people who are willing to trade correctness for speed, since it doesn’t matter how quickly one is able to find the wrong answer. But this is an unusual circumstance. Since the only purpose of memoization is to speed up a function, we want the overhead to be as small as possible.</span></p>
<p><span class="font17">We’ll adopt a compromise. The default behavior of</span><span class="font2">memoize </span><span class="font17">will be fast, but not correct in all cases. We’ll give the user of</span><span class="font2">memoize </span><span class="font17">an escape hatch to fix this. If the user doesn’t like the default key-generation method, they may supply an alternative, which </span><span class="font2">memoize </span><span class="font17">will use instead.</span></p>
<p><span class="font17">The change is simple:</span></p>
<p><span class="font2">sub memoize {</span></p>
<div>
<p><span class="font9" style="font-weight:bold;">CODE LIBRARY</span></p>
</div><br clear="all">
<div>
<p><span class="font0">memoize-norm1</span></p>
</div><br clear="all">
<p><span class="font2" style="font-weight:bold;">my ($func, $keygen) = @_;</span></p>
<p><span class="font2">my %cache;</span></p>
<p><span class="font2">my $stub = sub {</span></p>
<p><span class="font2" style="font-weight:bold;">my $key = $keygen ? $keygen-&gt;(@_) : join ',', @_;</span></p>
<p><span class="font2">$cache{$key} = $func-&gt;(@_) unless exists $cache{$key}; return $cache{$key};</span></p>
<p><span class="font2">};</span></p>
<p><span class="font2">return $stub;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">The stub returned by </span><span class="font2">memoize </span><span class="font17">looks to see if a </span><span class="font2">$keygen </span><span class="font17">function was supplied when the original function was memoized. If so, it uses the </span><span class="font2">keygen </span><span class="font17">function to </span></p>
<p><span class="font17">construct the hash key; if not, it uses the default method. The extra test is fairly cheap, but we can eliminate it if we want to by performing the test for </span><span class="font2">Skeygen </span><span class="font17">once, at the time the function is memoized, instead of once for each call to the memoized function:</span></p>
<div>
<p><span class="font9" style="font-weight:bold;">CODE LIBRARY</span></p>
</div><br clear="all">
<div>
<p><span class="font0">memoize-norm2</span></p>
</div><br clear="all">
<p><span class="font2">sub memoize {</span></p>
<p><span class="font2">my (Sfunc, Skeygen) = @_;</span></p>
<p><span class="font2">my %cache;</span></p>
<p><span class="font2">my Sstub = Skeygen ?</span></p>
<p><span class="font2">sub { my Skey = Skeygen-&gt;(@_);</span></p>
<p><span class="font2">Scache{Skey} = Sfunc-&gt;(@_) unless exists Scache{Skey}; return Scache{Skey};</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">sub { my Skey = join ',', @_;</span></p>
<p><span class="font2">Scache{Skey} = Sfunc-&gt;(@_) unless exists Scache{Skey}; return Scache{Skey};</span></p>
<p><span class="font2">}</span></p>
<p><span class="font3"><sup>;</sup></span></p>
<p><span class="font2">return Sstub;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">We can pull an even better trick here. In these versions of </span><span class="font2">memoize</span><span class="font17">, </span><span class="font2">Skeygen </span><span class="font17">is an anonymous function that has to be invoked on each call to the memoized function. Perl, unfortunately, has a relatively high overhead for function calls, and since the purpose of</span><span class="font2">memoize </span><span class="font17">is to speed things up, we’d like to avoid this if we can.</span></p>
<p><span class="font17">Perl’s </span><span class="font2">eval </span><span class="font17">feature comes to the rescue here. Instead of specifying </span><span class="font2">Skeygen </span><span class="font17">as a reference to a key-generation function, we’ll pass in a string that contains the code to generate the key, and incorporate this code directly into the stub, rather than as a sub-function that the stub must call.</span></p>
<p><span class="font17">To use this version of </span><span class="font2">memoize</span><span class="font17">, we will say something like this:</span></p>
<p><span class="font2">Smemoized = memoize(\&amp;fib, q{my @args = @_;</span></p>
<p><span class="font2">s/([\\,])/\\S1/g for @args;</span></p>
<p><span class="font2">join ',', @args;</span></p>
<p><span class="font2">});</span></p>
<p><span class="font2">memoize </span><span class="font17">will interpolate this bit of code into the appropriate place in a template of the memoized function (this is called </span><span class="font17" style="font-style:italic;">inlining)</span><span class="font17"> and use </span><span class="font2">eval </span><span class="font17">to compile the</span></p>
<p><span class="font17">result into a real function:</span></p>
<p><span class="font2">sub memoize { my (Sfunc, Skeygen) = @_; Skeygen ||=q{join ',', @_};</span></p>
<div>
<p><span class="font9" style="font-weight:bold;">CODE LIBRARY</span></p>
</div><br clear="all">
<div>
<p><span class="font0">memoize-norm3</span></p>
</div><br clear="all">
<p><span class="font2">my %cache;</span></p>
<p><span class="font2">my Snewcode = q{</span></p>
<p><span class="font2">sub { my Skey = do { KEYGEN };</span></p>
<p><span class="font2">Scache{Skey} = Sfunc-&gt;(@_) unless exists Scache{Skey}; return Scache{Skey};</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">};</span></p>
<p><span class="font2">Snewcode =- s/KEYGEN/Skeygen/g;</span></p>
<p><span class="font2">return eval Snewcode;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">Here we used Perl’s </span><span class="font2">q{...} </span><span class="font17">operator, which is identical with </span><span class="font2">'...'</span><span class="font17">, except that single-quote characters aren’t special inside of </span><span class="font2">q{...}</span><span class="font17">. Instead, the </span><span class="font2">q{...} </span><span class="font17">construction ends at the first matching </span><span class="font2">} </span><span class="font17">character. If we hadn’t used </span><span class="font2">q{...} </span><span class="font17">here, the third line would have been rather cryptic:</span></p>
<p><span class="font2">Skeygen ||= 'join \',\', @_';</span></p>
<p><span class="font17">We used the </span><span class="font2">s/// </span><span class="font17">operator to inline the value of </span><span class="font2">Skeygen</span><span class="font17">, instead of simply interpolating it into a double-quoted string. This is slightly less efficient, but it needs to be done only once per memoized function, so it probably doesn’t matter. The benefit is that with the </span><span class="font2">s/// </span><span class="font17">technique, the </span><span class="font2">Snewcode </span><span class="font17">variable is easy to read; if we had used string interpolation, it would have been:</span></p>
<p><span class="font2">my Snewcode = &quot;</span></p>
<p><span class="font2">sub { my \Skey = do { Skeygen };</span></p>
<p><span class="font2">\Scache{\Skey} = \Sfunc-&gt;(\@_) unless exists \Scache{\Skey}; return \Scache{\Skey};</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">&quot;;</span></p>
<p><span class="font17">Here the backslashes clutter up the code. A maintenance programmer reading this might not notice that </span><span class="font2">Skeygen </span><span class="font17">is being interpolated even though everything else is backslashed. With the </span><span class="font2">s/// </span><span class="font17">technique, </span><span class="font2">KEYGEN </span><span class="font17">stands out clearly.</span></p>
<p><span class="font17">For this example, the cache management overhead is about 37% lower with the inlining version of </span><span class="font2">memoize</span><span class="font17">.</span></p>
<p><span class="font17">It’s easy to tweak this version so that it still accepts a function reference the way the previous one did:</span></p>
<div>
<p><span class="font9" style="font-weight:bold;">CODE LIBRARY</span></p>
</div><br clear="all">
<div>
<p><span class="font0">memoize-norm4</span></p>
</div><br clear="all">
<p><span class="font2">sub memoize {</span></p>
<p><span class="font2">my (Sfunc, Skeygen) = @_;</span></p>
<p><span class="font2" style="font-weight:bold;">my Skeyfunc;</span></p>
<p><span class="font2">if (Skeygen eq '') {</span></p>
<p><span class="font2">Skeygen = q{join ',', @_}</span></p>
<p><span class="font2" style="font-weight:bold;">} elsif (UNIVERSAL::isa(Skeygen, 'CODE')) {</span></p>
<p><span class="font2" style="font-weight:bold;">Skeyfunc = Skeygen;</span></p>
<p><span class="font2" style="font-weight:bold;">Skeygen = q{Skeyfunc-&gt;(@_)};</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">my %cache;</span></p>
<p><span class="font2">my Snewcode = q{</span></p>
<p><span class="font2">sub { my Skey = do { KEYGEN };</span></p>
<p><span class="font2">Scache{Skey} = Sfunc-&gt;(@_) unless exists Scache{Skey}; return Scache{Skey};</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">};</span></p>
<p><span class="font2">Snewcode =- s/KEYGEN/Skeygen/g;</span></p>
<p><span class="font2">return eval Snewcode;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">Here, if no key generator is supplied, we inline </span><span class="font2">join ',', @_ </span><span class="font17">as usual. If </span><span class="font2">Skeygen </span><span class="font17">is a function reference, we can’t simply inline it, because it will turn into something useless like </span><span class="font2">CODE(0x436c1d)</span><span class="font17">. Instead, we save the function reference in the </span><span class="font2">Skeyfunc </span><span class="font17">variable and inline some code that will call the function via </span><span class="font2">Skeyfunc</span><span class="font17">.</span></p>
<p><span class="font17">The </span><span class="font2">UNIVERSAL::isa(Skeygen, 'CODE') </span><span class="font17">line requires some explanation. We want to test to see if </span><span class="font2">Skeygen </span><span class="font17">is a code reference. The obvious way of doing that is:</span></p>
<p><span class="font2">if (ref(Skeygen) eq 'CODE') { ... }</span></p>
<p><span class="font17">Unfortunately, the Perl </span><span class="font2">ref </span><span class="font17">function is broken, because it confuses two different properties of its argument. If </span><span class="font2">Skeygen </span><span class="font17">is a </span><span class="font17" style="font-style:italic;">blessed</span><span class="font17"> code reference, the test above will fail, because </span><span class="font2">ref </span><span class="font17">will return the name of the class into which </span><span class="font2">Skeygen </span><span class="font17">has been blessed. Using </span><span class="font2">UNIVERSAL::isa </span><span class="font17">avoids this problem. It’s also possible, although much less likely, that the test could yield true for a non-code reference; this will happen if someone has been silly enough to bless the non-code reference into the class </span><span class="font2">CODE</span><span class="font17">.</span></p>
<ul style="list-style:none;"><li>
<h5><a name="bookmark43"></a><span class="font19">3.7.1 More Applications of User-Supplied Key Generators</span></h5></li></ul>
<p><span class="font17">With any of these key-generation features, users of our </span><span class="font2">memoize </span><span class="font17">function have escape hatches if the </span><span class="font2">join </span><span class="font17">method doesn’t work correctly for the function they are trying to memoize. They can substitute a key generator based on </span><span class="font2">Storable </span><span class="font17">or the escape-character method or whatever is appropriate.</span></p>
<p><span class="font17">User-supplied key generators solve the problems that may occur when two different argument lists hash to the same key. They also solve the converse problem, which occurs when two equivalent argument lists hash to different keys.</span></p>
<p><span class="font17">Consider a function whose argument is a hash, which might contain any, all, or none of the keys </span><span class="font2">A</span><span class="font17">, </span><span class="font2">B</span><span class="font17">, and </span><span class="font2">C</span><span class="font17">, each with an associated numeric value. Further, suppose that </span><span class="font2">B</span><span class="font17">, if omitted, defaults to 17, and </span><span class="font2">A </span><span class="font17">defaults to 32:</span></p>
<p><span class="font2">sub example {</span></p>
<p><span class="font2">my %args = @_;</span></p>
<p><span class="font2">$args{A} = 32 unless defined $args{A};</span></p>
<p><span class="font2">$args{B} = 17 unless defined $args{B};</span></p>
<p><span class="font2"># ...</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">Then the following calls are all equivalent:</span></p>
<table border="1">
<tr><td>
<p><span class="font2">example(C =&gt;</span></p></td><td>
<p><span class="font2">99);</span></p></td></tr>
<tr><td>
<p><span class="font2">example(C =&gt;</span></p></td><td>
<p><span class="font2">99, A =&gt; 32);</span></p></td></tr>
<tr><td>
<p><span class="font2">example(A =&gt;</span></p></td><td>
<p><span class="font2">32, C =&gt; 99);</span></p></td></tr>
<tr><td>
<p><span class="font2">example(B =&gt;</span></p></td><td>
<p><span class="font2">17, C =&gt; 99);</span></p></td></tr>
<tr><td>
<p><span class="font2">example(C =&gt;</span></p></td><td>
<p><span class="font2">99, B =&gt; 17);</span></p></td></tr>
<tr><td style="vertical-align:bottom;">
<p><span class="font2">example(A =&gt;</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">32, C =&gt; 99, B =&gt;</span></p></td></tr>
<tr><td style="vertical-align:bottom;">
<p><span class="font2">example(B =&gt;</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">17, A =&gt; 32, C =&gt;</span></p></td></tr>
<tr><td style="vertical-align:bottom;">
<p><span class="font2">(etc.)</span></p></td><td></td></tr>
</table>
<p><span class="font2">17);</span></p>
<p><span class="font2">99);</span></p>
<p><span class="font17">The </span><span class="font2">join </span><span class="font17">method of key construction generates a different key for each of these calls (</span><span class="font2">&quot;C,99&quot; </span><span class="font17">versus </span><span class="font2">&quot;A,32,C,99&quot; </span><span class="font17">versus </span><span class="font2">&quot;C,99,A,32&quot; </span><span class="font17">and so forth). The cache manager will therefore miss opportunities to avoid calling the real </span><span class="font2">example() </span><span class="font17">function. A call to </span><span class="font2">example(A =&gt; 32, C =&gt; 99) </span><span class="font17">must produce the same result as a call to </span><span class="font2">example(C =&gt; 99, A =&gt; 32)</span><span class="font17">, but the cache manager doesn’t know that, because the argument lists are superficially different. If we can arrange that equivalent argument lists are transformed to the same hash key, the cache manager will return the same value for </span><span class="font2">example(C =&gt;99, A =&gt; 32) </span><span class="font17">that it had previously computed for </span><span class="font2">example(A =&gt;32, C =&gt; 99)</span><span class="font17">, without the redundant</span></p>
<div>
<p><span class="font20">90</span></p>
</div><br clear="all">
<p><span class="font15">CHAPTER 3 Caching and Memoization</span></p>
<p><span class="font17">call to </span><span class="font2">example</span><span class="font17">. This will increase the cache hit rate </span><span class="font17" style="font-style:italic;">h</span><span class="font17"> in the formula </span><span class="font17" style="font-style:italic;">hf — K</span><span class="font17">that expresses the speed-up from memoization. The following key generator does the trick:</span></p>
<p><span class="font2">sub {</span></p>
<p><span class="font2">my %h = @_;</span></p>
<p><span class="font2">$h{A} = 32 unless defined $h{A};</span></p>
<p><span class="font2">$h{B} = 17 unless defined $h{B}; join &quot;,&quot;, @h{'A','B','C'};</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">Each of the eight equivalent calls (of which </span><span class="font2">example(C =&gt;99, A =&gt; 32) </span><span class="font17">was one) receives a key of </span><span class="font2">&quot;32,17,99&quot; </span><span class="font17">from this function. Here we pay an up-front cost: This key generator takes about ten times as long as the simple </span><span class="font2">join </span><span class="font17">generator, so the </span><span class="font17" style="font-style:italic;">K</span><span class="font17"> in the </span><span class="font17" style="font-style:italic;">hf</span><span class="font3"> — </span><span class="font17" style="font-style:italic;">K</span><span class="font17"> formula is larger. Whether this cost is repaid depends on how expensive it is to call the real function, </span><span class="font17" style="font-style:italic;">f</span><span class="font17">, and on the size of the increase of cache hits frequency, </span><span class="font17" style="font-style:italic;">h</span><span class="font17">. As usual, there is no substitute for benchmarking.</span></p>
<ul style="list-style:none;"><li>
<h5><a name="bookmark44"></a><span class="font19">3.7.2 Inlined Cache Manager with Argument Normalizer</span></h5></li></ul>
<p><span class="font17">Here’s an interesting trick we can play with the inlined key-generation code.</span></p>
<p><span class="font17">Consider the following function, a variation on the example we just saw:</span></p>
<p><span class="font2">sub example {</span></p>
<p><span class="font2">my ($a, $b, $c) = @_;</span></p>
<p><span class="font2">$a = 32 unless defined $a;</span></p>
<p><span class="font2">$b = 17 unless defined $b;</span></p>
<p><span class="font2"># more calculation here ...</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">A suitable key generator might be:</span></p>
<p><span class="font2">my ($a, $b, $c) = @_;</span></p>
<p><span class="font2">$a = 32 unless defined $a;</span></p>
<p><span class="font2">$b = 17 unless defined $b;</span></p>
<p><span class="font2">join ',', $a, $b, $c;</span></p>
<p><span class="font17">It’s a little irritating to have to repeat the code that sets the defaults for the arguments, and equally irritating to have to run it twice. If we change the</span></p>
<ul style="list-style:none;"><li>
<p class="font15">3.7 KEY GENERATION <span class="font20">91</span></p></li></ul>
<p><span class="font17">key-generation code as follows, we will be able to remove the argument checking from the example function:</span></p>
<p><span class="font2">$_[0] = 32 unless defined $_[0];</span></p>
<p><span class="font2">$_[1] = 17 unless defined $_[1];</span></p>
<p><span class="font2">join ',', @_;</span></p>
<p><span class="font17">When this is inlined into the </span><span class="font2">memoize </span><span class="font17">function, the result is:</span></p>
<p><span class="font2">sub { my $key = do { $_[0] = 32 unless defined $_[0];</span></p>
<p><span class="font2">$_[1] = 17 unless defined $_[1];</span></p>
<p><span class="font2">join ',', @_;</span></p>
<p><span class="font2">};</span></p>
<p><span class="font2">$cache{$key} = $func-&gt;(@_) unless exists $cache{$key};</span></p>
<p><span class="font2">return $cache{$key};</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">Notice what happens here. The key is generated as before, but there is a side effect: </span><span class="font2">@_ </span><span class="font17">is modified. If there is a cache miss, the memoized function calls </span><span class="font2">$func </span><span class="font17">with the modified </span><span class="font2">@_</span><span class="font17">. Since </span><span class="font2">@_ </span><span class="font17">has been modified to include the default values already, we can omit the default-setting code from the original function:</span></p>
<p><span class="font2">sub example {</span></p>
<p><span class="font2">my ($a, $b, $c) = @_;</span></p>
<p><span class="font2">## defaults set by key generation code</span></p>
<p><span class="font2">## $a = 32 unless defined $a;</span></p>
<p><span class="font2">## $b = 17 unless defined $b;</span></p>
<p><span class="font2"># more calculation here ...</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">Of course, once we’ve modified the </span><span class="font2">example </span><span class="font17">function in this way, we can’t turn the memoization off, because essential functionality has been moved into the key generator.</span></p>
<p><span class="font17">Another danger with this technique is that modifying </span><span class="font2">@_ </span><span class="font17">can have peculiar effects back in the </span><span class="font17" style="font-style:italic;">calling</span><span class="font17"> function. Elements of </span><span class="font2">@_ </span><span class="font17">are aliased to the corresponding arguments back in the caller, and assigning to elements of </span><span class="font2">@_ </span><span class="font17">in the memoized function can modify variables outside the memoized function. Here is a simple example:</span></p>
<p><span class="font2">sub set_to_57 {</span></p>
<p><span class="font2">$_[0] = 57;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">my $x = 119;</span></p>
<p><span class="font2">set_to_57($x);</span></p>
<p><span class="font17">This does set </span><span class="font2">$x </span><span class="font17">to 57, as if we had done </span><span class="font2">$x = 57</span><span class="font17">, even though the assignment is performed outside the scope of </span><span class="font2">$x </span><span class="font17">and shouldn’t be able to affect it. Our assignments inside the key-generator code may have similar effects.</span></p>
<p><span class="font17">Sometimes this feature of Perl is useful, but most often it is more trouble than it is worth, and we normally avoid it. We do this by never operating on </span><span class="font2">@_ </span><span class="font17">directly, but by copying its contents into a series of lexical variables as soon as the function is called:</span></p>
<p><span class="font2">sub safe_function {</span></p>
<p><span class="font2">my ($n) = @_;</span></p>
<p><span class="font2">$n = 57; # does *not* set $x to 57 } my $x = 119;</span></p>
<p><span class="font2">safe_function($x);</span></p>
<p><span class="font17">By combining these techniques, we can get a version of the key-generation code that obviates the need for the default-setting code in the real function, but which is still safe:</span></p>
<p><span class="font2">memoize(\&amp;example, q{</span></p>
<p><span class="font2">my ($a, $b, $c) = @_;</span></p>
<p><span class="font2">$a = 32 unless defined $a;</span></p>
<p><span class="font2">$b = 17 unless defined $b;</span></p>
<p><span class="font2">@_ = ($a, $b, $c); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# line 5</span></p>
<p><span class="font2">join ',', @_;</span></p>
<p><span class="font2">});</span></p>
<p><span class="font17">The elements of </span><span class="font2">@_ </span><span class="font17">are aliases for the arguments back in the calling function, but </span><span class="font2">@_ </span><span class="font17">itself isn’t. The assignment to </span><span class="font2">@_ </span><span class="font17">on line 5 doesn’t overwrite the values back in the caller; it discards the aliases entirely and replaces the contents of </span><span class="font2">@_ </span><span class="font17">with the new values. This trick works only when the key-generation code is inlined into the memoized function; if the key-generation code is called as a subroutine, the change to </span><span class="font2">@_ </span><span class="font17">has no effect after the subroutine returns.</span></p>
<ul style="list-style:none;"><li>
<h5><a name="bookmark45"></a><span class="font19">3.7.3 Functions with Reference Arguments</span></h5></li></ul>
<p><span class="font17">Here’s another problem solved by the custom key-generator feature. Consider this function:</span></p>
<p><span class="font2">sub is_in {</span></p>
<p><span class="font2">my (Sneedle, Shaystack) = @_;</span></p>
<p><span class="font2">for my Sitem (@Shaystack) {</span></p>
<p><span class="font2">return 1 if Sitem == Sneedle;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">return;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">The function takes </span><span class="font2">Sneedle</span><span class="font17">, which is a number, and </span><span class="font2">Shaystack</span><span class="font17">, which is a list of numbers, and returns true if and only if </span><span class="font2">Shaystack </span><span class="font17">contains </span><span class="font2">Sneedle</span><span class="font17">. A typical call is:</span></p>
<p><span class="font2">if (is_in(Smy_id, \@employee_ids)) { ... }</span></p>
<p><span class="font17">We might like to try memoizing </span><span class="font2">is_in</span><span class="font17">, but a possible problem is that the </span><span class="font2">Shaystack </span><span class="font17">argument is a reference. When it is handled by the </span><span class="font2">join </span><span class="font17">function, it turns into a string like </span><span class="font2">ARRAY(0x436c1d)</span><span class="font17">. If we later call </span><span class="font2">is_in() </span><span class="font17">with a </span><span class="font2">Shaystack </span><span class="font17">argument that refers to a different array with the same contents, the hash key will be different, which may not be what we want; conversely, if the contents of </span><span class="font2">@employee_ids </span><span class="font17">change, the hash key will still be the same, which certainly isn’t what we want. The key generator is generating the key from the identity of the array, but the </span><span class="font2">is_in() </span><span class="font17">function doesn’t care about the identity of the array; it cares only about the contents. A more appropriate key-generation function in this case is:</span></p>
<p><span class="font2">sub { join &quot;,&quot;, S_[0], @{S_[1]} }</span></p>
<p><span class="font17">Again, whether this actually produces a performance win depends on many circumstances that will be hard to foresee. When performance is important, it is essential to gather real data. Long experience has shown that even experts are likely to guess wrong about what is fast and what is slow.</span></p>
<ul style="list-style:none;"><li>
<h5><a name="bookmark46"></a><span class="font19">3.7.4 &nbsp;Partitioning</span></h5></li></ul>
<p><span class="font17">The </span><span class="font2">find_share </span><span class="font17">function of Chapter 1 provides a convenient example of a function for which memoization fixes slow recursion, as well as requiring a custom</span></p>
<p><span class="font17">key generator:</span></p>
<p><span class="font2">sub find_share {</span></p>
<p><span class="font2">my (Starget, Streasures) = @_;</span></p>
<p><span class="font2">return [] if Starget == 0;</span></p>
<p><span class="font2">return if Starget &lt;&nbsp;0 || @Streasures == 0;</span></p>
<p><span class="font2">my (Sfirst, @rest) = @Streasures;</span></p>
<p><span class="font2">my Ssolution = find_share(Starget-Sfirst, \@rest);</span></p>
<p><span class="font2">return [Sfirst, @Ssolution] if Ssolution;</span></p>
<p><span class="font2">return &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;find_share(Starget &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;, \@rest);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">As you’ll recall, this function takes an array of treasures and a target value, and tries to select a subset of the treasures that total the target value exactly. If there is such a set, it returns an array with just those treasures; if not, it returns </span><span class="font2">undef</span><span class="font17">.</span></p>
<p><span class="font17">We saw in Chapter 1 that this function has the same problem as the </span><span class="font2">fib </span><span class="font17">function: It can be slow, because it repeats the same work over and over again. When trying to select treasures from </span><span class="font2">1 23456789 10 </span><span class="font17">that total 53, </span><span class="font2">find_share </span><span class="font17">comes upon the same situation twice: Itfindsthat 1</span><span class="font3">+</span><span class="font17">2</span><span class="font3">+</span><span class="font17">3 </span><span class="font3">+ </span><span class="font17">6 </span><span class="font3">= </span><span class="font17">12, andinvokes </span><span class="font2">find_share(41, [7,8,9,10])</span><span class="font17">, which eventually returns undefined. Then later, it finds that 1 </span><span class="font3">+ </span><span class="font17">2 </span><span class="font3">+ </span><span class="font17">4 </span><span class="font3">+ </span><span class="font17">5 </span><span class="font3">= </span><span class="font17">12, and invokes </span><span class="font2">find_share(41, [7,8,9,10]) </span><span class="font17">a second time. Clearly, this is a good opportunity to try some caching.</span></p>
<p><span class="font17">For even this simple case, memoization yields a speed-up of about 68%. For larger examples, such as </span><span class="font2">find_share(200, [1..20])</span><span class="font17">, the speedup is larger, about 82%. In some cases, memoization can make the difference between a practical and an impractical algorithm. The unmemoized version of </span><span class="font2">find_share([1..20], 210) </span><span class="font17">takes several </span><span class="font17" style="font-style:italic;">thousand</span><span class="font17"> times longer to run than the memoized version. (I used the key generation function </span><span class="font2">sub {join &quot;-&quot;, @{S_[1]}, S_[0]}</span><span class="font17">.)</span></p>
<ul style="list-style:none;"><li>
<h5><a name="bookmark47"></a><span class="font19">3.7.5 Custom Key Generation for Impure Functions</span></h5></li></ul>
<p><span class="font17">Custom key generation can also be used to deal with certain kinds of functions that depend on information other than their arguments.</span></p>
<p><span class="font17">Let’s consider a long-running network server program whose job is to sell some product, such as pizzas or weapons-grade plutonium. The cost of a pizza or a canister of plutonium includes the cost of delivery, which in turn depends on the current hour of the day and day of the week. Delivery late at night and on weekends is more expensive because fewer delivery persons are available and</span></p>
<ul style="list-style:none;"><li>
<p class="font15">3.7 KEY GENERATION <span class="font20">95</span></p></li></ul>
<p><span class="font17">nobody likes to work at 3 AM.<a name="footnote12"></a><sup><a href="#bookmark240">12</a></sup><sup></sup> The server might contain a function something like this:</span></p>
<p><span class="font2">sub delivery_charge {</span></p>
<div>
<p><span class="font9" style="font-weight:bold;">CODE LIBRARY</span></p>
</div><br clear="all">
<p><span class="font2">my (Squantity_ordered) = @_; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="font0"><sup>deliver</sup>y<sup>-c</sup>ha<sup>rge</sup></span></p>
<p><span class="font2">my (Shour, Sday_of_week) = (localtime)[2,6];</span></p>
<ul style="list-style:none;"><li>
<p><span class="font2"># perform complex computation involving Sweight, $gross_cost,</span></p></li>
<li>
<p><span class="font2"># &nbsp;&nbsp;&nbsp;&nbsp;Shour, Sday_of_week, and Squantity_ordered</span></p></li>
<li>
<p><span class="font2"># ...</span></p></li></ul>
<p><span class="font2">return Sdelivery_charge;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">Because the function is complicated, we would like to memoize it. The default key generator, </span><span class="font2">join(',', @_)</span><span class="font17">, is unsuitable here, because we would lose the time dependence of the delivery charge. But it’s easy to solve the problem with a custom key-generation function such as:</span></p>
<p><span class="font2">sub delivery_charge_key {</span></p>
<p><span class="font2">join ',', @_, (localtime)[2,6];</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">delivery_charge </span><span class="font17">is not a pure function, but in this case it may not matter. The only real issue is whether there will be enough cache hits to gain a performance win. We might expect the function to have many cache misses for the first week, until the day of the week rolls over, and then to start seeing more cache hits. In this case the effectiveness of the caching might depend on the longevity of the program. Similarly, we might wonder if the following key-generation function wouldn’t be better:</span></p>
<p><span class="font2">sub delivery_charge_key {</span></p>
<p><span class="font2">my (Shour, Sday_of_week) = (localtime)[2,6];</span></p>
<p><span class="font2">my Sweekend = Sday_of_week == 0 || Sday_of_week == 6;</span></p>
<p><span class="font2">join ',', @_, Shour, Sweekend;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">This function takes longer to run, but might get more cache hits because it recognizes that values cached on Monday may be used again on Tuesday and Wednesday. Again, which is best will depend on subtle factors in the program’s behavior.</span></p>
<div>
<p><span class="font20">96</span></p>
</div><br clear="all">
<p><span class="font15">CHAPTER 3 Caching and Memoization</span></p>
<ul style="list-style:none;"><li>
<h5><a name="bookmark48"></a><span class="font18">3.8 CACHING IN OBJECT METHODS</span></h5></li></ul>
<p><span class="font17">For object methods, it often makes little sense to store the cached values in a separate hash. Consider an </span><span class="font2">Investor </span><span class="font17">object in a program written by an investment bank. The object represents one of the bank’s customers:</span></p>
<p><span class="font2">package Investor;</span></p>
<ul style="list-style:none;"><li>
<p><span class="font2"># Compute total amount currently invested sub total {</span></p></li></ul>
<p><span class="font2">my $self = shift;</span></p>
<p><span class="font2"># ... complex computation performed here ... return $total;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">If the </span><span class="font2">$total </span><span class="font17">is not expected to change, we might add caching to it, using the object’s identity as a key into the cache hash:</span></p>
<ul style="list-style:none;"><li>
<p><span class="font2"># Compute total amount currently invested</span></p></li></ul>
<p><span class="font2">{ my %cache;</span></p>
<p><span class="font2">sub total {</span></p>
<p><span class="font2">my $self = shift;</span></p>
<p><span class="font2">return $cache{$self} if exists $cache{$self};</span></p>
<p><span class="font2"># ... complex computation performed here ... return $cache{$self} = $total;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">However, this technique has a serious problem. When we use an object as a hash key, Perl converts it to a string. The typical hash key will look like </span><span class="font2">Investor=HASH(0x80ef8dc)</span><span class="font17">. The hexadecimal numeral is the address at which the object’s data is actually stored. It is essential that this key be different for every two objects, or we run the risk of false cache hits, where we retrieve one object’s total while thinking that it belongs to a different object. In Perl, these hash keys are indeed distinct for all the live objects in the system at any given time, but no guarantee is made about dead objects. If an object is destroyed and a new object is created, the new object might very well exist at the same memory address formerly occupied by the old object and thus be confused with it:</span></p>
<ul style="list-style:none;"><li>
<p><span class="font2"># here 90,000 is returned from the cache</span></p></li></ul>
<p><span class="font2">$old_total = $old_object-&gt;total();</span></p>
<ul style="list-style:none;"><li>
<p class="font15">3.8 CACHING IN OBJECT METHODS <span class="font20">97</span></p></li></ul>
<p><span class="font2">undef $old_object;</span></p>
<p><span class="font2">$new_object = Investor-&gt;new();</span></p>
<p><span class="font2">$new_total = $new_object-&gt;total();</span></p>
<p><span class="font17">Here we ask for the total for the new investor. It should be 0, since the investor is new. But instead, the </span><span class="font2">-&gt;total </span><span class="font17">method happens to look in the cache under the same hash key that was used by the </span><span class="font2">$old_object </span><span class="font17">that was recently destroyed; the method sees the </span><span class="font2">90000 </span><span class="font17">stored there, and returns it erroneously. This problem can be solved with a </span><span class="font2">DESTROY </span><span class="font17">method that deletes an object’s data from the cache, or by associating a unique, non-re-usable ID number with every object in the program, and using the ID number as the hash key, but there is a much more straightforward solution.</span></p>
<p><span class="font17">In an OOP context, the cache hash technique is peculiar, because there is a more natural place to store the cached data: as member data in the object itself. A cached total becomes another property that might or might not be carried by each individual object:</span></p>
<p><span class="font2"># Compute total amount currently invested</span></p>
<p><span class="font2">sub total {</span></p>
<p><span class="font2">my $self = shift;</span></p>
<p><span class="font2">return $self-&gt;{cached_total} if exists $self-&gt;{cached_total};</span></p>
<p><span class="font2"># ... complex computation performed here ...</span></p>
<p><span class="font2">return $self-&gt;{cached_total} = $total;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">Here the logic is exactly the same as before; the only difference is that the method stores the total for each object in the object itself, instead of in an auxiliary hash. This avoids the problem of hash key collision that arose with the auxiliary hash.</span></p>
<p><span class="font17">Another advantage of this technique is that the space devoted to storage of the cached total is automatically reclaimed when the object is destroyed. With the auxiliary hash, each cached value would persist forever, even after the object to which it belonged was destroyed.</span></p>
<p><span class="font17">Finally, storing the cached information in each object allows more flexible control over when it is expired. In our example </span><span class="font2">total </span><span class="font17">computes the total amount of money that a certain investor has invested. Caching this total may be appropriate since investors may not invest new money too frequently. But caching it forever is probably not appropriate. In this example, whenever an investor invests more money, we need some way of signalling the </span><span class="font2">total </span><span class="font17">function that the cached total is no longer correct, and must be recomputed from scratch. This is called </span><span class="font17" style="font-style:italic;">expiring</span><span class="font17"> the cached value.</span></p>
<p><span class="font17">With the auxiliary hash technique, there was no way to do this without adding a special-purpose method in the scope of the cache hash, something like this:</span></p>
<p><span class="font2"># Compute total amount currently invested</span></p>
<p><span class="font2">{ my %cache;</span></p>
<p><span class="font2">sub total {</span></p>
<p><span class="font2">my $self = shift;</span></p>
<p><span class="font2">return $cache{$self} if exists $cache{$self};</span></p>
<p><span class="font2"># ... complex computation performed here ... return $cache{$self} = $total;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2" style="font-weight:bold;">sub expire_total {</span></p>
<p><span class="font2" style="font-weight:bold;">my $self = shift;</span></p>
<p><span class="font2" style="font-weight:bold;">delete $cache{$self};</span></p>
<p><span class="font2" style="font-weight:bold;">}</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">sub invest {</span></p>
<p><span class="font2">my ($self, $amount, ...) = @_;</span></p>
<p><span class="font2">$self-&gt;expire_total;</span></p>
<p><span class="font2">}</span></p>
<h6><a name="bookmark241"></a><span class="font17">With the object-oriented technique, no special method is necessary, because each method can directly expire the cached total if it needs to:</span></h6>
<p><span class="font2"># Compute total amount currently invested</span></p>
<p><span class="font2">sub total {</span></p>
<p><span class="font2">my $self = shift;</span></p>
<p><span class="font2">return $self-&gt;{cached_total} if exists $self-&gt;{cached_total};</span></p>
<p><span class="font2"># ... complex computation performed here ...</span></p>
<p><span class="font2">return $self-&gt;{cached_total} = $total;</span></p>
<p><span class="font2">} sub invest {</span></p>
<p><span class="font2">my ($self, $amount, ...) = @_; delete $self-&gt;{cached_total};</span></p>
<p><span class="font2">...</span></p>
<p><span class="font2">}</span></p>
<ul style="list-style:none;"><li>
<p class="font15">3.8 CACHING IN OBJECT METHODS <span class="font20">99</span></p></li></ul>
<ul style="list-style:none;"><li>
<h5><a name="bookmark49"></a><span class="font19">3.8.1 Memoization of Object Methods</span></h5></li></ul>
<p><span class="font17">As we saw, for object methods, we often like to cache each computed value with the object for which it is relevant, instead of in one separate hash. The </span><span class="font2">memoize </span><span class="font17">function we saw earlier doesn’t do this, but it’s not hard to build one that does:</span></p>
<p><span class="font2">sub memoize_method {</span></p>
<div>
<p><span class="font9" style="font-weight:bold;">CODE LIBRARY</span></p>
</div><br clear="all">
<div>
<p><span class="font0">memoize-method</span></p>
</div><br clear="all">
<p><span class="font2">my (Smethod, Skey) = @_;</span></p>
<p><span class="font2">return sub {</span></p>
<p><span class="font2">my Sself = shift;</span></p>
<p><span class="font2">return Sself-&gt;{Skey} if exists Sself-&gt;{Skey};</span></p>
<p><span class="font2">return Sself-&gt;{Skey} = Smethod-&gt;(Sself, @_);</span></p>
<p><span class="font2">};</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">Smethod </span><span class="font17">is a reference to the true method. </span><span class="font2">Skey </span><span class="font17">is the name of the slot in each object in which the cached values will be stored. The stub function returned here is suitable for use as a method. When the stub is invoked, it retrieves the object on whose behalf it was called, just like any other method; then it looks in the object for member data named </span><span class="font2">Skey </span><span class="font17">to see if a value is cached there. If so, the stub returns the cached value; if not, it calls the real method, caches the result in the object, and returns the new cached result.</span></p>
<p><span class="font17">To use this, we might write something like this:</span></p>
<p><span class="font2">*Investor::total = memoize_method(\&amp;Investor::total, 'cached_total'); Sinvestor_bob-&gt;total;</span></p>
<p><span class="font17">This installs the stub in the symbol table in place of the original method. Alternatively, we might use:</span></p>
<p><span class="font2">Smemoized_total = memoize_method(\&amp;Investor::total, 'cached_total');</span></p>
<p><span class="font2">Sinvestor_bob-&gt;Smemoized_total;</span></p>
<p><span class="font17">These are not quite the same. In the former case, all calls to </span><span class="font2">-&gt;total </span><span class="font17">will use the memoized version of the method, including calls from subclasses that inherit the method. In the latter case, we get the memoized version of the method only when we explicitly ask for it by using the </span><span class="font2">-&gt;Smemoized(...) </span><span class="font17">notation.</span></p>
<div>
<p><span class="font20">100</span></p>
</div><br clear="all">
<p><span class="font15">CHAPTER 3 Caching and Memoization</span></p>
<ul style="list-style:none;"><li>
<h5><a name="bookmark50"></a><span class="font18">3.9 PERSISTENT CACHES</span></h5></li></ul>
<p><span class="font17">Before we leave the topic of automatic memoization, we’ll see a few peripheral techniques. We saw how a function could be replaced with a memoized version that stored return values in a cache; the cache was simply a hash variable.</span></p>
<p><span class="font17">In Perl, one can use the </span><span class="font2">tie </span><span class="font17">operator to associate a hash variable with a disk database, so that data stored in the hash is automatically written to the disk, and data fetched back from the hash actually comes from the disk. To add this feature to our </span><span class="font2">memoize </span><span class="font17">function is simple:</span></p>
<p><span class="font2" style="font-weight:bold;">use DB_File;</span></p>
<p><span class="font2">sub memoize {</span></p>
<p><span class="font2" style="font-weight:bold;">my ($func, Skeygen, $file) = @_;</span></p>
<p><span class="font2">my %cache;</span></p>
<p><span class="font2" style="font-weight:bold;">if (defined $file) {</span></p>
<p><span class="font2" style="font-weight:bold;">tie %cache =&gt; 'DB_File', $file, O_RDWR|O_CREAT, 0666</span></p>
<p><span class="font2" style="font-weight:bold;">or die &quot;Couldn’t access cache file $file: $!; aborting&quot;;</span></p>
<p><span class="font2" style="font-weight:bold;">}</span></p>
<p><span class="font2">my $stub = sub {</span></p>
<p><span class="font2">my $key = Skeygen ? $keygen-&gt;(@_) : join ',', @_;</span></p>
<p><span class="font2">Scache{Skey} = Sfunc-&gt;(@_) unless exists Scache{Skey}; return Scache{Skey};</span></p>
<p><span class="font2">};</span></p>
<p><span class="font2">return Sstub;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">Here we’ve added an optional third parameter, which is the name of the disk file that will receive the cached data. If supplied, we use </span><span class="font2">tie </span><span class="font17">to tie the hash to the file. Note that if you don’t use this feature, you pay hardly any cost at all — a single </span><span class="font2">defined() </span><span class="font17">test at the time you call </span><span class="font2">memoize()</span><span class="font17">.</span></p>
<p><span class="font17">When the cache hash is tied to a disk file in this way, the cache becomes persistent. Data stored in the cache on one run of the program remains in the file after the program has exited, and is available to the function the next time the program is run. The program is incrementally replacing the function with a lookup table on the disk. The cost to the programmer is nearly zero, since we did not have to change any of the code in the original function.</span></p>
<p><span class="font17">If we get tired of waiting for the lookup table to be completely populated, we can force the issue. We can write a tiny program that does nothing but call the memoized function over and over with different arguments each time. We start</span></p>
<p><span class="font17">it up on Friday afternoon and go home for the weekend. When we come back on Monday, the persistent cache will have the values of the function precomputed. When we run our real application, all calls to the memoized function will return almost instantly, since the values have been saved in the database.</span></p>
<p><span class="font17">Once again, this may not be a win. Remember, the speed-up from memoization is </span><span class="font17" style="font-style:italic;">hf - K,</span><span class="font17"> where </span><span class="font17" style="font-style:italic;">K</span><span class="font17">is the overhead of managing the cache. If </span><span class="font17" style="font-style:italic;">K</span><span class="font17">is sufficiently large, it will overwhelm the gains from the </span><span class="font17" style="font-style:italic;">hf</span><span class="font17"> part of the formula, as in the </span><span class="font2">sub { $_[0] * $_[0] } </span><span class="font17">example from Section 3.6. When we store cache data in a disk file, the overhead </span><span class="font17" style="font-style:italic;">K</span><span class="font17"> can be many times greater than normal, because our program will have to make an operating-system request to look in the disk database.</span></p>
<p><span class="font17">An alternative and more flexible interface is to allow the user of </span><span class="font2">memoize() </span><span class="font17">to supply their own tied hash:</span></p>
<p><span class="font2">sub memoize {</span></p>
<p><span class="font2">my (Sfunc, Skeygen, Scache) = @_;</span></p>
<p><span class="font2" style="font-weight:bold;">Scache = {} unless defined Scache;</span></p>
<p><span class="font2">my Sstub = sub {</span></p>
<p><span class="font2">my Skey = Skeygen ? Skeygen-&gt;(@_) : join ',', @_;</span></p>
<p><span class="font2" style="font-weight:bold;">$cache-&gt;{$key} = $func-&gt;(@_) unless exists $cache-&gt;{$key}; return $cache-&gt;{$key};</span></p>
<p><span class="font2">};</span></p>
<p><span class="font2">return Sstub;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">This allows the user to supply a cache that is tied to a disk file using their favorite DBM implementation, even one we’ve never heard of. They could also pass in an ordinary hash; that would allow them to erase the cache or to expire old values from it if they wanted to.</span></p>
<ul style="list-style:none;"><li>
<h5><a name="bookmark51"></a><span class="font18">3.10 ALTERNATIVES TO MEMOIZATION</span></h5></li></ul>
<p><span class="font17">Most pure functions present an opportunity for caching. Although it may appear at first that pure functions are rare, they do appear with some frequency. One place where pure functions are especially common is as the comparator functions used in sorting.</span></p>
<p><span class="font17">The Perl built-in </span><span class="font2">sort </span><span class="font17">operator is generic, in that it can sort a list of any kind of data into any order desired by the program. By default, it sorts a list of strings into alphabetical order, but the programmer may optionally supply a </span><span class="font17" style="font-style:italic;">comparator function</span><span class="font17"> that tells Perl how to reorder </span><span class="font2">sort</span><span class="font17">’s argument list. The comparator</span></p>
<p><span class="font17">function is called repeatedly, each time with two different elements from the list to be sorted, and must return a negative value if the two elements are in the correct order, a positive value if the two elements are in the wrong order, and zero if it doesn’t care. Typically, a comparator function’s return value depends only on the values of its arguments, the two list items it is comparing, so it is a pure function.</span></p>
<p><span class="font17">Probably the simplest example of a comparator function is the comparator that compares numbers for sorting into numerical order:</span></p>
<p><span class="font2">©sorted_numbers = sort { $a &lt;=&gt; $b } ©numbers;</span></p>
<p><span class="font17">Here </span><span class="font2">{ $a &lt;=&gt; $b } </span><span class="font17">is the comparator function. The </span><span class="font2">sort </span><span class="font17">operator examines the list of </span><span class="font2">@numbers</span><span class="font17">, sets </span><span class="font2">$a </span><span class="font17">and </span><span class="font2">$b </span><span class="font17">to the numbers it wishes to have compared, and invokes the comparator function. </span><span class="font2">&lt;=&gt; </span><span class="font17">is a special Perl operator that returns a negative value if </span><span class="font2">$a </span><span class="font17">is less than </span><span class="font2">$b</span><span class="font17">, a positive value if </span><span class="font2">$a </span><span class="font17">is greater than </span><span class="font2">$b</span><span class="font17">, and zero if </span><span class="font2">$a </span><span class="font17">and </span><span class="font2">$b </span><span class="font17">are equal.<a name="footnote13"></a><sup><a href="#bookmark242">13</a></sup><sup></sup> </span><span class="font2">cmp </span><span class="font17">is an analogous operator for strings; this is the default that Perl uses if you don’t specify an explicit comparator.</span></p>
<p><span class="font17">An alternative syntax uses a named function instead of a bare block:</span></p>
<p><span class="font2">©sorted_numbers = sort numerically ©numbers;</span></p>
<p><span class="font2">sub numerically { $a &lt;=&gt; $b }</span></p>
<p><span class="font17">This is equivalent to the bare-block version.</span></p>
<p><span class="font17">A more interesting example sorts a list of date strings of the form </span><span class="font2">&quot;Apr 16, 1945&quot; </span><span class="font17">into chronological order:</span></p>
<div>
<p><span class="font9" style="font-weight:bold;">CODE LIBRARY</span></p>
</div><br clear="all">
<div>
<p><span class="font0">chrono-1</span></p>
</div><br clear="all">
<p><span class="font2">©sorted_dates = sort chronologically ©dates;</span></p>
<p><span class="font2">%m2n =</span></p>
<table border="1">
<tr><td rowspan="2">
<p><span class="font2">( jan =&gt; &nbsp;1, feb =&gt;</span></p>
<p><span class="font2">apr =&gt; &nbsp;4, may =&gt;</span></p>
<p><span class="font2">jul =&gt; &nbsp;7, aug =&gt;</span></p>
<p><span class="font2">oct =&gt; 10, nov =&gt;</span></p></td><td colspan="2">
<p><span class="font2">2, mar =&gt;</span></p>
<p><span class="font2">5, jun =&gt;</span></p>
<p><span class="font2">8, sep =&gt;</span></p></td><td rowspan="2">
<p><span class="font2">3,</span></p>
<p><span class="font2">6,</span></p>
<p><span class="font2">9,</span></p>
<p><span class="font2">12, );</span></p></td></tr>
<tr><td>
<p><span class="font2">11,</span></p></td><td>
<p><span class="font2">dec =&gt;</span></p></td></tr>
<tr><td colspan="2" style="vertical-align:bottom;">
<p><span class="font2">sub chronologically { my ($am, $ad, $ay) =</span></p>
<p><span class="font2">($a =- /(\w{3}) (\d+),</span></p></td><td colspan="2" style="vertical-align:bottom;">
<p><span class="font2">(\d+)/);</span></p></td></tr>
</table>
<p><span class="font2">my ($bm, $bd, $by) =</span></p>
<p><span class="font2">($b =- /(\w{3}) (\d+), (\d+)/);</span></p>
<p><span class="font2">$ay &nbsp;&lt;=&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$by</span></p>
<p><span class="font2">|| $m2n{lc $am} &lt;=&gt; $m2n{lc $bm}</span></p>
<p><span class="font2">|| &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$ad &nbsp;&lt;=&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$bd;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">The two date strings to be compared are loaded into </span><span class="font2">$a </span><span class="font17">and </span><span class="font2">$b</span><span class="font17">, as before, and then split up into </span><span class="font2">$ay</span><span class="font17">, </span><span class="font2">$by</span><span class="font17">, </span><span class="font2">$am</span><span class="font17">, and so forth. </span><span class="font2">$ay </span><span class="font17">and </span><span class="font2">$by</span><span class="font17">, the years, are compared first. The </span><span class="font2">|| </span><span class="font17">operator here is a common idiom in sort comparators for sorting by secondary keys. The </span><span class="font2">|| </span><span class="font17">operator returns its left operand, unless that is zero, in which case it returns its right operand. If the years are the same, then </span><span class="font2">$ay &lt;=&gt; $by </span><span class="font17">returns zero, and the </span><span class="font2">|| </span><span class="font17">operator passes control to the part of the expression involving the months, which are used to break the tie. But if the years are different, then the result of the first </span><span class="font2">&lt;=&gt; </span><span class="font17">is nonzero, and this is the result of the </span><span class="font2">|| </span><span class="font17">expression, instructing </span><span class="font2">sort </span><span class="font17">how to order </span><span class="font2">$a </span><span class="font17">and </span><span class="font2">$b </span><span class="font17">in the result list without ever having looked at the months or the days. If control passes to the </span><span class="font2">$am &lt;=&gt; $bm </span><span class="font17">part, the same thing happens. The months are compared; if the result is conclusive, the function returns immediately, and if the months are the same, control passes to the final tiebreaker of comparing the days.</span></p>
<p><span class="font17">Internally, Perl’s </span><span class="font2">sort </span><span class="font17">operator has been implemented with various algorithms that have </span><span class="font17" style="font-style:italic;">O(n</span><span class="font17"> log </span><span class="font17" style="font-style:italic;">n)</span><span class="font17"> running time. This means that to sort a list that is </span><span class="font17" style="font-style:italic;">n</span><span class="font17"> times larger than another typically takes somewhat more than </span><span class="font17" style="font-style:italic;">n</span><span class="font17"> times as long. If the list size doubles, the running time more than doubles. The following table compares the length of the argument list with the number of calls typically made to the comparator function:</span></p>
<table border="1">
<tr><td>
<p><span class="font17">Length</span></p></td><td>
<p><span class="font17"># calls</span></p></td><td>
<p><span class="font17">calls / element</span></p></td></tr>
<tr><td>
<p><span class="font17">5</span></p></td><td>
<p><span class="font17">7</span></p></td><td>
<p><span class="font17">1.40</span></p></td></tr>
<tr><td>
<p><span class="font17">10</span></p></td><td>
<p><span class="font17">26</span></p></td><td>
<p><span class="font17">2.60</span></p></td></tr>
<tr><td style="vertical-align:bottom;">
<p><span class="font17">20</span></p></td><td style="vertical-align:bottom;">
<p><span class="font17">60</span></p></td><td style="vertical-align:bottom;">
<p><span class="font17">3.00</span></p></td></tr>
<tr><td>
<p><span class="font17">40</span></p></td><td>
<p><span class="font17">195</span></p></td><td>
<p><span class="font17">4.87</span></p></td></tr>
<tr><td style="vertical-align:bottom;">
<p><span class="font17">80</span></p></td><td style="vertical-align:bottom;">
<p><span class="font17">417</span></p></td><td style="vertical-align:bottom;">
<p><span class="font17">5.21</span></p></td></tr>
<tr><td style="vertical-align:bottom;">
<p><span class="font17">100</span></p></td><td style="vertical-align:bottom;">
<p><span class="font17">569</span></p></td><td style="vertical-align:bottom;">
<p><span class="font17">5.69</span></p></td></tr>
<tr><td>
<p><span class="font17">1000</span></p></td><td>
<p><span class="font17">9502</span></p></td><td>
<p><span class="font17">9.50</span></p></td></tr>
<tr><td style="vertical-align:bottom;">
<p><span class="font17">10000</span></p></td><td style="vertical-align:bottom;">
<p><span class="font17">139136</span></p></td><td style="vertical-align:bottom;">
<p><span class="font17">13.91</span></p></td></tr>
</table>
<p><span class="font17">I got the “# calls” column by generating a list of random numbers of the indicated length and sorting it with a comparator function that incremented a counter each time it was called. The number of calls will vary depending on the list and on the comparator function, but these values are typical.</span></p>
<p><span class="font17">Now consider a list of 10,000 dates. 139,136 calls are made to the comparator function; each call performs two pattern-match operations, so there are 278,272 pattern matches in all. This means each date is split up into year, month, and day 27.8 times on average. Since the three components for a given date never change, it’s clear that 26.8 of these matchings are wasted.</span></p>
<p><span class="font17">The first thing that might come to mind is to memoize the </span><span class="font2">chronologically </span><span class="font17">function, but this doesn’t work well in practice. Although </span><span class="font2">sort </span><span class="font17">will call </span><span class="font2">chronologically </span><span class="font17">repeatedly with the same date, it won’t call it twice on the same </span><span class="font17" style="font-style:italic;">pair</span><span class="font17"> of dates (Unless, of course, the input list contains duplicate dates.) Since the hash keys must incorporate both arguments, the memoized function will never have a cache hit.</span></p>
<p><span class="font17">Instead, we’ll do something slightly different, and memoize just the expensive part of the function. This will require a version of </span><span class="font2">memoize() </span><span class="font17">that can handle a function that returns a list.</span></p>
<div>
<p><span class="font9" style="font-weight:bold;">CODE LIBRARY</span></p>
</div><br clear="all">
<div>
<p><span class="font0">chrono-2</span></p>
</div><br clear="all">
<p><span class="font2">@sorted_dates = sort chronologically @dates;</span></p>
<p><span class="font2">%m2n =</span></p>
<p><a href="#bookmark243"><span class="font2">( jan =&gt; &nbsp;1, feb =&gt; &nbsp;2, mar =&gt;</span></a></p>
<p><a href="#bookmark244"><span class="font2">apr =&gt; &nbsp;4, may =&gt; &nbsp;5, jun =&gt;</span></a></p>
<p><a href="#bookmark245"><span class="font2">jul =&gt; &nbsp;7, aug =&gt; &nbsp;8, sep =&gt;</span></a></p>
<p><span class="font2">oct =&gt; 10, nov =&gt; 11, dec =&gt; 12, );</span></p>
<p><span class="font2">sub chronologically {</span></p>
<p><span class="font2">my ($am, $ad, $ay) = split_date($a);</span></p>
<p><span class="font2">my ($bm, $bd, $by) = split_date($b);</span></p>
<table border="1">
<tr><td></td><td>
<p><span class="font2">$ay</span></p></td><td>
<p><span class="font2">&lt;=&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$by</span></p></td></tr>
<tr><td>
<p><span class="font2">||</span></p></td><td>
<p><span class="font2">$m2n{lc $am}</span></p></td><td>
<p><span class="font2">&lt;=&gt; $m2n{lc $bm}</span></p></td></tr>
<tr><td style="vertical-align:bottom;">
<p><span class="font2">||</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">$ad</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">&lt;=&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$bd;</span></p></td></tr>
<tr><td style="vertical-align:bottom;">
<p><span class="font2">}</span></p></td><td></td><td></td></tr>
</table>
<p><span class="font2">sub split_date {</span></p>
<p><span class="font2">$_[0] =- /(\w{3}) (\d+), (\d+)/;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">If we set up caching on </span><span class="font2">split_date</span><span class="font17">, we’ll still make 278,272 calls to it, but 268,272 will result in cache hits, and only the remaining 10,000 will require pattern matching. The only catch is that we’ll have to write the caching code by hand, because </span><span class="font2">split_date </span><span class="font17">returns a list, and our </span><span class="font2">memoize </span><span class="font17">functions deal correctly only with functions that return scalars.</span></p>
<p><span class="font17">At this point, we could go in three directions. We could enhance our </span><span class="font2">memoize </span><span class="font17">function to deal correctly with list-context returns. (Or we could use the CPAN </span><span class="font2">Memoize </span><span class="font17">module, which does work correctly for functions that return lists.) We could write the caching code manually. But it’s more instructive to sidestep the problem by replacing </span><span class="font2">split_date </span><span class="font17">with a function that returns a scalar. If the scalar is constructed correctly, we will be able to dispense with the complicated </span><span class="font2">|| </span><span class="font17">logic in </span><span class="font2">chronologically </span><span class="font17">and just use a simple string compare.</span></p>
<p><span class="font17">Here’s the idea: We will split the date, as before, but instead of returning a list of fields, we will pack the fields into a single string. The fields will appear in the string in the order we need to examine them, with the year first, then the month, then the day. The string for </span><span class="font2">&quot;Apr 16, 1945&quot; </span><span class="font17">will be </span><span class="font2">&quot;19450416&quot;</span><span class="font17">. When we compare strings with </span><span class="font2">cmp</span><span class="font17">, Perl will stop comparing as soon as possible, so if one string begins with </span><span class="font2">&quot;1998...&quot; </span><span class="font17">and another with </span><span class="font2">&quot;1996...&quot; </span><span class="font17">Perl will know the result as soon as it sees the fourth character, and won’t bother to examine the month or day. String comparison is very fast, likely to beat out a sequence of </span><span class="font2">&lt;=&gt;</span><span class="font17">s and </span><span class="font2">|| </span><span class="font17">s.</span></p>
<p><span class="font17">Here’s the modified code:</span></p>
<p><span class="font2">@sorted_dates = sort chronologically @dates;</span></p>
<div>
<p><span class="font9" style="font-weight:bold;">CODE LIBRARY</span></p>
</div><br clear="all">
<div>
<p><span class="font0">chrono-3</span></p>
</div><br clear="all">
<p><span class="font2">%m2n =</span></p>
<table border="1">
<tr><td>
<p><span class="font2">( jan =&gt;</span></p></td><td>
<p><span class="font2">1,</span></p></td><td>
<p><span class="font2">feb =&gt;</span></p></td><td>
<p><span class="font2">2,</span></p></td><td>
<p><span class="font2">mar =&gt;</span></p></td><td>
<p><span class="font2">3,</span></p></td></tr>
<tr><td style="vertical-align:bottom;">
<p><span class="font2">apr =&gt;</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">4,</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">may =&gt;</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">5,</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">jun =&gt;</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">6,</span></p></td></tr>
<tr><td>
<p><span class="font2">jul =&gt;</span></p></td><td>
<p><span class="font2">7,</span></p></td><td>
<p><span class="font2">aug =&gt;</span></p></td><td>
<p><span class="font2">8,</span></p></td><td>
<p><span class="font2">sep =&gt;</span></p></td><td>
<p><span class="font2">9,</span></p></td></tr>
<tr><td style="vertical-align:bottom;">
<p><span class="font2">oct =&gt;</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">10,</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">nov =&gt;</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">11,</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">dec =&gt;</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">12,</span></p></td></tr>
</table>
<p><span class="font2">);</span></p>
<p><span class="font2">sub chronologically {</span></p>
<p><span class="font2">date_to_string($a) cmp date_to_string($b)</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">sub date_to_string {</span></p>
<p><span class="font2">my ($m, $d, $y) = ($_[0] =- /(\w{3}) (\d+), (\d+)/); sprintf &quot;%04d%02d%02d&quot;, $y, $m2n{lc $m}, $d;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">Now we can memoize </span><span class="font2">date_to_string</span><span class="font17">. Whether this will win over the previous version depends on whether the </span><span class="font2">sprintf </span><span class="font17">plus </span><span class="font2">cmp </span><span class="font17">is faster than the </span><span class="font2">&lt;=&gt; </span><span class="font17">plus </span><span class="font2">||</span><span class="font17">. As usual, a benchmark is required; it turns out that the code with the </span><span class="font2">sprintf </span><span class="font17">is about twice as fast.<a name="footnote14"></a><sup><a href="#bookmark246">14</a></sup><sup></sup></span></p>
<p><span class="font17">Sorting is often one of those places in the program where we need to squeeze out as much performance as possible. For a list of 10,000 dates, we call </span><span class="font2">sprintf </span><span class="font17">exactly 10,000 times (once </span><span class="font2">date_to_string </span><span class="font17">is memoized) but we still call </span><span class="font2">date_to_string </span><span class="font17">itself278,272 times. As the list of dates becomes longer, this disparity will increase, and the function calls will eventually come to dominate the running time of the sort.</span></p>
<p><span class="font17">We can get more speed by simplifying the cache handling and eliminating the 268,272 extra function calls. To do this, we go back to handwritten caching code:</span></p>
<div>
<p><span class="font9" style="font-weight:bold;">CODE LIBRARY</span></p>
</div><br clear="all">
<div>
<p><span class="font0">chrono-orc</span></p>
</div><br clear="all">
<p><span class="font2">{ my %cache;</span></p>
<p><span class="font2">sub chronologically {</span></p>
<p><span class="font2">($cache{$a} ||= date_to_string($a))</span></p>
<p><span class="font2">cmp</span></p>
<p><span class="font2">($cache{$b} ||= date_to_string($b))</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">Here we make use of the </span><span class="font2">||= </span><span class="font17">operator, which seems almost custom-made for caching applications. </span><span class="font2">$x ||= $y </span><span class="font17">yields the value of </span><span class="font2">$x </span><span class="font17">if it is true; if not, it assigns </span><span class="font2">$y </span><span class="font17">to </span><span class="font2">$x </span><span class="font17">and yields the value of </span><span class="font2">$y</span><span class="font17">. </span><span class="font2">$cache{$a} ||= date_to_string($a) </span><span class="font17">checks to see if </span><span class="font2">$cache{$a} </span><span class="font17">has a true value; if so, that is the value used in the comparison with the </span><span class="font2">cmp </span><span class="font17">operator. If nothing is cached yet, then </span><span class="font2">$cache{$a} </span><span class="font17">is false, and </span><span class="font2">chronologically </span><span class="font17">calls </span><span class="font2">date_to_string</span><span class="font17">, stores the result in the cache, and uses the result in the comparison. This inline cache technique is called the </span><span class="font17" style="font-style:italic;">Orcish Maneuver,</span><span class="font17"> because its essential features are the </span><span class="font2">|| </span><span class="font17">and the cache.<sup>10</sup></span></p>
<p><span class="font17">Memoizing </span><span class="font2">date_to_string </span><span class="font17">yields a two-and-a-half-fold speed-up; replacing the memoization with the Orcish Maneuver yields an </span><span class="font17" style="font-style:italic;">additional</span><span class="font17"> twofold speed-up.</span></p>
<p><span class="font17">Astute readers will note that the Orcish Maneuver doesn’t always work quite right. In this example, it’s impossible for </span><span class="font2">date_to_string </span><span class="font17">to ever return a false value. But let’s return for a moment to the example where we compute the total amount invested for each investor:</span></p>
<p><span class="font2">{ my %cache;</span></p>
<p><span class="font2">sub by_total_invested {</span></p>
<p><span class="font2">($cache{$a} ||= total_invested($a))</span></p>
<p><span class="font15">takes a long time compared to </span><span class="font1">sprintf</span><span class="font15">. This is just another example of why the benchmark really is necessary.</span></p>
<ul style="list-style:none;"><li>
<p class="font15">10 Joseph Hall, author of <span class="font15" style="font-style:italic;">Effective Perl Programming,</span><span class="font15"> is responsible for this name.</span></p></li></ul>
<p><span class="font2">($cache{$b} ||= total_invested($b))</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">Suppose Luke the Hermit has invested no money at all. The first time he appears in </span><span class="font2">by_total_invested</span><span class="font17">, we call </span><span class="font2">total_invested </span><span class="font17">for Luke, and we get back 0. We store this 0 in the cache under Luke’s key. The next time Luke appears, we check the cache and find that the value stored there is 0. Because this value is false, we call </span><span class="font2">total_invested </span><span class="font17">again, even though we had a cache hit. The problem here is that the </span><span class="font2">||= </span><span class="font17">operator doesn’t distinguish between a cache miss and a cache hit where the cached value happens to be false.</span></p>
<p><span class="font17">The Lisp people have a name for this phenomenon: They call it the </span><span class="font17" style="font-style:italic;">semipredicate problem.</span><span class="font17"> A </span><span class="font17" style="font-style:italic;">predicate</span><span class="font17"> is a function that returns a boolean value. A </span><span class="font17" style="font-style:italic;">semipredicate </span><span class="font17">can return a specific false value, indicating failure, or one of many meaningful true values, indicating success. The </span><span class="font2">$cache{$a} </span><span class="font17">is a semipredicate because it might return 0, or any of an infinity of useful true values. We get into trouble when 0 is </span><span class="font17" style="font-style:italic;">also</span><span class="font17"> one of the true values, because we can’t distinguish it from the 0 that means false. This is the semipredicate problem.</span></p>
<p><span class="font17">In our present example, the semipredicate problem won’t cause much trouble. The only cost is a few extra calls to </span><span class="font2">total_invested </span><span class="font17">for people who haven’t invested any money. If we find that these extra calls are slowing down our sorting significantly (unlikely, but possible) we can replace the comparator function with the following version:</span></p>
<p><span class="font2">{ my %cache;</span></p>
<p><span class="font2">sub by_total_invested {</span></p>
<p><span class="font2">(exists $cache{$a} ? $cache{$a} : ($cache{$a} = total_invested($a)))</span></p>
<p><span class="font2">(exists $cache{$b} ? $cache{$b} : ($cache{$b} = total_invested($b))) }</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">This version uses the reliable </span><span class="font2">exists </span><span class="font17">operator to check to see if the cache is populated. Even if the value stored in the cache is false, </span><span class="font2">exists </span><span class="font17">will still return true. Beware, though, that this costs about 10% more than the simpler version.</span></p>
<p><span class="font17">There’s an alternative that costs hardly anything extra, but does have the disadvantage of being rather bizarre. It’s based on the following trick: When the Perl string </span><span class="font2">&quot;0e0&quot; </span><span class="font17">is used as a number, it behaves exactly like 0; the </span><span class="font2">e0 </span><span class="font17">is interpreted by Perl as a scientific notation exponent. But unlike an ordinary 0, the string </span><span class="font2">&quot;0e0&quot; </span><span class="font17">is true rather than false.<a name="footnote15"></a><sup><a href="#bookmark247">15</a></sup><sup></sup></span></p>
<p><span class="font17">If we write </span><span class="font1">by_total_invested </span><span class="font17">like this, we avoid the semipredicate problem with hardly any extra cost:</span></p>
<p><span class="font2">{ my %cache;</span></p>
<p><span class="font2">sub by_total_invested {</span></p>
<p><span class="font2">($cache{$a} ||= total_invested($a) || &quot;0e0&quot;)</span></p>
<p><span class="font2">($cache{$b} ||= total_invested($b) || &quot;0e0&quot;)</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">If </span><span class="font2">total_invested </span><span class="font17">returns zero, the function caches </span><span class="font2">&quot;0e0&quot; </span><span class="font17">instead. The next time we look up the total invested by the same customer, the function sees </span><span class="font2">&quot;0e0&quot; </span><span class="font17">in the cache, and this value is true, so it doesn’t call </span><span class="font2">total_invested </span><span class="font17">a second time. This </span><span class="font2">&quot;0e0&quot; </span><span class="font17">is the value given to the </span><span class="font2">&lt;=&gt; </span><span class="font17">operator for comparison, but in a numeric comparison it behaves exactly like 0, which is just what we want. The speed cost of the additional </span><span class="font2">|| </span><span class="font17">operation, invoked only when a false value is returned by </span><span class="font2">total_invested()</span><span class="font17">, is tiny.</span></p>
<ul style="list-style:none;"><li>
<h5><a name="bookmark52"></a><span class="font18">3.11 EVANGELISM</span></h5></li></ul>
<p><span class="font17">If you’re trying to explain to a C programmer why Perl is good, automatic memoization makes a wonderful example. Almost all programmers are familiar with caching techniques. Even if they don’t use any caching techniques in their own programs, they are certainly familiar with the concept, from caching in web browsers, in the cache memory of their computer, in the DNS server, in their web proxy server, or elsewhere. Caching, like most simple, useful ideas, is ubiquitous.</span></p>
<p><span class="font17">Adding caching isn’t too much trouble, but it takes at least a few minutes to modify the code. With all modifications, there’s a chance that you might make a mistake, which has to be factored into the average time. Once you’re done, it</span></p>
<p><span class="font17">may turn out that the caching was a bad idea, because the cache management overhead dominates the running time of the function, or because there aren’t as many cache hits on a typical run as you expected there to be; then you have to take the caching code out, and again you run the risk of making a mistake. Not to overstate the problems, of course, but it will take at least a few minutes in each direction.</span></p>
<p><span class="font17">With memoization, adding the caching code no longer takes minutes; it takes seconds. You add one line of code:</span></p>
<p><span class="font2">memoize 'myfunction';</span></p>
<p><span class="font17">and it is impossible to make a serious mistake and break the function. If the memoization turns out to have been a bad idea, you can turn it off again in </span><span class="font17" style="font-style:italic;">one second.</span><span class="font17"> Most programmers can appreciate the convenience of this. If you have five minutes to explain to a C programmer what benefits Perl offers over C, memoization is an excellent example to use.</span></p>
<ul style="list-style:none;"><li>
<h5><a name="bookmark53"></a><span class="font18">3.12 THE BENEFITS OF SPEED</span></h5></li></ul>
<p><span class="font17">It may be tempting at this point to say that memoization is only an incremental improvement over manual caching techniques, because it does the same thing, and the only additional benefit is that you can turn it on and off more quickly. But that isn’t really true. When a speed and convenience difference between tools is large enough, it changes the way you think about the tool and the ways you can use it. To automatically memoize a function takes 1/100 as much time as to write caching code for it manually. This is the same as the difference between the speed of an airplane and the speed of an oxcart. To say that the airplane is just a faster oxcart is to miss something essential: The quantitative difference is so large that it becomes a substantive qualitative difference as well.</span></p>
<p><span class="font17">For example, with automatic memoization, it becomes possible to add caching behavior to functions without having to consider the performance details carefully in advance. Memoization is so easy that it can pay to adopt a strategy of “shoot first and ask questions later.” If a function is slow, try slapping some caching onto it and see if it helps matters. If a recursive function might have bad recursion behavior, put in some caching and see if the problem goes away. If not, you can take the caching away again and investigate more thoroughly. When the total cost is ten seconds of programming time, you can try this without having to think much in advance about whether it will be successful. With manual caching, you would have to spend at least a quarter hour, which is too much to invest on a mere fishing expedition.</span></p>
<p><span class="font17">With automatic memoization, you can enable caching behavior at run time. For example:</span></p>
<p><span class="font2">sub function {</span></p>
<p><span class="font2">if (++SCALLS == 100) { memoize 'function'}</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">Here we don’t bother to memoize the function until partway through the program’s run. When the function realizes it’s being heavily used, it enables caching behavior. To do the same thing without automatic memoization requires a rewrite of the function rather than the addition of a single line.</span></p>
<ul style="list-style:none;"><li>
<h5><a name="bookmark54"></a><span class="font19">3.12.1 Profiling and Performance Analysis</span></h5></li></ul>
<p><span class="font17">Automatic memoization allows caching to be used in profiling and performance analysis in a way that would be impractical otherwise. The typical situation involves a large application that runs too slowly. We would like to speed it up. We will do this by rewriting parts of the program to be faster, perhaps by introducing a better algorithm, and possibly at the expense of a certain amount of clarity or maintainability.</span></p>
<p><span class="font17">Trying to speed up every part of the program is a bad allocation of resources. This is because of what is known as the“90-10 rule,” which says that 90% of the execution time of a program takes place in only 10% of the code, the rest being initialization code that is executed only once, or special-case code such as error handlers that are executed rarely or never. If we work over the entire program and speed up every part by 5%, we have a 5% gain. But if we can identify and rewrite just the crucial 10% to the same degree, we will get a net 4.5% gain in the program’s total run time at only 10% of the cost; the cost-benefit ratio is nine times as large. So before we optimize, we would like very much to identify the parts of the program that contribute most to the run time, and concentrate on improving just those parts.</span></p>
<p><span class="font17">It’s sad when a programmer spends a week carefully optimizing a subroutine to run 20% faster, only to discover that the program spent only 2% of its total execution time in that subroutine, and that the week of hard work has yielded only an 0.4% speed-up overall. Historically, programmers have been bad at guessing which parts of the program are heavily used; we need real measurements.</span></p>
<p><span class="font17">Traditionally, measurements are done using a tool called a </span><span class="font17" style="font-style:italic;">profiler.</span><span class="font17"> The program is run in a special profiling environment that causes it to dump out a record of what it is doing every so often (typically many times per second).</span></p>
<p><span class="font15">3.12 THE BENEFITS OF SPEED</span></p>
<div>
<p><span class="font20">111</span></p>
</div><br clear="all">
<p><span class="font17">Afterwards, the data is massaged into a report that lists the subroutines in which the program spends the most execution time. There are profiler tools for Perl, but they can be strange and hard to use. Automatic memoization is an alternative.</span></p>
<p><span class="font17">Run the program once and time how long it takes. Then guess which parts of the program are bottlenecks, and memoize them. Arrange for the memoized data to be stored in a persistent file. (Remember, this requires adding only one line of code to the program.) Run the program a second time; this will populate the cache on the disk. Run the program a third time. All calls to the memoized functions will return almost immediately, because the data is residing in a disk database; the functions do no work at all beyond what is required to get the answers from the database. On the third run, you are simulating how quickly the program would run if it were possible to eliminate the time taken by the target functions. If this run is substantially faster than the unmemoized run time, you have some candidates for optimization; if the times are similar, you know that you should look elsewhere.</span></p>
<p><span class="font17">You might wonder why not simply leave the memoization in place if the memoized run is substantially shorter, and the answer is that while memoization might cause the target functions to run faster, it might also cause them not to work correctly. Suppose you suspect that the bottleneck function is the one that formats the report. While memoizing this function and having it deliver a precached report may cause it to run faster, it is probably not what the recipient of the report would prefer.</span></p>
<ul style="list-style:none;"><li>
<h5><a name="bookmark55"></a><span class="font19">3.12.2 Automatic Profiling</span></h5></li></ul>
<p><span class="font17">Another profiling technique, one that’s even more flexible, uses the techniques we’ve seen in this chapter, but without any actual caching. The </span><span class="font2">memoize </span><span class="font17">function takes an existing function and puts a cache-managing front-end onto it. There’s no reason why this front-end has to do cache management; it could do something else:</span></p>
<p><span class="font2">use Time::HiRes 'time';</span></p>
<div>
<p><span class="font9" style="font-weight:bold;">CODE LIBRARY</span></p>
</div><br clear="all">
<div>
<p><span class="font0">profile</span></p>
</div><br clear="all">
<p><span class="font2">my (%time, %calls);</span></p>
<p><span class="font2">sub profile {</span></p>
<p><span class="font2">my ($func, $name) = @_;</span></p>
<p><span class="font2">my $stub = sub {</span></p>
<p><span class="font2">my $start = time;</span></p>
<p><span class="font2">my $return = $func-&gt;(@_);</span></p>
<p><span class="font2">my $end = time;</span></p>
<p><span class="font2">my Selapsed = Send - Sstart; $calls{$name} += 1; Stime{Sname} += Selapsed;</span></p>
<p><span class="font2">return Sreturn;</span></p>
<p><span class="font2">};</span></p>
<p><span class="font2">return Sstub;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">The </span><span class="font2">profile </span><span class="font17">function shown here is similar in structure to the </span><span class="font2">memoize </span><span class="font17">function we saw earlier. Like </span><span class="font2">memoize</span><span class="font17">, it takes a function as its argument and constructs and returns a stub, which may be called directly or installed in the symbol table in place of the original.</span></p>
<p><span class="font17">When the stub is invoked, it records the current time in </span><span class="font2">Sstart</span><span class="font17">. Normally the Perl </span><span class="font2">time </span><span class="font17">function returns the current time to the nearest second; the </span><span class="font2">Time::HiRes </span><span class="font17">module replaces the </span><span class="font2">time </span><span class="font17">function with one that has finer granularity, if possible. The stub calls the real function and saves its return value. Then it computes the total elapsed time and updates two hashes. One hash records, for each function, how many calls have been made to that function; the stub simply increments that count. The other hash records the total elapsed time spent executing each function; the stub adds the elapsed time for the just-completed call to the total.</span></p>
<p><span class="font17">At the end of program execution, we can print out a report:</span></p>
<p><span class="font2">END {</span></p>
<p><span class="font2">printf STDERR &quot;%-12s %9s %6s\n&quot;, &quot;Function&quot;, &quot;# calls&quot;, &quot;Elapsed&quot;;</span></p>
<p><span class="font2">for my Sname (sort {Stime{Sb} &lt;=&gt; Stime{Sa}} (keys %time)) {</span></p>
<p><span class="font2">printf STDERR &quot;%-12s %9d %6.2f\n&quot;, Sname, Scalls{Sname}, Stime{Sname}; }</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">The output will look something like this:</span></p>
<table border="1">
<tr><td>
<p><span class="font17">Function</span></p></td><td>
<p><span class="font17"># calls</span></p></td><td>
<p><span class="font17">Elapsed</span></p></td></tr>
<tr><td>
<p><span class="font2">printout</span></p></td><td>
<p><span class="font17">1</span></p></td><td>
<p><span class="font17">10.21</span></p></td></tr>
<tr><td>
<p><span class="font2">searchfor</span></p></td><td>
<p><span class="font17">1</span></p></td><td>
<p><span class="font17">0.34</span></p></td></tr>
<tr><td style="vertical-align:bottom;">
<p><span class="font2">page</span></p></td><td style="vertical-align:bottom;">
<p><span class="font17">1</span></p></td><td style="vertical-align:bottom;">
<p><span class="font17">0.06</span></p></td></tr>
<tr><td style="vertical-align:bottom;">
<p><span class="font2">check_file</span></p></td><td style="vertical-align:bottom;">
<p><span class="font17">18</span></p></td><td style="vertical-align:bottom;">
<p><span class="font17">0.01</span></p></td></tr>
</table>
<p><span class="font17">This is output from the </span><span class="font2">perldoc </span><span class="font17">program that comes standard with Perl. From this output, we can see that most of the execution time is occurring in the </span><span class="font2">printout </span><span class="font17">function; if we want to make </span><span class="font2">perldoc </span><span class="font17">faster, this is the function we should concentrate on.</span></p>
<ul style="list-style:none;"><li>
<h5><a name="bookmark56"></a><span class="font19">3.12.3 Hooks</span></h5></li></ul>
<p><span class="font17">This is clearly a very rudimentary profiling tool. A better version would use the </span><span class="font2">times() </span><span class="font17">function to measure CPU time consumed instead of wall-clock time. But the flexibility of the technique should be clear; we can put an arbitrary front-end onto a function, or change the front-end at run time. The front-end can perform caching, or keep track of function call data; it could validate the function arguments if we wanted, enforce pre- and post-conditions, or whatever else we like.</span></p>
<p><span class="font14">CHAPTER</span></p>
<h3><a name="bookmark248"></a><span class="font25">ITERATORS</span></h3>
<ul style="list-style:none;"><li>
<h5><a name="bookmark58"></a><span class="font18">4.1 INTRODUCTION</span></h5></li></ul>
<p><span class="font17">An </span><span class="font17" style="font-style:italic;">iterator</span><span class="font17"> is an object interface to a list.</span></p>
<p><span class="font17">The object’s member data consists of the list and some state information marking a “current position” in the list. The iterator supports one method, which we will call </span><span class="font2">NEXTVAL</span><span class="font17">. The </span><span class="font2">NEXTVAL </span><span class="font17">method returns the list element at the current position and updates the current position so that the next time </span><span class="font2">NEXTVAL </span><span class="font17">is called, the next list element will be returned.</span></p>
<p><span class="font17">Why would anyone want an object interface to a list? Why not just use a list? There are several reasons. The simplest is that the list might be enormous, so large that you do not want to have it in memory all at once. It is often possible to design iterators to generate list items as they’re requested, so that only a small part of the list need ever be in memory at once.</span></p>
<ul style="list-style:none;"><li>
<h5><a name="bookmark59"></a><span class="font19">4.1.1 &nbsp;Filehandles Are Iterators</span></h5></li></ul>
<p><span class="font17">Iterators are familiar to everyone who has ever programmed in Perl, because filehandles are iterators. When you open a file for reading, you get back a filehandle object:</span></p>
<p><span class="font2">open(FILEHANDLE, 'filename');</span></p>
<p><span class="font17">We’ll look at filehandles first because they are a familiar example that exhibit all the advantages of iterators. A filehandle does represent a list, namely the list of lines from a file. The </span><span class="font2">NEXTVAL </span><span class="font17">operation is written in Perl as </span><span class="font2">&lt;FILEHANDLE&gt;</span><span class="font17">.</span></p>
<p><span class="font17">When you do </span><span class="font2">&lt;FILEHANDLE&gt;</span><span class="font17">, Perl returns the line at the current position and updates the current position so that the next time you do </span><span class="font2">&lt;FILEHANDLE&gt; </span><span class="font17">you get the next line.</span></p>
<p><span class="font17">Imagine an alternate universe in which the Perl </span><span class="font2">open </span><span class="font17">function yielded not a filehandle but instead, a list of lines:</span></p>
<p><span class="font2">@lines = open('filename'); # alternate universe interface</span></p>
<p><span class="font17">Almost any programmer asked to criticize this interface will complain that this would consume too much memory if the file is very large. One of the principal reasons for filehandles is that files can be so large and need to be represented in programs in some way other than as a possibly enormous list of lines.</span></p>
<p><span class="font17">Another problem with the imaginary iterator-less version is the following common pattern:</span></p>
<p><span class="font2">open(FILEHANDLE, 'filename');</span></p>
<p><span class="font2">while (&lt;FILEHANDLE&gt;) {</span></p>
<p><span class="font2">last if /Plutonium/;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">close FILEHANDLE;</span></p>
<p><span class="font2"># do something with $_;</span></p>
<p><span class="font17">This code opens a file and reads through it looking for a record that contains the word “Plutonium”. When it finds the record, it exits the loop immediately, closes the file, and then does something with the record it just extracted. On average, it has to search only half of the file, because the plutonium will typically be somewhere near the middle; it might even get lucky and find it right at the beginning. In the worst case, the plutonium is at the end of the file, or is missing entirely, and the program has to read the whole file to discover that.</span></p>
<p><span class="font17">In the imaginary alternate universe with no filehandles, we get the worst case every time:</span></p>
<ul style="list-style:none;"><li>
<p><span class="font2"># alternate universe interface</span></p></li></ul>
<p><span class="font2">@lines = open('filename');</span></p>
<p><span class="font2">for (@lines) {</span></p>
<p><span class="font2">last if /Plutonium/;</span></p>
<p><span class="font2">}</span></p>
<ul style="list-style:none;"><li>
<p><span class="font2"># do something with $_;</span></p></li></ul>
<p><span class="font15">4.1 INTRODUCTION </span><span class="font20">117</span></p>
<p><span class="font17">Even if the plutonium is at the beginning of the file, the alternate universe </span><span class="font2">open() </span><span class="font17">still reads the entire file, a colossal waste of I/O and processor time.</span></p>
<p><span class="font17">Unix programmers, remembering that Perl’s open function can also open</span></p>
<p><span class="font17">a pipe to a command, will object even more strenuously:</span></p>
<p><span class="font2">@lines = open(&quot;yes |&quot;); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# alternate universe interface</span></p>
<p><span class="font17">Here Perl runs the Unix </span><span class="font2">yes </span><span class="font17">command and reads its output. But there’s a terrible problem: the output of </span><span class="font2">yes </span><span class="font17">is infinite. The program will hang in an infinite loop at this line until all memory is exhausted, and then it will drop dead. The filehandle version works just fine.</span></p>
<ul style="list-style:none;"><li>
<h5><a name="bookmark60"></a><span class="font19">4.1.2 Iterators Are Objects</span></h5></li></ul>
<p><span class="font17">The final advantage of an iterator over a plain array is that an iterator is an object, which means it can be shared among functions.</span></p>
<p><span class="font17">Consider a program that opens and reads a Windows </span><span class="font2">INI </span><span class="font17">file. Here’s an example of an </span><span class="font2">INI </span><span class="font17">file:</span></p>
<p><span class="font2">[Display]</span></p>
<p><span class="font2">model=Samsui</span></p>
<p><span class="font2">[Capabilities]</span></p>
<p><span class="font2">supports_3D=y</span></p>
<p><span class="font2">power_save=n</span></p>
<p><span class="font17">The file is divided into sections, each of which is headed by a title like </span><span class="font2">[Display] </span><span class="font17">or </span><span class="font2">[Capabilities]</span><span class="font17">. Within each section are variable definitions such as </span><span class="font2">model=Samsui</span><span class="font17">. </span><span class="font2">model </span><span class="font17">is the name of a configuration variable and </span><span class="font2">Samsui </span><span class="font17">is its value.</span></p>
<p><span class="font17">A function to parse a single section of an </span><span class="font2">INI </span><span class="font17">file might look something like this:</span></p>
<p><span class="font2">sub parse_section {</span></p>
<p><span class="font2">my $fh = shift;</span></p>
<p><span class="font2">my $title = parse_section_title($fh);</span></p>
<p><span class="font2">my %variables = parse_variables($fh);</span></p>
<p><span class="font2">return [$title, \%variables];</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">The function gets a filehandle as its only argument. </span><span class="font2">parse_section() </span><span class="font17">passes the filehandle to the </span><span class="font2">parse_section_title() </span><span class="font17">function, which reads the first line and extracts and returns the title; then </span><span class="font2">parse_section() </span><span class="font17">passes the same filehandle to </span><span class="font2">parse_variables()</span><span class="font17">, which reads the rest of the section and returns a hash with the variable definitions. Unlike an array of lines, </span><span class="font2">Sfh </span><span class="font17">keeps track of the current position in the </span><span class="font2">INI </span><span class="font17">file, so that </span><span class="font2">parse_section_title() </span><span class="font17">and </span><span class="font2">parse_variables() </span><span class="font17">don’t read the same data. Instead, </span><span class="font2">parse_variables() </span><span class="font17">picks up wherever </span><span class="font2">parse_section_title </span><span class="font17">left off. The corresponding code with an array wouldn’t work:</span></p>
<p><span class="font2">sub parse_section {</span></p>
<p><span class="font2">my @lines = @_;</span></p>
<p><span class="font2">my Stitle = parse_section_title(©lines);</span></p>
<p><span class="font2">my %variables = parse_variables(©lines);</span></p>
<p><span class="font2">return [Stitle, \%variables];</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">There would be no way for </span><span class="font2">parse_section_title() </span><span class="font17">to remove the section title line from </span><span class="font2">©lines</span><span class="font17">. (This is a rather contrived example, but illustrates the possible problem. Packaging up </span><span class="font2">©lines </span><span class="font17">as an object, even by doing something as simple as passing </span><span class="font2">\©lines </span><span class="font17">instead, solves the problem.)</span></p>
<ul style="list-style:none;"><li>
<h5><a name="bookmark61"></a><span class="font19">4.1.3 Other Common Examples of Iterators</span></h5></li></ul>
<p><span class="font17">Like all good, simple ideas, iterators pop up all over. If you remember only one example, remember filehandles, because filehandles are ubiquitous. But Perl has several other examples of built-in iterators. We’ll take a quick tour of the most important ones.</span></p>
<p><span class="font17">Dirhandles are analogous to filehandles. They are created with the </span><span class="font2">opendir </span><span class="font17">function, and encapsulate a list of directory entries that can be read with the </span><span class="font2">readdir </span><span class="font17">operator:</span></p>
<p><span class="font2">opendir D, &quot;/tmp&quot;;</span></p>
<p><span class="font2">©entries = readdir D;</span></p>
<p><span class="font17">But </span><span class="font2">readdir </span><span class="font17">in scalar context functions as an iterator, reading one entry at a time from </span><span class="font2">D</span><span class="font17">:</span></p>
<p><span class="font2">opendir D, &quot;/tmp&quot;;</span></p>
<p><span class="font2">while (my Sentry = readdir D) {</span></p>
<div>
<p><span class="font15">4.2 HOMEMADE ITERATORS</span></p>
</div><br clear="all">
<div>
<h4><a name="bookmark249"></a><span class="font20">119</span></h4>
</div><br clear="all">
<p><span class="font2"># Do something with Sentry }</span></p>
<p><span class="font17">The built-in </span><span class="font2">glob </span><span class="font17">operator is similar, producing one file at a time whose name matches a certain pattern:</span></p>
<p><span class="font2">while (my Sfile = glob(&quot;/tmp/*.[ch]&quot;)) {</span></p>
<ul style="list-style:none;"><li>
<p><span class="font2"># Do something with Sfile</span></p></li></ul>
<p><span class="font2">}</span></p>
<p><span class="font17">Perl hashes always have an iterator built in to iterate over the keys or values in the hash. The </span><span class="font2">keys </span><span class="font17">and </span><span class="font2">values </span><span class="font17">functions produce lists of keys and values, respectively. If the hash is very large, these lists will be large, so Perl also provides a function to operate the iterator directly, namely </span><span class="font2">each</span><span class="font17">:</span></p>
<p><span class="font2">while (my Skey = each %hash) {</span></p>
<ul style="list-style:none;"><li>
<p><span class="font2"># Do something with Skey</span></p></li></ul>
<p><span class="font2">}</span></p>
<p><span class="font17">Normally the Perl regex engine just checks to see if a string matches a pattern, and reports true or false. However, it’s sometimes of interest what part of the target string matched. In list context, the </span><span class="font2">m//g </span><span class="font17">operator produces a list of all matching substrings:</span></p>
<p><span class="font2">©matches = (&quot;12:34:56&quot; =- m/(\d+)/g);</span></p>
<p><span class="font17">Here </span><span class="font2">©matches </span><span class="font17">contains </span><span class="font2">(&quot;12&quot;, &quot;34&quot;, &quot;56&quot;)</span><span class="font17">. In scalar context, </span><span class="font2">m//g </span><span class="font17">becomes the </span><span class="font2">NEXTVAL </span><span class="font17">operation for an iterator inside the regex, producing a different match each time:</span></p>
<p><span class="font2">while (&quot;12:34:56&quot; =- m/(\d+)/g) {</span></p>
<ul style="list-style:none;"><li>
<p><span class="font2"># do something with S1</span></p></li></ul>
<p><span class="font2">}</span></p>
<p><span class="font17">We will see this useful and little-known feature in more detail in Chapter 8. Now we’ll see how we can build our own iterators.</span></p>
<ul style="list-style:none;"><li>
<h5><a name="bookmark62"></a><span class="font18">4.2 HOMEMADE ITERATORS</span></h5></li></ul>
<p><span class="font17">Our </span><span class="font2">dir_walk() </span><span class="font17">function from Chapter 1 took a directory name and a callback function and searched the directory recursively, calling the callback for</span></p>
<p><span class="font20">120 </span><span class="font15">CHAPTER 4 Iterators</span></p>
<p><span class="font17">each file and directory under the original directory. Now let’s see if we can structure </span><span class="font2">dir_walk() </span><span class="font17">as an iterator. If we did, then instead of searching the directory, </span><span class="font2">dir_walk() </span><span class="font17">would return an iterator object. This object would support a </span><span class="font2">NEXTVAL </span><span class="font17">operation, which would return a different file or directory name each time it was called.</span></p>
<p><span class="font17">First let’s make sure that doing this is actually worthwhile. Suppose we had such an iterator. Could we still use it in callback style? Certainly. Suppose </span><span class="font2">make_iterator </span><span class="font17">were a function that constructed an iterator that would return the filenames from a directory tree. Then we would still be able to emulate the original </span><span class="font2">dir_walk() </span><span class="font17">like this:</span></p>
<p><span class="font2">sub dir_walk {</span></p>
<p><span class="font2">my (Sdir, Sfilefunc, Sdirfunc, Suser) = @_;</span></p>
<p><span class="font2">my Siterator = make_iterator(Sdir);</span></p>
<p><span class="font2">while (my Sfilename = NEXTVAL(Siterator)) {</span></p>
<p><span class="font2">if (-f Sfilename) { Sfilefunc-&gt;(Sfilename, Suser) }</span></p>
<p><span class="font2">else &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ Sdirfunc-&gt;(Sfilename, Suser) }</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">Here I’ve written </span><span class="font2">NEXTVAL(Siterator) </span><span class="font17">to represent the </span><span class="font2">NEXTVAL </span><span class="font17">operation. Since we don’t know yet how the iterator is implemented, we don’t know what the real syntax of the </span><span class="font2">NEXTVAL </span><span class="font17">operation will be.</span></p>
<p><span class="font17">This example shows that the iterator version is at least as powerful as the original callback version. However, if we could build it, the iterator version would have several advantages over the callback version. We would be able to stop part way through processing the directory tree, and then pick up later where we left off, and we would have a file-tree-walk object that we could pass around from one function to another.</span></p>
<p><span class="font17">We’ll use a really excellent trick to build our iterator: the iterator will be a function. The </span><span class="font2">NEXTVAL </span><span class="font17">operation on the iterator will simply be to call the function. When we call the iterator function it will do some computing, figure out what the next filename is, and return it. This means that the </span><span class="font2">NEXTVAL(Siterator) </span><span class="font17">in our example code is actually doing </span><span class="font2">Siterator-&gt;()</span><span class="font17">.</span></p>
<p><span class="font17">The iterator will need to retain some state information inside it, but we’ve already seen that Perl functions can do that. In Chapter 3, memoized functions were able to retain the cache hash between calls.</span></p>
<p><span class="font17">Before we get into the details of the </span><span class="font2">dir_walk() </span><span class="font17">iterator, let’s try out the idea on a simpler example.</span></p>
<div>
<p><span class="font15">4.2 HOMEMADE ITERATORS</span></p>
</div><br clear="all">
<div>
<h4><a name="bookmark250"></a><span class="font20">121</span></h4>
</div><br clear="all">
<ul style="list-style:none;"><li>
<h5><a name="bookmark63"></a><span class="font19">4.2.1 A Trivial Iterator: </span><span class="font3">upto()</span></h5></li></ul>
<p><span class="font17">Here’s a function called </span><span class="font2">upto() </span><span class="font17">that builds iterators, and which is mostly useful as an example. Given two numbers, </span><span class="font17" style="font-style:italic;">m</span><span class="font17"> and </span><span class="font17" style="font-style:italic;">n,</span><span class="font17"> it returns an iterator that will return all the numbers between </span><span class="font17" style="font-style:italic;">m</span><span class="font17"> and </span><span class="font17" style="font-style:italic;">n</span><span class="font17">, inclusive:</span></p>
<p><span class="font2">sub upto {</span></p>
<div>
<p><span class="font9" style="font-weight:bold;">CODE LIBRARY</span></p>
</div><br clear="all">
<div>
<p><span class="font0">upto</span></p>
</div><br clear="all">
<p><span class="font2">my ($m, $n) = @_;</span></p>
<p><span class="font2">return sub {</span></p>
<p><span class="font2">return $m &lt;= $n ? $m++ : undef;</span></p>
<p><span class="font2">};</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">my $it = upto(3, 5);</span></p>
<p><span class="font17">This constructs an iterator object that will count from 3 up to 5 if we ask it to. The iterator object is just an anonymous subroutine that has captured the values of </span><span class="font2">$m </span><span class="font17">and </span><span class="font2">$n</span><span class="font17">.</span></p>
<p><span class="font17">The iterator is a subroutine, returned by the final </span><span class="font2">return sub { ... } </span><span class="font17">statement. Because the iterator is a subroutine, its </span><span class="font2">NEXTVAL </span><span class="font17">operation is simply invoking the subroutine. The subroutine runs and returns a value; this is the next value from the iterator. To get the next value (“kick the iterator”) we simply do:</span></p>
<p><span class="font2">my Snextval = $it-&gt;();</span></p>
<p><span class="font17">This stores the number 3 into </span><span class="font2">$nextval</span><span class="font17">. If we do it again, it stores 4. If we do it a third time, it stores 5. Any calls after that will return </span><span class="font2">undef</span><span class="font17">.</span></p>
<p><span class="font17">To loop over the iterator’s values:</span></p>
<p><span class="font2">while (defined(my $val = $it-&gt;())) {</span></p>
<ul style="list-style:none;"><li>
<p><span class="font2"># now do something with $val, such as: print &quot;$val</span><span class="font2" style="font-weight:bold;">\</span><span class="font2">n&quot;;</span></p></li></ul>
<p><span class="font2">}</span></p>
<p><span class="font17">This prints 3, 4, 5, and then quits the loop.</span></p>
<p><span class="font17">This may have a substantial memory savings over something like:</span></p>
<p><span class="font2">for my $val (1 .. 10000000) {</span></p>
<ul style="list-style:none;"><li>
<p><span class="font2"># now do something with $val</span></p></li></ul>
<p><span class="font2">} </span><span class="font17">which, until Perl 5.005, would generate a gigantic list of numbers before starting the iteration.</span></p>
<p><span class="font17">If you have a sweet tooth, you can put some syntactic sugar on your serial:</span></p>
<div>
<p><span class="font9" style="font-weight:bold;">CODE LIBRARY</span></p>
</div><br clear="all">
<p><span class="font2">package Iterator_Utils;</span></p>
<p><span class="font0">Iterator_uti1s.pm &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="font2"><sub>US</sub>e base Exporter;</span></p>
<p><span class="font2">@EXPORT_OK = qw(NEXTVAL Iterator</span></p>
<p><span class="font2">append imap igrep</span></p>
<p><span class="font2">iterate_function filehandle_iterator list_iterator);</span></p>
<p><span class="font2">%EXPORT_TAGS = ('all' =&gt; \@EXPORT_OK);</span></p>
<p><span class="font2">sub NEXTVAL { $_[0]-&gt;() }</span></p>
<p><span class="font17">Then in place of the preceding examples, we can use this:</span></p>
<p><span class="font2">my $nextval = NEXTVAL($it);</span></p>
<p><span class="font17">and this:</span></p>
<p><span class="font2">while (defined(my $val = NEXTVAL($it))) {</span></p>
<p><span class="font2"># now do something with $val</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">We’ll do this from now on.</span></p>
<p><span class="font17">The internal operation of the iterator is simple. When the subroutine is called, it returns the value of </span><span class="font2">$m </span><span class="font17">and increments </span><span class="font2">$m </span><span class="font17">for next time. Eventually, </span><span class="font2">$m </span><span class="font17">exceeds </span><span class="font2">$n</span><span class="font17">, and the subroutine returns an undefined value thereafter. When an iterator runs out of data this way, we say it has been </span><span class="font17" style="font-style:italic;">exhausted.</span><span class="font17"> We’ll adopt the convention that a call to an exhausted iterator returns an undefined value, and then see some alternatives to this starting in Section 4.5.</span></p>
<p><span class="font17">SYNTACTIC SUGAR FOR MANUFACTURING ITERATORS</span></p>
<p><span class="font17">From now on, instead of writing </span><span class="font2">return sub { ... } </span><span class="font17">in a function, we will write </span><span class="font2">return Iterator { ... } </span><span class="font17">to make it clear that an iterator is being constructed:</span></p>
<p><span class="font2">sub upto {</span></p>
<p><span class="font2">my ($m, $n) = @_;</span></p>
<div>
<p><span class="font15">4.2 HOMEMADE ITERATORS</span></p>
</div><br clear="all">
<div>
<h4><a name="bookmark251"></a><span class="font20">123</span></h4>
</div><br clear="all">
<p><span class="font2" style="font-weight:bold;">return Iterator {</span></p>
<p><span class="font2">return Sm &lt;= Sn ? $m++ : undef;</span></p>
<p><span class="font2">};</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">This bit of sugar is easy to accomplish:</span></p>
<p><span class="font2">sub Iterator (&amp;) { return $_[0] } </span><span class="font17">when we write this:</span></p>
<p><span class="font2">Iterator { ... }</span></p>
<p><span class="font17">Perl behaves as though we had written:</span></p>
<p><span class="font2">Iterator(sub { ... })</span></p>
<p><span class="font17">instead. Once past the sugar, the </span><span class="font2">Iterator() </span><span class="font17">function itself is trivial. Since the iterator </span><span class="font17" style="font-style:italic;">is</span><span class="font17"> the anonymous function, it returns the argument unchanged.</span></p>
<p><span class="font17">Using this </span><span class="font2">Iterator() </span><span class="font17">sugar may make the code a little easier to understand. It will also give us an opportunity to hang additional semantics on iterator construction if we want to, by adding features to the </span><span class="font2">Iterator() </span><span class="font17">function. We will see an example of this in Section 4.5.7.</span></p>
<p><span class="font19">4.2.2 </span><span class="font3">dir_walk()</span></p>
<p><span class="font17">Now that we’ve seen a function that builds simple iterators, we can investigate a more useful one, which builds iterators that walk a directory tree and generate filenames one at a time:</span></p>
<p><span class="font2"># iterator version</span></p>
<div>
<p><span class="font9" style="font-weight:bold;">CODE LIBRARY</span></p>
</div><br clear="all">
<div>
<p><span class="font0">dir-walk-iterator</span></p>
</div><br clear="all">
<p><span class="font2">sub dir_walk {</span></p>
<p><span class="font2">my @queue = shift;</span></p>
<p><span class="font2">return Iterator {</span></p>
<p><span class="font2">while (@queue) {</span></p>
<p><span class="font2">my Sfile = shift @queue;</span></p>
<p><span class="font2">if (-d Sfile) {</span></p>
<p><span class="font2">opendir my Sdh, Sfile or next;</span></p>
<p><span class="font2">my @newfiles = grep {$_ ne &quot;.&quot; &amp;&amp;&nbsp;S_ ne &quot;..&quot;} readdir Sdh; push @queue, map &quot;$file/$_&quot;, @newfiles;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">return $file;</span></p>
<p><span class="font2">} else {</span></p>
<p><span class="font2">return;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">};</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">The pattern here is the same as in </span><span class="font2">upto()</span><span class="font17">. </span><span class="font2">dir_walk() </span><span class="font17">is a function that sets up some state variables for the iterator and then returns a closure that captures the state variables. When the closure is executed, it computes and returns the next filename, updating the state variables in the process.</span></p>
<p><span class="font17">The closure maintains a queue of the files and directories that it hasn’t yet examined. Initially, the queue contains only the single top-level directory that the user asked it to search. Each time the iterator is invoked, it removes the item at the front of the queue. If this item is a plain file, the iterator returns it immediately; if the item is a directory, the iterator reads the directory and queues the directory’s contents before returning the name of the directory.</span></p>
<p><span class="font17">After enough calls to the iterator, the queue will become empty. Once this happens, the iterator is exhausted, and further calls to the iterator will return </span><span class="font2">undef</span><span class="font17">. In this case, </span><span class="font2">undef </span><span class="font17">doesn’t cause a semipredicate problem, because no valid filename is ever </span><span class="font2">undef</span><span class="font17">.</span></p>
<p><span class="font17">There is one subtle point to make here. The items in </span><span class="font2">©queue </span><span class="font17">must be full paths like </span><span class="font2">.</span><a href="file:///src/perl/japh.pl"><span class="font2">/src/perl/japh.pl</span></a><span class="font17">, not basenames like </span><span class="font2">japh.pl</span><span class="font17">, or else the </span><span class="font2">-d </span><span class="font17">operator won’t work. A common error when using </span><span class="font2">-d </span><span class="font17">is to get the basenames back from </span><span class="font2">readdir </span><span class="font17">and test them with </span><span class="font2">-d </span><span class="font17">immediately. This doesn’t work, because </span><span class="font2">-d</span><span class="font17">, like all file operators, interprets a bare filename as a request to look for that name in the </span><span class="font17" style="font-style:italic;">current</span><span class="font17"> directory. In order to use </span><span class="font2">-d</span><span class="font17">, we have to track the directory names also.</span></p>
<p><span class="font17">The </span><span class="font2">map </span><span class="font17">function accomplishes this. When we read the filenames out of the directory named </span><span class="font2">$file </span><span class="font17">with </span><span class="font2">readdir</span><span class="font17">, we get only the basenames. The </span><span class="font2">map </span><span class="font17">appends the directory name to each basename before the result is put on the queue. The result is full paths that work properly with </span><span class="font2">-d</span><span class="font17">.</span></p>
<p><span class="font17">Even if we didn’t need the full paths for use with </span><span class="font2">-d</span><span class="font17">, the user of the iterator probably needs them. It’s not usually useful to be told that the program has located a file named </span><span class="font2">japh.pl </span><span class="font17">unless you also find out which directory it’s in.</span></p>
<ul style="list-style:none;"><li>
<h5><a name="bookmark66"></a><span class="font19">4.2.3 On Clever Inspirations</span></h5></li></ul>
<p><span class="font17">Although this works well, it has one big defect: it appears to have required cleverness. The original </span><span class="font2">dir_walk() </span><span class="font17">from Chapter 1 was reasonably straightforward: process the current file, and if it happens to be a directory, make recursive calls to process its contents. The iterator version is not recursive; in place of recursion, it maintains a queue.</span></p>
<p><span class="font17">The problem that the queue is solving is that a recursive function maintains a lot of state on Perl’s internal call stack. Here’s the recursive function </span><span class="font2">dir_walk() </span><span class="font17">again:</span></p>
<p><span class="font2">sub dir_walk {</span></p>
<p><span class="font2">my (Stop, Scode) = @_;</span></p>
<p><span class="font2">my SDIR;</span></p>
<p><span class="font2">Scode-&gt;(Stop);</span></p>
<p><span class="font2">if (-d Stop) {</span></p>
<p><span class="font2">my Sfile;</span></p>
<p><span class="font2">unless (opendir SDIR, Stop) {</span></p>
<p><span class="font2">warn &quot;Couldn’t open directory Stop: S!; skipping.</span><span class="font2" style="font-weight:bold;">\</span><span class="font2">n&quot;;</span></p>
<p><span class="font2">return;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">while (Sfile = readdir SDIR) {</span></p>
<p><span class="font2">next if Sfile eq '.'|| Sfile eq '..'</span></p>
<p><span class="font2">dir_walk(&quot;Stop/Sfile&quot;, Scode);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">Each recursive call down in the </span><span class="font2">while </span><span class="font17">loop must save the values of </span><span class="font2">Stop</span><span class="font17">, </span><span class="font2">Scode</span><span class="font17">, </span><span class="font2">SDIR</span><span class="font17">, and </span><span class="font2">Sfile </span><span class="font17">on the call stack; when </span><span class="font2">dir_walk() </span><span class="font17">is re-entered, new instances of these variables are created. The values must be saved so that they can be restored when the recursive call returns; at this time, the new instances are destroyed.</span></p>
<p><span class="font17">When the </span><span class="font2">dir_walk() </span><span class="font17">function finally returns to its original caller, all of the state information that was held in </span><span class="font2">Stop</span><span class="font17">, </span><span class="font2">Scode</span><span class="font17">, </span><span class="font2">SDIR</span><span class="font17">, and </span><span class="font2">Sfile </span><span class="font17">has been lost. In order for the iterator to simulate a recursive function, it needs to be able to return to its caller without losing all that state information.</span></p>
<p><span class="font17">Recursion is essentially an automatic stack-management feature. When our function makes a recursive call, Perl takes care of saving the function’s state information on its private, internal stack, and restoring it again as necessary. But here the automatic management isn’t what we want; we need manual control over what is saved and restored, so recursion doesn’t work. Instead, we replace the call stack with the </span><span class="font2">@queue </span><span class="font17">variable and do all our stack management manually, with </span><span class="font2">push </span><span class="font17">and </span><span class="font2">shift</span><span class="font17">.</span></p>
<div><img src="HigherOrderPerl_files/HigherOrderPerl-18.jpg" alt="" style="width:37pt;height:51pt;">
</div><br clear="all">
<div>
<p><span class="font11">6</span></p><img src="HigherOrderPerl_files/HigherOrderPerl-19.jpg" alt="" style="width:21pt;height:52pt;">
<p><span class="font11">9</span></p>
</div><br clear="all">
<div>
<p><span class="font11">10</span></p><img src="HigherOrderPerl_files/HigherOrderPerl-20.jpg" alt="" style="width:20pt;height:21pt;">
<p><span class="font11">11 12</span></p>
</div><br clear="all">
<div><img src="HigherOrderPerl_files/HigherOrderPerl-21.jpg" alt="" style="width:37pt;height:52pt;">
</div><br clear="all">
<div>
<p><span class="font11">1</span></p><img src="HigherOrderPerl_files/HigherOrderPerl-22.jpg" alt="" style="width:22pt;height:83pt;">
<p><span class="font11">12</span></p>
</div><br clear="all">
<div>
<p><span class="font11">4 rS 10 11</span></p>
</div><br clear="all">
<p><span class="font14">FIGURE 4.1 </span><span class="font16">Depth-first traversal/breadth-first traversal.</span></p>
<p><span class="font17">The cost of the manual stack management is the trouble we have to go to. But the payoff, as do-it-yourselfers know, is flexibility. A recursive function for directory walking usually traverses the tree in depth-first order, visiting all the contents of each directory before moving on to the next directory. Sometimes we might prefer a breadth-first search, where all the files and directories at one level of the tree are visited before those lower down. Figure 4.1 illustrates both methods.</span></p>
<p><span class="font17">To get the recursive function to traverse the tree in breadth-first order or in any order other than depth-first is very difficult. But the iterator version accomplishes this easily. The previous iterator code traverses the directory in breadth-first order. If we replace </span><span class="font2">shift </span><span class="font17">with </span><span class="font2">pop</span><span class="font17">, </span><span class="font2">©queue </span><span class="font17">behaves as a stack, rather than a queue, and the iterator generates its output in depth-first order, exactly as the original recursive function did.</span></p>
<p><span class="font17">Replacing the recursion with the queue seems like a clever inspiration, but clever inspirations are usually in short supply. In Chapter 5, we’ll see that any recursive function can be turned into an iterator in a formulaic way, so that we can save our clever inspirations for something else.</span></p>
<ul style="list-style:none;"><li>
<h5><a name="bookmark67"></a><span class="font18">4.3 EXAMPLES</span></h5></li></ul>
<p><span class="font17">Let’s see some possibly useful examples of iterators. We’ll start with a replacement for </span><span class="font2">File::Find</span><span class="font17">, a variation on </span><span class="font2">dir_walk(). </span><span class="font17">It searches a directory hierarchy, looking for possibly interesting files:</span></p>
<div>
<p><span class="font9" style="font-weight:bold;">CODE LIBRARY</span></p>
</div><br clear="all">
<p><span class="font2">sub interesting_files {</span></p>
<p><span class="font0"><sup>interestin</sup>g-<sup>fi</sup>1<sup>es</sup> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="font2"><sub>m</sub>y $is_interesting = shift;</span></p>
<p><span class="font2" style="font-weight:bold;">my @queue = @_;</span></p>
<p><span class="font2">return Iterator {</span></p>
<p><span class="font2" style="font-weight:bold;">while (@queue) {</span></p>
<p><span class="font2">my Sfile = shift @queue;</span></p>
<p><span class="font2">if (-d Sfile) {</span></p>
<p><span class="font2">opendir my Sdh, Sfile or next;</span></p>
<p><span class="font2">my @newfiles = grep {S_ ne &quot;.&quot; &amp;&amp;&nbsp;S_ ne &quot;..&quot;} readdir Sdh; push @queue, map &quot;Sfile/S_&quot;, @newfiles;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2" style="font-weight:bold;">return $file if $is_interesting-&gt;($file);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2" style="font-weight:bold;">return;</span></p>
<p><span class="font2">};</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">Here we’ve made only a few changes. </span><span class="font2">interesting_files() </span><span class="font17">accepts a callback, </span><span class="font2">Sis_interesting</span><span class="font17">, which will return true if its argument is the name of an “interesting” file. We’ll also allow the user to specify more than one initial directory to search. This is trivial: We just take all the given directory names and load them into the initial queue.</span></p>
<p><span class="font17">The returned iterator is very similar. Instead of returning every file that it finds in the queue, the iterator returns only if the file is interesting, as determined by the callback. Otherwise, the iterator shifts another file off the queue and tries again. If the queue is exhausted before an interesting file is found, control leaves the </span><span class="font2">while </span><span class="font17">loop and the iterator returns </span><span class="font2">undef</span><span class="font17">. If the user calls the iterator again, the queue is still empty, so the iterator returns </span><span class="font2">undef </span><span class="font17">immediately.</span></p>
<p><span class="font17">To use this, we might write:</span></p>
<p><span class="font2"># Files are deemed to be interesting if they mention octopuses sub contains_octopuses {</span></p>
<p><span class="font2">my Sfile = shift;</span></p>
<p><span class="font2">return unless -T Sfile &amp;&amp;&nbsp;open my(Sfh), &quot;&lt;&quot;, Sfile;</span></p>
<p><span class="font2">while (&lt;Sfh&gt;) {</span></p>
<p><span class="font2">return 1 if /octopus/i;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">return;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">my Soctopus_file =</span></p>
<p><span class="font2">interesting_files(\&amp;contains_octopuses, 'uploads', 'downloads');</span></p>
<p><span class="font17">Now that we have the iterator, we can find all the interesting files:</span></p>
<p><span class="font2">while ($file = NEXTVAL($octopus_file)) {</span></p>
<p><span class="font2"># do something with the file</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">Or perhaps we only want to know if there are any interesting files at all:</span></p>
<p><span class="font2">if (NEXTVAL($next_octopus)) {</span></p>
<ul style="list-style:none;"><li>
<p><span class="font2"># yes, there is an interesting file</span></p></li></ul>
<p><span class="font2">} else {</span></p>
<ul style="list-style:none;"><li>
<p><span class="font2"># no, there isn’t.</span></p></li></ul>
<p><span class="font2">}</span></p>
<p><span class="font2">undef $next_octopus;</span></p>
<p><span class="font17">With a recursive function, we might have had trouble stopping the function when we found the interesting file; with the iterator, it’s trivial, since it only searches as far as is necessary to find the first interesting file, and then leaves the rest of the hierarchy unsearched and waiting in the queue. When we </span><span class="font2">undef $next_octopus</span><span class="font17">, this saved state is discarded, and the memory used for storing it is freed.</span></p>
<ul style="list-style:none;"><li>
<h5><a name="bookmark68"></a><span class="font19">4.3.1 Permutations</span></h5></li></ul>
<p><span class="font17">A </span><span class="font17" style="font-style:italic;">permutation</span><span class="font17"> is a rearrangement of the items in a list. A frequently asked question in newsgroups is how to produce all the permutations of a certain list. For example, the permutations of the list </span><span class="font2">('red', 'yellow', 'blue') </span><span class="font17">are:</span></p>
<p><span class="font2">( &nbsp;&nbsp;['red', 'yellow', 'blue'],</span></p>
<p><span class="font2">['red', 'blue', 'yellow'],</span></p>
<p><span class="font2">['yellow', 'red', 'blue'],</span></p>
<p><span class="font2">['yellow', 'blue', 'red'],</span></p>
<p><span class="font2">['blue', 'red', 'yellow'], ['blue', 'yellow', 'red'], )</span></p>
<p><span class="font17">It’s not completely clear to me why this is useful. Last time it came up in the newsgroup, I asked the poster, and he explained that he was trying to generate</span></p>
<ul style="list-style:none;"><li>
<p class="font15">4.3 EXAMPLES <span class="font20">129</span></p></li></ul>
<p><span class="font17">a name for a new product by assembling short phrases or syllables into different orders. Regardless of whether this is a good idea, it does seem to be something people want to do.</span></p>
<p><span class="font17">A beginner who tries to solve this problem may be completely puzzled. A programmer with more experience will immediately try to write a recursive function to generate the list, and will usually produce something that works. For example, here’s the solution from the Perl Frequently Asked Questions List, written by Tom Christiansen and Nathan Torkington:</span></p>
<p><span class="font2">sub permute {</span></p>
<p><span class="font2">my @items = @{ $_[0] };</span></p>
<p><span class="font2">my @perms = @{ $_[1] };</span></p>
<p><span class="font2">unless (©items) {</span></p>
<p><span class="font2">print &quot;@perms</span><span class="font2" style="font-weight:bold;">\</span><span class="font2">n&quot;;</span></p>
<p><span class="font2">} else {</span></p>
<p><span class="font2">my(©newitems,©newperms,$i);</span></p>
<p><span class="font2">foreach $i (0 .. $#items) {</span></p>
<p><span class="font2">©newitems = @items;</span></p>
<p><span class="font2">©newperms = @perms;</span></p>
<p><span class="font2">unshift(©newperms, splice(©newitems, $i, 1));</span></p>
<p><span class="font2">permute([@newitems], [©newperms]);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2"># sample call:</span></p>
<p><span class="font2">permute([qw(red yellow blue green)], []);</span></p>
<p><span class="font17">Items are removed from </span><span class="font2">©items </span><span class="font17">and placed onto the end of </span><span class="font2">©perms</span><span class="font17">. When all the items have been so placed, </span><span class="font2">@items </span><span class="font17">is empty and the resulting permutation, which is in </span><span class="font2">©perms</span><span class="font17">, is printed. (We should probably replace the </span><span class="font2">print </span><span class="font17">with a call to a callback.) The important part of this function is the </span><span class="font2">else </span><span class="font17">clause. In this clause, the function removes one of the unused items from the </span><span class="font2">©items </span><span class="font17">array, appends it to the end of the </span><span class="font2">©perms </span><span class="font17">array, and calls itself recursively to distribute the remaining items.</span></p>
<p><span class="font17">This solution works, but has a glaring problem. If you pass in a list of ten items, it doesn’t return until it has printed all 3,628,800 permutations. This is likely to take a lot of time — twenty or thirty minutes on my computer. If we modify the function to generate a list of permutations, it’s even worse. It returns a list of 3,628,800 items, each of which is an array of 10 items. This is likely to use up a substantial portion of your computer’s real memory; if it does, your OS is likely to start thrashing while trying to compute the result, and it will take an even longer time to finish. The function is inefficient to begin with, because it performs six array copies per call, a total of 24,227,478 copies in our preceding example above. The function is simply too slow to be practical except in trivial cases. And since we probably can’t use all of the 3.6 million permutations anyway, most of the work is wasted.</span></p>
<p><span class="font17">This is the sort of problem that iterators were made to solve. We want to generate a list of permutations, but the list might be enormous. Rather than generating the entire list at once, as the FAQ solution does, we will use an iterator that generates the permutations one at a time.</span></p>
<p><span class="font17">To make an iterator for permutations requires either an insight, or techniques from later in the chapter. The insight-requiring version is interesting and instructive, so we’ll look at it briefly before we move into the more generally useful versions that require less insight.</span></p>
<p><span class="font17">Regardless of the internals of </span><span class="font2">permute()</span><span class="font17">, here’s how we’ll be using it:</span></p>
<p><span class="font2">my $it = permute('A'..'D');</span></p>
<p><span class="font2">while (my @p = NEXTVAL($it)) { print &quot;@p</span><span class="font2" style="font-weight:bold;">\</span><span class="font2">n&quot;;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">The function </span><span class="font2">permute() </span><span class="font17">constructs the iterator itself:</span></p>
<div>
<p><span class="font9" style="font-weight:bold;">CODE LIBRARY</span></p>
</div><br clear="all">
<p class="font2">sub permute {</p>
<p><span class="font0">permute</span></p>
<p><span class="font2">my @items = @_;</span></p>
<p><span class="font2">my ©pattern = (0) x @items;</span></p>
<p><span class="font2">return Iterator {</span></p>
<p><span class="font2">return unless ©pattern;</span></p>
<p><span class="font2">my ©result = pattern_to_permutation(</span><span class="font2" style="font-weight:bold;">\</span><span class="font2">©pattern, </span><span class="font2" style="font-weight:bold;">\</span><span class="font2">©items);</span></p>
<p><span class="font2">©pattern = increment_pattern(©pattern);</span></p>
<p><span class="font2">return ©result;</span></p>
<p><span class="font2">};</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">Each permutation is represented by a “pattern” that says in what order to select elements from the original list. Suppose the original list is </span><span class="font2">('A', 'B', 'C', 'D')</span><span class="font17">. A pattern of </span><span class="font2">2 0 10 </span><span class="font17">selects (and removes) item 2 from the original list, the </span><span class="font2">'C'</span><span class="font17">, leaving </span><span class="font2">('A', 'B', 'D')</span><span class="font17">; then item 0, </span><span class="font2">'A'</span><span class="font17">, from the remaining items; then item 1, the </span><span class="font2">'D'</span><span class="font17">, then item 0, the </span><span class="font2">'B'</span><span class="font17">; the result is the permutation </span><span class="font2">('C', 'A', 'D', 'B')</span><span class="font17">. This selection process is performed by </span><span class="font2">pattern_to_permutation()</span><span class="font17">:</span></p>
<p><span class="font2">sub pattern_to_permutation {</span></p>
<p><span class="font2">my Spattern = shift;</span></p>
<p><span class="font2">my @items = @{shift()};</span></p>
<p><span class="font2">my @r;</span></p>
<p><span class="font2">for (@$pattern) {</span></p>
<p><span class="font2">push @r, splice(@items, $_, 1);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">@r;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">The generation of the patterns is the interesting part. What patterns make sense? If there are four items in the original list, then the first element of the pattern must be a number between 0 and 3, the second element must be a number between 0 and 2, the third must be 0 or 1, and the last element must be 0. Each pattern corresponds to a different permutation; if we can generate all possible patterns, we can generate all possible permutations.</span></p>
<p><span class="font17">Generating all the patterns is performed by </span><span class="font2">increment_pattern()</span><span class="font17">. For this example, it generates the following patterns in the following order:</span></p>
<p><span class="font17">0000 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1100 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2200</span></p>
<p><span class="font17">0010 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1110 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2210</span></p>
<table border="1">
<tr><td>
<p><span class="font17">0 100</span></p></td><td>
<p><span class="font17">12 0 0</span></p></td><td>
<p><span class="font17">3 0 0 0</span></p></td></tr>
<tr><td style="vertical-align:bottom;">
<p><span class="font17">0 110</span></p></td><td style="vertical-align:bottom;">
<p><span class="font17">12 10</span></p></td><td style="vertical-align:bottom;">
<p><span class="font17">3 0 10</span></p></td></tr>
<tr><td style="vertical-align:bottom;">
<p><span class="font17">0 2 0 0</span></p></td><td style="vertical-align:bottom;">
<p><span class="font17">2 0 0 0</span></p></td><td style="vertical-align:bottom;">
<p><span class="font17">3 100</span></p></td></tr>
<tr><td style="vertical-align:bottom;">
<p><span class="font17">0 2 10</span></p></td><td style="vertical-align:bottom;">
<p><span class="font17">2 0 10</span></p></td><td style="vertical-align:bottom;">
<p><span class="font17">3 110</span></p></td></tr>
<tr><td style="vertical-align:bottom;">
<p><span class="font17">10 0 0</span></p></td><td style="vertical-align:bottom;">
<p><span class="font17">2 10 0</span></p></td><td style="vertical-align:bottom;">
<p><span class="font17">3 2 0 0</span></p></td></tr>
<tr><td style="vertical-align:bottom;">
<p><span class="font17">10 10</span></p></td><td style="vertical-align:bottom;">
<p><span class="font17">2 110</span></p></td><td style="vertical-align:bottom;">
<p><span class="font17">3 2 10</span></p></td></tr>
</table>
<p><span class="font17">What is the pattern here? It turns out that getting from one pattern to the next is rather simple:</span></p>
<ul style="list-style:none;"><li>
<p><span class="font17">1. &nbsp;Scan the numbers in the pattern from right to left.</span></p></li>
<li>
<p><span class="font17">2. &nbsp;If you can legally increment the current number, do so, and halt.</span></p></li>
<li>
<p><span class="font17">3. &nbsp;Otherwise, change the current number to 0 and continue.</span></p></li>
<li>
<p><span class="font17">4. &nbsp;If you fall off the left end, then the sequence was the last one.</span></p></li></ul>
<p><span class="font17">This algorithm should sound familiar, because you learned it a long time ago. It’s exactly the same as the algorithm you use to </span><span class="font17" style="font-style:italic;">count:</span></p>
<p><span class="font17">210397</span></p>
<p><span class="font17">210398</span></p>
<table border="1">
<tr><td style="vertical-align:bottom;">
<p><span class="font20">132</span></p></td><td style="vertical-align:bottom;">
<p><span class="font15">CHAPTER 4 Iterators</span></p></td></tr>
</table>
<p><span class="font17">210399</span></p>
<p><span class="font17">210400</span></p>
<p><span class="font17">210401</span></p>
<p><span class="font17">To increment a numeral, scan the digits right to left. If you find a digit that you can legally increment (that is, a digit that is less than 9) then increment it, and stop; you are finished. Otherwise, change the digit to 0 and continue leftwards. If you fall off the left end, it’s because every digit was 9, so that was the last number. (You can now extend the number by inferring and incrementing an unwritten 0 just past the left end.)</span></p>
<p><span class="font17">To count in base 2, the algorithm is again the same. Only the definition of “legal digit” changes: instead of “less than 10” it is “less than 2”. To generate the permutation patterns, the algorithm is the same, except that this time “legal” means “the digit in the </span><span class="font17" style="font-style:italic;">nth</span><span class="font17"> column from the right may not exceed </span><span class="font17" style="font-style:italic;">n</span><span class="font17">.”</span></p>
<p><span class="font17">The elements of the permutation pattern are like the wheels of an imaginary odometer. But where each wheel on a real odometer is the same size, and carries numbers from 0 to 9 (or 0 to 1 on planets where the odometer reads out in base 2), each wheel in the permutation odometer is a different size. The last one just has a 0 on it; the next has just a 0 and a 1, and so on. But like a real odometer, each wheel turns one notch when the wheel to its right has completed a whole revolution.</span></p>
<p><span class="font17">The code to manage a regular odometer looks like this:</span></p>
<p><span class="font2">sub increment_odometer {</span></p>
<p><span class="font2">my @odometer = @_;</span></p>
<p><span class="font2">my $wheel = $#odometer; # start at rightmost wheel</span></p>
<p><span class="font2">until ($odometer[$wheel] &lt;&nbsp;9 || $wheel &lt;&nbsp;0) { $odometer[$wheel] = 0;</span></p>
<p><span class="font2">$wheel--; # next wheel to the left</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">if ($wheel &lt;&nbsp;0) {</span></p>
<p><span class="font2">return; # fell off the left end; no more sequences</span></p>
<p><span class="font2">} else {</span></p>
<p><span class="font2">$odometer[$wheel]++; # this wheel now turns one notch return @odometer;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
<ul style="list-style:none;"><li>
<p class="font15">4.3 EXAMPLES <span class="font20">133</span></p></li></ul>
<p><span class="font17">The code to produce the permutation patterns is almost exactly the same:</span></p>
<p><span class="font2">sub increment_pattern { my @odometer = @_; my Swheel = S#odometer; # start at rightmost wheel </span><span class="font2" style="font-weight:bold;">until ($odometer[$wheel] &lt;&nbsp;$#odometer-$wheel || $wheel &lt;&nbsp;0) { </span><span class="font2">Sodometer[Swheel] = 0;</span></p>
<p><span class="font2">Swheel--; # next wheel to the left } if (Swheel &lt;&nbsp;0) {</span></p>
<p><span class="font2">return; # fell off the left end; no more sequences } else {</span></p>
<p><span class="font2">Sodometer[Swheel]++; # this wheel now turns one notch return @odometer;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
<p class="font17">We can simplify the code with a little mathematical trickery. Just as we can predict in advance what positions the wheels of an odometer will hold after we’ve travelled 19,683 miles, even if it reads out in base 2, we can predict what positions the wheels of our pattern-odometer will hold the 19,683rd time we call it: <span class="font2">sub n_to_pat {</span></p>
<div>
<p><span class="font9" style="font-weight:bold;">CODE LIBRARY</span></p>
</div><br clear="all">
<p><span class="font0">permute-n </span><span class="font2">my @odometer; my (Sn, Slength) = @_; for my Si (1 .. Slength) { unshift @odometer, Sn % Si; Sn = int(Sn/Si); } return Sn ? () : @odometer; }</span></p>
<p><span class="font2">permute() </span><span class="font17">must change a little to match, since the state information is now a simple counter instead of an entire pattern:</span></p>
<p><span class="font2">sub permute { my @items = @_; </span><span class="font2" style="font-weight:bold;">my $n = 0; </span><span class="font2">return Iterator {</span></p>
<div>
<h4><a name="bookmark252"></a><span class="font20">134</span></h4>
</div><br clear="all">
<div>
<p><span class="font15">CHAPTER 4 Iterators</span></p>
</div><br clear="all">
<p><span class="font2" style="font-weight:bold;">my ©pattern = n_to_pat($n, scalar(@items));</span></p>
<p><span class="font2">my @result = pattern_to_permutation(</span><span class="font2" style="font-weight:bold;">\</span><span class="font2">@pattern, </span><span class="font2" style="font-weight:bold;">\</span><span class="font2">@items);</span></p>
<p><span class="font2" style="font-weight:bold;">$n++;</span></p>
<p><span class="font2">return @result;</span></p>
<p><span class="font2">};</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">This last function is an example of a useful class of iterators that return </span><span class="font17" style="font-style:italic;">f</span><span class="font17"> (0),</span><span class="font17" style="font-style:italic;">f</span><span class="font17"> (1),</span><span class="font17" style="font-style:italic;">f</span><span class="font17"> (2),</span><span class="font17" style="font-style:italic;">...</span><span class="font17"> for some function </span><span class="font17" style="font-style:italic;">f</span><span class="font17">:</span></p>
<p><span class="font2">sub iterate_function { my $n = 0;</span></p>
<p><span class="font2">my $f = shift;</span></p>
<p><span class="font2">return Iterator { return $f-&gt;($n++);</span></p>
<p><span class="font2">};</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">This is an iterator that generates values of a function for </span><span class="font17" style="font-style:italic;">n = 0,1,2....</span><span class="font17"> You might want many values of the function, or few; an iterator may be a more flexible way to get them than a simple loop, because it is a data structure.</span></p>
<p><span class="font17">The permutation iterators shown here do a lot of splicing. </span><span class="font2">pattern_to_ permutation() </span><span class="font17">copies the original list ofitems and then dismantles it; everytime an element is removed the other elements must be shifted down in memory to fill up the gap. With enough ingenuity, it’s possible to avoid this, abandoning the idea of the patterns. Instead of starting over with a fresh list every time, in the original order, and then using the pattern to select items from it to make the new permutation, we can take the previous permutation and just apply whatever transformation is appropriate to turn it into the new one:</span></p>
<div>
<p><span class="font9" style="font-weight:bold;">CODE LIBRARY</span></p>
</div><br clear="all">
<div>
<p><span class="font0">permute-flop</span></p>
</div><br clear="all">
<p><span class="font2">sub permute {</span></p>
<p><span class="font2">my @items = @_;</span></p>
<p><span class="font2">my $n = 0;</span></p>
<p><span class="font2">return Iterator {</span></p>
<p><span class="font2">$n++, return @items if $n==0;</span></p>
<p><span class="font2">my $i;</span></p>
<p><span class="font2">my $p = $n;</span></p>
<p><span class="font2">for ($i=1; $i&lt;=@items &amp;&amp;&nbsp;$p%$i==0; $i++) { $p /= $i;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">my $d = $p % $i;</span></p>
<ul style="list-style:none;"><li>
<p class="font15">4.3 EXAMPLES <span class="font20">135</span></p></li></ul>
<p><span class="font2">my $j = ©items - $i;</span></p>
<p><span class="font2">return if $j &lt;&nbsp;0;</span></p>
<p><span class="font2">©items[$j+1..$#items] = reverse ©items[$j+1..$#items];</span></p>
<p><span class="font2">©items[$j,$j+$d] = ©items[$j+$d,$j];</span></p>
<p><span class="font2">$n++;</span></p>
<p><span class="font2">return @items;</span></p>
<p><span class="font2">};</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">The key piece of code here is the pair of slice assignments of </span><span class="font2">©items</span><span class="font17">. The insight behind this code is that at any given stage, we can ignore the first few items and concentrate only on the last few. Let’s say we’re rearranging just the last three items. We start with something like </span><span class="font2">... A B C D </span><span class="font17">and produce the various rearrangements of the last three items, ending with </span><span class="font2">... A D C B</span><span class="font17">.</span></p>
<p><span class="font17">At this point, the last three items are in backwards order. We need to put them back in forward order (this is the assignment with the </span><span class="font2">reverse</span><span class="font17">) and then switch the </span><span class="font2">A</span><span class="font17">, the next item over, with one of the three we just finished permuting. (This is the second assignment.) We need to do this three times, first switching </span><span class="font2">A </span><span class="font17">with </span><span class="font2">B</span><span class="font17">, then with </span><span class="font2">C</span><span class="font17">, and finally with </span><span class="font2">D</span><span class="font17">; after each switch, we run again through all possible permutations of the last three items. Of course, there are complications, since permuting the last three items involves applying the same process to the last </span><span class="font17" style="font-style:italic;">two</span><span class="font17"> items, and is itself part of the process of permuting the last four items.</span></p>
<ul style="list-style:none;"><li>
<h5><a name="bookmark69"></a><span class="font19">4.3.2 Genomic Sequence Generator</span></h5></li></ul>
<p><span class="font17">In 1999, I got email from a biologist at the University ofVirginia. He was working on the Human Genome Project, dealing with DNA. DNA is organized as a sequence of base pairs, each of which is typically represented by the letter </span><span class="font2">A</span><span class="font17">, </span><span class="font2">C</span><span class="font17">, </span><span class="font2">G</span><span class="font17">, or </span><span class="font2">T</span><span class="font17">. The information carried in the chromosome of any organism can be recorded as a string of these four letters. A bacteriophage will have a few thousand of these symbols, and a human chromosome will have between 30 and 300 million. Much of the Human Genome Project involved data munging on these strings; Perl was invaluable for this munging. (For more details about this, see Lincoln Stein’s widely-reprinted article “How Perl Saved the Human Genome Project.”<a name="footnote16"></a><sup><a href="#bookmark253">16</a></sup><sup></sup>)</span></p>
<p><span class="font17">The biologist who wrote to me wanted a function that, given an input pattern like </span><span class="font2">&quot;A(CGT)CGT&quot;</span><span class="font17">, would produce the output list </span><span class="font2">('ACCGT', 'AGCGT',</span></p>
<p><span class="font2">'ATCGT')</span><span class="font17">. The </span><span class="font2">(CGT) </span><span class="font17">in the input is a wildcard that indicates that the second position may be filled by any one of the symbols </span><span class="font2">C</span><span class="font17">, </span><span class="font2">G</span><span class="font17">, or </span><span class="font2">T</span><span class="font17">. Similarly, an input of </span><span class="font2">&quot;A(CT)G(AC)&quot; </span><span class="font17">should yield the list </span><span class="font2">('ACGA', 'ATGA', 'ACGC', 'ATGC')</span><span class="font17">. He had written a recursive function to generate the appropriate output list, but was concerned that he would run into memory limitations if he used it on long, ambiguous inputs, where the result would be a list of many thousands of strings.</span></p>
<p><span class="font17">An iterator is exactly the right solution here:</span></p>
<div>
<p><span class="font9" style="font-weight:bold;">CODE LIBRARY</span></p>
</div><br clear="all">
<div>
<p><span class="font0">make-genes-1</span></p>
</div><br clear="all">
<p><span class="font2">sub make_genes {</span></p>
<p><span class="font2">my $pat = shift;</span></p>
<p><span class="font2">my @tokens = split /[()]/, $pat;</span></p>
<p><span class="font2">for (my $i = 1; $i &lt;&nbsp;@tokens; $i += 2) { $tokens[$i] = [0, split(//, $tokens[$i])];</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">my $FINISHED = 0;</span></p>
<p><span class="font2">return Iterator {</span></p>
<p><span class="font2">return if $FINISHED;</span></p>
<p><span class="font2">my $finished_incrementing = 0;</span></p>
<p><span class="font2">my $result = &quot;&quot;;</span></p>
<p><span class="font2">for my $token (©tokens) {</span></p>
<p><span class="font2">if (ref $token eq &quot;&quot;) { &nbsp;&nbsp;&nbsp;# plain string</span></p>
<p><span class="font2">$result .= $token;</span></p>
<p><span class="font2">} else { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# wildcard</span></p>
<p><span class="font2">my ($n, @c) = @$token;</span></p>
<p><span class="font2">$result .= $c[$n];</span></p>
<p><span class="font2">unless ($finished_incrementing) {</span></p>
<p><span class="font2">if ($n == $#c) { $token-&gt;[0] = 0 }</span></p>
<p><span class="font2">else { $token-&gt;[0]++; $finished_incrementing = 1 } }</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">$FINISHED = 1 unless $finished_incrementing;</span></p>
<p><span class="font2">return $result;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
<h6><a name="bookmark254"></a><span class="font17">Here the input pattern </span><span class="font2">&quot;AA(CGT)CG(AT)&quot; </span><span class="font17">is represented by the following data structure, which is stored in </span><span class="font2">©tokens</span><span class="font17">:</span></h6>
<p><span class="font2">[ &quot;AA&quot;,</span></p>
<p><span class="font2">[ 0, &quot;C&quot;, &quot;G&quot;, &quot;T&quot;],</span></p>
<ul style="list-style:none;"><li>
<p class="font15">4.3 EXAMPLES <span class="font20">137</span></p></li></ul>
<p><span class="font2">&quot;CG&quot;,</span></p>
<p><span class="font2">[ 0, &quot;A&quot;, &quot;T&quot;],</span></p>
<p><span class="font2">]</span></p>
<p><span class="font17">The code to construct the data structure uses some tricks:</span></p>
<p><span class="font2">my @tokens = split /[()]/, $pat;</span></p>
<p><span class="font2">for (my $i = 1; $i &lt;&nbsp;@tokens; $i += 2) {</span></p>
<p><span class="font2">$tokens[$i] = [0,split(//, $tokens[$i])];</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">The peculiar-looking </span><span class="font2">split </span><span class="font17">pattern says that </span><span class="font2">$pat </span><span class="font17">should be split wherever there is an open- or a close- parenthesis character. The return value has the convenient property that the wildcard sections are always in the odd-numbered positions in the resulting list. For example, </span><span class="font2">&quot;AA(CGT)CG(AT)&quot; </span><span class="font17">is split into </span><span class="font2">(&quot;AA&quot;, &quot;CGT&quot;, &quot;CG&quot;, &quot;AT&quot;)</span><span class="font17">. Even if the string begins with a delimiter, </span><span class="font2">split </span><span class="font17">will insert an empty string into the initial position of the result: </span><span class="font2">&quot;(A)C&quot; </span><span class="font17">is split into </span><span class="font2">(&quot;&quot;, &quot;A&quot;, &quot;C&quot;)</span><span class="font17">.</span></p>
<p><span class="font17">The following code processes only the wildcard parts of the resulting </span><span class="font2">@tokens </span><span class="font17">list:</span></p>
<p><span class="font2">for (my $i = 1; $i &lt;&nbsp;@tokens; $i += 2) {</span></p>
<p><span class="font2">$tokens[$i] = [0,split(//, $tokens[$i])];</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">The odd-numbered elements of </span><span class="font2">(&quot;AA&quot;, &quot;CGT&quot;, &quot;CG&quot;, &quot;AT&quot;) </span><span class="font17">are transformed by this into </span><span class="font2">(&quot;AA&quot;, [ 0, &quot;C&quot;, &quot;G&quot;, &quot;T&quot;], &quot;CG&quot;, [ 0, &quot;A&quot;, &quot;T&quot;])</span><span class="font17">. The iterator then captures this list, which is stored in </span><span class="font2">@tokens</span><span class="font17">. Elements of this list that are plain strings correspond to the non-wildcard parts of the input pattern, and are inserted into the output verbatim. Elements that are arrays correspond to the wildcard parts of the input pattern and indicate choice points.</span></p>
<p><span class="font17">The internal structure of the iterator is similar to the structure of the permutation generator. When it’s run, it scans the token string, one token at a time. During the scan, it does two things: It accumulates an output string, and it adjusts the numeric parts of the wildcard tokens. Tokens are handled differently depending on whether they are plain strings (</span><span class="font2">ref $token eq &quot;&quot;</span><span class="font17">) or wildcards. Plain strings are just copied directly to the result.</span></p>
<p><span class="font17">Wildcard handling is a little more interesting. The wildcard token is first decomposed into its component parts:</span></p>
<p><span class="font2">my ($n, @c) = @$token;</span></p>
<div>
<h4><a name="bookmark255"></a><span class="font20">138</span></h4>
</div><br clear="all">
<div>
<p><span class="font15">CHAPTER 4 Iterators</span></p>
</div><br clear="all">
<p><span class="font2">Sn </span><span class="font17">says which element of </span><span class="font2">@c </span><span class="font17">should be chosen next:</span></p>
<p><span class="font2">Sresult .= Sc[Sn];</span></p>
<p><span class="font17">Then the iterator may need to adjust </span><span class="font2">Sn </span><span class="font17">to have a different value so that a different element of </span><span class="font2">@c </span><span class="font17">will be chosen next time. In the permutation-pattern generator, we scanned from right to left, resetting wheels to zero until we found one small enough to be incremented. Here we’re scanning from left to right, but the principle is the same. </span><span class="font2">Sfinished_incrementing </span><span class="font17">is a flag that tells the iterator whether it has been able to increment one of the digits, after which it doesn’t need to adjust any of the others:</span></p>
<p><span class="font2">unless (Sfinished_incrementing) {</span></p>
<p><span class="font2">if ($n == S#c) { Stoken-&gt;[0] = 0 }</span></p>
<p><span class="font2">else { Stoken-&gt;[0]++; Sfinished_incrementing = 1 }</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">The function can increment the value in a wildcard token if it would still index a valid element of </span><span class="font2">@c </span><span class="font17">afterwards. Otherwise, the value is reset to zero and the iterator keeps looking. This is analogous to the way we used </span><span class="font2">increment_pattern() </span><span class="font17">earlier to cycle through all possible permutation patterns; here we use the same sort of odometer technique to cycle through all possible selections of the wildcards.</span></p>
<p><span class="font17">When we have cycled through all the possible choices, the numbers in the wildcard tokens all have their maximum possible values; we can recognize this condition because we will have scanned all of them without finding one we could increment, and so </span><span class="font2">Sfinished_incrementing </span><span class="font17">will still be false after the scan. The iterator sets the </span><span class="font2">SFINISHED </span><span class="font17">flag so that it doesn’t start over again from the beginning; thereafter, the iterator returns immediately, without generating a string:</span></p>
<p><span class="font2">SFINISHED = 1 unless Sfinished_incrementing;</span></p>
<p><span class="font17">There’s nothing in this iterator that treats </span><span class="font2">A</span><span class="font17">, </span><span class="font2">C</span><span class="font17">, </span><span class="font2">T</span><span class="font17">, and </span><span class="font2">G </span><span class="font17">specially, so we can use it as a generic string generator:</span></p>
<p><span class="font2">my Sit = make_genes('(abc)(de)-(12)');</span></p>
<p><span class="font2">print &quot;Ss</span><span class="font2" style="font-weight:bold;">\</span><span class="font2">n&quot; while Ss = NEXTVAL(Sit);</span></p>
<p><span class="font17">The output looks like this:</span></p>
<p><span class="font2">ad-1</span></p>
<p><span class="font2">bd-1</span></p>
<ul style="list-style:none;"><li>
<p class="font15">4.3 EXAMPLES <span class="font20">139</span></p></li></ul>
<p><span class="font2">cd-1</span></p>
<p><span class="font2">ae-1</span></p>
<p><span class="font2">be-1</span></p>
<p><span class="font2">ce-1</span></p>
<p><span class="font2">ad-2</span></p>
<p><span class="font2">bd-2</span></p>
<p><span class="font2">cd-2</span></p>
<p><span class="font2">ae-2</span></p>
<p><span class="font2">be-2</span></p>
<p><span class="font2">ce-2</span></p>
<p><span class="font17">Biologists don’t usually use </span><span class="font2">(ACT) </span><span class="font17">to indicate a choice of </span><span class="font2">A</span><span class="font17">, </span><span class="font2">C</span><span class="font17">, or </span><span class="font2">T</span><span class="font17">; they typically use the single letter </span><span class="font2">H</span><span class="font17">. I don’t know if the biologist who asked me this question was trying to avoid confusing me with unnecessary detail, or if he really did want to handle patterns like </span><span class="font2">(ACT)</span><span class="font17">. But supposing that we want to handle the standard abbreviations, a simple preprocessor will take care of it:</span></p>
<p><span class="font2">%n_expand = qw(N ACGT</span></p>
<div>
<p><span class="font9" style="font-weight:bold;">CODE LIBRARY</span></p>
</div><br clear="all">
<p><span class="font2">B CGT D AGT H ACT V ACG &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="font0"><sup>make-genes</sup>-2</span></p>
<p><span class="font2">K GT M AC R AG S CG W AT Y CT);</span></p>
<p><span class="font2">sub make_dna_sequences {</span></p>
<p><span class="font2">my $pat = shift;</span></p>
<p><span class="font2">for my $abbrev (keys %n_expand) {</span></p>
<p><span class="font2">$pat =- s/$abbrev/($n_expand{$abbrev})/g;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">return make_genes($pat);</span></p>
<p><span class="font2">}</span></p>
<ul style="list-style:none;"><li>
<h5><a name="bookmark70"></a><span class="font19">4.3.3 Filehandle Iterators</span></h5></li></ul>
<p><span class="font17">Now we’ll see how to turn an ordinary Perl filehandle into a synthetic closurebased iterator. Why would we want to this? Because in the rest of the chapter we’ll develop many tools for composing and manipulating iterators, and these tools apply just as well to Perl filehandles as long as we use the following little wrapper:</span></p>
<p><span class="font2">sub filehandle_iterator { my $fh = shift;</span></p>
<p><span class="font2">return Iterator { &lt;$fh&gt; };</span></p>
<p><span class="font2">}</span></p>
<div>
<p><span class="font9" style="font-weight:bold;">CODE LIBRARY</span></p>
</div><br clear="all">
<div>
<p><span class="font0">db.txt</span></p>
</div><br clear="all">
<div>
<p><span class="font9" style="font-weight:bold;">CODE LIBRARY</span></p>
</div><br clear="all">
<div>
<p><span class="font0">FlatDB.pm</span></p>
</div><br clear="all">
<div>
<p><span class="font17">We can now use:</span></p>
<p><span class="font2">my $it = filehandle_iterator(*STDIN);</span></p>
<p><span class="font2">while (defined(my $line = NEXTVAL($it))) {</span></p>
<p><span class="font2"># do something with $line</span></p>
<p><span class="font2">}</span></p>
</div><br clear="all">
<div>
<h5><a name="bookmark71"></a><span class="font19">4.3.4 A Flat-File Database</span></h5>
</div><br clear="all">
<div>
<p><span class="font17">Now let’s do a real application. We’ll develop a small flat-file database. A </span><span class="font17" style="font-style:italic;">flat-file database</span><span class="font17"> is one that stores the data in a plain text file, with one record per line.</span></p>
<p><span class="font17">Our database will have a format something like this:</span></p>
</div><br clear="all">
<div>
<p><span class="font2">LASTNAME:FIRSTNAME:CITY:STATE:OWES</span></p>
</div><br clear="all">
<div>
<p><span class="font2">Adler:David:New York:NY:157.00</span></p>
</div><br clear="all">
<div>
<p><span class="font2">Ashton:Elaine:Boston:MA:0.00</span></p>
</div><br clear="all">
<div>
<p><span class="font2">Dominus:Mark:Philadelphia:PA:0.00</span></p>
<p><span class="font2">Orwant:Jon:Cambridge:MA:26.30</span></p>
<p><span class="font2">Schwern:Michael:New York:NY:149658.23</span></p>
</div><br clear="all">
<div>
<p><span class="font2">Wall:Larry:Mountain View:CA:-372.14</span></p>
</div><br clear="all">
<div>
<p><span class="font17">The first line is a header, sometimes called a </span><span class="font17" style="font-style:italic;">schema,</span><span class="font17"> that defines the names of the fields; the later lines are data records. Each record has the same number of data fields, separated by colons. This sample of the data shows only six records, but the file might contain thousands of records. For large files, the iterator approach is especially important. A flat-file database must be searched entirely for every query, and this is slow. By using an iterator approach, we will allow programs to produce useful results before the entire file has been scanned.</span></p>
<p><span class="font17">We’ll develop the database as an object-oriented class, </span><span class="font2">FlatDB</span><span class="font17">. The </span><span class="font2">FlatDB </span><span class="font17">class will support a </span><span class="font2">new </span><span class="font17">method that takes a data filename and returns a database handle object:</span></p>
</div><br clear="all">
<div>
<p><span class="font2">package FlatDB;</span></p>
<p><span class="font2">my SFIELDSEP = qr/:/;</span></p>
</div><br clear="all">
<div>
<p><span class="font2">sub new {</span></p>
<p><span class="font2">my $class = shift;</span></p>
<p><span class="font2">my $file = shift;</span></p>
<p><span class="font2">open my $fh, &quot;&lt;&quot;, $file or return;</span></p>
<p><span class="font2">chomp(my Sschema = &lt;$fh&gt;);</span></p>
</div><br clear="all">
<p><span class="font2">my @field = split SFIELDSEP, Sschema;</span></p>
<p><span class="font2">my %fieldnum = map { uc Sfield[S_] =&gt; $_ } (0..S#field);</span></p>
<p><span class="font2">bless { FH =&gt; Sfh, FIELDS =&gt; \@field, FIELDNUM =&gt; \%fieldnum, FIELDSEP =&gt; SFIELDSEP } =&gt; $class;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">The database handle object contains a number of items that might be useful, in addition to the open data filehandle itself. For our sample database, the contents of the database handle object look like this:</span></p>
<p><span class="font2">{</span></p>
<p><span class="font2">FH =&gt; (the handle),</span></p>
<p><span class="font2">FIELDS =&gt; ['LASTNAME', 'FIRSTNAME', 'CITY', 'STATE', 'OWES'],</span></p>
<p><span class="font2">FIELDNUM =&gt; { CITY =&gt; 2,</span></p>
<p><span class="font2">FIRSTNAME =&gt; 1,</span></p>
<p><span class="font2">LASTNAME =&gt; 0,</span></p>
<p><span class="font2">OWES =&gt; 4,</span></p>
<p><span class="font2">STATE =&gt; 3,</span></p>
<p><span class="font2">},</span></p>
<p><span class="font2">FIELDSEP =&gt; qr/:/,</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">The database handle object will support a </span><span class="font2">query </span><span class="font17">method that takes a field name and a value and returns all the records that have the specified value in the field. But we don’t want </span><span class="font2">query </span><span class="font17">to simply read all the records in the data file and return a list of matching records, because that might be very expensive. Instead, </span><span class="font2">query </span><span class="font17">will return an iterator that will return matching records one at a time:</span></p>
<ul style="list-style:none;"><li>
<p><span class="font2"># usage: Sdbh-&gt;query(fieldname, value)</span></p></li>
<li>
<p><span class="font2"># returns all records for which (fieldname) matches (value)</span></p></li></ul>
<p><span class="font2">use Fcntl ':seek';</span></p>
<p><span class="font2">sub query {</span></p>
<p><span class="font2">my Sself = shift;</span></p>
<p><span class="font2">my (Sfield, Svalue) = @_;</span></p>
<p><span class="font2">my Sfieldnum = Sself-&gt;{FIELDNUM}{uc Sfield};</span></p>
<p><span class="font2">return unless defined Sfieldnum;</span></p>
<p><span class="font2">my Sfh = Sself-&gt;{FH};</span></p>
<p><span class="font2">seek Sfh, 0, SEEK_SET;</span></p>
<p><span class="font2">&lt;Sfh&gt;; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# discard schema line</span></p>
<p><span class="font2">return Iterator {</span></p>
<p><span class="font2">local S_;</span></p>
<p><span class="font2">while (&lt;Sfh&gt;) {</span></p>
<p><span class="font2">chomp;</span></p>
<p><span class="font2">my ©fields = split $self-&gt;{FIELDSEP}, $_, -1;</span></p>
<p><span class="font2">my Sfieldval = Sfields[Sfieldnum];</span></p>
<p><span class="font2">return S_ if Sfieldval eq $value;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">return;</span></p>
<p><span class="font2">};</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">query </span><span class="font17">first looks in the </span><span class="font2">FIELDNUM </span><span class="font17">hash to ascertain two things. First, is the requested field name actually a field in the database, and second, if so, what number column is it? The result is stored in </span><span class="font2">Sfieldnum</span><span class="font17">; if the field name is invalid, </span><span class="font2">query </span><span class="font17">returns </span><span class="font2">undef </span><span class="font17">to indicate an error. Otherwise, the function seeks the filehandle back to the beginning of the data to begin the search, using the </span><span class="font2">seek </span><span class="font17">function.</span></p>
<p><span class="font2">seek() </span><span class="font17">has a rather strange interface, inherited from the original design of Unix in the 1970s: </span><span class="font2">seek(Sfh, Sposition, Swhence) </span><span class="font17">positions the filehandle so that the next read or write will occur at byte position </span><span class="font2">Sposition</span><span class="font17">. The </span><span class="font2">Swhence </span><span class="font17">argument is actually the integer 0, 1, or 2, but mnemonic names for these values are provided by the standard Perl </span><span class="font2">Fcntl </span><span class="font17">module. If </span><span class="font2">Swhence </span><span class="font17">is the constant </span><span class="font2">SEEK_SET</span><span class="font17">, </span><span class="font2">Sposition </span><span class="font17">is interpreted as a number of bytes forward from the beginning of the file. Here we use </span><span class="font2">seek(Sfh, 0, SEEK_SET)</span><span class="font17">, which positions the handle at the beginning of the file, so that the following </span><span class="font2">&lt;Sfh&gt; </span><span class="font17">reads and discards the schema line.</span></p>
<p><span class="font17">The </span><span class="font2">query </span><span class="font17">function then returns the iterator, which captures the values of </span><span class="font2">Sself</span><span class="font17">, </span><span class="font2">Sfh</span><span class="font17">, </span><span class="font2">Sfieldnum</span><span class="font17">, and </span><span class="font2">Svalue</span><span class="font17">.</span></p>
<p><span class="font17">The iterator is quite simple. When it’s invoked, it starts reading data lines from the database. It splits up each record into fields, and compares the appropriate field value (in </span><span class="font2">Sfields[Sfieldnum]</span><span class="font17">) with the desired value (in </span><span class="font2">Svalue</span><span class="font17">). If there’s a match, it returns the current record immediately; if not, it tries the next record. When it reaches the end of the file, the </span><span class="font2">while </span><span class="font17">loop exits and the function returns an undefined result to indicate failure.</span></p>
<p><span class="font17">The iterator is planning to change the value of </span><span class="font2">S_ </span><span class="font17">in the while loop. Since </span><span class="font2">S_ </span><span class="font17">is a global variable, this means that the function calling the iterator might get a nasty surprise:</span></p>
<p><span class="font2">S_ = 'I love you';</span></p>
<p><span class="font2">NEXTVAL(Sq);</span></p>
<p><span class="font2">print S_;</span></p>
<p><span class="font17">We don’t want the invocation of </span><span class="font2">Sq </span><span class="font17">to change the value of </span><span class="font2">S_</span><span class="font17">. To prevent this, the iterator uses </span><span class="font2">local S_</span><span class="font17">. This saves the old value of </span><span class="font2">S_ </span><span class="font17">on entry to the iterator, and</span></p>
<div>
<p><span class="font15">4.3 EXAMPLES</span></p>
</div><br clear="all">
<div>
<h4><a name="bookmark256"></a><span class="font20">143</span></h4>
</div><br clear="all">
<p><span class="font17">arranges for the old value to be automatically restored when the iterator returns. With this </span><span class="font2">local </span><span class="font17">line, it is safe for the iterator to use </span><span class="font2">$_ </span><span class="font17">any way it wants to. You should probably take this precaution in any function that uses </span><span class="font2">$_</span><span class="font17">.</span></p>
<p><span class="font17">A simple demonstration:</span></p>
<p><span class="font2">use FlatDB;</span></p>
<p><span class="font2">my $dbh = FlatDB-&gt;new('db.txt') or die $!;</span></p>
<p><span class="font2">my $q = $dbh-&gt;query('STATE', 'NY');</span></p>
<p><span class="font2">while (my $rec = NEXTVAL($q)) { print $rec;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">The output is:</span></p>
<p><span class="font2">Adler:David:New York:NY:157.00</span></p>
<p><span class="font2">Schwern:Michael:New York:NY:149658.23</span></p>
<p><span class="font17">Many obvious variations are possible. We might support different kinds of queries, which return a list of the fields, or a list of just some of the fields. Or instead of passing a field-value pair, we might pass a callback function that will be called with each record and returns true if the record is interesting:</span></p>
<p><span class="font2">use FlatDB;</span></p>
<p><span class="font2">my $dbh = FlatDB-&gt;new('db.txt') or die $!;</span></p>
<p><span class="font2">my $q = $dbh-&gt;callbackquery(sub { my %F=@_; $F{STATE} eq 'NY'});</span></p>
<p><span class="font2">while (my $rec = NEXTVAL($q)) {</span></p>
<p><span class="font2">print $rec;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2"># Output as before</span></p>
<p><span class="font17">With </span><span class="font2">callbackquery </span><span class="font17">we can ask for a list of the people who owe more than $10, which was impossible with </span><span class="font2">-&gt;query</span><span class="font17">:</span></p>
<p><span class="font2">my $q = $dbh-&gt;callbackquery(sub { my %F=@_; $F{OWES} &gt;&nbsp;10 });</span></p>
<p><span class="font17">Similarly, we can now use Perl’s full regex capabilities in queries:</span></p>
<p><span class="font2">my $q = $dbh-&gt;callbackquery(sub { my %F=@_; $F{FIRSTNAME} =- /*M/ });</span></p>
<div>
<p><span class="font20">144</span></p>
</div><br clear="all">
<p><span class="font15">CHAPTER 4 Iterators</span></p>
<p><span class="font17">This callback approach is much more flexible than hardwiring every possible comparison type into the iterator code, and it’s easy to support:</span></p>
<p><span class="font2">use Fcntl ':seek';</span></p>
<p><span class="font2">sub callbackquery {</span></p>
<p><span class="font2">my $self = shift;</span></p>
<p><span class="font2" style="font-weight:bold;">my $is_interesting = shift;</span></p>
<p><span class="font2">my $fh = $self-&gt;{FH};</span></p>
<p><span class="font2">seek $fh, 0, SEEK_SET;</span></p>
<p><span class="font2">&lt;$fh&gt;; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# discard header line</span></p>
<p><span class="font2">return Iterator {</span></p>
<p><span class="font2">local $_;</span></p>
<p><span class="font2">while (&lt;$fh&gt;) {</span></p>
<p><span class="font2">chomp;</span></p>
<p><span class="font2" style="font-weight:bold;">my %F;</span></p>
<p><span class="font2" style="font-weight:bold;">my @fieldnames = @{$self-&gt;{FIELDS}};</span></p>
<p><span class="font2">my @fields = split $self-&gt;{FIELDSEP};</span></p>
<p><span class="font2" style="font-weight:bold;">for (0 .. $#fieldnames) {</span></p>
<p><span class="font2" style="font-weight:bold;">$F{$fieldnames[$_]} = $fields[$_];</span></p>
<p><span class="font2" style="font-weight:bold;">}</span></p>
<p><span class="font2" style="font-weight:bold;">return $_ if $is_interesting-&gt;(%F);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">return;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">The only major change here is in the iterator itself, mostly to set up the </span><span class="font2">%F </span><span class="font17">hash that is passed to the callback. I originally had a hash slice assignment instead of the </span><span class="font2">for </span><span class="font17">loop:</span></p>
<p><span class="font2">@F{@{$self-&gt;{FIELDS}}} = split $self-&gt;{FIELDSEP};</span></p>
<p><span class="font17">The punctuation made my eyes glaze over, so I used the loop instead.</span></p>
<p><span class="font17">IMPROVED DATABASE</span></p>
<p><span class="font17">The database code we’ve just seen has one terrible drawback: All of the iterators share a single filehandle, and this means that only one iterator can be active at any time. Consider this example:</span></p>
<p><span class="font2">use FlatDB;</span></p>
<p><span class="font2">my $dbh = FlatDB-&gt;new('db.txt') or die $!;</span></p>
<ul style="list-style:none;"><li>
<p class="font15">4.3 EXAMPL</p>
<div>
<p><span class="font15">E S </span><span class="font20">145</span></p>
</div><br clear="all"></li></ul>
<p><span class="font2">my $q1 = $dbh-&gt;query('STATE', 'MA');</span></p>
<p><span class="font2">my $q2 = $dbh-&gt;query('STATE', 'NY');</span></p>
<p><span class="font2">for (1..2) {</span></p>
<p><span class="font2">print NEXTVAL($q1), NEXTVAL($q2);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">We’d like this to print both </span><span class="font2">NY </span><span class="font17">records and both </span><span class="font2">MA </span><span class="font17">records, but it doesn’t; it produces only one of each:</span></p>
<p><span class="font2">Ashton:Elaine:Boston:MA:0.00</span></p>
<p><span class="font2">Schwern:Michael:New York:NY:149658.23</span></p>
<p><span class="font17">What goes wrong? We would like </span><span class="font2">$q1 </span><span class="font17">to generate records 2 and 4, and </span><span class="font2">$q2 </span><span class="font17">to generate records 1 and 5. The sequence of events is shown in Figure 4.2. </span><span class="font2">$q1 </span><span class="font17">executes the first time, and searches through the database looking for an </span><span class="font2">MA </span><span class="font17">record. In doing so, it skips over record 1 (David Adler) and then locates record 2 (Elaine Ashton), which it returns. The filehandle is now positioned at the beginning of the third record. When we invoke </span><span class="font2">$q2</span><span class="font17">, this is where the search continues. </span><span class="font2">$q2 </span><span class="font17">won’t find record 1, because the handle is already positioned past record 1. Instead, the iterator skips the next two records, until it finds record 5 (Michael Schwern), which it returns. The filehandle is now positioned just before record 6 (Larry Wall). When </span><span class="font2">$q1 </span><span class="font17">executes the second time, it skips record 6, reaches the end of the file, and returns </span><span class="font2">undef</span><span class="font17">. All further calls to both iterators produce nothing but </span><span class="font2">undef </span><span class="font17">because the filehandle is stuck at the end of the file. Although some commercial databases (such as Sybase) have this same deficiency, we can do better, and we will.</span></p>
<p><span class="font17">The obvious solution is to have a separate filehandle for each iterator. But open filehandles are a limited resource, and a program might have many active iterators at any time, so we’ll adopt a different solution. Each iterator will remember the position in the file at which its last search left off, and when it is invoked, it will reset the handle to that position and continue. This allows several iterators to share the same filehandle without getting confused.</span></p>
<p><span class="font17">We need to make only a few changes to </span><span class="font2">query </span><span class="font17">to support this:</span></p>
<ul style="list-style:none;"><li>
<p><span class="font2"># usage: $dbh-&gt;query(fieldname, value)</span></p></li>
<li>
<p><span class="font2"># returns all records for which (fieldname) matches (value)</span></p></li></ul>
<p><span class="font2">use Fcntl ':seek';</span></p>
<p><span class="font2">sub query {</span></p>
<p><span class="font2">my $self = shift;</span></p>
<p><span class="font2">my ($field, $value) = @_;</span></p>
<p><span class="font2">my Sfieldnum = $self-&gt;{FIELDNUM}{uc $field};</span></p>
<div><img src="HigherOrderPerl_files/HigherOrderPerl-23.jpg" alt="" style="width:133pt;height:73pt;">
<p><span class="font2">(state = MA)</span></p>
<p><span class="font2">(state = NY)</span></p>
<p><span class="font2">NEXTVAL (</span><span class="font11">$q1) =&gt; </span><span class="font2">2 Ashton</span></p>
</div><br clear="all">
<div>
<p><span class="font11">$q1 </span><span class="font2">(state = MA)</span></p>
</div><br clear="all">
<div>
<p><span class="font2">HEADER</span></p>
<table border="1">
<tr><td>
<p><span class="font2">1 Adler</span></p></td><td>
<p><span class="font2">NY</span></p></td></tr>
<tr><td style="vertical-align:bottom;">
<p><span class="font2">2 Ashton</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">MA</span></p></td></tr>
<tr><td style="vertical-align:bottom;">
<p><span class="font2">3 Dominus</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">PA</span></p></td></tr>
<tr><td>
<p><span class="font2">4 Orwant</span></p></td><td>
<p><span class="font2">MA</span></p></td></tr>
<tr><td style="vertical-align:bottom;">
<p><span class="font2">5 Schwern</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">NY</span></p></td></tr>
<tr><td style="vertical-align:bottom;">
<p><span class="font2">6 Wall</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">CA</span></p></td></tr>
</table>
</div><br clear="all">
<div>
<p><span class="font2">fh</span></p>
</div><br clear="all">
<div>
<p><span class="font11">$q2 </span><span class="font2">(state = NY)</span></p>
</div><br clear="all">
<p><span class="font2">NEXTVAL (</span><span class="font11">$q2</span><span class="font2">) =&gt; 5 Schwern</span></p>
<div><img src="HigherOrderPerl_files/HigherOrderPerl-24.jpg" alt="" style="width:133pt;height:73pt;">
<p><span class="font2">(state = MA)</span></p>
<p><span class="font2">(state = NY)</span></p>
</div><br clear="all">
<div>
<p><span class="font2">NEXTVAL (</span><span class="font11">$q1</span><span class="font2">) </span><span class="font11">=&gt; </span><span class="font2">undef</span></p><img src="HigherOrderPerl_files/HigherOrderPerl-25.jpg" alt="" style="width:133pt;height:73pt;">
<p><span class="font2">(state = MA)</span></p>
<p><span class="font2">(state = NY)</span></p>
<p><span class="font2">NEXTVAL (</span><span class="font11">$q2) =&gt; </span><span class="font2">undef</span></p>
</div><br clear="all">
<p><span class="font2">HEADER</span></p>
<table border="1">
<tr><td>
<p><span class="font2">1 Adler</span></p></td><td>
<p><span class="font2">NY</span></p></td></tr>
<tr><td style="vertical-align:bottom;">
<p><span class="font2">2 Ashton</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">MA</span></p></td></tr>
<tr><td>
<p><span class="font2">3 Dominus</span></p></td><td>
<p><span class="font2">PA</span></p></td></tr>
<tr><td style="vertical-align:bottom;">
<p><span class="font2">4 Orwant</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">MA</span></p></td></tr>
<tr><td>
<p><span class="font2">5 Schwern</span></p></td><td>
<p><span class="font2">NY</span></p></td></tr>
<tr><td style="vertical-align:bottom;">
<p><span class="font2">6 Wall</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">CA</span></p></td></tr>
</table>
<p><span class="font11">$q1</span></p>
<table border="1">
<tr><td>
<p><span class="font2">fh</span></p></td><td style="vertical-align:bottom;">
<p><span class="font11">Bq2</span></p></td></tr>
</table>
<p><span class="font2">(state = NY)</span></p>
<div>
<p><span class="font2">(state = MA)</span></p>
</div><br clear="all">
<p><span class="font2">NEXTVAL (</span><span class="font11">$q1</span><span class="font2">) =&gt; undef</span></p>
<p><span class="font14">FIGURE 4.2 </span><span class="font16">Interference between two query handles.</span></p>
<p><span class="font2">return unless defined Sfieldnum;</span></p>
<p><span class="font2">my Sfh = Sself-&gt;{FH};</span></p>
<p><span class="font2">seek Sfh, 0, SEEK_SET;</span></p>
<p><span class="font2">&lt;$fh&gt;; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# discard header line</span></p>
<p><span class="font2" style="font-weight:bold;">my Sposition = tell Sfh;</span></p>
<p><span class="font2">return Iterator {</span></p>
<p><span class="font2">local $_;</span></p>
<p><span class="font2" style="font-weight:bold;">seek Sfh, Sposition, SEEK_SET;</span></p>
<p><span class="font2">while (&lt;$fh&gt;) {</span></p>
<p><span class="font2">chomp;</span></p>
<p><span class="font2" style="font-weight:bold;">Sposition = tell Sfh;</span></p>
<p><span class="font2">my @fields = split Sself-&gt;{FIELDSEP};</span></p>
<p><span class="font2">my Sfieldval = $fields[$fieldnum];</span></p>
<p><span class="font2">return $_ if Sfieldval eq $value;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">return;</span></p>
<p><span class="font2">};</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2"># callbackquery with bug fix</span></p>
<p><span class="font2">use Fcntl ':seek';</span></p>
<p><span class="font2">sub callbackquery {</span></p>
<p><span class="font2">my Sself = shift;</span></p>
<p><span class="font2">my Sis_interesting = shift;</span></p>
<p><span class="font2">my Sfh = Sself-&gt;{FH};</span></p>
<p><span class="font2">seek Sfh, 0, SEEK_SET;</span></p>
<p><span class="font2">&lt;Sfh&gt;; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# discard header line</span></p>
<p><span class="font2" style="font-weight:bold;">my Sposition = tell Sfh;</span></p>
<p><span class="font2">return Iterator {</span></p>
<p><span class="font2">local S_;</span></p>
<p><span class="font2" style="font-weight:bold;">seek Sfh, Sposition, SEEK_SET;</span></p>
<p><span class="font2">while (&lt;Sfh&gt;) {</span></p>
<p><span class="font2" style="font-weight:bold;">Sposition = tell Sfh;</span></p>
<p><span class="font2">my %F;</span></p>
<p><span class="font2">my @fieldnames = @{Sself-&gt;{FIELDS}};</span></p>
<p><span class="font2">my @fields = split Sself-&gt;{FIELDSEP};</span></p>
<p><span class="font2">for (0 .. S#fieldnames) {</span></p>
<p><span class="font2">SF{Sfieldnames[S_]} = Sfields[S_];</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">return S_ if Sis_interesting-&gt;(%F);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">return;</span></p>
<p><span class="font2">};</span></p>
<p><span class="font2">} 1;</span></p>
<p><span class="font17">The iterators here capture one additional value, </span><span class="font2">Sposition</span><span class="font17">, which records the current position of the filehandle in the file; initially this position is at the start of the first data record. This position is supplied by the Perl </span><span class="font2">tell </span><span class="font17">operator, which returns the filehandle’s current position; if this position is later used with </span><span class="font2">seek Sfh, Sposition, SEEK_SET</span><span class="font17">, the filehandle will be set back to that position. This is precisely what the iterators do whenever they are invoked. Regardless of what other functions have used the filehandle in the meantime, or where they have left it, the first thing the iterators do is to seek the filehandle back to the current position using the </span><span class="font2">seek </span><span class="font17">operator. Each time an iterator reads a record, it updates its notion of the current position, again using </span><span class="font2">tell</span><span class="font17">, so its </span><span class="font2">seek </span><span class="font17">in a future invocation will skip the record that was just read.</span></p>
<p><span class="font17">With this change, our two-iterators-at-once example works perfectly:</span></p>
<p><span class="font2">Ashton:Elaine:Boston:MA:0.00</span></p>
<p><span class="font2">Adler:David:New York:NY:157.00</span></p>
<p><span class="font2">Orwant:Jon:Cambridge:MA:26.30</span></p>
<p><span class="font2">Schwern:Michael:New York:NY:149658.23</span></p>
<ul style="list-style:none;"><li>
<h5><a name="bookmark73"></a><span class="font19">4.3.5 Searching Databases Backwards</span></h5></li></ul>
<p><span class="font17">Perhaps the most common occurrence of a flat-file database is a process log file. Anyone who runs a web server knows that the server can churn out megabytes of log information every day. These logs are essentially flat databases. Each line represents a request for a web page, and includes fields that describe the source of the request, the page requested, the date and time of the request, and the outcome of the request. A sample follows:</span></p>
<p><span class="font2">208.190.220.160 - - [04/Aug/2001:08:14:29 -0400] &quot;GET /-mjd/pictures/new.gif HTTP/1.1&quot;</span></p>
<p><span class="font2">200 95 &quot;</span><a href="http://perl.plover.com/"><span class="font2">http://perl.plover.com/</span></a><span class="font2">&quot; &quot;Mozilla/5.0 (Macintosh; U; PPC; en-US; rv:0.9.2)</span></p>
<p><span class="font2">Gecko/20010629&quot;</span></p>
<p><span class="font2">195.3.19.207 - - [04/Aug/2001:13:39:11 -0400] &quot;GET /pics/small-sigils.gif HTTP/1.1&quot; 200 1586 &quot;</span><a href="http://perl.plover.com/"><span class="font2">http://perl.plover.com/</span></a><span class="font2">&quot; &quot;Mozilla/4.0 (compatible; MSIE 5.01; Windows NT 5.0; DigExt)&quot;</span></p>
<ul style="list-style:none;"><li>
<p class="font15">4.3 EXAMPLES <span class="font20">149</span></p></li></ul>
<p><span class="font2">192.94.94.33 - - [07/Aug/2001:12:06:34 -0400] &quot;GET /yak/Identity/slide005.html HTTP/1.0&quot;</span></p>
<p><span class="font2">200 821 &quot;</span><a href="http://perl.plover.com/yak/Identity/slide004.html"><span class="font2">http://perl.plover.com/yak/Identity/slide004.html</span></a><span class="font2">&quot; &quot;Mozilla/4.6 [en]</span></p>
<p><span class="font2">(X11; I; SunOS 5.8 sun4u)&quot;</span></p>
<p><span class="font2">199.93.193.10 - - [13/Aug/2001:13:04:39 -0400] &quot;GET /yak/dirty/miller_glenn_r.jpg HTTP/1.0&quot;</span></p>
<p><span class="font2">200 4376 &quot;</span><a href="http://perl.plover.com/yak/dirty/slide009.html"><span class="font2">http://perl.plover.com/yak/dirty/slide009.html</span></a><span class="font2">&quot; &quot;Mozilla/4.77 [en] (X11; U;</span></p>
<p><span class="font2">SunOS 5.6 sun4u)&quot;</span></p>
<p><span class="font2">216.175.77.248 - - [15/Aug/2001:14:25:20 -0400] &quot;GET </span><a href="file:///yak/handson/examples/wordsort.pl"><span class="font2">/yak/handson/examples/wordsort.pl</span></a></p>
<p><span class="font2">HTTP/1.0&quot; 200 125 &quot;</span><a href="http://perl.plover.com:80/yak/handson/examples/"><span class="font2">http://perl.plover.com:80/yak/handson/examples/</span></a><span class="font2">&quot; &quot;Wget/1.5.3&quot;</span></p>
<p><span class="font2">194.39.218.254 - - [16/Aug/2001:07:44:02 -0400] &quot;GET /pics/medium-sigils.gif HTTP/1.0&quot; 304 -</span></p>
<p><span class="font2">&quot;</span><a href="http://perl.plover.com/local.html"><span class="font2">http://perl.plover.com/local.html</span></a><span class="font2">&quot; &quot;Mozilla/4.0 (compatible; MSIE 5.01; Windows NT 5.0)&quot; 210.239.93.70 - msdw [22/Aug/2001:01:29:28 -0400] &quot;GET /class/msdw-tokyo/ HTTP/1.0&quot; 401 469</span></p>
<p><span class="font2">&quot;</span><a href="http://perl.plover.com/class/"><span class="font2">http://perl.plover.com/class/</span></a><span class="font2">&quot; &quot;Mozilla/4.0 (compatible; MSIE 5.5; Windows NT 4.0)&quot;</span></p>
<p><span class="font2">151.204.38.119 - - [25/Aug/2001:13:48:01 -0400] &quot;GET /yak/path/hanoi06.gif HTTP/1.0&quot; 200 239</span></p>
<p><span class="font2">&quot;</span><a href="http://perl.plover.com/yak/path/"><span class="font2">http://perl.plover.com/yak/path/</span></a><span class="font2">&quot; &quot;Mozilla/4.77 [en] (WinNT; U)&quot;</span></p>
<p><span class="font17">One of the common tasks of system administrators is to search through the log files looking for certain matching records; for example, the last time a certain user visited, or the last time a certain page was fetched. In fact, Perl itself first rose to prominence as a tool for helping system administrators answer exactly these sorts of questions. A typical query will look something like this:</span></p>
<p><span class="font2">perl -ane 'print $F[10] if $F[6] =- m{/book/$}' access-log</span></p>
<p><span class="font17">The </span><span class="font2">-n </span><span class="font17">option implies a loop; Perl will automatically read the input file </span><span class="font2">access-log </span><span class="font17">line by line and execute the indicated program once for each line. The </span><span class="font2">-a </span><span class="font17">option implies that each line will be automatically </span><span class="font2">split </span><span class="font17">into the special </span><span class="font2">@F </span><span class="font17">array. The </span><span class="font2">-e </span><span class="font17">option introduces the program, which uses the </span><span class="font2">@F </span><span class="font17">array that was set up by </span><span class="font2">-a</span><span class="font17">. In these log files, field #6 is the path of the page that is being requested, and field #10 is the URL of the “referring page,” which is the one that contained a link to the page that is being requested. This query will yield the URLs of pages that may contain links to the page that talks about the book you are now reading.</span></p>
<p><span class="font17">If what you want is all such records, this works very well. But more often, you are more interested in recent activity than in old activity. The preceding </span><span class="font2">perl </span><span class="font17">command example produces the records in chronological order, with the oldest ones first, because that’s the order in which they appear in the file. That means that to get to the part of interest, you have to wait until the entire file has been read, analyzed, and printed. If the file is large, this will take a long time.</span></p>
<p><span class="font17">One solution to this problem is to store the records in reverse order, with the most recent ones first. Unfortunately, under most operating systems, this is impossible. Unix, for example, supports appending records only to the end of a file, not to the beginning.</span></p>
<p><span class="font17">Instead, we’ll build an iterator that can read a file backwards, starting with the most recent records. If we plug this iterator into our existing query system, we’ll get a flat-file database query system that produces the most recent records first, with no additional effort.</span></p>
<p><span class="font17">A QUERY PACKAGE THAT TRANSFORMS</span></p>
<p><span class="font17">ITERATORS</span></p>
<p><span class="font17">There is one minor technical problem that we have to solve before we can proceed. As written, the </span><span class="font2">FlatDB </span><span class="font17">constructor wants a filename, not another iterator. A few changes are necessary to build a version that accepts an arbitrary iterator:</span></p>
<p><span class="font2" style="font-weight:bold;">package FlatDB::Iterator;</span></p>
<p><span class="font2">my SFIELDSEP = qr/\s+/;</span></p>
<p><span class="font2">sub new {</span></p>
<p><span class="font2">my Sclass = shift;</span></p>
<p><span class="font2" style="font-weight:bold;">my $it = shift;</span></p>
<p><span class="font2" style="font-weight:bold;">my @field = @_;</span></p>
<p><span class="font2">my %fieldnum = map { uc Sfield[S_] =&gt; $_ } (0..S#field);</span></p>
<p><span class="font2">bless { FH =&gt; Sit, FIELDS =&gt; \@field, FIELDNUM =&gt; \%fieldnum, FIELDSEP =&gt; SFIELDSEP } =&gt; $class;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">For the original </span><span class="font2">FlatDB </span><span class="font17">package, we assumed that the data file itself would begin with a schema line. HTTP log files don’t have a schema line, so here we’ve assumed that the field names will be passed to the constructor as arguments. The calling sequence for </span><span class="font2">FlatDB::Iterator::new </span><span class="font17">is:</span></p>
<p><span class="font2">FlatDB::Iterator-&gt;new(</span></p>
<p><span class="font2">Siterator,</span></p>
<p><span class="font2">qw(address rfc931 username datetime tz method page protocol status bytes referrer agent)</span></p>
<p><span class="font2">);</span></p>
<p><span class="font17">The </span><span class="font2">qw(...) </span><span class="font17">list specifies the names of the fields in the data that will be produced by </span><span class="font2">Siterator</span><span class="font17">.</span></p>
<ul style="list-style:none;"><li>
<p class="font15">4.3 EXAMPLES <span class="font20">151</span></p></li></ul>
<p><span class="font2">query </span><span class="font17">requires only trivial changes. The code to skip the descriptor records goes away, and the code to fetch the next record changes from:</span></p>
<p><span class="font2">while (&lt;Sfh&gt;) {</span></p>
<p><span class="font17">to:</span></p>
<p><span class="font2" style="font-weight:bold;">while (defined ($_ = NEXTVAL($it))) {</span></p>
<p><span class="font17">A more subtle change is that we must get rid of the </span><span class="font2">seek Sfh, 0, SEEK_SET </span><span class="font17">line, because there’s no analogous operation for iterators. (We’ll see in Chapter 6 how to build iterators that overcome this drawback.) This means that each database object can be used only for one query. After that, we must throw it away, because there’s no way to rewind and reread the data:</span></p>
<ul style="list-style:none;"><li>
<p><span class="font2"># usage: Sdbh-&gt;query(fieldname, value)</span></p></li>
<li>
<p><span class="font2"># returns all records for which (fieldname) matches (value) sub query {</span></p></li></ul>
<p><span class="font2">my Sself = shift;</span></p>
<p><span class="font2">my (Sfield, $value) = @_;</span></p>
<p><span class="font2">my Sfieldnum = Sself-&gt;{FIELDNUM}{uc Sfield};</span></p>
<p><span class="font2">return unless defined Sfieldnum;</span></p>
<p><span class="font2">my Sit = Sself-&gt;{FH};</span></p>
<ul style="list-style:none;"><li>
<p><span class="font2" style="font-weight:bold;"># seek $fh, 0, SEEK_SET;</span></p></li>
<li>
<p><span class="font2" style="font-weight:bold;"># &lt;$fh&gt;; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# discard header line</span></p></li></ul>
<p><span class="font2">return Iterator {</span></p>
<p><span class="font2">local S_;</span></p>
<p><span class="font2" style="font-weight:bold;">while (defined ($_ = NEXTVAL($it))) {</span></p>
<p><span class="font2">my @fields = split Sself-&gt;{FIELDSEP};</span></p>
<p><span class="font2">my Sfieldval = Sfields[Sfieldnum];</span></p>
<p><span class="font2">return S_ if Sfieldval eq Svalue;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">return;</span></p>
<p><span class="font2">};</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">It’s similarly easy to write the amended version of </span><span class="font2">callbackquery</span><span class="font17">.</span></p>
<p><span class="font17">If </span><span class="font2">Sit </span><span class="font17">were an iterator that produced the lines from a log file in reverse order, we could use:</span></p>
<p><span class="font2">my Sqit =</span></p>
<p><span class="font2">FlatDB::Iterator-&gt;new(Sit, @FIELDNAMES)-&gt;query(Sfield, Svalue);</span></p>
<p><span class="font17">And </span><span class="font2">Sqit </span><span class="font17">would be an iterator that would generate the specified records from the file, one at a time, starting with the most recent.</span></p>
<p><span class="font17">AN ITERATOR THAT READS FILES BACKWARDS</span></p>
<p><span class="font17">Building an iterator that reads a file backwards is more an exercise in systems programming than anything else. We’ll take the easy way out and use the Unix </span><span class="font2">tac </span><span class="font17">program as our base. The </span><span class="font2">tac </span><span class="font17">program reads a file and emits its lines in reverse order:</span></p>
<p><span class="font2">sub readbackwards {</span></p>
<p><span class="font2">my Sfile = shift;</span></p>
<p><span class="font2">open my(Sfh), &quot;|-&quot;, &quot;tac&quot;, Sfile</span></p>
<p><span class="font2">or return;</span></p>
<p><span class="font2">return Iterator { return scalar(&lt;Sfh&gt;) };</span></p>
<p><span class="font2">}</span></p>
<h6><a name="bookmark257"></a><span class="font17">If </span><span class="font2">tac </span><span class="font17">isn’t available, we can use the </span><span class="font2">File::ReadBackwards </span><span class="font17">module from CPAN instead:</span></h6>
<p><span class="font2">use File::ReadBackwards;</span></p>
<p><span class="font2">sub readbackwards {</span></p>
<p><span class="font2">my Sfile = shift;</span></p>
<p><span class="font2">my Srbw = File::ReadBackwards-&gt;new(Sfile)</span></p>
<p><span class="font2">or return;</span></p>
<p><span class="font2">return Iterator { return Srbw-&gt;readline };</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">PUTTING IT TOGETHER</span></p>
<h6><a name="bookmark258"></a><span class="font17">We can now search a log file backwards:</span></h6>
<p><span class="font2">my @fields = qw(address rfc931 username datetime tz method page protocol status bytes referrer agent);</span></p>
<p><span class="font2">my Slogfile = readbackwards(&quot;/usr/local/apache/logs/access-log&quot;) my $db = FlatDB::Iterator-&gt;new($logfile, @fields);</span></p>
<p><span class="font2">my Sq = Sdb-&gt;callbackquery(sub {my %F=@_; SF{PAGE}=- m{/book/S}});</span></p>
<p><span class="font2">while (1) {</span></p>
<p><span class="font2">for (1..10) {</span></p>
<p><span class="font2">print NEXTVAL($q);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">print &quot;q to quit; CR to continue</span><span class="font2" style="font-weight:bold;">\</span><span class="font2">n&quot;;</span></p>
<p><span class="font2">chomp(my $resp = &lt;STDIN&gt;);</span></p>
<p><span class="font2">last if $resp =- /q/i;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">This program starts up fast and immediately produces the most recent few records, without reading through the entire file first. It uses little memory, even when there are many matching records.</span></p>
<p><span class="font17">We had to do some extra work to read a file backwards in the first place, but once we had done that, we could plug the iterator directly into our existing query system.</span></p>
<ul style="list-style:none;"><li>
<h5><a name="bookmark77"></a><span class="font19">4.3.6 Random Number Generation</span></h5></li></ul>
<p><span class="font17">Perl comes with a built-in random number generator. The random numbers are not truly random; they’re what’s called </span><span class="font17" style="font-style:italic;">pseudo-random,</span><span class="font17"> which means they’re generated by a mechanical process that yields repeatable results. Perl typically uses the </span><span class="font2">rand</span><span class="font17">, </span><span class="font2">random</span><span class="font17">, or </span><span class="font2">drand48 </span><span class="font17">function provided by the local C library.</span></p>
<p><span class="font17">A typical random number generator function looks something like this:</span></p>
<p><span class="font2">my $seed = 1;</span></p>
<p><span class="font2">sub Rand {</span></p>
<p><span class="font2">$seed = (27*$seed+11111) &amp;&nbsp;0x7fff;</span></p>
<p><span class="font2">return $seed;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">This example has poor randomness properties. For example, its output alternates between odd and even numbers. Don’t use it in any software that needs truly random numbers.</span></p>
<p><span class="font17">The </span><span class="font2">Rand() </span><span class="font17">function takes no arguments and returns a new “random” number. The random number generator has an internal value, called the </span><span class="font17" style="font-style:italic;">seed</span><span class="font17">. Each time it is invoked, it performs a transformation on the seed, saves the new seed, and returns the new seed. Since the output for </span><span class="font2">Rand </span><span class="font17">depends only on the seed, we can think of it as generating a single sequence of numbers:</span></p>
<p><span class="font17">11138</span></p>
<p><span class="font17">16925</span></p>
<p><span class="font17">9334 985 4938 13365 11518 27185 24210 9421</span></p>
<p><span class="font17">We can see that the sequence produced by </span><span class="font2">Rand </span><span class="font17">must eventually repeat. Because the output is always an integer less than 32,768, if we call </span><span class="font2">Rand </span><span class="font17">32,769 times, two of the calls must have returned the same value, let’s say </span><span class="font17" style="font-style:italic;">v.</span><span class="font17"> This means that the seed was </span><span class="font17" style="font-style:italic;">v</span><span class="font17"> both times. But since the output of </span><span class="font2">Rand </span><span class="font17">depends only on the value of the seed, the outputs that follow the second appearance of </span><span class="font17" style="font-style:italic;">v</span><span class="font17"> must be identical to those that followed the first appearance; this shows that the sequence repeats after no more than 32,768 calls. It might, of course, repeat much sooner than that. The length of the repeated portion is called the </span><span class="font17" style="font-style:italic;">period</span><span class="font17"> of the generator. The sample random number generator shown here has a period of only 16384. Changing the </span><span class="font2">27 </span><span class="font17">to </span><span class="font2">29 </span><span class="font17">will increase the period to 32768. (The design of random number generators is a topic of some complexity. The interested reader is referred to </span><span class="font17" style="font-style:italic;">The Art of Computer Programming,</span><span class="font17"> Volume II,<a name="footnote17"></a><sup><a href="#bookmark259">17</a></sup><sup></sup> for more information about this.)</span></p>
<p><span class="font17">Since the output of the generator depends only on the seed, and the seed is initialized to 1, this random number generator will generate the same sequence of numbers, starting with 1, 11138, 16925,</span><span class="font17" style="font-style:italic;">...</span><span class="font17"> each time the program is run.</span></p>
<p><span class="font17">Sometimes this is desirable. Suppose the program crashes. You might like to rerun it under the debugger to see what went wrong. But if the program’s behavior depended on a sequence of random numbers, it will be important to be able to reproduce the same sequence of numbers, or else the debugging run may not do the same thing and may not reveal the problem.</span></p>
<p><span class="font17">Nevertheless, when you ask for random numbers, you usually want them to be different every time. For this reason, random number generators come with an auxiliary function for initializing the seed:</span></p>
<p><span class="font2">sub SRand {</span></p>
<p><span class="font2">$seed = shift;</span></p>
<p><span class="font2">}</span></p>
<ul style="list-style:none;"><li>
<p class="font15">4.3 EXAMPLES <span class="font20">155</span></p></li></ul>
<p><span class="font17">To get unpredictable random numbers, we call the </span><span class="font2">SRand() </span><span class="font17">function once, at the beginning of the program, with an argument that will vary from run to run, such as the current time or process ID number:</span></p>
<p><span class="font2">SRand(SS);</span></p>
<p><span class="font17">The random generator will start at a different place in the sequence each time the program is run. If the program saves the seed in a file, the seed can be re-used later during a debugging run to force the generator to produce the same sequence of random numbers a second time.</span></p>
<p><span class="font17">This design is very common; C libraries come with paired sets of functions called </span><span class="font2">rand </span><span class="font17">and </span><span class="font2">srand</span><span class="font17">, or </span><span class="font2">random </span><span class="font17">and </span><span class="font2">srandom</span><span class="font17">, or </span><span class="font2">drand48 </span><span class="font17">and </span><span class="font2">srand48</span><span class="font17">, which are analogous to </span><span class="font2">Rand() </span><span class="font17">and </span><span class="font2">SRand()</span><span class="font17">. The Perl built-in </span><span class="font2">rand </span><span class="font17">and </span><span class="font2">srand </span><span class="font17">functions work the same way, and are usually backed by one or another of the C function pairs.</span></p>
<p><span class="font17">This interface has several problems, however. One is that it’s not clear who has responsibility for seeding the random generator. Suppose you have the following program:</span></p>
<p><span class="font2">use CGI::Push;</span></p>
<p><span class="font2">my Sseed = shift || $$ ;</span></p>
<p><span class="font2">srand(Sseed);</span></p>
<p><span class="font2">open LOG, &quot;&gt;&nbsp;Slogfile&quot; or die ... ;</span></p>
<p><span class="font2">print LOG &quot;Random seed: Sseed</span><span class="font2" style="font-weight:bold;">\</span><span class="font2">n&quot;;</span></p>
<p><span class="font2">do_push(...);</span></p>
<p><span class="font17">Normally, the program is run with no command-line argument, and the random number generator is seeded with the process ID as usual. The seed is then saved to the debugging log. If the program fails, it can be rerun, and the same seed can be supplied as a command-line argument.</span></p>
<p><span class="font17">However, there’s a problem. The </span><span class="font2">CGI::Push </span><span class="font17">module also needs to generate random numbers, and it makes its own call to </span><span class="font2">srand </span><span class="font17">when </span><span class="font2">do_push() </span><span class="font17">is called. This will overwrite the seed that the main program wanted to use.</span></p>
<p><span class="font17">Imagine the problems this could cause. Suppose the main program had saved its seed to a file for use in a later debugging session, and then the program did indeed crash. You start the debugger, and tell the program to re-use the same seed. And it does, up until the call to </span><span class="font2">do_push</span><span class="font17">, which re-seeds the generator, using its own seeding policy, which knows nothing of your debugging strategy. After the call to </span><span class="font2">do_push</span><span class="font17">, all the random numbers produced by </span><span class="font2">rand </span><span class="font17">are unpredictable again. The more separate modules the program uses, the more likely they are</span></p>
<div>
<h4><a name="bookmark260"></a><span class="font20">156</span></h4>
</div><br clear="all">
<div>
<p><span class="font15">CHAPTER 4 Iterators</span></p>
</div><br clear="all">
<p><span class="font17">to fight over the random number seed like drunken fraternity brothers fighting over the remote control.</span></p>
<p><span class="font17">A related problem concerns the generator itself. Recall that our example generator generates a sequence of 16,384 numbers before repeating, but with careful choice of the constants, we can improve it to get the maximum possible period of 32,768. Now consider the following program:</span></p>
<p><span class="font2">use Foo;</span></p>
<p><span class="font2">while (&lt;&gt;) {</span></p>
<p><span class="font2">my Srandom = Rand();</span></p>
<p><span class="font2"># do something with Srandom</span></p>
<p><span class="font2">foo();</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">Unbeknownst to the author of this program, the </span><span class="font2">foo </span><span class="font17">function, imported from the </span><span class="font2">Foo </span><span class="font17">module, also generates a random number using </span><span class="font2">Rand</span><span class="font17">. This means that the pool of 32,768 random numbers is split between the main program and </span><span class="font2">foo</span><span class="font17">, with the main program getting the first, third, fifth, seventh random numbers, and so on, and the </span><span class="font2">foo </span><span class="font17">function getting the second, fourth, six, eighth, and so on. Since the main program is seeing only half of the pool of numbers, the period of the sequence it sees is only half as big. Whatever is done with </span><span class="font2">Srandom</span><span class="font17">, it will repeat every 16,384 lines. Even though we were at some pains to make the pool of random numbers as large as possible, our efforts were foiled, because both sources of random data were drawing from the same well of entropy.</span></p>
<p><span class="font17">The underlying problem here is that the random number generator is a single global resource, and the seed is a global variable. Global variables almost always have this kind of allocation problem. Iterators provide a solution. It’s easy to convert the </span><span class="font2">Rand </span><span class="font17">function to an iterator:</span></p>
<div>
<p><span class="font9" style="font-weight:bold;">CODE LIBRARY</span></p>
</div><br clear="all">
<p><span class="font2">sub make_rand {</span></p>
<p><span class="font0"><sup>rng</sup>-<sup>iterat</sup>°<sup>r</sup>-P<sup>l</sup> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="font2">my Sseed = shift || (time &amp;&nbsp;0x7fff);</span></p>
<p><span class="font2">return Iterator {</span></p>
<p><span class="font2">Sseed = (29*$seed+11111) &amp;&nbsp;0x7fff;</span></p>
<p><span class="font2">return Sseed;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">Calling </span><span class="font2">make_rand() </span><span class="font17">returns an iterator that generates a different random number each time it is called. The optional argument to </span><span class="font2">make_rand() </span><span class="font17">specifies the seed; if omitted, it is derived from the current time of day. Revisiting the last example:</span></p>
<p><span class="font2">use Foo;</span></p>
<p><span class="font2">my Srng = make_rand();</span></p>
<p><span class="font2">while (&lt;&gt;) {</span></p>
<p><span class="font2">my Srandom = NEXTVAL(Srng);</span></p>
<p><span class="font2"># do something with Srandom</span></p>
<p><span class="font2">foo();</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">The main program now has its own private random number generator, represented by </span><span class="font2">Srng</span><span class="font17">. This generator is not available to </span><span class="font2">foo</span><span class="font17">. </span><span class="font2">foo </span><span class="font17">can allocate its own random number generator, which is completely independent of </span><span class="font2">Srng</span><span class="font17">. Each generator is seeded separately, so there is no question about who bears responsibility for the initial seeding. Each part of the program is responsible for seeding its own generators at the time they are created.</span></p>
<p><span class="font17">If it is desirable for two parts of the program to share a generator for some reason, they can do that simply by sharing the iterator object.</span></p>
<ul style="list-style:none;"><li>
<h5><a name="bookmark78"></a><span class="font18">4.4 FILTERS AND TRANSFORMS</span></h5></li></ul>
<p><span class="font17">Because iterators are objects, we can write functions to operate on them. What might be useful? Since iterators encapsulate lists, we should expect that the same sort of functions that are useful for lists will also be useful for iterators. Two of Perl’s most useful list functions are </span><span class="font2">grep </span><span class="font17">and </span><span class="font2">map</span><span class="font17">. </span><span class="font2">grep </span><span class="font17">filters a list, returning a new list of all the elements that possess some property. </span><span class="font2">map </span><span class="font17">transforms a list, applying an operation to each element, and returning a new list. Both of these are useful operations for iterators.</span></p>
<p><span class="font17">In the diagrams that follow, iterators will be represented as follows:</span></p><img src="HigherOrderPerl_files/HigherOrderPerl-26.jpg" alt="" style="width:117pt;height:58pt;">
<p><span class="font17">The boxes represent actions, as in a regular flow chart. When an iterator is kicked, it emits a value, which is represented by the dotted line coming out of the left-hand side. Solid arrows represent the flow of control, dotted arrows the flow of data.</span></p>
<p><span class="font19">4.4.1 </span><span class="font3">imap()</span></p>
<p><span class="font17">We’ll see the iterator version of </span><span class="font2">map </span><span class="font17">first because it’s simpler:</span></p>
<p><span class="font2">sub imap {</span></p>
<p><span class="font2">my ($transform, $it) = @_;</span></p>
<p><span class="font2">return Iterator {</span></p>
<p><span class="font2">my Snext = NEXTVAL(Sit);</span></p>
<p><span class="font2">return unless defined Snext;</span></p>
<p><span class="font2">return $transform-&gt;($next);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">imap() </span><span class="font17">takes two arguments: a callback function and an iterator. It returns a new iterator whose output is the same as that of the original iterator, but with every element transformed by the callback function:</span></p>
<p><span class="font11">imap($f, $it)</span></p><img src="HigherOrderPerl_files/HigherOrderPerl-27.jpg" alt="" style="width:199pt;height:128pt;">
<p><span class="font17">For example, suppose we wanted a random number generator that behaved more like Perl’s built-in generator, returning a fraction between 0 and 1 instead of an integer between 0 and 32767. We could rewrite </span><span class="font2">make_rand()</span><span class="font17">, but there’s no need if we have </span><span class="font2">imap()</span><span class="font17">:</span></p>
<p><span class="font2">my Srng = imap(sub { $_[0] / 37268 }, make_rand());</span></p>
<p><span class="font2">make_rand() </span><span class="font17">constructs an iterator that generates a random integer, as before. We pass the iterator to </span><span class="font2">imap()</span><span class="font17">, which returns a different iterator, which is stored in </span><span class="font2">$rng</span><span class="font17">. When we invoke </span><span class="font2">$rng</span><span class="font17">, it calls the original iterator, which returns an integer; this is stored in </span><span class="font2">Snext </span><span class="font17">and passed to </span><span class="font2">Stransform</span><span class="font17">, which divides the integer by 32768 and returns the result. The first few outputs from </span><span class="font2">Srng </span><span class="font17">are:</span></p>
<p><span class="font17">0.298915960072985</span></p>
<p><span class="font17">0.174170870451862</span></p>
<p><span class="font17">0.0735751851454331</span></p>
<p><span class="font17">0.673312224965118</span></p>
<p><span class="font17">0.480626811205324</span></p>
<p><span class="font17">0.168267682730493</span></p>
<p><span class="font17">0.781635719652249</span></p>
<p><span class="font17">0.104996243425995</span></p>
<p><span class="font17">0.705269936674895</span></p>
<p><span class="font17">0.528147472362348</span></p>
<p><span class="font17">The syntax for </span><span class="font2">imap() </span><span class="font17">is a little cumbersome. Since it’s analogous to </span><span class="font2">map</span><span class="font17">, it would be nice if it had the same syntax. Fortunately, Perl allows this. The first step is to add a prototype to </span><span class="font2">imap()</span><span class="font17">:</span></p>
<p><span class="font2" style="font-weight:bold;">sub imap (&amp;$) {</span></p>
<p><span class="font2">my (Stransform, Sit) = @_;</span></p>
<p><span class="font2">return Iterator {</span></p>
<p><span class="font2">my Snext = NEXTVAL(Sit);</span></p>
<p><span class="font2">return unless defined Snext;</span></p>
<p><span class="font2">return Stransform-&gt;(Snext);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">The </span><span class="font2">(&amp;S) </span><span class="font17">tells Perl that </span><span class="font2">imap() </span><span class="font17">will get exactly two arguments, that the first will be a code reference (</span><span class="font2">&amp; </span><span class="font17">symbolizes subroutines) and the second will be a scalar (</span><span class="font2">S </span><span class="font17">symbolizes scalars). When we announce to Perl that a function’s first argument will be a code reference, the announcement triggers a change in the Perl parser to allow the word </span><span class="font2">sub </span><span class="font17">to be omitted from before the first argument and the comma to be omitted after — just as with </span><span class="font2">map </span><span class="font17">and </span><span class="font2">grep</span><span class="font17">. We can now write:</span></p>
<p><span class="font2">my Srng = imap { S_[0] / 37268 } make_rand();</span></p>
<p><span class="font17">The </span><span class="font2">S </span><span class="font17">in the prototype will ensure that </span><span class="font2">make_rand() </span><span class="font17">will be called in scalar context and will produce a single scalar result; normally, it would be called in list context and might produce many scalars.</span></p>
<p><span class="font17">The only difference between this syntax and </span><span class="font2">map</span><span class="font17">’s is that we had to use </span><span class="font2">$_[0] </span><span class="font17">in the code block instead of </span><span class="font2">$_</span><span class="font17">. If we are willing to commit more trickery, we can use </span><span class="font2">$_ </span><span class="font17">instead of </span><span class="font2">$_[0] </span><span class="font17">in the code reference, just as with </span><span class="font2">map</span><span class="font17">:</span></p>
<p><span class="font2">sub imap (&amp;$) {</span></p>
<p><span class="font2">my (Stransform, Sit) = @_; return Iterator {</span></p>
<p><span class="font2" style="font-weight:bold;">local $_ = NEXTVAL($it); return unless defined $_; return $transform-&gt;();</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">Instead of storing the output of the underlying iterator into a private </span><span class="font2">Snext </span><span class="font17">variable, we store it into </span><span class="font2">S_</span><span class="font17">. Then we needn’t pass it explicitly to </span><span class="font2">Stransform</span><span class="font17">; </span><span class="font2">Stransform </span><span class="font17">can see the value anyway, because </span><span class="font2">S_ </span><span class="font17">is global. As usual, we use </span><span class="font2">local </span><span class="font17">to save the old value of </span><span class="font2">S_ </span><span class="font17">before we overwrite it. We can now write:</span></p>
<p><span class="font2">my Srng = imap { S_ / 37268 } make_rand();</span></p>
<p><span class="font17">which has exactly the same syntax as </span><span class="font2">map</span><span class="font17">.</span></p>
<p><span class="font19">4.4.2 </span><span class="font3">igrep()</span></p>
<p><span class="font17">The trickery is the same for </span><span class="font2">igrep()</span><span class="font17">, and only the control flow is different:</span></p>
<p><span class="font2">sub igrep (&amp;S) {</span></p>
<p><span class="font2">my (Sis_interesting, Sit) = @_;</span></p>
<p><span class="font2">return Iterator {</span></p>
<p><span class="font2">local S_;</span></p>
<p><span class="font2">while (defined (S_ = NEXTVAL(Sit))) {</span></p>
<p><span class="font2">return S_ if Sis_interesting-&gt;();</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">return;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">The iterator returned by </span><span class="font2">igrep() </span><span class="font17">kicks the underlying iterator repeatedly until it starts returning </span><span class="font2">undef </span><span class="font17">(at which point </span><span class="font2">igrep() </span><span class="font17">gives up and also returns </span><span class="font2">undef</span><span class="font17">) or it returns an interesting item, as judged by the </span><span class="font2">Sis_interesting </span><span class="font17">callback (see Figure 4.3). When it finds an interesting item, it returns it.</span></p>
<ul style="list-style:none;"><li>
<p class="font15">4.4 FILTERS AND TRANSFORMS</p>
<div>
<p><span class="font20">161</span></p>
</div><br clear="all">
<div>
<p><span class="font11">igrep($f, $it)</span></p><img src="HigherOrderPerl_files/HigherOrderPerl-28.jpg" alt="" style="width:169pt;height:105pt;">
</div><br clear="all"></li></ul>
<p><span class="font11">igrep</span></p>
<p><span class="font2">. . ncAAon-^ fooo.. . </span><span class="font2" style="text-decoration:underline;">jo ?!</span></p>
<p><span class="font14" style="font-variant:small-caps;">figure 4.3 </span><span class="font2">igrep()</span><span class="font16">.</span></p>
<p><span class="font17">Now that we have </span><span class="font2">igrep()</span><span class="font17">, we no longer need </span><span class="font2">interesting_files()</span><span class="font17">, which searched a directory tree and returned the interesting files. Instead, we can get the same effect by filtering the output of </span><span class="font2">dir_walk()</span><span class="font17">:</span></p>
<ul style="list-style:none;"><li>
<p><span class="font2"># instead of &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;my Snext_octopus =</span></p></li>
<li>
<p><span class="font2"># &nbsp;&nbsp;&nbsp;interesting_files(</span><span class="font2" style="font-weight:bold;">\</span><span class="font2">&amp;contains_octopuses, 'uploads', 'downloads');</span></p></li></ul>
<p><span class="font2">my Snext_octopus = igrep { contains_octopuses(S_) } dir_walk('uploads', 'downloads');</span></p>
<p><span class="font2">while (Sfile = NEXTVAL($next_octopus)) {</span></p>
<p><span class="font2"># do something with the file</span></p>
<p><span class="font2">}</span></p>
<p><span class="font19">4.4.3 </span><span class="font3">list_iterator()</span></p>
<p><span class="font17">Sometimes it’s convenient to have a way to turn a list into an iterator:</span></p>
<p><span class="font2">sub list_iterator { my @items = @_;</span></p>
<p><span class="font2">return Iterator {</span></p>
<p><span class="font2">return shift @items;</span></p>
<p><span class="font2">};</span></p>
<p><span class="font2">}</span></p><img src="HigherOrderPerl_files/HigherOrderPerl-29.jpg" alt="" style="width:237pt;height:295pt;">
<p><span class="font14" style="font-variant:small-caps;">figure 4.4 </span><span class="font2">append()</span><span class="font16">.</span></p>
<p><span class="font2">list_iterator('fish', 'dog', 'carrot') </span><span class="font17">produces an iterator that generates </span><span class="font2">'fish'</span><span class="font17">, then </span><span class="font2">'dog'</span><span class="font17">, then </span><span class="font2">'carrot'</span><span class="font17">, and then an infinite sequence of undefined values.</span></p>
<p><span class="font19">4.4.4 </span><span class="font3">append()</span></p>
<p><span class="font2">map </span><span class="font17">and </span><span class="font2">grep </span><span class="font17">aren’t the only important operations on lists. Some of the most important operations don’t even have names, because they’re so common. One of these is the </span><span class="font2">append() </span><span class="font17">operation (see Figure 4.4), which attaches two or more lists together head-to-tail to yield a single list.</span></p>
<p><span class="font2">sub append { my @its = @_;</span></p>
<p><span class="font2">return Iterator {</span></p>
<p><span class="font2">while (@its) { my $val = NEXTVAL($its[0]);</span></p>
<p><span class="font2">return $val if defined $val;</span></p>
<p><span class="font2">shift @its; # Discard exhausted iterator }</span></p>
<p><span class="font2">return;</span></p>
<p><span class="font2">};</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">We call </span><span class="font2">append() </span><span class="font17">with zero or more iterators as arguments. It returns a new iterator that produces all the items from the first iterator, followed by all the items from the second iterator, and so on. For example, </span><span class="font2">append(upto(1,3), upto(5,8), upto(9,11)) </span><span class="font17">returns an iterator that yields the values 1, 2, 3, 5, 6, 7, 8, 9, 10, 11 in order, and undefined values thereafter.</span></p>
<p><span class="font17">The </span><span class="font2">while </span><span class="font17">loop invokes the first iterator in the argument list; if it yields an undefined value, the first iterator is exhausted, so it is discarded (by the </span><span class="font2">shift</span><span class="font17">) and the next argument is tried. This continues until a nonempty iterator is found or the argument list is itself exhausted. Then the loop exits and the iterator returns the value from the nonempty iterator, if there was one, or </span><span class="font2">undef </span><span class="font17">if not.</span></p>
<ul style="list-style:none;"><li>
<h5><a name="bookmark83"></a><span class="font18">4.5 THE SEMIPREDICATE PROBLEM</span></h5></li></ul>
<p><span class="font17">So far, our iterators have all indicated exhaustion by returning the undefined value. For the examples we’ve seen, this is perfectly adequate. An undefined value can never be confused with any number, any file path, any permutation of a list, or any string. But in general, an iterator might generate data that includes the undefined value. For example, consider an iterator whose job is to generate values from certain columns of a SQL database. SQL databases have a special </span><span class="font2">NULL </span><span class="font17">value that is different from every number and every string. It’s natural to represent this </span><span class="font2">NULL </span><span class="font17">value in Perl with </span><span class="font2">undef</span><span class="font17">, and in fact the Perl </span><span class="font2">DBI </span><span class="font17">module does this. But if the database field can potentially contain any string value or </span><span class="font2">NULL</span><span class="font17">, then the iterator cannot use </span><span class="font2">undef </span><span class="font17">to indicate end-of-data as well as </span><span class="font2">NULL</span><span class="font17">.</span></p>
<p><span class="font17">Most of our iterator utility functions, such as </span><span class="font2">imap()</span><span class="font17">, will become confused if the iterator generates </span><span class="font2">undef </span><span class="font17">as a valid data value. If the iterator returns </span><span class="font2">undef </span><span class="font17">to indicate that the database contained </span><span class="font2">NULL</span><span class="font17">, the utility function will erroneously conclude that the iterator has been exhausted.</span></p>
<p><span class="font17">You may recall from Chapter 3 that this is called the </span><span class="font17" style="font-style:italic;">semipredicate problem. </span><span class="font17">Our iterators are semipredicates because they return </span><span class="font2">undef </span><span class="font17">to indicate exhaustion, and a data value otherwise. The difficulty occurs when we need </span><span class="font2">undef </span><span class="font17">to sometimes be understood as a data value instead of as a flag indicating exhaustion.</span></p>
<p><span class="font20">164 </span><span class="font15">CHAPTER 4 Iterators</span></p>
<ul style="list-style:none;"><li>
<h5><a name="bookmark84"></a><span class="font19">4.5.1 Avoiding the Problem</span></h5></li></ul>
<p><span class="font17">There are several ways around this. One is simply to declare that no iterator is ever allowed to return an undefined value; if </span><span class="font2">undef </span><span class="font17">is a legal return, the iterator must be restructured to return its data in some other format. Suppose we have an iterator that might return any scalar value, including </span><span class="font2">undef</span><span class="font17">:</span></p>
<p><span class="font2">sub make_iterator {</span></p>
<p><span class="font2">return Iterator {</span></p>
<p><span class="font2">my $return_value;</span></p>
<p><span class="font2">■ ■■</span></p>
<p><span class="font2">if </span><span class="font2" style="font-style:italic;">(exhausted</span><span class="font2">) {</span></p>
<p><span class="font2">return;</span></p>
<p><span class="font2">} else {</span></p>
<p><span class="font2">return $return_value;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">This won’t work because the caller will not be able to distinguish an iterator returning </span><span class="font2">undef </span><span class="font17">to indicate exhaustion from one that happens to be returning an undefined value of </span><span class="font2">$return_value</span><span class="font17">. We can restructure this iterator to be unambiguous:</span></p>
<p><span class="font2"># array reference version</span></p>
<p><span class="font2">sub make_iterator {</span></p>
<p><span class="font2">■■■</span></p>
<p><span class="font2">return Iterator {</span></p>
<p><span class="font2">my $return_value;</span></p>
<p><span class="font2">■■■</span></p>
<p><span class="font2">if </span><span class="font2" style="font-style:italic;">(exhausted</span><span class="font2">) {</span></p>
<p><span class="font2">return;</span></p>
<p><span class="font2">} else {</span></p>
<p><span class="font2" style="font-weight:bold;">return [$return_value];</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">The iterator now always returns an array reference, except that it returns </span><span class="font2">undef </span><span class="font17">when it is exhausted. When </span><span class="font2">$return_value </span><span class="font17">is undefined, the iterator returns </span><span class="font2">[undef]</span><span class="font17">, which is easily distinguished from </span><span class="font2">undef </span><span class="font17">because it </span><span class="font17" style="font-style:italic;">is</span><span class="font17"> defined. In fact, the caller doesn’t even need to use </span><span class="font2">defined</span><span class="font17">, because the exhaustion indicator is false, while all other possible returns, including </span><span class="font2">[undef]</span><span class="font17">, are true.</span></p>
<ul style="list-style:none;"><li>
<p class="font15">4.5 THE S E MI P RE D I C AT E PROBLEM <span class="font20">165</span></p></li></ul>
<p><span class="font17">Often this simple solution imposes no extra costs. The Perl </span><span class="font2">DBI </span><span class="font17">module uses this strategy in some cases. The </span><span class="font2">$sth-&gt;fetchrow_arrayref </span><span class="font17">method returns a row of data from the result of a database query using an undefined return to indicate that there are no more rows available.</span></p>
<p><span class="font17">Each row may contain undefined values, which represent the database’s </span><span class="font2">NULL </span><span class="font17">entries, and if a row contains only one field, it may be a single </span><span class="font2">NULL</span><span class="font17">. But </span><span class="font2">fetchrow_arrayref </span><span class="font17">always returns the row data as an array reference, so a row with a single </span><span class="font2">NULL </span><span class="font17">is easily distinguished from the </span><span class="font2">undef </span><span class="font17">that indicates that no more rows are available:</span></p>
<p><span class="font2">while (my $row = $sth-&gt;fetchrow_arrayref) {</span></p>
<ul style="list-style:none;"><li>
<p><span class="font2"># do something with this $row</span></p></li></ul>
<p><span class="font2">}</span></p>
<ul style="list-style:none;"><li>
<p><span class="font2"># no more rows</span></p></li></ul>
<p><span class="font17">A related solution is to require that the iterator be used only in list context:</span></p>
<ul style="list-style:none;"><li>
<p><span class="font2"># list-context-only version sub make_iterator {</span></p></li></ul>
<p><span class="font2">...</span></p>
<p><span class="font2">return Iterator {</span></p>
<p><span class="font2">my $return_value;</span></p>
<p><span class="font2">...</span></p>
<p><span class="font2">if </span><span class="font2" style="font-style:italic;">(exhausted</span><span class="font2">) {</span></p>
<p><span class="font2" style="font-weight:bold;">return ();</span></p>
<p><span class="font2">} else {</span></p>
<p><span class="font2">return $return_value;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">Now a successful call to the iterator </span><span class="font17" style="font-style:italic;">always</span><span class="font17"> returns a value, and when the iterator is exhausted it stops returning values. We can use it like this:</span></p>
<p><span class="font2">while (($val) = NEXTVAL($iterator)) {</span></p>
<ul style="list-style:none;"><li>
<p><span class="font2"># do something with $val</span></p></li></ul>
<p><span class="font2">}</span></p>
<ul style="list-style:none;"><li>
<p><span class="font2"># iterator is exhausted</span></p></li></ul>
<p><span class="font17">The value of a list assignment when used as the condition of a </span><span class="font2">while </span><span class="font17">or </span><span class="font2">if </span><span class="font17">statement is the number of values returned on the right-hand side of the assignment. Even if the iterator returns a list such as </span><span class="font2">(undef) </span><span class="font17">or </span><span class="font2">(0)</span><span class="font17">, the condition tested by </span><span class="font2">while </span><span class="font17">will be 1, which is true. When the iterator is exhausted, it will return an empty list, the condition will evaluate to 0, and the loop will exit.</span></p>
<ul style="list-style:none;"><li>
<h5><a name="bookmark85"></a><span class="font19">4.5.2 Alternative </span><span class="font3">undef</span><span class="font19">s</span></h5></li></ul>
<p><span class="font17">Sometimes we don’t want to avoid the semipredicate problem by returning lists or arrayrefs, or we can’t. For </span><span class="font2">DBI</span><span class="font17">, the technique is natural, because the data in a row of a database is naturally represented as an array. But if our iterator returns only single scalars, it may be inconvenient to wrap up every value as an array reference just to unwrap it again in the caller. There are several strategies for dealing with the problem instead of avoiding it this way.</span></p>
<p><span class="font17">The first strategy is that when we construct the iterator, we could supply a special value that we know will never be returned normally. This value could be captured in the iterator, something like this:</span></p>
<p><span class="font2">sub make_iterator {</span></p>
<p><span class="font2">my (..., $final_value, ...) = @_;</span></p>
<p><span class="font2">return Iterator {</span></p>
<p><span class="font2">■ ■■</span></p>
<p><span class="font2">if </span><span class="font2" style="font-style:italic;">(exhausted)</span><span class="font2"> { return $final_value }</span></p>
<p><span class="font2">■■■</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">However, this would be annoying, since we’d have to inform functions like </span><span class="font2">imap() </span><span class="font17">what the special final value was for each iterator they needed to process. It’s possible to construct a single value that will work for every iterator in the entire program, so that the iterators and the functions that use them can all assume it.</span></p>
<p><span class="font17">To construct such a value, we use a trick borrowed from the C language. In C, many functions return pointers; for example, the memory allocator (</span><span class="font2">malloc</span><span class="font17">) returns a pointer to a block of unused memory, and the </span><span class="font2">fopen </span><span class="font17">function returns a pointer to C’s version of a filehandle object. C has a special pointer value, called the </span><span class="font17" style="font-style:italic;">null pointer,</span><span class="font17"> which these functions return when there is an error. The null pointer’s only useful property is that it compares unequal to any valid pointer.</span></p>
<p><span class="font17">Occasionally a C programmer wants to write a function that can return pointers, and indicate two sorts of errors with two different special values. The null pointer will serve for one of these two, but what will be the other one? In C there’s an easy solution: use </span><span class="font2">malloc </span><span class="font17">to allocate a byte and return a</span></p>
<ul style="list-style:none;"><li>
<p class="font15">4.5 THE SEMIPREDICATE PROBLEM</p>
<div>
<p><span class="font20">167</span></p>
</div><br clear="all"></li></ul>
<p><span class="font17">pointer to it; this will serve as the alternative special value. No other valid pointer will ever point to that address, because </span><span class="font2">malloc </span><span class="font17">has reserved it.</span></p>
<p><span class="font17">We can do an analogous thing in Perl. We will invent a new value that can’t possibly be confused with any legal data value, including </span><span class="font2">undef</span><span class="font17">. We will use this “alternative undef” in place of the real </span><span class="font2">undef</span><span class="font17">. How can we do that? It’s simple:</span></p>
<p><span class="font2">SEXHAUSTED = [];</span></p>
<p><span class="font2">$EXHAUSTED </span><span class="font17">is now guaranteed to be distinct from any other value our program will ever generate. If a value is not an arrayref, we can distinguish it from </span><span class="font2">SEXHAUSTED</span><span class="font17">, which is an arrayref. If a value is an arrayref, then it must refer to a different array than </span><span class="font2">SEXHAUSTED </span><span class="font17">does, unless it was copied from </span><span class="font2">SEXHAUSTED </span><span class="font17">itself. That is,</span></p>
<p><span class="font2" style="font-weight:bold;">\</span><span class="font2">@a == SEXHAUSTED</span></p>
<p><span class="font17">is guaranteed to be false for all arrays </span><span class="font2">@a</span><span class="font17">. Similarly, </span><span class="font2">[...] == SEXHAUSTED </span><span class="font17">is guaranteed to be false, because </span><span class="font2">[...] </span><span class="font17">generates a new, fresh array, which is different from the one in </span><span class="font2">SEXHAUSTED</span><span class="font17">.</span></p>
<p><span class="font17">We can now write functions, analogous to </span><span class="font2">undef </span><span class="font17">and </span><span class="font2">defined</span><span class="font17">, to generate and detect special values:</span></p>
<p><span class="font2">{ my SEXHAUSTED = [];</span></p>
<ul style="list-style:none;"><li>
<p><span class="font2"># like 'undef()'</span></p></li></ul>
<p><span class="font2">sub special () { return SEXHAUSTED }</span></p>
<ul style="list-style:none;"><li>
<p><span class="font2"># like 'not defined()' sub is_special (S) {</span></p></li></ul>
<p><span class="font2">my Sarg = shift; ref(Sarg) &amp;&amp;&nbsp;Sarg == SEXHAUSTED;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">Having done this, we can build an iterator that uses </span><span class="font2">SEXHAUSTED </span><span class="font17">to indicate end-of-data:</span></p>
<p><span class="font2">sub dbi_query_iterator { my (Ssth, @params) = @_;</span></p>
<p><span class="font2">$sth-&gt;execute(@params) or return ;</span></p>
<p><span class="font2">return Iterator {</span></p>
<p><span class="font2">my $row;</span></p>
<p><span class="font2">if ($sth &amp;&amp;&nbsp;$row = $sth-&gt;fetchrow_arrayref()) { return $row-&gt;[0];</span></p>
<p><span class="font2">} else { # exhausted</span></p>
<p><span class="font2">undef $sth;</span></p>
<p><span class="font2">return special();</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">$sth </span><span class="font17">is a Perl </span><span class="font2">DBI </span><span class="font17">object that represents a SQL statement. </span><span class="font2">dbi_query_iterator() </span><span class="font17">takes this object and yields an iterator that will produce the results of the query, one at a time. It asks the database to execute the query by calling </span><span class="font2">$sth-&gt;execute</span><span class="font17">; if this fails it returns failure. Otherwise, the iterator uses the </span><span class="font2">DBI </span><span class="font17">method </span><span class="font2">fetchrow_arrayref </span><span class="font17">to fetch the next row of data from the database; it extracts the first item from the row, if there was one, and returns it. This item might be </span><span class="font2">undef</span><span class="font17">, which indicates a </span><span class="font2">NULL </span><span class="font17">database value.</span></p>
<p><span class="font17">When there are no more rows, </span><span class="font2">fetchrow_arrayref </span><span class="font17">returns </span><span class="font2">undef</span><span class="font17">. The iterator discards the private copy of </span><span class="font2">$sth </span><span class="font17">and returns the special value. Since the special value is distinguishable from any other scalar value, the caller receives an unambiguous indication that no more data is forthcoming. On future calls, the iterator continues to return the special value.</span></p>
<p><span class="font17">The caller can use the iterator this way:</span></p>
<p><span class="font2">until (is_special(my $value = NEXTVAL($iterator))) {</span></p>
<ul style="list-style:none;"><li>
<p><span class="font2"># do something with $value</span></p></li></ul>
<p><span class="font2">}</span></p>
<p><span class="font2"># no more data</span></p>
<p><span class="font17">It might seem that we could simplify the definition of </span><span class="font2">is_special() </span><span class="font17">by eliminating the test for </span><span class="font2">ref($arg)</span><span class="font17">:</span></p>
<ul style="list-style:none;"><li>
<p><span class="font2"># MIGHT NOT ALWAYS WORK</span></p></li></ul>
<p><span class="font2">sub is_special {</span></p>
<p><span class="font2">my $arg = shift;</span></p>
<p><span class="font2" style="font-weight:bold;">$arg == $EXHAUSTED;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">But this isn’t so. If </span><span class="font2">$arg </span><span class="font17">were an integer, and we were very unlucky, the test might yield true! Comparing an integer to a reference with </span><span class="font2">== </span><span class="font17">actually compares the integer to the machine address at which the referenced data is stored, and these two numbers might match. Similarly, using plain </span><span class="font2">eq </span><span class="font17">without the additional </span><span class="font2">ref </span><span class="font17">test wouldn’t be enough, because </span><span class="font2">Sarg </span><span class="font17">might happen to be the string </span><span class="font2">ARRAY(0x436c1d) </span><span class="font17">and might happen to match the stringized version of the reference exactly. So we need to check </span><span class="font2">Sarg </span><span class="font17">for referencehood before using </span><span class="font2">== </span><span class="font17">or </span><span class="font2">eq</span><span class="font17">. This kind of failure is extremely unlikely, but if it </span><span class="font17" style="font-style:italic;">did</span><span class="font17"> happen it could be very difficult to reproduce, and it might take us weeks to track down the problem, so it’s better to be on the safe side.</span></p>
<ul style="list-style:none;"><li>
<h5><a name="bookmark86"></a><span class="font19">4.5.3 Rewriting Utilities</span></h5></li></ul>
<p><span class="font17">If we switch from using an undefined value to using a special value, it looks like all the code that uses iterators, including functions like </span><span class="font2">imap()</span><span class="font17">, will have to be rewritten, because we’ve changed the interface specification. For example, </span><span class="font2">imap() </span><span class="font17">becomes:</span></p>
<p><span class="font2">sub special_imap {</span></p>
<p><span class="font2">my (Stransform, Sit) = @_;</span></p>
<p><span class="font2">return Iterator {</span></p>
<p><span class="font2">my Snext = NEXTVAL(Sit);</span></p>
<p><span class="font2" style="font-weight:bold;">return special() if is_special($next);</span></p>
<p><span class="font2">return Stransform-&gt;(Snext);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">It might seem that we need to pick an interface and then stick with it, but we don’t necessarily. Suppose we write all our utilities to use the special-value interface; our </span><span class="font2">imap() </span><span class="font17">is actually the </span><span class="font2">special_imap() </span><span class="font17">above.</span></p>
<p><span class="font17">Now we want to use some iterator, say </span><span class="font2">Suit</span><span class="font17">, that uses the </span><span class="font2">undef </span><span class="font17">convention instead of the special-value convention. Do we have to re-implement </span><span class="font2">imap() </span><span class="font17">and our other utilities to deal with the new </span><span class="font2">undef </span><span class="font17">iterators? No, we don’t:</span></p>
<p><span class="font2">sub undef_to_special {</span></p>
<p><span class="font2">my Sit = shift;</span></p>
<p><span class="font2">return Iterator {</span></p>
<p><span class="font2">my Sval = NEXTVAL(Sit);</span></p>
<p><span class="font2">return defined(Sval) ? Sval : special() ;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">We can’t pass </span><span class="font2">Suit </span><span class="font17">directly to </span><span class="font2">imap()</span><span class="font17">, but we can pass </span><span class="font2">undef_to_special(Suit) </span><span class="font17">instead, and it will do what we want. </span><span class="font2">undef_to_special() </span><span class="font17">takes an </span><span class="font2">undef</span><span class="font17">-style</span></p>
<div>
<h4><a name="bookmark261"></a><span class="font20">170</span></h4>
</div><br clear="all">
<div>
<p><span class="font15">CHAPTER 4 Iterators</span></p>
</div><br clear="all">
<p><span class="font17">iterator and turns it into a special-value-style iterator. It is like a mask that an iterator can wear to pretend that its interface is something else. Any </span><span class="font2">undef</span><span class="font17">-style iterator can put on the </span><span class="font2">undef_to_special() </span><span class="font17">mask and pretend to be an special-value-style iterator.</span></p>
<p><span class="font17">We could also write a similar </span><span class="font2">special_to_undef() </span><span class="font17">mask function to convert the other way. Of course, it wouldn’t work correctly on iterators that might return undefined values.</span></p>
<ul style="list-style:none;"><li>
<h5><a name="bookmark87"></a><span class="font19">4.5.4 Iterators That Return Multiple Values</span></h5></li></ul>
<p><span class="font17">The “special value” solution to the semipredicate problem works adequately, but has the disadvantage that the </span><span class="font2">special() </span><span class="font17">and </span><span class="font2">is_special() </span><span class="font17">functions may have to be exported everywhere in the program. (And also the possible disadvantage that it may be peculiar.) Since functions in Perl can return multiple values, and an iterator is just a function, a more straightforward solution may be to have the iterator return two values at a time; the second value will indicate whether the iterator is exhausted:</span></p>
<p><span class="font2">sub dbi_query_iterator {</span></p>
<p><span class="font2">my (Ssth, @params) = @_;</span></p>
<p><span class="font2">Ssth-&gt;execute(@params) or return ;</span></p>
<p><span class="font2">return Iterator {</span></p>
<p><span class="font2">my Srow;</span></p>
<p><span class="font2">if (Ssth &amp;&amp;&nbsp;Srow = Ssth-&gt;fetchrow_arrayref()) {</span></p>
<p><span class="font2" style="font-weight:bold;">return ($row-&gt;[0], 1);</span></p>
<p><span class="font2">} else { # exhausted</span></p>
<p><span class="font2">if (Ssth) { Ssth-&gt;finish; undef Ssth; }</span></p>
<p><span class="font2" style="font-weight:bold;">return (undef, 0);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">To use this, the caller writes something like:</span></p>
<p><span class="font2">while (my (Sval, Scontinue) = NEXTVAL(Siterator)) { last unless Scontinue;</span></p>
<p><span class="font2"># do something with Sval...</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2"># now it is empty</span></p>
<ul style="list-style:none;"><li>
<p class="font15">4.5 THE SEMIPREDICATE PROBLEM</p>
<div>
<p><span class="font20">171</span></p>
</div><br clear="all"></li></ul>
<ul style="list-style:none;"><li>
<h5><a name="bookmark88"></a><span class="font19">4.5.5 Explicit Exhaustion Function</span></h5></li></ul>
<p><span class="font17">The iterator knows when it is exhausted, and it will tell us if we ask it. But we haven’t provided any way to do that; all we can do is ask it for the next value with the </span><span class="font2">NEXTVAL </span><span class="font17">operator. We would like to be able to ask the iterator two types of questions: “Are you empty?” and if not, “Since you’re not empty, what is the next item?” There’s an obvious hook to hang this expansion on: Since the iterator is simply a function, we will pass it an argument to tell it which question we want answered. To preserve compatibility (and to optimize the common case) we’ll leave the iterator’s behavior the same when it is called without arguments; calling it with no arguments will continue to ask an iterator to return its next value. But we’ll add new semantics: if we pass the iterator the string </span><span class="font2">&quot;exhausted?&quot;</span><span class="font17">, it will return a true or false value indicating whether or not it is empty. With this new functionality added, our </span><span class="font2">dbi_query_iterator() </span><span class="font17">becomes:</span></p>
<p><span class="font2">sub dbi_query_iterator { my ($sth, @params) = @_; $sth-&gt;execute(@params) or return ;</span></p>
<p><span class="font2" style="font-weight:bold;">my Srow = Ssth-&gt;fetchrow_arrayref();</span></p>
<p><span class="font2">return Iterator {</span></p>
<p><span class="font2" style="font-weight:bold;">my Saction = shift() || 'nextval';</span></p>
<p><span class="font2" style="font-weight:bold;">if (Saction eq 'exhausted?') { return ! defined Srow;</span></p>
<p><span class="font2" style="font-weight:bold;">} elsif (Saction eq 'nextval') { my Soldrow = Srow;</span></p>
<p><span class="font2" style="font-weight:bold;">Srow = Ssth-&gt;fetchrow_arrayref; return Soldrow-&gt;[0];</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">The iterator now returns </span><span class="font2">undef </span><span class="font17">either when the rows are exhausted or when the value in the row happens to be </span><span class="font2">NULL</span><span class="font17">, and the caller can’t tell which. But that doesn’t matter, because the caller of this iterator isn’t looking for </span><span class="font2">undef </span><span class="font17">to know when to stop reading the iterator. Instead, the caller is doing this:</span></p>
<p><span class="font2">until ($iterator-&gt;('exhausted?')) { my $val = NEXTVAL($iterator);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2"># now it is empty</span></p>
<div>
<p><span class="font20">172</span></p>
</div><br clear="all">
<p><span class="font15">CHAPTER 4 Iterators</span></p>
<h6><a name="bookmark262"></a><span class="font17">We can provide syntactic sugar for </span><span class="font2">'exhausted?' </span><span class="font17">that is analogous to </span><span class="font2">NEXTVAL</span><span class="font17">:</span></h6>
<p><span class="font2">sub EXHAUSTED {</span></p>
<p><span class="font2">S_[0]-&gt;('exhausted?');</span></p>
<p><span class="font2">}</span></p>
<h6><a name="bookmark263"></a><span class="font17">This loop then becomes:</span></h6>
<p><span class="font2">until (EXHAUSTED(Siterator)) {</span></p>
<p><span class="font2">my Sval = NEXTVAL(Siterator);</span></p>
<p><span class="font2">...</span></p>
<p><span class="font2">}</span></p>
<ul style="list-style:none;"><li>
<p><span class="font2"># now it is empty</span></p></li></ul>
<h6><a name="bookmark264"></a><span class="font17">Or, if you don’t like </span><span class="font2">until</span><span class="font17">, we could define the obvious </span><span class="font2">MORE </span><span class="font17">function, and write:</span></h6>
<p><span class="font2">while (MORE(Siterator)) {</span></p>
<p><span class="font2">my Sval = NEXTVAL(Siterator);</span></p>
<p><span class="font2">...</span></p>
<p><span class="font2">}</span></p>
<ul style="list-style:none;"><li>
<p><span class="font2"># now it is empty</span></p></li></ul>
<h6><a name="bookmark265"></a><span class="font17">A mask function allows iterators in the old, </span><span class="font2">undef</span><span class="font17">-returning style to support </span><span class="font2">EXHAUSTED </span><span class="font17">queries:</span></h6>
<p><span class="font2">sub undef_to_exhausted {</span></p>
<p><span class="font2">my Sit = shift;</span></p>
<p><span class="font2">my Sval = NEXTVAL(Sit);</span></p>
<p><span class="font2">return Iterator {</span></p>
<p><span class="font2">my Saction = shift || 'nextval';</span></p>
<p><span class="font2">if (Saction eq 'nextval') {</span></p>
<p><span class="font2">my Soldval = Sval;</span></p>
<p><span class="font2">Sval = NEXTVAL(Sit);</span></p>
<p><span class="font2">return Soldval;</span></p>
<p><span class="font2">} elsif (Saction eq 'exhausted?') { return not defined Sval;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">If our versions of utilities such as </span><span class="font2">imap() </span><span class="font17">are set up to support the </span><span class="font2">NEXTVAL</span><span class="font17">/ </span><span class="font2">EXHAUSTED </span><span class="font17">interface, we can still use the old-style iterators with them, by wrapping them in an </span><span class="font2">undef_to_exhausted() </span><span class="font17">mask. Similarly, the utilities produce</span></p>
<ul style="list-style:none;"><li>
<p class="font15">4.5 THE SEMIPREDICATE PROBLEM</p>
<div>
<p><span class="font20">173</span></p>
</div><br clear="all"></li></ul>
<p><span class="font17">iterators with the </span><span class="font2">NEXTVAL</span><span class="font17">/</span><span class="font2">EXHAUSTED </span><span class="font17">interface, so if we want to use one in the old </span><span class="font2">undef </span><span class="font17">style (and we know that’s safe) we can build a mask function that goes the other way:</span></p>
<p><span class="font2">sub exhausted_to_undef { my $it = shift;</span></p>
<p><span class="font2">return Iterator {</span></p>
<p><span class="font2">if (EXHAUSTED($it)) { return }</span></p>
<p><span class="font2">else &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ return NEXTVAL($it) }</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">It’s better if all our iterators conform to the same interface style, of course, but the mask functions show that they don’t have to, and that if we make the wrong choice early on and have to switch to a different system later on, we can do that, or if we want to use the simple style for most iterators and save the more complicated two-operation interface for a few cases, we can do that also.</span></p>
<p><span class="font17">Interfacing different sorts of iterators is something we’ve also been doing implicitly through the entire chapter. In Section 4.3 we saw </span><span class="font2">filehandle_ iterator()</span><span class="font17">, which is essentially a mask function: it converts one kind of iterator (a filehandle) into another (our synthetic, function-based iterators). If we needed to, we could go in the other direction and write a mask function that would wrap up one of our iterators as a filehandle, using Perl’s tied filehandle interface. We will see how to do this in Section 4.6.3.</span></p>
<p><span class="font17">Similarly, the various versions of </span><span class="font2">dbi_query_iterator() </span><span class="font17">were also mask functions, converting from </span><span class="font2">DBI</span><span class="font17">’s statement handles to function-based iterators. We could go in the other direction here if we had to, probably by building an object class that obeyed the DBI statement handle interface, but implementing our own versions of </span><span class="font2">-&gt;fetchrow_arrayref </span><span class="font17">and the like.</span></p>
<ul style="list-style:none;"><li>
<h5><a name="bookmark89"></a><span class="font19">4.5.6 Four-Operation Iterators</span></h5></li></ul>
<p><span class="font17">As long as we’re on the topic of iterators that support two kinds of queries (one for exhaustion and one for the next value), we might as well see this idea in its full generality. The C-style </span><span class="font2">for </span><span class="font17">loop has a very general model of iteration:</span></p>
<p><span class="font2">for </span><span class="font2" style="font-style:italic;">(initialize; test; update)</span><span class="font2"> {</span></p>
<p><span class="font2" style="font-style:italic;">action;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">Occasionally you may need an equally general iterator:</span></p>
<p><span class="font2">for (Sit-&gt;('start'); not Sit-&gt;('exhausted?'); Sit-&gt;('next')) { # do something with $it-&gt;('value');</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">exhausted? </span><span class="font17">here is as in the previous section. The </span><span class="font2">next </span><span class="font17">operation doesn’t return anything; it just tells the iterator to forget the current value and to get ready to deliver the next value. </span><span class="font2">value </span><span class="font17">tells the iterator to return the current value; if we make two calls to </span><span class="font2">Sit-&gt;('value') </span><span class="font17">without </span><span class="font2">Sit-&gt;('next') </span><span class="font17">in between, we’ll get the same value both times.</span></p>
<p><span class="font2">start </span><span class="font17">initializes the iterator. An explicit </span><span class="font2">start </span><span class="font17">call simplifies the code in some of the iterators we’ve seen already. For example, </span><span class="font2">dbi_query_iterator() </span><span class="font17">had to do </span><span class="font2">fetchrow_arrayref() </span><span class="font17">in two places, once to initialize itself, and once after every </span><span class="font2">NEXTVAL</span><span class="font17">:</span></p>
<p><span class="font2">sub dbi_query_iterator { my (Ssth, @params) = @_; Ssth-&gt;execute(@params) or return;</span></p>
<p><span class="font2">my Srow = Ssth-&gt;fetchrow_arrayref(); return Iterator {</span></p>
<p><span class="font2">my Saction = shift() || 'nextval'; if (Saction eq 'exhausted?') { return ! defined Srow;</span></p>
<p><span class="font2">} elsif (Saction eq 'nextval') { my Soldrow = Srow;</span></p>
<p><span class="font2">Srow = Ssth-&gt;fetchrow_arrayref; return Soldrow;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">Here’s the four-operation version of the same function. Although it does more, the code is almost the same length:</span></p>
<p><span class="font2">sub dbi_query_iterator { my (Ssth, @params) = @_; Ssth-&gt;execute(@params) or return ;</span></p>
<p><span class="font2" style="font-weight:bold;">my Srow;</span></p>
<p><span class="font2">return Iterator {</span></p>
<p><span class="font2" style="font-weight:bold;">my Saction = shift();</span></p>
<p><span class="font2">if (Saction eq 'exhausted?') { return ! defined Srow;</span></p>
<p><span class="font2" style="font-weight:bold;">} elsif (Saction eq 'value') {</span></p>
<p><span class="font2" style="font-weight:bold;">return Srow;</span></p>
<p><span class="font2" style="font-weight:bold;">} elsif (Saction eq 'next' </span><span class="font2">|| </span><span class="font2" style="font-weight:bold;">Saction eq 'start'){ Srow = Ssth-&gt;fetchrow_arrayref;</span></p>
<p><span class="font2" style="font-weight:bold;">} else {</span></p>
<p><span class="font2" style="font-weight:bold;">die &quot;Unknown iterator operation 'Saction'&quot;;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">We can still support the old </span><span class="font2">NEXTVAL </span><span class="font17">operation if we want to:</span></p>
<p><span class="font2">sub dbi_query_iterator {</span></p>
<p><span class="font2">my (Ssth, @params) = @_;</span></p>
<p><span class="font2">Ssth-&gt;execute(@params) or return ;</span></p>
<p><span class="font2">my Srow;</span></p>
<p><span class="font2">return Iterator {</span></p>
<p><span class="font2" style="font-weight:bold;">my Saction = shift() </span><span class="font2">|| </span><span class="font2" style="font-weight:bold;">'nextval';</span></p>
<p><span class="font2">if (Saction eq 'exhausted?') {</span></p>
<p><span class="font2">return ! defined Srow;</span></p>
<p><span class="font2">} elsif (Saction eq 'value') {</span></p>
<p><span class="font2">return Srow;</span></p>
<p><span class="font2">} elsif (Saction eq 'next'|| Saction eq 'start'</span></p>
<p><span class="font2">|| </span><span class="font2" style="font-weight:bold;">Saction eq 'nextval') {</span></p>
<p><span class="font2" style="font-weight:bold;">return Srow = Ssth-&gt;fetchrow_arrayref;</span></p>
<p><span class="font2">} else {</span></p>
<p><span class="font2">die &quot;Unknown iterator operation 'Saction'&quot;;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">Here calling </span><span class="font2">start </span><span class="font17">twice has a possibly surprising effect: </span><span class="font2">start </span><span class="font17">and </span><span class="font2">next </span><span class="font17">are identical! Sometimes it’s useful to have </span><span class="font2">start </span><span class="font17">mean that the iterator should start over at the beginning, forcing it to go back to the beginning of its notional list. The cost of this is that the iterator has to remember a list of all the values it has ever produced, in case someone tells it to start over. It also complicates the programming. While this is occasionally useful enough to be worth the extra costs, it’s usually simpler to declare that calling </span><span class="font2">start </span><span class="font17">twice on the same iterator is erroneous.</span></p>
<p><span class="font20">176 </span><span class="font15">CHAPTER 4 Iterators</span></p>
<ul style="list-style:none;"><li>
<h5><a name="bookmark90"></a><span class="font19">4.5.7 Iterator Methods</span></h5></li></ul>
<p><span class="font17">People can be funny about syntax, and Perl programmers are even more obsessed with syntax than most people. When Larry Wall described the syntax of Perl 6 for the first time, people were up in arms because he was replacing the </span><span class="font2">-</span><span class="font2" style="font-style:italic;">&gt;</span><span class="font17"> operator with </span><span class="font2">. </span><span class="font17">and the </span><span class="font2">. </span><span class="font17">operator with </span><span class="font2">_</span><span class="font17">. Even though there is only a little difference between:</span></p>
<p><span class="font2">$it-&gt;start</span></p>
<p><span class="font17">and:</span></p>
<p><span class="font2">$it-&gt;('start')</span></p>
<p><span class="font17">people love the first one and hate the second one. It’s easy to make the first syntax available though. The first syntax is an object method call, so we need to make our iterators into Perl objects. We do that with a small change to the </span><span class="font2">Iterator() </span><span class="font17">function:</span></p>
<p><span class="font2">sub Iterator (&amp;) { my $it = shift; bless $it =&gt; 'Iter';</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">Now we can add whatever methods we want for iterators:</span></p>
<div>
<p><span class="font2">sub Iter::start</span></p>
<p><span class="font2">sub Iter::exhausted</span></p>
<p><span class="font2">sub Iter::next</span></p>
</div><br clear="all">
<p><span class="font2">{ $_[0]-&gt;('start') &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></p>
<p><span class="font2">{ $_[0]-&gt;('exhausted?') }</span></p>
<p><span class="font2">{ $_[0]-&gt;('next') &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></p>
<div>
<p><span class="font2">sub Iter::value</span></p>
</div><br clear="all">
<div>
<p><span class="font2">{ $_[0]-&gt;('value') &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></p>
</div><br clear="all">
<p><span class="font17">The prototypical loop, which looked like this:</span></p>
<p><span class="font2">for ($it-&gt;('start'); not $it-&gt;('exhausted?'); $it-&gt;('next')) { # do something with $it-&gt;('value');</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">can now be written like this:</span></p>
<p><span class="font2">for ($it-&gt;start; not $it-&gt;exhausted; $it-&gt;next) { # do something with $it-&gt;value;</span></p>
<p><span class="font2">}</span></p>
<h5><a name="bookmark91"></a><span class="font18">4.6 ALTERNATIVE INTERFACES TO ITERATORS</span></h5>
<p><span class="font17">We’ve already seen that there are two ways to get the next value from any of these iterators. We can use:</span></p>
<p><span class="font2">Snext_value = NEXTVAL(Siterator);</span></p>
<p><span class="font17">or, equivalently, we can write:</span></p>
<p><span class="font2">Snext_value = Siterator-&gt;();</span></p>
<p><span class="font17">which is just what </span><span class="font2">NEXTVAL </span><span class="font17">is doing behind the scenes.</span></p>
<p><span class="font17">So much for syntax; semantics is more interesting. Since an iterator is just a function, we aren’t limited to iterators that return scalar values.</span></p>
<ul style="list-style:none;"><li>
<h5><a name="bookmark92"></a><span class="font19">4.6.1 Using </span><span class="font3">foreach </span><span class="font19">to Loop Over More Than One Array</span></h5></li></ul>
<p><span class="font17">An occasional question is how to loop over two arrays simultaneously. Perl provides </span><span class="font2">foreach</span><span class="font17">, and the equivalent </span><span class="font2">for</span><span class="font17">, which are convenient when you want to loop over a single array:</span></p>
<p><span class="font2">for Selement (@a) {</span></p>
<p><span class="font2"># do something with Selement</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">But suppose you want to write a function that compares two arrays element by element and reports whether they are the same? (The obvious notation, </span><span class="font2">@x == @y</span><span class="font17">, returns true whenever the two arrays have the same length.) You’d like to loop over pairs of corresponding elements, but there’s no way to do that. The only obvious way out is to loop over the array indices instead:</span></p>
<p><span class="font2">sub equal_arrays (</span><span class="font2" style="font-weight:bold;">\</span><span class="font2">@</span><span class="font2" style="font-weight:bold;">\</span><span class="font2">@) {</span></p>
<p><span class="font2">my (Sx, Sy) = @_;</span></p>
<p><span class="font2">return unless @Sx == @Sy; # arrays are the same length?</span></p>
<p><span class="font2">for my Si (0 .. S#Sx) {</span></p>
<p><span class="font2">return unless Sx-&gt;[Si] eq Sy-&gt;[Si]; &nbsp;&nbsp;# mismatched elements</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">return 1; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# arrays are equal</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">To call this function, we write:</span></p>
<p><span class="font2">if (equal_arrays(@x, @y)) { ... }</span></p>
<p><span class="font20">178 </span><span class="font15">CHAPTER 4 Iterators</span></p>
<p><span class="font17">The </span><span class="font2">(</span><span class="font2" style="font-weight:bold;">\</span><span class="font2">@</span><span class="font2" style="font-weight:bold;">\</span><span class="font2">@) </span><span class="font17">prototype tells Perl that the two argument arrays should be passed by reference, instead of being flattened into a single list of array elements. Inside the function, the two references are stored into </span><span class="font2">$x </span><span class="font17">and </span><span class="font2">$y</span><span class="font17">. The </span><span class="font2">@$x == @$y </span><span class="font17">test makes sure that the two arrays have equal lengths before examining the elements.</span></p>
<p><span class="font17">An alternative approach is to build an iterator that can be used whenever this sort of loop is required:</span></p>
<p><span class="font2">sub equal_arrays (</span><span class="font2" style="font-weight:bold;">\</span><span class="font2">@</span><span class="font2" style="font-weight:bold;">\</span><span class="font2">@) {</span></p>
<p><span class="font2">my ($x, $y) = @_</span></p>
<p><span class="font2">return unless @$x == @$y;</span></p>
<p><span class="font2" style="font-weight:bold;">my $xy = each_array(@_);</span></p>
<p><span class="font2" style="font-weight:bold;">while (my ($xe, $ye) = NEXTVAL($xy)) { return unless $xe eq $ye;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">return 1;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">The following iterator, invented by Eric Roode, does the trick:</span></p>
<p><span class="font2">sub each_array { my @arrays = @_; my $cur_elt = 0; my $max_size = 0;</span></p>
<p><span class="font2"># Get the length of the longest input array for (©arrays) {</span></p>
<p><span class="font2">$max_size = @$_ if @$_ &gt;&nbsp;$max_size;</span></p>
<p><span class="font2">} return Iterator {</span></p>
<p><span class="font2">$cur_elt = 0, return () if $cur_elt &gt;= $max_size;</span></p>
<p><span class="font2">my $i = $cur_elt++;</span></p>
<p><span class="font2">return map $_-&gt;[$i], @arrays;</span></p>
<p><span class="font2">};</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">The caller of this function passes in references to one or more arrays, which are stored into </span><span class="font2">©arrays</span><span class="font17">. The iterator captures this variable, as well as </span><span class="font2">$cur_elt</span><span class="font17">, which records its current position. Each time the iterator is invoked, it gathers one element from each array and returns the list of elements; it also increments </span><span class="font2">$cur_elt </span><span class="font17">for next time. When </span><span class="font2">$cur_elt </span><span class="font17">is larger than the last index of the</span></p>
<p><span class="font17">largest array, the iterator is exhausted and returns the empty list instead, resetting </span><span class="font2">$cur_elt </span><span class="font17">so that the iterator can be used again.</span></p>
<p><span class="font17">Another place where this function might be useful is in generating HTML forms. Suppose </span><span class="font2">©labels </span><span class="font17">contains a list of user-visible labels for radio buttons, say </span><span class="font2">('Alaska', 'Alabama', ... 'Yukon Territory')</span><span class="font17">, and </span><span class="font2">©values </span><span class="font17">contains the internal tags that will be sent back by the browser when the user selects each button, say </span><span class="font2">('AK', 'AL', ..., 'YT')</span><span class="font17">.</span></p>
<p><span class="font17">Probably these arrays should have been structured as an array of arrays, </span><span class="font2">(['Alaska', 'AK'], ['Alabama', 'AL'], ...)</span><span class="font17">, but that’s not always convenient or even possible. (It’s tempting to say that the structure should have been a hash, but that’s a mistake for several reasons: the hash loses the order of the data; also, neither labels nor values are required to be distinct.)</span></p>
<p><span class="font17">With the multiple-list iterator, we can write things like:</span></p>
<p><span class="font2">my Sbuttons = each_array(\©labels, \©values);</span></p>
<p><span class="font2">while (my ($label, $value) = NEXTVAL($buttons)) {</span></p>
<p><span class="font2">print HTML qq{&lt;input type=radio value=&quot;$value&quot;&gt; $label&lt;br&gt;\n};</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">The version Eric Roode uses has a clever twist:</span></p>
<p><span class="font2">sub each_array (\©;\©\©\©\©\©\©\©\©\©\©\©\©\©\©\©\©\©\©\©\©\©\©\©\©) { my ©arrays = ©_;</span></p>
<p><span class="font2">...</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">The prototype here says that the arguments will be arrays, and will be passed implicitly by reference, and that there will be at least one. The </span><span class="font2">; </span><span class="font17">character separates the required arguments from the optional ones. Because of the prototype, Eric can leave off the backslashes in calls to </span><span class="font2">each_array()</span><span class="font17">, and write:</span></p>
<p><span class="font2">$ea = each_array(©a, ©b, ©c, ©d);</span></p>
<p><span class="font17">While this is slightly more convenient for his common case, it forecloses the possibility of passing literal array references or array references contained in scalar variables, so that:</span></p>
<p><span class="font2">$aref = \©a;</span></p>
<p><span class="font2">$ea = each_array($aref, [1,2,3]);</span></p>
<div>
<p><span class="font20">180</span></p>
</div><br clear="all">
<p><span class="font15">CHAPTER 4 Iterators</span></p>
<p><span class="font17">becomes illegal; it must be written in this somewhat bizarre form:</span></p>
<p><span class="font2">$ea = each_array(@$aref, @{[1,2,3]});</span></p>
<p><span class="font17">Besides, a more interesting use for the argument space is coming up.</span></p>
<p><span class="font17">It’s not clear what the best behavior is when the function is passed arrays of different lengths, say </span><span class="font2">(1,2,3) </span><span class="font17">and </span><span class="font2">('A','B','C','D')</span><span class="font17">. The preceding version returns four pairs: </span><span class="font2">(1, 'A')</span><span class="font17">, </span><span class="font2">(2, 'B')</span><span class="font17">, </span><span class="font2">(3, 'C')</span><span class="font17">, and </span><span class="font2">(undef, 'D')</span><span class="font17">. It might be preferable in some circumstances to have the iterator become exhausted at the end of the shortest input array, instead of the longest. To get this behavior, just replace the maximum computation with a minimum. We can also provide a version of </span><span class="font2">each_array </span><span class="font17">that has either behavior, depending on an optional argument:</span></p>
<p><span class="font2">sub each_array {</span></p>
<p><span class="font2">my @arrays = @_;</span></p>
<p><span class="font2" style="font-weight:bold;">my $stop_type = ref $arrays[0] ? 'maximum' : shift ©arrays;</span></p>
<p><span class="font2" style="font-weight:bold;">my $stop_size = @{$arrays[0]};</span></p>
<p><span class="font2">my $cur_elt = 0;</span></p>
<p><span class="font2"># Get the length of the longest (or shortest) input array</span></p>
<p><span class="font2" style="font-weight:bold;">if ($stop_type eq 'maximum') {</span></p>
<p><span class="font2">for (@arrays) {</span></p>
<p><span class="font2">$stop_size = @$_ if @$_ &gt;&nbsp;$stop_size;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2" style="font-weight:bold;">} elsif ($stop_type eq 'minimum') {</span></p>
<p><span class="font2">for (@arrays) {</span></p>
<p><span class="font2" style="font-weight:bold;">$stop_size = @$_ if @$_ &lt;&nbsp;$stop_size;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2" style="font-weight:bold;">} else {</span></p>
<p><span class="font2" style="font-weight:bold;">croak &quot;each_array: unknown stopping behavior '$stop_type'&quot;;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">return Iterator {</span></p>
<p><span class="font2">return () if $cur_elt &gt;= $stop_size;</span></p>
<p><span class="font2">my $i = $cur_elt++;</span></p>
<p><span class="font2">return map $_-&gt;[$i], @arrays;</span></p>
<p><span class="font2">};</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">If the first argument is not an array ref, we shift it off into </span><span class="font2">$stop_type</span><span class="font17">, which otherwise defaults to </span><span class="font2">&quot;maximum&quot;</span><span class="font17">. Only </span><span class="font2">&quot;maximum&quot; </span><span class="font17">and </span><span class="font2">&quot;minimum&quot; </span><span class="font17">are supported here. As usual, we can gain flexibility and eliminate the repeated code by allowing a callback argument to specify the method for selecting the stopping point:</span></p>
<p><span class="font2">sub each_array {</span></p>
<p><span class="font2">my @arrays = @_;</span></p>
<p><span class="font2" style="font-weight:bold;">my $stop_func = UNIVERSAL::isa($arrays[0], 'ARRAY') ? 'maximum' : shift ©arrays;</span></p>
<p><span class="font2">my $stop_size = @{$arrays[0]};</span></p>
<p><span class="font2" style="font-weight:bold;">my %stop_funcs = ('maximum'=&gt;</span></p>
<p><span class="font2" style="font-weight:bold;">sub { $_[0] &gt;&nbsp;$_[1] ? $_[0] : $_[1] }, 'minimum'=&gt;</span></p>
<p><span class="font2" style="font-weight:bold;">sub { $_[0] &lt;&nbsp;$_[1] ? $_[0] : $_[1] }, </span><span class="font2">);</span></p>
<p><span class="font2" style="font-weight:bold;">unless (ref $stop_func eq 'CODE') {</span></p>
<p><span class="font2" style="font-weight:bold;">$stop_func = $stop_funcs{$stop_func}</span></p>
<p><span class="font2" style="font-weight:bold;">or croak &quot;each_array: unknown stopping behavior '$stop_func'&quot;;</span></p>
<p><span class="font2" style="font-weight:bold;">} </span><span class="font2"># Get the length of the longest (or shortest) input array for (@arrays) {</span></p>
<p><span class="font2" style="font-weight:bold;">$stop_size = &amp;$stop_func($stop_size, scalar @$_);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">my $cur_elt = 0;</span></p>
<p><span class="font2">return Iterator {</span></p>
<p><span class="font2">return () if $cur_elt &gt;= $stop_size;</span></p>
<p><span class="font2">my $i = $cur_elt++;</span></p>
<p><span class="font2">return map $_-&gt;[$i], @arrays;</span></p>
<p><span class="font2">};</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">each_array </span><span class="font17">now has several calling conventions. The basic one we’ve seen already:</span></p>
<p><span class="font2">my $each = each_array(\@x, \@y, ...);</span></p>
<p><span class="font17">This builds an iterator that produces one list for each element in the longest input array. The first argument to </span><span class="font2">each_array </span><span class="font17">may also be a callback function that is used to generate the array limit:</span></p>
<p><span class="font2">sub max { $_[0] &gt;&nbsp;$_[1] ? $_[0] : $_[1] };</span></p>
<p><span class="font2">my $each = each_array(\&amp;max, \@x, \@y, ...);</span></p>
<div>
<h4><a name="bookmark266"></a><span class="font20">182</span></h4>
</div><br clear="all">
<div>
<p><span class="font15">CHAPTER 4 Iterators</span></p>
</div><br clear="all">
<p><span class="font17">The callback function is given two arguments: the current stopping size and the size of one of the arrays. It returns a new choice of stopping size. In the preceding example, it returns the maximum. The third way of calling </span><span class="font2">each_array </span><span class="font17">is to pass a string key that symbolizes a commonly chosen function:</span></p>
<p><span class="font2">my Seach = each_array('maximum', </span><span class="font2" style="font-weight:bold;">\</span><span class="font2">@x, </span><span class="font2" style="font-weight:bold;">\</span><span class="font2">@y, ...);</span></p>
<p><span class="font17">This selects a canned maximum function from the table </span><span class="font2">%stop_funcs</span><span class="font17">.</span></p>
<p><span class="font17">We can get a different behavior by supplying a more interesting function:</span></p>
<p><span class="font2">my Sall_equal = sub {</span></p>
<p><span class="font2">if ($_[0] == $_[1]) { return $_[0] }</span></p>
<p><span class="font2">croak &quot;each_array: Not every array has length $_[0]&quot;;</span></p>
<p><span class="font2">};</span></p>
<p><span class="font2">my Seach = each_array($all_equal, \@x, \@y, ...);</span></p>
<p><span class="font17">Here </span><span class="font2">each_array </span><span class="font17">croaks unless every input array has the same length. If this behavior turns out to be frequently needed, we can add the </span><span class="font2">$all_equal </span><span class="font17">function to the </span><span class="font2">%stop_funcs </span><span class="font17">table and support:</span></p>
<p><span class="font2">my Seach = each_array('all_equal', </span><span class="font2" style="font-weight:bold;">\</span><span class="font2">@x, </span><span class="font2" style="font-weight:bold;">\</span><span class="font2">@y, ...);</span></p>
<p><span class="font17">without breaking backward compatibility.</span></p>
<ul style="list-style:none;"><li>
<h5><a name="bookmark93"></a><span class="font19">4.6.2 An Iterator with an </span><span class="font3">each</span><span class="font19">-Like Interface</span></h5></li></ul>
<p><span class="font17">Every Perl hash contains an iterator component, which is accessed by </span><span class="font2">each()</span><span class="font17">. Each call to </span><span class="font2">each() </span><span class="font17">produces another key from the hash, and, in list context, the corresponding value.</span></p>
<p><span class="font17">Following this model, we can make a transformation function, analogous to </span><span class="font2">imap()</span><span class="font17">, that may produce a more useful result:</span></p>
<p><span class="font2">sub eachlike (&amp;$) {</span></p>
<p><span class="font2">my (Stransform, Sit) = @_;</span></p>
<p><span class="font2">return Iterator {</span></p>
<p><span class="font2">local S_ = NEXTVAL(Sit);</span></p>
<p><span class="font2">return unless defined S_;</span></p>
<p><span class="font2" style="font-weight:bold;">my $value = $transform-&gt;();</span></p>
<p><span class="font2" style="font-weight:bold;">return wantarray ? ($_, $value) : $value;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
<ul style="list-style:none;"><li>
<p class="font15">4.6 ALTERNATIVE INTERFACES TO ITERATO</p></li></ul>
<p><span class="font2">eachlike() </span><span class="font17">transforms an iterator by applying a function to every element of the iterator. In scalar context, the iterators produced by </span><span class="font2">eachlike() </span><span class="font17">behave exactly the same as those produced by </span><span class="font2">imap()</span><span class="font17">. But in list context, an </span><span class="font2">eachlike() </span><span class="font17">iterator returns two values: the original, unmodified value, and the transformed value. For example:</span></p>
<p><span class="font2">my Sn = eachlike { S_ * 2 } upto(3,5);</span></p>
<p><span class="font17">This loop will print the values 6, 8, 10, just as ifwe had used </span><span class="font2">imap()</span><span class="font17">:</span></p>
<p><span class="font2">while (defined(my $q = NEXTVAL(Sn))) { print &quot;$q\n&quot;;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">This loop will print </span><span class="font2">3 6</span><span class="font17">, </span><span class="font2">4 8</span><span class="font17">, </span><span class="font2">5 10</span><span class="font17">:</span></p>
<p><span class="font2">while (my @q = NEXTVAL(Sn)) { print &quot;@q\n&quot;;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">Our implementation of </span><span class="font2">dir_walk() </span><span class="font17">took a callback argument; the callback function was applied to each filename in the directory tree, and the iterator returned the resulting values. This complicated the implementation of </span><span class="font2">dir_walk()</span><span class="font17">. </span><span class="font2">eachlike() </span><span class="font17">renders this complication entirely unnecessary. It’s quite enough for </span><span class="font2">dir_walk() </span><span class="font17">to return plain filenames, because in place of:</span></p>
<p><span class="font2">my Sit = dir_walk(SDIR, sub { ... } );</span></p>
<p><span class="font17">We can now use:</span></p>
<p><span class="font2">my Sit = eachlike { ... } dir_walk(SDIR);</span></p>
<p><span class="font17">In scalar context, </span><span class="font2">$it </span><span class="font17">will behave as if it had been generated by the former, more complicated version of </span><span class="font2">dir_walk()</span><span class="font17">. But in addition, it can also be used like this:</span></p>
<p><span class="font2">while (my (Sfilename, Svalue) = NEXTVAL(Sit)) {</span></p>
<p><span class="font2"># do something with the filename or the value or both }</span></p>
<p><span class="font17">For example, print out all the dangling symbolic links in a directory:</span></p>
<p><span class="font2">my Sit = eachlike { -l &amp;&amp;&nbsp;! -e } dir_walk(SDIR);</span></p>
<p><span class="font2">while (my (Sfilename, Sbadlink) = NEXTVAL(Sit)) {</span></p>
<p><span class="font2">print &quot;Sfilename is a dangling link&quot; if Sbadlink;</span></p>
<p><span class="font2">}</span></p>
<div>
<p><span class="font4">I</span></p>
<p><span class="font15" style="font-variant:small-caps;">rs</span><span class="font20"> 183</span></p>
</div><br clear="all">
<ul style="list-style:none;"><li>
<h5><a name="bookmark94"></a><span class="font19">4.6.3 Tied Variable Interfaces</span></h5></li></ul>
<p><span class="font17">The ordinary interface to an iterator may be unfamiliar. By using Perl’s </span><span class="font2">tie </span><span class="font17">feature, which allows us to associate any semantics we want with a perl variable, we can make an iterator look like an ordinary scalar. Or rather, it will look like one of Perl’s magical scalars, such as </span><span class="font2">$! </span><span class="font17">or </span><span class="font2">$.</span><span class="font17">, which might contain different values depending on when it’s examined.</span></p>
<p><span class="font17">SUMMARY OF </span><span class="font3">ti e</span></p>
<p><span class="font17">In Perl, scalar variables may be </span><span class="font17" style="font-style:italic;">tied.</span><span class="font17"> This means that access to the variable is mediated by a Perl object. The </span><span class="font2">tie </span><span class="font17">function associates the variable with a particular object, which we say is </span><span class="font17" style="font-style:italic;">tied to</span><span class="font17"> the variable.</span></p>
<p><span class="font17">Suppose the scalar </span><span class="font2">$s </span><span class="font17">is tied to the object </span><span class="font2">$o</span><span class="font17">.</span></p>
<p><span class="font17">When you write this: Perl actually does this instead:</span></p>
<p><span class="font2">print $s; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print $o-&gt;FETCH();</span></p>
<p><span class="font2">$r = $s; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$r = $o-&gt;FETCH();</span></p>
<p><span class="font2">$s = $value; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$o-&gt;STORE($value);</span></p>
<p><span class="font17">If anyone tries to read from or write to </span><span class="font2">$s</span><span class="font17">, then instead of doing whatever it would usually do, Perl makes a method call on </span><span class="font2">$o </span><span class="font17">instead. An attempt to read </span><span class="font2">$s </span><span class="font17">turns into </span><span class="font2">$o-&gt;FETCH()</span><span class="font17">. The return value of the </span><span class="font2">FETCH </span><span class="font17">method is reported as being the value stored in </span><span class="font2">$s</span><span class="font17">.</span></p>
<p><span class="font17">Similarly, an attempt to do </span><span class="font2">$s = $value </span><span class="font17">turns into </span><span class="font2">$o-&gt;STORE($value)</span><span class="font17">. It is the responsibility of the </span><span class="font2">STORE </span><span class="font17">method to store the value somewhere so that it can be retrieved by a later call to </span><span class="font2">FETCH</span><span class="font17">.</span></p>
<p><span class="font17">To tie a scalar variable in Perl, we use the built-in </span><span class="font2">tie </span><span class="font17">operator:</span></p>
<p><span class="font2">tie $scalar, 'Package', </span><span class="font2" style="font-style:italic;">ARGUMENTS...</span></p>
<p><span class="font17">This makes a method call to </span><span class="font2">Package-&gt;TIESCALAR(</span><span class="font2" style="font-style:italic;">ARGUMENTS</span><span class="font2">...)</span><span class="font17">. </span><span class="font2">TIESCALAR </span><span class="font17">must be an object constructor. The object that it returns is the one that will be associated with </span><span class="font2">$scalar </span><span class="font17">and which will receive subsequent </span><span class="font2">FETCH </span><span class="font17">and </span><span class="font2">STORE </span><span class="font17">messages.</span></p>
<p><span class="font17">Here’s a (silly) example:</span></p>
<p><span class="font2">package CIA;</span></p>
<p><span class="font2">sub TIESCALAR {</span></p>
<p><span class="font2">my $package = shift;</span></p>
<ul style="list-style:none;"><li>
<p class="font15">4.6 ALTERNATIVE INTERFACES TO ITERATORS</p>
<div>
<p><span class="font20">185</span></p>
</div><br clear="all"></li></ul>
<p><span class="font2">my Sself = {};</span></p>
<p><span class="font2">bless Sself =&gt; Spackage;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">sub STORE { }</span></p>
<p><span class="font2">sub FETCH { &quot;&lt;&lt;Access forbidden&gt;&gt;&quot; }</span></p>
<p><span class="font17">This is an implementation of an extra-secret tied scalar. If we tie a scalar into the</span></p>
<p><span class="font2">CIA </span><span class="font17">package, all data stored into it becomes inaccessible:</span></p>
<p><span class="font2">tie Ssecret, 'CIA';</span></p>
<p><span class="font17">This creates the association between </span><span class="font2">Ssecret </span><span class="font17">and the object constructed by </span><span class="font2">CIA::TIESCALAR</span><span class="font17">. Accesses to </span><span class="font2">Ssecret </span><span class="font17">will turn into </span><span class="font2">FETCH </span><span class="font17">and </span><span class="font2">STORE </span><span class="font17">methods on the object:</span></p>
<p><span class="font2">Ssecret = 'atomic ray';</span></p>
<p><span class="font17">Instead of storing </span><span class="font2">'atomic ray' </span><span class="font17">in the usual way, </span><span class="font2">STORE </span><span class="font17">is invoked. It’s passed the object and new value as arguments, but it just throws them away, without storing the data anywhere. That’s OK, because if you later ask the scalar what it contains:</span></p>
<p><span class="font2">print &quot;The secret weapon is 'Ssecret'.\n&quot;</span></p>
<p><span class="font17">The output is:</span></p>
<p><span class="font2">The secret weapon is '&lt;&lt;Access forbidden&gt;&gt;'.</span></p>
<p><span class="font17">which is pleasantly mysterious, and has the side benefit of defending national security.</span></p>
<p><span class="font17">TIED SCALARS</span></p>
<p><span class="font17">We can use this feature to associate a tied scalar variable with an iterator. When the value of the scalar variable is examined, Perl gets control behind the scenes, kicks the iterator, and reports the next iterator value as the current value of the variable.</span></p>
<p><span class="font2">package Iterator2Scalar;</span></p>
<p><span class="font2">sub TIESCALAR {</span></p>
<p><span class="font2">my (Spackage, Sit) = @_;</span></p>
<table border="1">
<tr><td style="vertical-align:bottom;">
<p><span class="font20">186</span></p></td><td style="vertical-align:bottom;">
<p><span class="font15">CHAPTER 4 Iterators</span></p></td></tr>
</table>
<p><span class="font2">my Sself = { It =&gt; Sit }; bless Sself =&gt; Spackage;</span></p>
<p><span class="font2">} sub FETCH {</span></p>
<p><span class="font2">my (Sself) = @_;</span></p>
<p><span class="font2">NEXTVAL(Sself-&gt;{It});</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">sub STORE {</span></p>
<p><span class="font2">require Carp;</span></p>
<p><span class="font2">Carp::croak(&quot;Iterator is read-only&quot;); }</span></p>
<p><span class="font17">Now we can use:</span></p>
<p><span class="font2">tie Snextfile, 'Iterator2Scalar', dir_walk(SDIR);</span></p>
<p><span class="font2">while (Sfilename = Snextfile) {</span></p>
<p><span class="font2"># do something with Sfilename</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">TIED FILEHANDLES</span></p>
<p><span class="font17">A tied scalar interface to an iterator produces a magical variable that encapsulates the iterator. This may be an intuitive interface in some cases, but it may also be peculiar. The user may be surprised to find that the variable’s value changes spontaneously, or that the variable can’t be assigned to.</span></p>
<p><span class="font17">Since Perl 5.004, filehandles have also been tie-able. A filehandle is often the most natural interface for a synthetic iterator. Since filehandles </span><span class="font17" style="font-style:italic;">are</span><span class="font17"> examples of iterators, nobody will get any surprises when our filehandle behaves like an iterator or displays iterator-like limitations. People won’t be surprised if a filehandle returns a different value each time it’s read. They won’t be surprised that they can’t assign a value to it. They won’t be surprised when a filehandle refuses to be rewound back to the beginning, since even ordinary filehandles don’t always support that. They might be surprised by the handle’s failure to support the </span><span class="font2">getc </span><span class="font17">operator, but more likely they won’t even notice that it’s missing.</span></p>
<p><span class="font17">The interface to tied filehandles is similar to that for tied scalars. Since filehandles aren’t first-class variables in Perl, the caller passes an entire glob, and the </span><span class="font2">tie </span><span class="font17">operator ties the filehandle part of the glob:</span></p>
<p><span class="font2">tie *IT, 'Iterator2Handle', Siterator;</span></p>
<ul style="list-style:none;"><li>
<p class="font15">4.7 AN EXTENDED EXAMPLE: WEB SPIDERS <span class="font20">187</span></p></li></ul>
<p><span class="font17">This calls the </span><span class="font2">Iterator2Handle::TIEHANDLE </span><span class="font17">constructor method, which is analogous to </span><span class="font2">TIESCALAR</span><span class="font17">:</span></p>
<p><span class="font2">package Iterator2Handle;</span></p>
<p><span class="font2">sub TIEHANDLE {</span></p>
<p><span class="font2">my ($package, $iterator) = @_;</span></p>
<p><span class="font2">my $self = { IT =&gt; $iterator }; bless $self =&gt; $package;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">When the user tries to read from the handle using the usual </span><span class="font2">&lt;IT&gt; </span><span class="font17">notation, Perl will call the </span><span class="font2">READLINE </span><span class="font17">method on the tied object:</span></p>
<p><span class="font2">sub READLINE {</span></p>
<p><span class="font2">my $self = shift;</span></p>
<p><span class="font2">return NEXTVAL($self-&gt;{IT});</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">To use the iterator, the user now does:</span></p>
<p><span class="font2">$some_value = &lt;IT&gt;;</span></p>
<p><span class="font2"># ... or ...</span></p>
<p><span class="font2">while ($nextval = &lt;IT&gt;) {</span></p>
<ul style="list-style:none;"><li>
<p><span class="font2"># do something with $nextval</span></p></li></ul>
<p><span class="font2">}</span></p>
<p><span class="font17">They can even use Perl’s shortcut for reading a filehandle in a </span><span class="font2">while </span><span class="font17">loop:</span></p>
<p><span class="font2">while (&lt;IT&gt;) {</span></p>
<ul style="list-style:none;"><li>
<p><span class="font2"># do something with $_</span></p></li></ul>
<p><span class="font2">}</span></p>
<ul style="list-style:none;"><li>
<h5><a name="bookmark267"></a><span class="font18">4.7 AN EXTENDED EXAMPLE:</span></h5></li></ul>
<h5><a name="bookmark268"></a><span class="font18">WEB SPIDERS</span></h5>
<p><span class="font17">We’ll now use the tools provided to build a replacement for Ave Wrigley’s </span><span class="font2">WWW::SimpleRobot </span><span class="font17">module, which traverses a web site, invoking a callback for</span></p>
<div>
<h4><a name="bookmark269"></a><span class="font20">188</span></h4>
</div><br clear="all">
<div>
<p><span class="font15">CHAPTER 4 Iterators</span></p>
</div><br clear="all">
<p><span class="font17">each page. </span><span class="font2">SimpleRobot </span><span class="font17">provides two callback hooks, one of which is called for documents that can’t be retrieved, the other for documents that can. It also supports options to specify whether the traversal will be breadth- or depth-first, and a regex that the URLs of the retrieved documents must match.</span></p>
<p><span class="font17">Our robot, which we’ll call </span><span class="font2">Grasshopper</span><span class="font17">, will be at once simpler and more flexible. The robot will be embedded in an iterator, and the iterator will simply return URLs. If the user wants a callback invoked for each URL, they can add one with </span><span class="font2">imap</span><span class="font17">.</span></p>
<p><span class="font17">Our basic tools will be the </span><span class="font2">LWP::Simple </span><span class="font17">and </span><span class="font2">HTML::LinkExtor </span><span class="font17">modules. </span><span class="font2">LWP::Simple </span><span class="font17">provides a simple interface for building web clients. </span><span class="font2">HTML::LinkExtor </span><span class="font17">parses an HTML page and returns a list of all the links found on the page. Here is the first cut:</span></p>
<p><span class="font2">use HTML::LinkExtor;</span></p>
<p><span class="font2">use LWP::Simple;</span></p>
<p><span class="font2">sub traverse {</span></p>
<p><span class="font2">my @queue = @_;</span></p>
<p><span class="font2">my %seen;</span></p>
<p><span class="font2">return Iterator {</span></p>
<p><span class="font2">while (@queue) {</span></p>
<p><span class="font2">my $url = shift @queue;</span></p>
<p><span class="font2">$url =<sub>-</sub> s/#.*$//;</span></p>
<p><span class="font2">next if $seen{$url}++;</span></p>
<p><span class="font2">my ($content_type) = head($url);</span></p>
<p><span class="font2">if ($content_type =- m{~text/html\b}) {</span></p>
<p><span class="font2">my $html = get($url);</span></p>
<p><span class="font2">push @queue, get_links($url, $html);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">return $url;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">return; # exhausted</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">The pattern here should be familiar; it’s the same as the pattern we followed for </span><span class="font2">walk_tree</span><span class="font17">. The iterator maintains a queue of unvisited URLs, initialized with the list of URLs the user requests that it visit. Whenever the iterator is invoked, it gets the first item in the queue, reads it for more URLs, adds these URLs to the end of the queue, and returns the URL. When the queue is empty, the iterator is exhausted.</span></p>
<p><span class="font17">Use of the iterator structure was essential. A simple recursive formulation just doesn’t work. Recursive searches always do DFS, so a recursive robot will follow the first link on the first page to arrive at the second page, then follow the first link on the second page, then the first link on the third page, and so on, never returning to any page to process the other links there until it hits a dead end. Dead ends on the web are unusual, so the recursive robot goes wandering off into cyberspace and never comes back. Breadth-first search is almost always preferable for this application, but with a simple recursive function there’s no way to get BFS.</span></p>
<p><span class="font17">There are a few web-specific features in the code. Some URLs may contain an anchor component, indicated by a </span><span class="font2"># </span><span class="font17">sign followed by the anchor name; this doesn’t identify a document, so we discard it. (The specification for URLs guarantees that any other </span><span class="font2"># </span><span class="font17">sign in the URL will be represented as </span><span class="font2">%23</span><span class="font17">, so this substitution should be safe.) The iterator maintains a hash, </span><span class="font2">%seen</span><span class="font17">, which records whether or not it has visited a URL already; if it has, then the URL is skipped. It uses the </span><span class="font2">head </span><span class="font17">function, supplied by </span><span class="font2">LWP::Simple</span><span class="font17">, to find out whether the URL represents an HTML document, and if not it doesn’t bother searching that document for links. In theory, </span><span class="font2">head </span><span class="font17">is supposed to indicate to the server that we do not want the entire document content; we want only meta-information, such as its content-type and length. In practice, the world is full of defective servers (and working servers running defective CGI programs) that send the entire document anyway. We’ve done the best we can here; if the server is going to send the document even though we asked it not to, there’s nothing we can do about that.</span></p>
<p><span class="font17">If the document does turn out to be HTML, we use the </span><span class="font2">get </span><span class="font17">function, also supplied by </span><span class="font2">LWP::Simple</span><span class="font17">, to retrieve the content, which we then pass into </span><span class="font2">get_links</span><span class="font17">. </span><span class="font2">get_links </span><span class="font17">will parse the HTML and return a list of all the link URLs found in the document. Here it is:</span></p>
<p><span class="font2">sub get_links {</span></p>
<p><span class="font2">my (Sbase, Shtml) = @_;</span></p>
<p><span class="font2">my ©links;</span></p>
<p><span class="font2">my Smore_links = sub {</span></p>
<p><span class="font2">my (Stag, %attrs) = @_;</span></p>
<p><span class="font2">push ©links, values %attrs;</span></p>
<p><span class="font2">};</span></p>
<p><span class="font2">HTML::LinkExtor-&gt;new(Smore_links, Sbase)-&gt;parse(Shtml); return ©links;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">The structure of </span><span class="font2">get_links </span><span class="font17">is a little peculiar, because </span><span class="font2">HTML::LinkExtor </span><span class="font17">uses an unfortunate interface. The </span><span class="font2">new </span><span class="font17">call constructs an </span><span class="font2">HTML::LinkExtor </span><span class="font17">object. We give the constructor a callback function, </span><span class="font2">$more_links</span><span class="font17">, and a base URL, </span><span class="font2">$base</span><span class="font17">. The callback function is invoked whenever the object locates an HTML element that contains a link. The link URLs themselves will be transformed into absolute URLs, interpreted relative to </span><span class="font2">$base</span><span class="font17">.</span></p>
<p><span class="font17">Parsing the document is triggered by the </span><span class="font2">-&gt;parse </span><span class="font17">method. We pass the HTML document as the argument. The object parses the document, invoking the callback each time it finds an HTML element that contains links. When we’re done parsing the document, the object is no longer needed, so we never store it anywhere; we create it just long enough to call a single method on it.</span></p>
<p><span class="font17">The callback we supply to the </span><span class="font2">HTML::LinkExtor </span><span class="font17">object is called once for each link-bearing HTML element. The arguments are the tag of the element, and a sequence of attribute-value pairs for its link-bearing attributes. For example, if the element is:</span></p>
<p><span class="font2">&lt;img border=0 src=&quot;pics/medium-sigils.gif&quot; height=71 width=151 align=right lowsrc=&quot;pics/small-sigils.gif&quot; alt=&quot;$@%&quot;&gt;</span></p>
<p><span class="font17">The arguments to the callback will be:</span></p>
<p><span class="font2">('IMG', 'SRC' =&gt; '.../pics/medium-sigils.gif',</span></p>
<p><span class="font2">'LOWSRC' =&gt; '.../pics/small-sigils.gif', )</span></p>
<p><span class="font17">Our callback discards the tag, extracts the URLs, and pushes them into the </span><span class="font2">@links </span><span class="font17">array. When the parse is complete, we return </span><span class="font2">@links</span><span class="font17">.</span></p>
<ul style="list-style:none;"><li>
<h5><a name="bookmark99"></a><span class="font19">4.7.1 Pursuing Only Interesting Links</span></h5></li></ul>
<p><span class="font17">The first cut of </span><span class="font2">Grasshopper </span><span class="font17">is almost useful. The one thing it’s missing is a way to tell the robot not to pursue links to other web sites. We’ll do that by inserting a callback filter function into </span><span class="font2">get_links()</span><span class="font17">. After </span><span class="font2">get_links() </span><span class="font17">extracts a list of links, it will invoke the user-supplied callback on this list. The callback will filter out the links that it doesn’t want the robot to pursue, and return a list of the interesting links. The call to </span><span class="font2">traverse </span><span class="font17">will now look like this:</span></p>
<p><span class="font2">traverse($is_interesting_link, $url1, ...);</span></p>
<p><span class="font17">We need to make some minor changes to </span><span class="font2">traverse()</span><span class="font17">:</span></p>
<p><span class="font2"># Version with 'interesting links' callback sub traverse {</span></p>
<p><span class="font2" style="font-weight:bold;">my $interesting_links = sub { @_ };</span></p>
<p><span class="font2" style="font-weight:bold;">$interesting_links = shift if ref $_[0] eq 'CODE';</span></p>
<p><span class="font2" style="font-weight:bold;">push @queue, $interesting_links-&gt;(get_links($url, $html));</span></p>
<p><span class="font2">■ ■■</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">Now we can ask it to traverse a single web site:</span></p>
<p><span class="font2">my Stop = '</span><a href="http://perl.plover.com/'"><span class="font2">http://perl.plover.com/'</span></a><span class="font2">;</span></p>
<p><span class="font2">my Sinteresting = sub { grep /~\QStop/o, @_ };</span></p>
<p><span class="font2">my Surls = traverse(Sinteresting, Stop);</span></p>
<p><span class="font17">This is already reasonably useful. Here’s a program that copies every reachable file on a site:</span></p>
<p><span class="font2">use File::Basename;</span></p>
<p><span class="font2">while (my Surl = NEXTVAL(Surls)) {</span></p>
<p><span class="font2">my Sfile = Surl;</span></p>
<p><span class="font2">Sfile =- s/~</span><span class="font2" style="font-weight:bold;">\</span><span class="font2">QStop//o;</span></p>
<p><span class="font2">my Sdir = dirname(Sfile);</span></p>
<p><span class="font2">system('mkdir', '-p', Sdir) == 0 or next;</span></p>
<p><span class="font2">open F, &quot;&gt;&quot;, Sfile or next;</span></p>
<p><span class="font2">print F get(Surl);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">Here’s a program to check whether any internal links on the site are bad:</span></p>
<p><span class="font2">while (my Surl = NEXTVAL(Surls)) {</span></p>
<p><span class="font2">print &quot;Bad link to: Surl&quot; unless head(Surl);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">This last example exposes two obvious weaknesses in the current design. We can find out that </span><span class="font2">Surl </span><span class="font17">is bad, but the iterator never tells us what page that bad URL appeared on, so we can’t do anything about it. And the way we find out that </span><span class="font2">Surl </span><span class="font17">is bad is rather silly. The iterator itself has just finished doing a </span><span class="font2">head </span><span class="font17">operation on this very URL, so we’re repeating work that was just done a moment ago. The second of these is easier to repair. Since the information is available anyway,</span></p>
<div>
<p><span class="font20">192</span></p>
</div><br clear="all">
<p><span class="font15">CHAPTER 4 Iterators</span></p>
<p><span class="font17">we’ll just have the iterator return it. In scalar context, it will return a URL; in list context, it will return a URL, a hash of header information, and the content, if available:</span></p>
<p><span class="font2">sub traverse {</span></p>
<p><span class="font2">■ ■■</span></p>
<p><span class="font2" style="font-weight:bold;">my (%head, Shtml);</span></p>
<p><span class="font2" style="font-weight:bold;">@head{qw(TYPE LENGTH LAST_MODIFIED EXPIRES SERVER)} = head(Surl);</span></p>
<p><span class="font2" style="font-weight:bold;">if (Shead{TYPE} = </span><span class="font2">- </span><span class="font2" style="font-weight:bold;">m{&quot;text/html\b}) {</span></p>
<p><span class="font2">Shtml = get(Surl);</span></p>
<p><span class="font2">push @queue, $interesting_links-&gt;(get_links($url,$html));</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2" style="font-weight:bold;">return wantarray ? (Surl, </span><span class="font2">\</span><span class="font2" style="font-weight:bold;">%head, Shtml) : Surl;</span></p>
<p><span class="font2">■■■</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">The bad link detector now becomes:</span></p>
<p><span class="font2">while (my (Surl, Shead) = NEXTVAL(Surls)) {</span></p>
<p><span class="font2">print &quot;Bad link to: $url\n&quot; unless $head-&gt;{TYPE};</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">The site copier is:</span></p>
<p><span class="font2">use File::Basename;</span></p>
<p><span class="font2" style="font-weight:bold;">while (my (Surl, Shead, Scontent) = NEXTVAL(Surls)) {</span></p>
<p><span class="font2" style="font-weight:bold;">next unless Shead-&gt;{TYPE};</span></p>
<p><span class="font2">my Sfile = Surl;</span></p>
<p><span class="font2">$file =- s/~\QStop//o;</span></p>
<p><span class="font2">my Sdir = dirname(Sfile);</span></p>
<p><span class="font2">system('mkdir', '-p', Sdir) == 0 or next;</span></p>
<p><span class="font2">open F, &quot;&gt;&quot;, Sfile or next;</span></p>
<p><span class="font2" style="font-weight:bold;">Scontent = get($url) unless defined Scontent;</span></p>
<p><span class="font2" style="font-weight:bold;">print F Scontent;</span></p>
<p><span class="font2">}</span></p>
<ul style="list-style:none;"><li>
<h5><a name="bookmark100"></a><span class="font19">4.7.2 Referring URLs</span></h5></li></ul>
<p><span class="font17">Including the referring URL is a little trickier, because by the time a URL shows up at the front of the queue, we’ve long since forgotten where we saw it. The solution</span></p>
<p><span class="font15">4.7 AN EXTENDED EXAMPLE: WEB SPIDERS</span></p>
<p><span class="font17">is to record the referring URLs in the queue also. Queue members will now be pairs of URLs. We will make the queue into an array of references to two-element arrays:</span></p>
<p><span class="font2">[ URL to investigate,</span></p>
<p><span class="font2">URL of the page where we saw it (the 'referrer') ]</span></p>
<p><span class="font17">The </span><span class="font2">traverse </span><span class="font17">function is now:</span></p>
<p><span class="font2">sub traverse {</span></p>
<p><span class="font2" style="font-weight:bold;">my $interesting_links = sub { shift; @_ };</span></p>
<p><span class="font2">$interesting_links = shift if ref $_[0] eq 'CODE';</span></p>
<p><span class="font2" style="font-weight:bold;">my @queue = map [$_, 'supplied by user'], @_;</span></p>
<p><span class="font2">my %seen;</span></p>
<p><span class="font2">return Iterator {</span></p>
<p><span class="font2">while (@queue) {</span></p>
<p><span class="font2" style="font-weight:bold;">my ($url, $referrer) = @{shift @queue};</span></p>
<p><span class="font2">$url =- s/#.*$//;</span></p>
<p><span class="font2">next if $seen{$url}++;</span></p>
<p><span class="font2">my (%head, $html);</span></p>
<p><span class="font2">@head{qw(TYPE LENGTH LAST_MODIFIED EXPIRES SERVER)} = head($url);</span></p>
<p><span class="font2">if ($head{TYPE} =- m{~text/html\b}) {</span></p>
<p><span class="font2">my $html = get($url);</span></p>
<p><span class="font2">push @queue,</span></p>
<p><span class="font2" style="font-weight:bold;">map [$_, $url],</span></p>
<p><span class="font2" style="font-weight:bold;">$interesting_links-&gt;($url, get_links($url, $html));</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2" style="font-weight:bold;">return wantarray ? ($url, </span><span class="font2">\</span><span class="font2" style="font-weight:bold;">%head, $referrer, $html) : $url;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">return; #exhausted</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">Instead of just copying the original URL list into the queue, we now annotate each one with a fake referrer. When we shift an item off the queue, we dismantle it into a URL and a referrer. The URL is treated as before. The referrer is passed to the </span><span class="font2">$interesting_links </span><span class="font17">callback, and each interesting link in the resulting list is annotated with its own referrer, the current URL, before being put into the queue. In list context, we return the referrer of each URL along with the other information about the document.</span></p>
<div>
<p><span class="font20">193</span></p>
</div><br clear="all">
<div>
<p><span class="font20">194</span></p>
</div><br clear="all">
<p><span class="font15">CHAPTER 4 Iterators</span></p>
<h6><a name="bookmark270"></a><span class="font17">Our bad link detector is now :</span></h6>
<p><span class="font2">my Stop = '</span><a href="http://perl.plover.com/'"><span class="font2">http://perl.plover.com/'</span></a></p>
<p><span class="font2" style="font-weight:bold;">my Sinteresting = sub { shift; grep /&quot;</span><span class="font2">\</span><span class="font2" style="font-weight:bold;">Q$top/o, @_ };</span></p>
<p><span class="font2">my Surls = traverse(Sinteresting, Stop);</span></p>
<p><span class="font2" style="font-weight:bold;">while (my ($url, Shead, Sreferrer) = NEXTVAL(Surls)) { next if Shead-&gt;{TYPE};</span></p>
<p><span class="font2" style="font-weight:bold;">print &quot;Page 'Sreferrer' has a bad link to 'Surl'</span><span class="font2">\</span><span class="font2" style="font-weight:bold;">n&quot;;</span></p>
<p><span class="font2">}</span></p>
<h6><a name="bookmark271"></a><span class="font17">Or, using </span><span class="font2">igrep </span><span class="font17">in the natural way:</span></h6>
<p><span class="font2">my Stop = '</span><a href="http://perl.plover.com/'"><span class="font2">http://perl.plover.com/'</span></a><span class="font2">;</span></p>
<p><span class="font2">my Sinteresting = sub { shift; grep /~\QStop/o, @_ };</span></p>
<p><span class="font2" style="font-weight:bold;">my Surls = igrep_l { not S_[1]{TYPE} } traverse(Sinteresting, Stop);</span></p>
<p><span class="font2">while (my (Surl, Shead, Sreferrer) = NEXTVAL(Surls)) { print &quot;Page 'Sreferrer' has a bad link to 'Surl'\n&quot;;</span></p>
<p><span class="font2">}</span></p>
<h6><a name="bookmark272"></a><span class="font17">The </span><span class="font2">igrep_l </span><span class="font17">here is a variation on </span><span class="font2">igrep </span><span class="font17">that filters a sequence of list values instead of a sequence of scalar values:</span></h6>
<p><span class="font2">sub igrep_l (&amp;S) { my (Sis_interesting, Sit) = @_; return Iterator {</span></p>
<p><span class="font2">while (my @vals = NEXTVAL(Sit)) { return @vals if Sis_interesting-&gt;(@vals);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">return;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
<h6><a name="bookmark273"></a><span class="font17">Returning to the web spider, we might write:</span></h6>
<p><span class="font2">while (my (Surl, Shead, Sreferrer) = NEXTVAL(Surls)) { print &quot;Page 'Sreferrer' has a bad link to 'Surl'</span><span class="font2" style="font-weight:bold;">\</span><span class="font2">n&quot;; print &quot;Edit now? &quot;;</span></p>
<p><span class="font15">4.7 AN EXTENDED EXAMPLE: WEB SPIDERS</span></p>
<div>
<p><span class="font20">195</span></p>
</div><br clear="all">
<p><span class="font2">my Sresp = &lt;&gt;;</span></p>
<p><span class="font2">if (Sresp =- /~y/i) {</span></p>
<p><span class="font2">system SENV{EDITOR}, url_to_filename($referrer);</span></p>
<p><span class="font2">} elsif (Sresp =- /</span><span class="font1"><sup>A</sup></span><span class="font2">q/i) {</span></p>
<p><span class="font2">last;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">Note that if the user enters </span><span class="font2">quit </span><span class="font17">to exit the loop and go on with the rest of the program, this </span><span class="font17" style="font-style:italic;">doesn’t</span><span class="font17"> foreclose the possibility that sometime later, they might continue from where they left off.</span></p>
<p><span class="font17">We now have a library good enough to check for bad offsite links as well as bad intrasite links:</span></p>
<p><span class="font2">my Stop = '</span><a href="http://perl.plover.com/'"><span class="font2">http://perl.plover.com/'</span></a><span class="font2">;</span></p>
<p><span class="font2" style="font-weight:bold;">my Sinteresting = sub { my $ref = shift;</span></p>
<p><span class="font2" style="font-weight:bold;">$ref =</span><span class="font2">- </span><span class="font2" style="font-weight:bold;">/&quot;</span><span class="font2">\</span><span class="font2" style="font-weight:bold;">Q$top/o ? @_ : () };</span></p>
<p><span class="font2">my Surls = igrep_l { not S_[1]{TYPE} } traverse(Sinteresting, Stop);</span></p>
<p><span class="font2">while (my (Surl, Shead, Sreferrer) = NEXTVAL(Surls)) {</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">The only thing that has changed is the </span><span class="font2">Sinteresting </span><span class="font17">callback that determines which links are worth pursuing. Formerly, links were worth pursuing if they </span><span class="font17" style="font-style:italic;">pointed to</span><span class="font17"> a </span><a href="http://perl.plover.com/"><span class="font2">http://perl.plover.com/</span></a><span class="font2"> </span><span class="font17">page. Now they’re worth pursuing as long as they’re </span><span class="font17" style="font-style:italic;">referred to</span><span class="font17"> by some </span><a href="http://perl.plover.com/"><span class="font2">http://perl.plover.com/</span></a><span class="font2"> </span><span class="font17">page. The checker will investigate pages at other sites, but it won’t investigate the links on the pages at those sites.</span></p>
<p><span class="font17">This works well, but there’s a more interesting solution available. If we think about how we’re using the queue, we can see that the queue itself could be an iterator! We kick it periodically to produce another item for consideration by </span><span class="font2">traverse()</span><span class="font17">’s iterator, and then apply various transformations (</span><span class="font2">s/#.*S//</span><span class="font17">) and filters (</span><span class="font2">next if Sseen{Surl}++</span><span class="font17">) to the result. This is only going to get more complicated, so we’ll probably get a win if we can leverage the tools we’ve developed for dealing with such structures:</span></p>
<p><span class="font2">sub traverse {</span></p>
<p><span class="font2" style="font-weight:bold;">my $interesting_link;</span></p>
<p><span class="font2">Sinteresting_link = shift if ref S_[0] eq 'CODE';</span></p>
<div>
<p><span class="font20">196</span></p>
</div><br clear="all">
<p><span class="font15">CHAPTER 4 Iterators</span></p>
<p><span class="font2">my @queue = map [S_, 'supplied by user'], @_;</span></p>
<p><span class="font2">my %seen;</span></p>
<p><span class="font2" style="font-weight:bold;">my $q_it = igrep { ! $seen{$_-&gt;[0]}++ }</span></p>
<p><span class="font2" style="font-weight:bold;">imap { $_-&gt;[0] =</span><span class="font2">- </span><span class="font2" style="font-weight:bold;">s/#.*$//; $_}</span></p>
<p><span class="font2" style="font-weight:bold;">Iterator { return shift(@queue) };</span></p>
<p><span class="font2" style="font-weight:bold;">if ($interesting_link) {</span></p>
<p><span class="font2" style="font-weight:bold;">$q_it = igrep {$interesting_link-&gt;(@$_)} $q_it;</span></p>
<p><span class="font2" style="font-weight:bold;">}</span></p>
<p><span class="font2" style="font-weight:bold;">return imap {</span></p>
<p><span class="font2" style="font-weight:bold;">my ($url, $referrer) = @$_;</span></p>
<p><span class="font2">my (%head, Shtml);</span></p>
<p><span class="font2">@head{qw(TYPE LENGTH LAST_MODIFIED EXPIRES SERVER)} = head(Surl);</span></p>
<p><span class="font2">if (Shead{TYPE} =- m{~text/html\b}) {</span></p>
<p><span class="font2">Shtml = get(Surl);</span></p>
<p><span class="font2">push @queue,</span></p>
<p><span class="font2">map [$_, Surl],</span></p>
<p><span class="font2" style="font-weight:bold;">get_links($url, $html);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">return wantarray ? (Surl, \%head, Sreferrer, Shtml) : Surl;</span></p>
<p><span class="font2" style="font-weight:bold;">} $q_it;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">The innermost iterator, the one that actually accesses the queue, shifts the first item off, as before, and returns it. Applications of </span><span class="font2">imap </span><span class="font17">and </span><span class="font2">igrep </span><span class="font17">trim fragment anchors off the URL and filter out URLs that have been seen already. Inside of the callbacks, </span><span class="font2">S_-&gt;[0] </span><span class="font17">is the URL and </span><span class="font2">S_-&gt;[1] </span><span class="font17">is the referrer. </span><span class="font2">Sq_it </span><span class="font17">is the main queue iterator. </span><span class="font2">NEXTVAL(Sq_it) </span><span class="font17">will return the next URL/referrer pair that </span><span class="font2">traverse </span><span class="font17">should process.</span></p>
<p><span class="font17">If the user has supplied an </span><span class="font2">Sinteresting_link </span><span class="font17">function, we insert it into the queue iterator </span><span class="font2">Sq_it</span><span class="font17">, where it will discard uninteresting links. If not, we ignore it completely, rather than inserting the identity function as a placeholder. Another change here is that because </span><span class="font2">Sinteresting_link </span><span class="font17">is filtering the output of the queue iterator, it processes only one URL at a time, rather than an entire list.</span></p>
<p><span class="font17">The </span><span class="font2">Sinteresting_link </span><span class="font17">function will receive the same implicit </span><span class="font2">S_ </span><span class="font17">that the other segments of </span><span class="font2">Sq_it </span><span class="font17">do, but for convenience we also pass the URL and referrer via the usual </span><span class="font2">@_ </span><span class="font17">mechanism. Our earlier examples:</span></p>
<p><span class="font2"># Do not pursue links to other sites</span></p>
<p><span class="font2">my Sinteresting = sub { shift; grep /~\QStop/o, @_ };</span></p>
<p><span class="font2"># Do not pursue links my Sinteresting = sub</span></p>
<p><span class="font2">found on other sites</span></p>
<div>
<p><span class="font2">{ my Sref = shift;</span></p>
<p><span class="font2">Sref =- /~\QStop/o ? @_ : () };</span></p>
</div><br clear="all">
<p><span class="font17">now become:</span></p>
<ul style="list-style:none;"><li>
<p><span class="font2"># Do not pursue links to other sites</span></p></li></ul>
<p><span class="font2">my Sinteresting = sub { S_[0] = - /~\QStop/o };</span></p>
<ul style="list-style:none;"><li>
<p><span class="font2"># Do not pursue links found on other sites</span></p></li></ul>
<p><span class="font2">my Sinteresting = sub { S_[1] =- /~\QStop/o };</span></p>
<p><span class="font17">The main </span><span class="font2">while(@queue) { ... shift ©queue .. } </span><span class="font17">control is replaced with a call to </span><span class="font2">imap</span><span class="font17">, which maps the </span><span class="font2">head</span><span class="font17">, </span><span class="font2">get</span><span class="font17">, and queue updating behavior over </span><span class="font2">Sq_it</span><span class="font17">.</span></p>
<p><span class="font17">Note that although we’ve added some code to support the new style, we’ve also deleted corresponding old code, so that both versions of the function are about the same length. This is to be expected, since the two functions are doing the same thing.</span></p>
<p><span class="font19">4.7.3 </span><span class="font3">robots.txt</span></p>
<p><span class="font17">Let’s add one more feature, one not supported by </span><span class="font2">WWW::SimpleRobot</span><span class="font17">. Some sites don’t want to be walked by robots, or want to warn robots away from certain portions of their web space. For example, </span><span class="font2">/finance/admin/reports/ </span><span class="font17">might actually be a CGI program, and asking for the document at </span><span class="font2">/finance/admin/reports/2000/12/24/08.html </span><span class="font17">would actually execute the program, which would compile the appropriate report and return it. Rather than storing 87,000 reports on the disk, on the off-chance that someone might want one, they are generated on demand. This is a good strategy when normal usage patterns are to request only a few reports per day.</span></p>
<p><span class="font17">A web robot that blunders into this part of the HTML space can waste a lot of network bandwidth and processing time on both ends of the connection, requesting thousands of reports. In the worst case, the report space might be infinite, and the robot will never get out.</span></p>
<p><span class="font17">To prevent this sort of accident, many sites advertise lists of the parts of their web space that robots should stay away from. Each site stores its robot policy in a file named</span><span class="font2">/robots.txt</span><span class="font17">. Good robots respect the policy laid out in this file.<a name="footnote18"></a><sup><a href="#bookmark274">18</a></sup><sup></sup></span></p>
<p><span class="font17">Here is a segment of </span><a href="http://www.pathfinder.com/robots.txt"><span class="font2">http://www.pathfinder.com/robots.txt</span></a><span class="font17">:</span></p>
<p><span class="font2"># Welcome to Pathfinder’s robots.txt</span></p>
<p><span class="font2">#</span></p>
<p><span class="font2">#</span></p>
<ul style="list-style:none;"><li>
<p><span class="font2"># --------------------------</span></p></li></ul>
<p><span class="font2">User-agent: *</span></p>
<p><span class="font2">Disallow: /cgi-bin/</span></p>
<p><span class="font2">Disallow: /event.ng/</span></p>
<p><span class="font2">Disallow: /money/money101/</span></p>
<p><span class="font2">Disallow: /offers/cp/</span></p>
<p><span class="font2">Disallow: /FoodWine/images/</span></p>
<ul style="list-style:none;"><li>
<p><span class="font2"># Disallow: /FoodWine/trecipes/</span></p></li></ul>
<p><span class="font2">Disallow: /FoodWine/aspen/</span></p>
<p><span class="font2">User-agent: Mozilla</span></p>
<p><span class="font2">Disallow: /cgi-bin/Money/netc/story.cgi</span></p>
<p><span class="font2">User-agent: MSIECrawler</span></p>
<p><span class="font2">Disallow: /</span></p>
<p><span class="font17">Blank lines and lines beginning with </span><span class="font2"># </span><span class="font17">signs are comments and are ignored. </span><span class="font2">User-agent: * </span><span class="font17">marks the beginning of a section that applies to all robots. The </span><span class="font2">Disallow </span><span class="font17">lines are requests that robots not retrieve any documents whose URLs have any of the indicated prefixes. The sections at the bottom labelled </span><span class="font2">Mozilla </span><span class="font17">and </span><span class="font2">MSIECrawler </span><span class="font17">apply only to those browsers; other browsers can ignore them.</span></p>
<p><span class="font17">The Perl module </span><span class="font2">WWW::RobotRules </span><span class="font17">parses these files and returns an object that can be queried about the status of any URL:</span></p>
<p><span class="font2">my $rules = WWW::RobotRules-&gt;('Grasshopper/1.0');</span></p>
<p><span class="font2">Grasshopper/1.0 </span><span class="font17">is the name of our robot. This instructs the </span><span class="font2">WWW::RobotRules </span><span class="font17">object to pay attention to directives addressed to </span><span class="font2">Grasshopper/1.0</span><span class="font17">, and to ignore those addressed to </span><span class="font2">Mozilla</span><span class="font17">, </span><span class="font2">MSIECrawler</span><span class="font17">, and other browsers.</span></p>
<p><span class="font17">We add a set of rules to the object with the </span><span class="font2">-&gt;parse </span><span class="font17">method. It has two arguments: the contents of the </span><span class="font2">robots.txt </span><span class="font17">file, and the URL at which we found it. We can call </span><span class="font2">-&gt;parse </span><span class="font17">multiple times to add rules files for different sites. To query the object about a URL, we use </span><span class="font2">$rules-&gt;allowed($url)</span><span class="font17">. This returns true if the rules allow us to visit the URL, false otherwise.</span></p>
<p><span class="font17">We will use </span><span class="font2">igrep() </span><span class="font17">to add a filter to the queue iterator </span><span class="font2">$q_it</span><span class="font17">. The filter will check each URL against the currently known set of robot rules and will discard it unless the rules allow it. Additionally, if the URL appears to refer to a site that hasn’t been visited yet, the filter will attempt to load the </span><span class="font2">robots.txt </span><span class="font17">file from that site and add it to the current set of rules.</span></p>
<p><span class="font17">The filter callback will be manufactured by the following function:</span></p>
<p><span class="font2">use WWW::RobotRules;</span></p>
<p><span class="font2">use URI::URL;</span></p>
<p><span class="font2">sub make_robot_filter {</span></p>
<p><span class="font2">my $agent = shift;</span></p>
<p><span class="font2">my %seen_site;</span></p>
<p><span class="font2">my $rules = WWW::RobotRules-&gt;new($agent);</span></p>
<p><span class="font2">return sub {</span></p>
<p><span class="font2">my $url = url(shift());</span></p>
<p><span class="font2">return 1 unless $url-&gt;scheme eq 'http';</span></p>
<p><span class="font2">unless ($seen_site{$url-&gt;netloc}++) { my $robots = $url-&gt;clone;</span></p>
<p><span class="font2">$robots-&gt;path('/robots.txt');</span></p>
<p><span class="font2">$robots-&gt;frag(undef);</span></p>
<p><span class="font2">$rules-&gt;parse($robots, get($robots));</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">$rules-&gt;allowed($url)</span></p>
<p><span class="font2">};</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">We can’t simply use a single, named function, because the robot filter function needs to be able to capture private versions of the variables </span><span class="font2">$rules </span><span class="font17">and </span><span class="font2">%seen_site</span><span class="font17">, and named functions don’t capture properly. We could have embedded the robot filter closure as a private function inside of </span><span class="font2">traverse()</span><span class="font17">, but I felt that </span><span class="font2">traverse() </span><span class="font17">was getting a little too long.</span></p>
<p><span class="font17">We’re using the </span><span class="font2">URI::URL </span><span class="font17">module here, which provides convenience methods for parsing and constructing URLs. In the URL </span><a href="http://perl"><span class="font2">http://perl</span></a><span class="font2">. plover.com/perl.html#search</span><span class="font17">, </span><span class="font2">http </span><span class="font17">is the </span><span class="font17" style="font-style:italic;">scheme,</span><span class="font2"> perl.plover.com </span><span class="font17">is the </span><span class="font17" style="font-style:italic;">netloc, </span><span class="font2">/perl.html </span><span class="font17">is the </span><span class="font17" style="font-style:italic;">path,</span><span class="font17"> and </span><span class="font2">#search </span><span class="font17">is the </span><span class="font17" style="font-style:italic;">fragment.</span><span class="font2"> scheme</span><span class="font17">, </span><span class="font2">netloc</span><span class="font17">, </span><span class="font2">path, </span><span class="font17">and </span><span class="font2">frag </span><span class="font17">methods retrieve or set these sections of a URL. The </span><span class="font2">clone </span><span class="font17">method copies a URL object and returns a new object.</span></p>
<p><span class="font17">URLs for schemes other than </span><span class="font2">http </span><span class="font17">are always allowed by the filter, because other schemes don’t have any mechanisms analogous to </span><span class="font2">robots.txt</span><span class="font17">. You could make an argument that we should filter out </span><span class="font2">mailto </span><span class="font17">URLs and the like, but that would be more appropriately done by a different filter; this one is only about enforcing </span><span class="font2">robots.txt </span><span class="font17">rules.</span></p>
<p><span class="font17">If the URL is from a new site, as recorded in the private </span><span class="font2">%seen_site </span><span class="font17">hash, the filter constructs the URL for the </span><span class="font2">robots.txt </span><span class="font17">file and attempts to retrieve and parse it. It then consults the rules to decide whether the original URL will be discarded.</span></p>
<p><span class="font2">my $ROBOT_NAME = 'Grasshopper/1.0';</span></p>
<p><span class="font2">sub traverse {</span></p>
<p><span class="font2">my $interesting_link;</span></p>
<p><span class="font2">$interesting_link = shift if ref $_[0] eq 'CODE';</span></p>
<p><span class="font2">my @queue = map [$_, 'supplied by user'], @_;</span></p>
<p><span class="font2">my %seen;</span></p>
<p><span class="font2" style="font-weight:bold;">my $robot_filter = make_robot_filter($ROBOT_NAME);</span></p>
<p><span class="font2" style="font-weight:bold;">my $q_it = igrep { ! $seen{$_-&gt;[0]}++ &amp;&amp;&nbsp;$robot_filter-&gt;($_-&gt;[0]) } </span><span class="font2">imap { $_-&gt;[0] =- s/#.*$//; $_ }</span></p>
<p><span class="font2">Iterator { return shift(@queue) };</span></p>
<p><span class="font2">}</span></p>
<ul style="list-style:none;"><li>
<h5><a name="bookmark102"></a><span class="font19">4.7.4 Summary</span></h5></li></ul>
<p><span class="font17">The are only two major features of </span><span class="font2">WWW::SimpleRobot </span><span class="font17">that we’ve omitted. One is depth-first instead of breadth-first searching, which we’ve already seen is trivial to support; we just change </span><span class="font2">shift </span><span class="font17">to </span><span class="font2">pop </span><span class="font17">to turn the queue into a stack. With our iterator-structured queue, this is as simple as replacing:</span></p>
<p><span class="font2">Iterator { return shift(@queue) };</span></p>
<p><span class="font17">with:</span></p>
<p><span class="font2">$depth_first ? Iterator { return pop(@queue) } : Iterator { return shift(@queue) };</span></p>
<p><span class="font17">The other feature is the </span><span class="font2">depth </span><span class="font17">feature, which allows the user to tell </span><span class="font2">WWW::SimpleRobot </span><span class="font17">how far to pursue chains of links. If </span><span class="font2">depth </span><span class="font17">is 5, then the robot will visit all the pages that are reachable by a path of five or fewer links, but no pages that can be reached only by paths of six or more links.</span></p>
<p><span class="font17">With a sufficiently ingenious </span><span class="font2">$interesting_links </span><span class="font17">callback, we can emulate this feature in the current system. But we might want to add it to the </span><span class="font2">traverse() </span><span class="font17">function for convenience. This is also only a small change: add the link depth of each URL to the queue items. It will then be passed automatically to the </span><span class="font2">$interesting_links </span><span class="font17">callback, which can cut off deep searches by saying:</span></p>
<p><span class="font2">return unless $_-&gt;[2] &lt;&nbsp;$max_depth;</span></p>
<p><span class="font17">These are the missing features. On the other hand, </span><span class="font2">Grasshopper </span><span class="font17">supports </span><span class="font2">robots.txt</span><span class="font17">, a major benefit. It also has the feature that it can be incorporated into a larger program as an auxiliary component. </span><span class="font2">WWW::SimpleRobot </span><span class="font17">will tend to take over the behavior of any program it’s part of, because once you call the </span><span class="font2">WWW::SimpleRobot::traverse </span><span class="font17">function, you won’t get control back until it has traversed the entire site, which could be avery long time. </span><span class="font2">Grasshopper </span><span class="font17">never takes control for longer than it takes to retrieve one page (plus possibly the </span><span class="font2">robots.txt </span><span class="font17">file for a new site), and if the program wants to do something else afterwards, it can pick up where it left off.</span></p>
<p><span class="font17">I don’t want to make too much of the operational differences between these two modules. They both have serious defects stemming from the design of </span><span class="font2">LWP::Simple</span><span class="font17">. But I think there’s one other difference that’s worth pointing out: </span><span class="font2">Grasshopper </span><span class="font17">requires less than half as much code; one-third if you don’t count the code required to support </span><span class="font2">robots.txt </span><span class="font17">handling, which </span><span class="font2">WWW::SimpleRobot </span><span class="font17">doesn’t do.</span></p>
<p><span class="font17">Where did this benefit come from? The queue structure itself didn’t gain us much, because </span><span class="font2">WWW::SimpleRobot </span><span class="font17">is using the same queue technique that we are. The object-oriented style of</span><span class="font2">WWW::SimpleRobot </span><span class="font17">imposes some overhead; with the functional approach there are no classes to declare. Some of the extra code in </span><span class="font2">WWW::SimpleRobot </span><span class="font17">is to support diagnostics, which shouldn’t count, because I omitted diagnostics from the iterator module. (On the other hand, a 49-line module probably doesn’t need many diagnostics.)</span></p>
<p><span class="font17">Probably the greatest contributor to overhead is option checking. With the functional approach, the module hardly supports any options directly. </span><span class="font2">WWW::SimpleRobot </span><span class="font17">has all its options on the inside. To support a new option, we have to attach it inside the module. </span><span class="font2">Grasshopper </span><span class="font17">is a module that has been turned inside out, all of its useful hooks are exposed to the caller, who can apply whatever options they want afterwards via functions like </span><span class="font2">igrep</span><span class="font17">.</span></p>
<p><span class="font14">CHAPTER</span></p>
<h3><a name="bookmark103"></a><span class="font25">FROM RECURSION</span></h3>
<h3><span class="font25">TO ITERATORS</span></h3>
<p><span class="font17">We’ve already seen that iterators are useful when a source of data is prepared to deliver more data than we want, or when it takes a long time to come up with each data item and we don’t want to waste time by computing more of them than we need to.</span></p>
<p><span class="font17">Both conditions occur frequently in conjunction with recursive functions. Recursive functions are often used for searching large, hierarchical spaces for solutions to some specification. If solutions are common, the space will contain more of them than we want to use; if solutions are rare, they will take a long time to find. In either case, we don’t want our program to have to populate an array with all the possible solutions before it can continue, and it is natural to use an iterator.</span></p>
<p><span class="font17">We saw another reason to get rid of recursion in the web robot example in Chapter 4: Recursive functions naturally perform depth-first searches. When this is inappropriate, as for a web robot, recursion offers no escape. With an iterator solution, we can order the queue any way we like or even reorder it dynamically when new information arrives.</span></p>
<p><span class="font17">But recursive functions are often easy to write, whereas iterators seemed to require ingenuity. In this chapter, we’ll look at techniques for transforming general recursive functions into iterators.</span></p>
<p><span class="font20">204 </span><span class="font15">CHAPTER 5 From Recursion to Iterators</span></p>
<ul style="list-style:none;"><li>
<h5><a name="bookmark104"></a><span class="font18">5.1 THE PARTITION PROBLEM REVISITED</span></h5></li></ul>
<p><span class="font17">As our prototypical example of such a problem, we’re going to look at the </span><span class="font17" style="font-style:italic;">partition problem,</span><span class="font17"> which we saw in Chapters 1 and 3. This is a simple but common problem that arises in many contexts, most commonly in optimization and operations research problems.</span></p>
<p><span class="font17">Recall that in the partition problem, we are given a list of treasures, each with a known value, and a target value, which represents the share of the treasures that we are trying to allocate to someone whom we will call the wizard. The question is whether there is any collection of treasures that will add up to the wizard’s share exactly, and if so, which treasures?</span></p>
<p><span class="font17">One runs into this problem and closely related problems everywhere. For example, I once was talking to Jonathan Hoefler, owner of the Hoefler Type Foundry. Hoefler needed to produce type samples for his catalog. For each font, he needed to find an English word or phrase that would fit in a column </span><span class="font17" style="font-style:italic;">exactly </span><span class="font17">3.25 inches wide. He had a dictionary, and could compute a table of the length of each word. For large font sizes, this was enough, because a single word such as “Hieroglyph” or “Cherrypickers” at 48- or 42-point size (respectively) would exactly fill the column; solving the problem for large sizes is a simple matter of scanning the table for the single word closest in size to 3.25 inches. But the same column must accommodate fonts of all sizes, from large to small, and there is no word that is 3.25 inches wide when set in 20-point type. Several words have to be put together to add up to the required length. For 20-point type, the example is “The Defenestration of Prague.”<a name="footnote19"></a><sup><a href="#bookmark275">19</a></sup><sup></sup> (See Figure 5.1.)</span></p>
<p><span class="font17">In regular text, the typesetter will expand the spaces between words slightly to take up extra space when needed, or will press the words more closely together. In ordinary typesetting, this is acceptable. But in a font specimen catalog, the font designer wants everything to look perfect, and the spacing has to be just so. The designer wants to pick text, which, when spaced in the most natural way, happens to fill the column as exactly as possible.</span></p>
<p><span class="font17">The problem of finding words to fit as perfectly as possible into the space in a font specimen catalog is very similar to the partition problem we saw in Chapter 3. The differences are that some allowance has to be made in the programming to handle appropriate inter-word space that follows every word but the last, that</span></p><a name="caption2"></a>
<h1><a name="bookmark276"></a><span class="font31" style="font-style:italic;">SEL</span><span class="font5"> h vc-</span><span class="font31" style="font-style:italic;">UNE Remy</span></h1>
<p><span class="font29" style="font-style:italic;">I)</span><span class="font5"> I \. S / </span><span class="font29" style="font-style:italic;">ferrol </span><span class="font5">IAS If A </span><span class="font29" style="font-style:italic;">Mailresse</span></p>
<p><span class="font5">I </span><span class="font29" style="font-style:italic;">III</span><span class="font5"> I /) \ A </span><span class="font29" style="font-style:italic;">Hieroglyph </span><span class="font28" style="font-style:italic;">COLLEGIAN Cherrypickers </span><span class="font26" style="font-style:italic;">CONGRESSMEN Baroque Musicians <sup>1 </sup></span><span class="font24" style="font-style:italic;">RELINQUISHMENTS Wilsons Fourteen Points <sup>4P </sup></span><span class="font23" style="font-style:italic;">AQUEDUCT DESIGNED The Defenestration of Prague “<sup>pt </sup></span><span class="font17" style="font-style:italic;">HMS BRITANNIA SETS SAIL FOR Works of the Impressionists 1885-1912 &nbsp;&nbsp;<sup>16 pt</sup></span></p>
<p><span class="font17" style="font-style:italic;">THE REIGNS OF THE GREAT KINGS Thefew remaining examples of Pompeian</span></p>
<p><span class="font17" style="font-style:italic;">EDWARD VIII, FIRST ROYAL SOVEREIGN </span><span class="font2" style="font-style:italic;">Ceramics from the site date to late in this century </span><span class="font17">™ pt </span><span class="font15" style="font-style:italic;">THE WORKS OF SAMUEL TAYLOR COLERIDGE An excavation at Herculaneum revealed an odd example</span><span class="font17"> 10 <sub>P</sub>t </span><span class="font15" style="font-style:italic;">WILHELM FRIEDALANN BACH WAS FOREMOST AMONG The copy from type specimen books is not traditionally entertaining</span></p>
<p><span class="font12" style="font-weight:bold;">MUSE N* I HTF DIDOT LIGHT ITALIC XVII </span><span class="font14">FIGURE 5.1 </span><span class="font16">A page from Hoefler’s type specimen catalog.</span></p>
<p><span class="font17">words may be re-used, and that it is permissible to miss the target value by a small amount.</span></p>
<p><span class="font17">Another related problem is how to back up your files from your hard disk onto floppy diskettes, using as few diskettes as possible. It is not permitted to split any file across two or more diskettes. This problem was intensely interesting to me in 1986, because the file backup program for my Macintosh did have just these restrictions, and as a penurious college student, I couldn’t afford to buy lots of diskettes.</span></p>
<p><span class="font17">We’ve seen the code for a recursive version of this problem already. It looks like this:</span></p>
<p><span class="font2">sub find_share {</span></p>
<p><span class="font2">my (Starget, Streasures) = @_;</span></p>
<p><span class="font2">return [] if Starget == 0;</span></p>
<p><span class="font2">return if Starget &lt;&nbsp;0 || @Streasures == 0;</span></p>
<p><span class="font2">my (Sfirst, @rest) = @Streasures;</span></p>
<p><span class="font2">my Ssolution = find_share(Starget-Sfirst, </span><span class="font2" style="font-weight:bold;">\</span><span class="font2">@rest);</span></p>
<p><span class="font2">return [Sfirst, @Ssolution] if Ssolution;</span></p>
<p><span class="font2">return &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;find_share(Starget &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;, </span><span class="font2" style="font-weight:bold;">\</span><span class="font2">@rest);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">This function returns an array of treasures that add up to the target sum, if there is such a solution, and </span><span class="font2">undef </span><span class="font17">if there is no solution.</span></p>
<ul style="list-style:none;"><li>
<h5><a name="bookmark105"></a><span class="font19">5.1.1 Finding All Possible Partitions</span></h5></li></ul>
<p><span class="font17">We could easily modify it to return </span><span class="font17" style="font-style:italic;">all</span><span class="font17"> possible solutions, instead of only one:</span></p>
<div>
<p><span class="font9" style="font-weight:bold;">CODE LIBRARY</span></p>
</div><br clear="all">
<p><span class="font2">sub partition {</span></p>
<p><span class="font0">P<sup>arti</sup>t<sup>io</sup>n-<sup>al1</sup> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="font2">my (Starget, Streasures) = @_;</span></p>
<p><span class="font2">return [] if Starget == 0;</span></p>
<p><span class="font2" style="font-weight:bold;">return () if Starget &lt;&nbsp;0 || ©Streasures == 0;</span></p>
<p><span class="font2">my (Sfirst, @rest) = ©Streasures;</span></p>
<p><span class="font2" style="font-weight:bold;">my ©solutions = partition(Starget-Sfirst, \©rest);</span></p>
<p><span class="font2" style="font-weight:bold;">return ((map {[Sfirst, ©$_]} ©solutions), partition(Starget, \©rest));</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">Why might we want to do such a thing? Suppose we’re trying to allocate shares to several people, say a wizard, a barbarian, and a plumber, out of the same pool</span></p>
<p><span class="font17">of treasure. First we allocate the wizard’s share. There might be several ways to do this, so we choose one. Next we want to allocate the barbarian’s share, but we find that there’s no way to do this. It might be that if we had allocated the wizard’s share differently, we wouldn’t have gotten into trouble over the barbarian’s share later. When we find out that we can’t allocate the barbarian’s share correctly, we want to </span><span class="font17" style="font-style:italic;">backtrack</span><span class="font17"> and try the wizard’s share in a different way.</span></p>
<p><span class="font17">Here’s a particularly simple example: Suppose that there are four treasures worth 1, 2, 3, and 4. The wizard is owed treasures worth 5 gold pieces, and the barbarian is owed 3. If we give treasures 2 and 3 to the wizard, we foreclose the only possible solutions for the barbarian. We need to backtrack and try a different distribution of treasures; in this case we should give treasures 1 and 4 to the wizard, and treasure 3 to the barbarian. (The plumber works for union scale and is paid by the hour.)</span></p>
<p><span class="font17">The preceding partition function delivers all possible shares for the wizard; so if we try </span><span class="font2">[2,3] </span><span class="font17">and discover that this causes problems later for the barbarian, we can backtrack and try the other solution, </span><span class="font2">[1,4]</span><span class="font17">, instead.</span></p>
<p><span class="font17">But this function has a serious problem that we might have foreseen: Even simple instances of the partition problem often have many different solutions. For example, the call </span><span class="font2">partition(105, [1..20]) </span><span class="font17">generates 15,272 solutions. Since we probably won’t need to find all these solutions, we would like to convert this function to an iterator.</span></p>
<p><span class="font17">In Chapter 4, we saw a technique for doing this. It involved replacing the implicit recursion stack with an explicit queue, and appeared to require ingenuity. But it turns out that this technique always works, and doesn’t require much ingenuity at all.</span></p>
<p><span class="font17">This tactic for turning a recursive function into an iterator is to have the iterator retain an agenda<a name="footnote20"></a><sup><a href="#bookmark277">20</a></sup><sup></sup> or to-do list of partially-complete partition attempts that it has not yet investigated. Each time we invoke the iterator, it will remove an item from the to-do list and investigate it. If the item represents a solution to the problem, the iterator will return it immediately. If the item requires further investigation, the iterator will investigate it a little further, possibly producing some new partially-investigated items, which it will put onto the to-do list be investigated later, and will continue to look through the agenda for solutions. If the agenda is exhausted before a solution is found, the iterator will report failure. Since the agenda is part of the iterator’s state, the iterator can return a solution to its caller, and the agenda state will remain intact until the next time the iterator is called.</span></p>
<p><span class="font17">We saw several examples of this approach, including the web spider, in Chapter 4.</span></p>
<p><span class="font17">For this problem, each item in the queue must contain the following information:</span></p>
<ul style="list-style:none;"><li>
<p><span class="font17">• &nbsp;&nbsp;A current target sum</span></p></li>
<li>
<p><span class="font17">• &nbsp;&nbsp;The </span><span class="font17" style="font-style:italic;">pool</span><span class="font17"> of treasures still available for use</span></p></li>
<li>
<p><span class="font17">• &nbsp;&nbsp;The </span><span class="font17" style="font-style:italic;">share</span><span class="font17"> containing the treasures already allocated toward the target</span></p></li></ul>
<p><span class="font17">In general, with this technique, each agenda item must contain all the information that would have been passed as arguments to the recursive version of the function.</span></p>
<div>
<p><span class="font9" style="font-weight:bold;">CODE LIBRARY</span></p>
</div><br clear="all">
<div>
<p><span class="font0">partition-it</span></p>
</div><br clear="all">
<p><span class="font2">sub make_partitioner {</span></p>
<p><span class="font2">my (Sn, Streasures) = @_;</span></p>
<p><span class="font2">my @todo = [Sn, Streasures, []];</span></p>
<p><span class="font17">Initially, the queue contains only one item that the iterator must investigate: The target sum is </span><span class="font2">Sn</span><span class="font17">, the number originally supplied by the user; the pool contains all the treasures; the share is empty. The iterator will move treasures from the pool to the share, deducting their values from the target, until the target is zero.</span></p>
<p><span class="font2">sub {</span></p>
<p><span class="font2">while (@todo) {</span></p>
<p><span class="font2">my Scur = pop @todo;</span></p>
<p><span class="font2">my (Starget, Spool, Sshare) = @Scur;</span></p>
<p><span class="font17">Here the iterator extracts the tail item from the agenda. This is the “current” item that it must investigate. The iterator extracts the target sum, the available pool of treasures, and the list of treasures already allocated to the share. The presence of this item in the to-do list indicates that if some subset of the treasures in </span><span class="font2">Spool </span><span class="font17">can be made to add up to </span><span class="font2">Starget</span><span class="font17">, then those treasures, plus the ones in </span><span class="font2">Sshare</span><span class="font17">, constitute a solution to the original problem.</span></p>
<p><span class="font17">The iterator can return under two circumstances. If it finds that the current item represents a solution, it will return the solution immediately. But if the agenda is exhausted before this occurs, then there is nothing left to investigate, there are no more solutions, and the iterator will immediately return failure.</span></p>
<p><span class="font2">if (Starget == 0) { return Sshare }</span></p>
<p><span class="font15">5.1 THE PARTITION PROBLEM REVISITED</span></p>
<div>
<p><span class="font20">209</span></p>
</div><br clear="all">
<p><span class="font17">If the target sum is zero, the current share is already a winner. The iterator returns it immediately. Any items that are still uninvestigated remain on the to-do list, awaiting the next call to the iterator.</span></p>
<p><span class="font2">next if Starget &lt;&nbsp;0 || @$pool == 0;</span></p>
<p><span class="font17">On the other hand, if the target is negative, the current item is hopeless, and the iterator should immediately discard it and investigate another item; similarly if the pool of treasures in the current item has been exhausted. The </span><span class="font2">next </span><span class="font17">restarts the </span><span class="font2">while </span><span class="font17">loop from the top, which begins by extracting a new current item from the agenda.</span></p>
<p><span class="font17">With these simple cases out of the way, the bulk of the code follows:</span></p>
<p><span class="font2">my (Sfirst, @rest) = @Spool;</span></p>
<p><span class="font2">push @todo, [Starget-Sfirst, \@rest, [@Sshare, Sfirst]],</span></p>
<p><span class="font2">[Starget &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;, \@rest, &nbsp;&nbsp;Sshare &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;];</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">In the typical case, the current item has two sub-items that must be investigated separately: Either the first treasure in the pool is included in the share, and the target is smaller, or it isn’t included, and the target is the same. For example, to satisfy </span><span class="font2">(28, [10,18,27], [1]) </span><span class="font17">we can either investigate </span><span class="font2">(18, [18,27], [1,10]) </span><span class="font17">or we can investigate </span><span class="font2">(28, [18,27], [1])</span><span class="font17">.</span></p>
<p><span class="font17">The iterator appends the two new items to the end of the queue and returns to the top of the </span><span class="font2">while </span><span class="font17">loop to investigate another item.</span></p>
<p><span class="font2">return undef;</span></p>
<p><span class="font2">} # end of anonymous iterator function</span></p>
<p><span class="font2">} # end of make_partitioner</span></p>
<p><span class="font17">If the to-do list is exhausted, the </span><span class="font2">while </span><span class="font17">loop exits, and the iterator returns </span><span class="font2">undef </span><span class="font17">to indicate failure.</span></p>
<ul style="list-style:none;"><li>
<h5><a name="bookmark106"></a><span class="font19">5.1.2 Optimizations</span></h5></li></ul>
<p><span class="font17">There are a few obvious ways to improve the preceding code. Suppose the current item is </span><span class="font2">[12, [12, ...], [...]]</span><span class="font17">. The function then constructs two new items, </span><span class="font2">[0, [...], [..., 12]] </span><span class="font17">and </span><span class="font2">[12, [...], [...]]</span><span class="font17">, and pushes them onto the end of the to-do list. But the first item is obviously a solution (because its target</span></p>
<div>
<p><span class="font20">210</span></p>
</div><br clear="all">
<p><span class="font15">CHAPTER 5 From Recursion to Iterators</span></p>
<p><span class="font17">sum is 0), so there’s no point in putting it on the end of the queue and working through every other item on the queue looking for a different solution; clearly we should return it right away.</span></p>
<p><span class="font17">Similarly, if the function constructs an item that is obviously useless, it could throw it away immediately rather than putting it on the queue to be thrown away later:</span></p>
<div>
<p><span class="font9" style="font-weight:bold;">CODE LIBRARY</span></p>
</div><br clear="all">
<p><span class="font2">sub make_partitioner {</span></p>
<p><span class="font0">partition-it-opt &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="font2">my (Sn, Streasures) = @_;</span></p>
<p><span class="font2">my @todo = [Sn, Streasures, []];</span></p>
<p><span class="font2">sub {</span></p>
<p><span class="font2">while (@todo) {</span></p>
<p><span class="font2">my Scur = pop @todo;</span></p>
<p><span class="font2">my (Starget, Spool, Sshare) = @Scur;</span></p>
<p><span class="font2">if (Starget == 0) { return Sshare } next if Starget &lt;&nbsp;0 || @Spool == 0;</span></p>
<p><span class="font2">my (Sfirst, @rest) = @Spool;</span></p>
<p><span class="font2" style="font-weight:bold;">push @todo, [Starget, \@rest, Sshare ] if @rest;</span></p>
<p><span class="font2" style="font-weight:bold;">if (Starget == Sfirst) { return [@Sshare, Sfirst];</span></p>
<p><span class="font2" style="font-weight:bold;">} elsif (Starget &gt;&nbsp;Sfirst &amp;&amp;&nbsp;@rest) { push @todo, [Starget-Sfirst, \@rest, [@Sshare, Sfirst]],</span></p>
<p><span class="font2" style="font-weight:bold;">}</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">return undef;</span></p>
<p><span class="font2">} # end of anonymous iterator function</span></p>
<p><span class="font2">} # end of make_partitioner</span></p>
<p><span class="font17">The first new line here appends to the queue what was previously the second new item. But here it’s conditionalized: The item is placed on the queue only if its treasure pool will still contain an unused item. If its pool is empty, then it can’t possibly result in a solution, so the function discards it immediately.</span></p>
<p><span class="font17">The following </span><span class="font2">if-elsif </span><span class="font17">block handles what was previously the first new item. The function is about to put the first treasure into the share and to subtract its size from the target sum. But unlike the previous version of the code, here it puts the new item on the queue only if the size of the first treasure is smaller than the target sum. If the first treasure is equal to the target sum, then the item it is about to put on the queue is actually a solution to the problem, so the iterator returns it immediately instead of queuing it. Conversely, if the first treasure is larger than the target sum, then the item the iterator was about to queue would have had a negative target sum, and would have been discarded the next time it was encountered; instead, the iterator never puts it in the queue at all. The </span><span class="font2">&amp;&amp;&nbsp;©rest </span><span class="font17">condition makes sure the iterator doesn’t queue an item with a positive target sum and an empty pool, which is guaranteed to fail.</span></p>
<p><span class="font17">It’s tempting to remove the:</span></p>
<p><span class="font2">if (Starget == 0) { return $share } next if Starget &lt;&nbsp;0 || ©Spool == 0;</span></p>
<p><span class="font17">lines now. They’re much less useful, since the cases they check for are all detected at the bottom of the loop, and items that have </span><span class="font2">Starget &lt;= 0 </span><span class="font17">or </span><span class="font2">©Spool == 0 </span><span class="font17">aren’t put into the queue to begin with. The only cases they do catch are when such items are placed directly into the queue by the caller of </span><span class="font2">make_partitioner</span><span class="font17">.</span></p>
<p><span class="font17">There are at least three ways we can deal with this. We can leave the checks in place. We can remove the checks and document the resulting deficiency in the function: If the initial value of </span><span class="font2">Sn </span><span class="font17">is 0, the iterator fails to report the empty solution. (Even with the extra checks, the function has a few boundary condition errors of this type. For example, it reports only three of the eight possible solutions to </span><span class="font2">make_partitioner(0, [0,0,0])</span><span class="font17">.) Or we can remove the checks and add preprocessing code that works around the bug. For example:</span></p>
<p><span class="font2">sub make_partitioner {</span></p>
<p><span class="font2">my (Sn, Streasures) = ©_;</span></p>
<p><span class="font2" style="font-weight:bold;">my @todo = Sn ? [$n, Streasures, []] : [$n, [], []]; </span><span class="font2">sub { }</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">If </span><span class="font2">make_partitioner </span><span class="font17">sees that we’re about to exercise the bug, which occurs only for </span><span class="font17" style="font-style:italic;">n =</span><span class="font17"> 0 and a nonempty treasure pool, it silently adjusts the pool behind the scenes to a case that </span><span class="font17" style="font-style:italic;">will</span><span class="font17"> produce the correct answer.</span></p>
<p><span class="font17">These three tactics are presented in increasing order of “cleverness.” Such cleverness should be used only when necessary, since it requires a corresponding application of cleverness on the part of the maintenance programmer eight weeks later, and such cleverness may not be available.</span></p>
<ul style="list-style:none;"><li>
<h5><a name="bookmark107"></a><span class="font19">5.1.3 Variations</span></h5></li></ul>
<p><span class="font17">The space searched by this function is organized like a tree:</span></p>
<p><span class="font11">6 [2346] []</span></p>
<p><span class="font2">=1_</span></p>
<div style="border:solid;">
<p><span class="font11">4 [346] [2]</span></p>
</div><br clear="all">
<p><span class="font11">6 [346]</span></p>
<p><span class="font11">[]</span></p>
<div style="border:solid;">
<p><span class="font11">1</span></p>
<p><span class="font11">[46]</span></p>
<p><span class="font11">[23]</span></p>
</div><br clear="all">
<div>
<p><span class="font11">4 [46] [2]</span></p>
</div><br clear="all">
<div>
<p><span class="font2">_CZ</span></p>
<p><span class="font11">-3</span></p>
<p><span class="font11">[6]</span></p>
<p><span class="font11">[234]</span></p>
</div><br clear="all">
<div>
<p><span class="font11">1</span></p>
<p><span class="font11">[6]</span></p>
<p><span class="font11">[23]</span></p>
</div><br clear="all">
<div>
<p><span class="font21">c;</span></p>
<p><span class="font11">0</span></p>
<p><span class="font11">[6]</span></p>
<p><span class="font11">[24]</span></p>
</div><br clear="all">
<div>
<p><span class="font14" style="font-variant:small-caps;">Zl_</span></p>
<p><span class="font11">4</span></p>
<p><span class="font11">[6]</span></p>
<p><span class="font11">[2]</span></p>
</div><br clear="all">
<div>
<p><span class="font2">__(ZZ</span></p>
<p><span class="font11">-5</span></p>
<p><span class="font11">[]</span></p>
<p><span class="font11">[236]</span></p>
</div><br clear="all">
<div>
<p><span class="font2">ZZ)__</span></p>
<p><span class="font11">1</span></p>
<p><span class="font11">[]</span></p>
<p><span class="font11">[23]</span></p>
</div><br clear="all">
<div>
<p><span class="font11">-2</span></p>
<p><span class="font11">[]</span></p>
<p><span class="font11">[26]</span></p>
</div><br clear="all">
<div>
<p><span class="font11">4 [] [2]</span></p>
</div><br clear="all">
<div>
<table border="1">
<tr><td></td><td>
<p><span class="font11" style="text-decoration:underline;">i</span></p>
<p><span class="font11">3 [46] [3]</span></p></td></tr>
<tr><td>
<p><span class="font11" style="text-decoration:underline;">r</span></p></td><td>
<p><span class="font7" style="font-style:italic;">-A</span></p></td></tr>
<tr><td style="vertical-align:bottom;">
<p><span class="font11">-1</span></p></td><td style="vertical-align:bottom;">
<p><span class="font11">3</span></p></td></tr>
<tr><td style="vertical-align:bottom;">
<p><span class="font11">[6]</span></p></td><td style="vertical-align:bottom;">
<p><span class="font11">[6]</span></p></td></tr>
<tr><td>
<p><span class="font11">[34]</span></p></td><td>
<p><span class="font11">[3]</span></p></td></tr>
</table>
<p><span class="font11">-3</span></p>
<p><span class="font11">[]</span></p>
<p><span class="font11">[36]</span></p>
<p><span class="font11">3 [] [3]</span></p>
</div><br clear="all">
<div>
<p><span class="font11">6</span></p>
<p><span class="font11">[46] []</span></p>
<p><span class="font11">2</span></p>
<p><span class="font11">[6]</span></p>
<p><span class="font11">[4]</span></p>
</div><br clear="all">
<div style="border:solid;">
<p><span class="font11">-4</span></p>
<p><span class="font11">[]</span></p>
<p><span class="font11">[46]</span></p>
</div><br clear="all">
<div>
<p><span class="font2">Zl_</span></p>
<p><span class="font11">2</span></p>
<p><span class="font11">[]</span></p>
<p><span class="font11">[4]</span></p>
</div><br clear="all">
<div>
<p><span class="font2">ZL_ </span><span class="font11">6 [6] []</span></p><img src="HigherOrderPerl_files/HigherOrderPerl-30.jpg" alt="" style="width:21pt;height:14pt;">
<p><span class="font11">0 [] [6]</span></p>
</div><br clear="all">
<div>
<p><span class="font11">6</span></p>
<p><span class="font11">[]</span></p>
<p><span class="font11">[]</span></p>
</div><br clear="all">
<p><span class="font17">Each node of this tree represents one of the items that the partitioner investigates, showing the target sum, the pool, and the share so far. For example, the root node represents an item with a target sum of 6, a pool containing 2, 3, 4, and 6, and an empty share. The root node is the item that the user of </span><span class="font2">make_partitioner </span><span class="font17">first inserted into the to-do list. Each node has two child nodes, which are the two derived items: one moves the first treasure from pool to share and subtracts it from the target sum, and the other removes the first treasure from the pool and discards it without changing the share or the target sum. The leaf nodes are those from which no further searching is done, because the pool is empty (bottom row) or the target sum is too small.</span></p>
<p><span class="font17">The partitioner always searches a node before searching its children, so it searches the tree in a generally top-to-bottom order. In fact, the version we saw first searches the nodes in depth-first order, visiting the root node, then the nodes down the leftmost branch, then the three nodes just to the right of the leftmost branch, and so on.</span></p>
<p><span class="font17">The second version of the partitioner saves time by refusing to investigate items that it sees will be leaves, effectively searching the smaller tree of Figure 5.2 instead.</span></p><img src="HigherOrderPerl_files/HigherOrderPerl-31.jpg" alt="" style="width:256pt;height:211pt;">
<p><span class="font14">FIGURE 5.2 </span><span class="font16">The search space of </span><span class="font2">partition(6, [2,3,4,6])</span><span class="font16">, pruned.</span></p>
<p><span class="font17">Whether to choose breadth- or depth-first search depends on the nature of the problem. Each has major contraindications. </span><span class="font17" style="font-style:italic;">Depth-first search (DFS)</span><span class="font17"> tends to yield shorter to-do lists. In any depth-first search of a tree, if each node in the tree has no more than </span><span class="font17" style="font-style:italic;">n</span><span class="font17"> children, and the depth of the tree is </span><span class="font17" style="font-style:italic;">d</span><span class="font17"> nodes, then the to-do list will contain at most (</span><span class="font17" style="font-style:italic;">n</span><span class="font3"> — </span><span class="font17">1)(</span><span class="font17" style="font-style:italic;">d</span><span class="font3"> — </span><span class="font17">1) </span><span class="font3">+ </span><span class="font17">1 items at any time. For the partition problem, </span><span class="font17" style="font-style:italic;">n</span><span class="font17"> is 2, and </span><span class="font17" style="font-style:italic;">d</span><span class="font17"> is no more than the number of items in the original pool. So in depth-first search, the to-do list will never exceed the size of the original pool.</span></p>
<p><span class="font17">In contrast, </span><span class="font17" style="font-style:italic;">breadth-first search (BFS)</span><span class="font17"> can sometimes lead to enormous to-do lists. The tree is searched top-down, and if all the solutions are in the leaves, each interior tree node must be put on the to-do list and taken off again before the search reaches the leaves where the solutions are. In the unpruned partition search example, shown on page 212, breadth-first search starts with the root node on the agenda, then removes it and replaces it with the two second-level nodes, then removes these and replaces them with the four third-level nodes, then replaces these with the eight fourth-level nodes. These are eventually replaced with the ten fifth-level nodes; if the problem had been bigger, there would have been sixteen fifth-level nodes instead of only ten. Breadth-first search may be contraindicated when the tree branches rapidly or when the solutions are all to be found among the leaves. Depth-first search, which dives straight down to where the solutions are, may be a better choice.</span></p>
<p><span class="font17">For some applications, however, depth-first search is a loser. Web spidering is one of these. I was once teaching a class in which one of the students decided to write a web spider. The central control of his program was a recursive function, something like this:</span></p>
<p><span class="font2">sub handle_page { my $url = shift; get the document from the network; if (the document is HTML) { parse it;</span></p>
<p><span class="font2">extract the links;</span></p>
<p><span class="font2">for (links) {</span></p>
<p><span class="font2">handle_page($_);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">Because the function was recursive, it naturally did a depth-first search on the web space. The result was completely useless. The spider started by reading the initial page and making a list of all the links from that first page. Then it followed the first link on the first page and made a list of all the links on the second page. Then it followed the first link on the second to a third page and made a list of all the links on that page, and so on. The spider went dashing off toward the horizon, never to return, except perhaps by accident. Clearly this wasn’t particularly useful. This is the major contraindication for depth-first search: a very large, or infinite search space.</span></p>
<p><span class="font17">To see a particularly simple example of this, consider a search for strings of the letters </span><span class="font2">A, B, </span><span class="font17">and </span><span class="font2">C </span><span class="font17">that read the same forwards as backwards (see Figure 5.3). We might imagine a search of the space of all strings.</span></p><img src="HigherOrderPerl_files/HigherOrderPerl-32.jpg" alt="" style="width:347pt;height:103pt;">
<p><span class="font14">FIGURE 5.3 </span><span class="font16">Searching for palindromes in the space of all strings.</span></p>
<p><span class="font17">Breadth-first search eventually finds all the desired strings, in order by length: </span><span class="font2">&quot;&quot;, &quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;AA&quot;, &quot;BB&quot;, &quot;CC&quot;, &quot;AAA&quot;, &quot;ABA&quot;, &quot;ACA&quot;, &quot;BAB&quot;, ...</span><span class="font17">.</span></p>
<p><span class="font17">Depth-first search, however, goes diving down the leftmost branch, finding </span><span class="font2">&quot;&quot;, &quot;A&quot;, &quot;AA&quot;, &quot;AAA&quot;, &quot;AAAA&quot;... </span><span class="font17">and never even looking at any branches that contain </span><span class="font2">B</span><span class="font17">s or </span><span class="font2">C</span><span class="font17">s.</span></p>
<ul style="list-style:none;"><li>
<h5><a name="bookmark108"></a><span class="font18">5.2 HOW TO CONVERT A RECURSIVE FUNCTION TO AN ITERATOR</span></h5></li></ul>
<p><span class="font17">We’ve seen several such techniques, including the odometer method and the agenda method. It appears that these took some ingenuity to find. What if they don’t happen to work for a particular function, and you don’t have enough ingenuity that day to find something that does work?</span></p>
<p><span class="font17">It turns out that that won’t happen, because the agenda method </span><span class="font17" style="font-style:italic;">always</span><span class="font17"> works. This is because we can consider every recursive function to be doing a tree search!</span></p>
<p><span class="font17">Ordinary function call semantics create a notional tree of function calls. Imagine that we have a node for each time a function is called, and node </span><span class="font17" style="font-style:italic;">A</span><span class="font17"> is the parent node of </span><span class="font17" style="font-style:italic;">B</span><span class="font17"> when the function invocation represented by </span><span class="font17" style="font-style:italic;">A</span><span class="font17"> is responsible for invoking the function represented by </span><span class="font17" style="font-style:italic;">B</span><span class="font17">. The root node is the main program, which is started by some agency outside of the program itself. A simple program like this:</span></p>
<p><span class="font2">#!/usr/bin/perl</span></p>
<p><span class="font2">Sdata = read_the_input();</span></p>
<p><span class="font2">Sresult = process_the_data($data);</span></p>
<p><span class="font2">print_the_output(Sresult);</span></p>
<p><span class="font17">evolves the simple tree depicted below. Such a tree is called a </span><span class="font17" style="font-style:italic;">call tree:</span></p><img src="HigherOrderPerl_files/HigherOrderPerl-33.jpg" alt="" style="width:181pt;height:44pt;">
<p><span class="font17">It’s important to realize that the call tree has one tree node not for each subroutine, but for each </span><span class="font17" style="font-style:italic;">invocation</span><span class="font17"> of each subroutine (see Figure 5.4).</span></p>
<p><span class="font2">sub read_input { for (1..8) {</span></p><img src="HigherOrderPerl_files/HigherOrderPerl-34.jpg" alt="" style="width:278pt;height:68pt;">
<p><span class="font14">FIGURE 5.4 </span><span class="font16">A more complicated call tree.</span></p>
<p><span class="font2">read_block($_);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">■ ■■</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">sub read_block {</span></p>
<p><span class="font2">my $n = shift;</span></p>
<p><span class="font2">if ($n % 2 == 0) { read_addendum() }</span></p>
<p><span class="font2">sub read_addendum { ■■■ }</span></p>
<p><span class="font17">In the call tree for a recursive function, the node for a subroutine may have children that represent calls to the same subroutine. For a recursive directory tree walker like </span><span class="font2">walk_tree</span><span class="font17">, the call tree is exactly the same as the directory tree itself. Figure 5.5 shows a more arbitrary example.</span></p>
<p><span class="font2">sub rec {</span></p>
<p><span class="font2">my ($n, $k) = @_;</span></p>
<p><span class="font2">print $k x $n, &quot;</span><span class="font2" style="font-weight:bold;">\</span><span class="font2">n&quot;;</span></p>
<p><span class="font2">for (1 ■■ $n-1) { rec($n-$_, $_);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p><img src="HigherOrderPerl_files/HigherOrderPerl-35.jpg" alt="" style="width:282pt;height:95pt;">
<p><span class="font14">FIGURE 5.5 </span><span class="font16">A call tree for a recursive function.</span></p>
<p><span class="font17">When a recursive function runs, we can imagine that it is performing a depth-first tree search on its own call tree. It starts at the root, which represents the initial invocation of the function. Each time the function calls itself, it is moving down the tree to a child node; when the call returns, it moves back up the parent. When run, the preceding code example does indeed produce the data from the tree nodes of Figure 5.5 in depth-first order:</span></p>
<p><span class="font2">1111</span></p>
<p><span class="font2">111</span></p>
<p><span class="font2">11</span></p>
<p><span class="font2">1</span></p>
<p><span class="font2">2</span></p>
<p><span class="font2">22</span></p>
<p><span class="font2">1</span></p>
<p><span class="font2">3</span></p>
<p><span class="font17">As a result, every recursive function is really doing a depth-first tree search. Whenever we want to convert a recursive function to an iterator, we can use the agenda method. Each agenda item will represent one call to the recursive function and will contain all the state information that the recursive function needed to do its work: in general, all its private variables, but often, just the arguments. When the iterator removes an item from the agenda, it starts pretending that it’s the recursive function, with the arguments described by the item it removed. If the recursive function would have called itself recursively, the iterator puts an item onto the agenda to represent the new arguments.</span></p>
<p><span class="font17">Let’s look at a new example to see how this works. Some time ago, a friend, Jeff Goff, was working on a game and asked how to write a function that would take a positive integer </span><span class="font17" style="font-style:italic;">n</span><span class="font17"> and produce a list of all the different ways it could be split into smaller integers. For example, if </span><span class="font17" style="font-style:italic;">n =</span><span class="font17"> 6, the desired list is:</span></p>
<p><span class="font17">6</span></p>
<p><span class="font17">5 1</span></p>
<p><span class="font17">4 2</span></p>
<p><span class="font17">4 1 1</span></p>
<p><span class="font17">33</span></p>
<p><span class="font17">3 2 1</span></p>
<p><span class="font17">3 1 1</span></p>
<div>
<p><span class="font17">1</span></p>
<p><span class="font17">1</span></p>
<p><span class="font17">1 1</span></p>
<p><span class="font17">1 1 1</span></p>
</div><br clear="all">
<p><span class="font17">2 2 2</span></p>
<p><span class="font17">2 2 1</span></p>
<p><span class="font17">2 1 1</span></p>
<p><span class="font17">1 1 1</span></p>
<div>
<p><span class="font20">218</span></p>
</div><br clear="all">
<p><span class="font15">CHAPTER 5 From Recursion to Iterators</span></p>
<p><span class="font17">Rather confusingly, this is called the </span><span class="font17" style="font-style:italic;">partitions of an integer problem,</span><span class="font17"> and each of the rows in the table is a </span><span class="font17" style="font-style:italic;">partition</span><span class="font17"> of the number 6.</span></p>
<p><span class="font17">First we have to suppose we have a recursive function that solves this problem. The function will take a number and split a chunk off it. For example, it might split 5 into 4 </span><span class="font3">+ </span><span class="font17">1 or 6 into 3 </span><span class="font3">+ </span><span class="font17">3. It will do this in every possible way. Then it will recurse, and split another chunk off the remainder, and so on:</span></p>
<div>
<p><span class="font9" style="font-weight:bold;">CODE LIBRARY</span></p>
</div><br clear="all">
<p><span class="font2">sub partition { </span><span class="font0">partition-repeats &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="font2">p<sub>r</sub>i<sub>nt</sub> &quot;@_</span><span class="font2" style="font-weight:bold;">\</span><span class="font2"><sub>n</sub>&quot;;</span></p>
<p><span class="font2">my ($n, ©parts) = @_; for (1 .. $n-1) { partition($n-$_, $_, ©parts); } }</span></p>
<p><span class="font17">This isn’t quite what we want, because it generates some of the partitions more than once. For example, if we start with 6, and split off 2 and then 3, we get 1 </span><span class="font3">+ </span><span class="font17">3 </span><span class="font3">+ </span><span class="font17">2; if we split off 3 first and then 2, we get 1 </span><span class="font3">+ </span><span class="font17">2 </span><span class="font3">+ </span><span class="font17">3, which is the same. The preceding function generates 32 partitions of 6, including 3 </span><span class="font3">+ </span><span class="font17">1 </span><span class="font3">+ </span><span class="font17">1 </span><span class="font3">+ </span><span class="font17">1,1 </span><span class="font3">+ </span><span class="font17">3 </span><span class="font3">+ </span><span class="font17">1 </span><span class="font3">+ </span><span class="font17">1,1 </span><span class="font3">+ </span><span class="font17">1 </span><span class="font3">+ </span><span class="font17">3 </span><span class="font3">+ </span><span class="font17">1, and 1 </span><span class="font3">+ </span><span class="font17">1 </span><span class="font3">+ </span><span class="font17">1 </span><span class="font3">+ </span><span class="font17">3, but there are only 11 different partitions.</span></p>
<p><span class="font17">The trick for eliminating extra items in a listing like this is to adopt a </span><span class="font17" style="font-style:italic;">canonical form</span><span class="font17"> for the output. Where there are several items that are essentially the same, a canonical form is just a convention about which item you’ll choose to represent all of them.</span></p>
<p><span class="font17">This idea should be familiar. Suppose we wanted to read a list of words, and report on the ones that appeared more than once. Easy; just use a hash:</span></p>
<p><span class="font2">for (©words) { $seen{$_}++ } ©repeats = grep $seen{$_} &gt;&nbsp;1, keys %seen;</span></p>
<p><span class="font17">But what if the words are in mixed-case, and the case doesn’t matter, so that we want to consider “perl”, “Perl”, and “PERL” as being the same? There’s only one easy way to do it: Use a hash, and store the all-lowercase version of the codes:</span></p>
<p><span class="font2">for (©words) { $seen{</span><span class="font2" style="font-weight:bold;">lc </span><span class="font2">$_}++ } ©repeats = grep $seen{$_} &gt;&nbsp;1, keys %seen;</span></p>
<p><span class="font17">The all-lowercase version is the canonical form for the words. Words are divided into groups of equivalent words, sometimes called </span><span class="font17" style="font-style:italic;">equivalence classes,</span><span class="font17"> and a representative is chosen from each group. For the group of equivalent words</span></p>
<p><span class="font17">containing:</span></p>
<table border="1">
<tr><td>
<p><span class="font17">perl</span></p></td><td>
<p><span class="font17">Perl</span></p></td><td>
<p><span class="font17">pErl</span></p></td><td>
<p><span class="font17">peRl</span></p></td></tr>
<tr><td>
<p><span class="font17">perL</span></p></td><td>
<p><span class="font17">PErl</span></p></td><td>
<p><span class="font17">PeRl</span></p></td><td>
<p><span class="font17">PerL</span></p></td></tr>
<tr><td style="vertical-align:bottom;">
<p><span class="font17">pERl</span></p></td><td style="vertical-align:bottom;">
<p><span class="font17">pErL</span></p></td><td style="vertical-align:bottom;">
<p><span class="font17">peRL</span></p></td><td style="vertical-align:bottom;">
<p><span class="font17">PERl</span></p></td></tr>
<tr><td>
<p><span class="font17">PErL</span></p></td><td>
<p><span class="font17">PeRL</span></p></td><td>
<p><span class="font17">pERL</span></p></td><td>
<p><span class="font17">PERL</span></p></td></tr>
</table>
<p><span class="font17">we choose “perl” as the canonical representative. Choosing the all-uppercase member of each group would work as well, of course, as would any other method that chooses exactly one representative from every equivalence class. Another familiar example is numerals: We might consider the numerals “0032.50,” “32.5,” and “325e-01” to be equivalent; when Perl converts these strings to an internal floating-point format, it is converting them to a canonical representation so that equivalent numerals have the same representation.</span></p>
<p><span class="font17">Returning to our problem of duplicate partitions, it appears that one solution will be to find a canonical form for partitions, and then discard any partitions that aren’t already in canonical form. Sometimes it can be difficult to find an appropriate canonical form. But not in the case of the partition problem. The partitions are lists of numbers, and since every list has one and only one sorted version, we’ll just say that the sorted version of the list is its canonical form.</span></p>
<p><span class="font17">We will produce partitions whose elements are in decreasing order, and no others. (We’ll say “decreasing” when what we really mean is “nonincreasing,” so we say that 5, 5, 4, 3, 3 is a “decreasing” sequence of numbers. This is more convenient than using the clumsy word “nonincreasing” everywhere.<a name="footnote21"></a><sup><a href="#bookmark278">21</a></sup><sup></sup>)</span></p>
<p><span class="font17">We could refit our subroutine to suppress the printing for the elements that aren’t in decreasing order:</span></p>
<p><span class="font2">sub partition {</span></p>
<p><span class="font2" style="font-weight:bold;">print &quot;@_\n&quot; if decreasing_order(@_);</span></p>
<p><span class="font2">my ($n, @parts) = @_;</span></p>
<p><span class="font2">for (1 .. $n-1) {</span></p>
<p><span class="font2">partition($n-$_, $_, @parts);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">However, it’s more efficient to avoid generating noncanonical partitions in the first place. To generate only those partitions whose members are in decreasing</span></p>
<p><span class="font17">order, we just have to take care not to split off any parts that are smaller than a part we have already split off:</span></p>
<div>
<p><span class="font9" style="font-weight:bold;">CODE LIBRARY</span></p>
</div><br clear="all">
<div>
<p><span class="font0">partition</span></p>
</div><br clear="all">
<p><span class="font2">sub partition {</span></p>
<p><span class="font2">print &quot;@_</span><span class="font2" style="font-weight:bold;">\</span><span class="font2">n&quot;;</span></p>
<p><span class="font2">my (Slargest, @rest) = @_;</span></p>
<p><span class="font2">my Smin = Srest[0] || 1;</span></p>
<p><span class="font2">my Smax = int(Slargest/2);</span></p>
<p><span class="font2">for (Smin .. Smax) {</span></p>
<p><span class="font2">partition(Slargest-S_, S_, @rest);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">Here instead of splitting off parts with any size at all between 1 and </span><span class="font2">Sn-1</span><span class="font17">, we put conditions on the size of the parts we can split off. We know that the arguments to the function are in decreasing order, so that the first argument is the largest part, the next is the next largest (if it exists), and the rest (if there are any) are no bigger than these two. We don’t want to split off a part that is smaller than one we split off before, so it is sufficient to make sure the split-off part is at least as large as </span><span class="font2">Srest[0]</span><span class="font17">, if it exists; if not, we haven’t split anything off yet, so it’s okay to split off any amount down to and including 1.</span></p>
<p><span class="font17">The split-off value must not be larger than half the largest element, or else the part left over after it is subtracted will be smaller than the part that was split off: we would go from </span><span class="font2">partition(5,2) </span><span class="font17">to </span><span class="font2">partition(2,3,2)</span><span class="font17">, and then the arguments wouldn’t be in decreasing order.</span></p>
<p><span class="font17">Figure 5.6 shows the call tree for the invocation </span><span class="font2">partition(7)</span><span class="font17">.</span></p>
<div><img src="HigherOrderPerl_files/HigherOrderPerl-36.jpg" alt="" style="width:312pt;height:168pt;">
<p><span class="font14">FIGURE </span><span class="font17" style="font-style:italic;">5.6</span><span class="font16"> Partitions of the integer 7, organized as a search space.</span></p>
</div><br clear="all">
<p><span class="font17">The large left branch contains all the partitions that include a part of size 1. The much smaller second branch contains just the partitions whose parts are all at least 2. The third branch contains the single partition, </span><span class="font2">(4, 3)</span><span class="font17">, whose parts are all at least 3.</span></p>
<p><span class="font17">Incidentally, it’s quite easy to change the function to solve the slightly different problem of producing the partitions where the parts are all different: Just change </span><span class="font2">Srest[0] </span><span class="font17">to </span><span class="font2">Srest[0]+1 </span><span class="font17">and </span><span class="font2">Slargest </span><span class="font17">to </span><span class="font2">(Slargest-1)</span><span class="font17">.</span></p>
<p><span class="font17">The function works just fine, producing each partition exactly once, and every partition in decreasing order, so now we’ll try to turn it into an iterator.</span></p>
<p><span class="font17">To do this, we need to identify the state that the function tracks during each invocation. We’ll then package up each state into an agenda item. In general, the state might include all of the function’s lexical variables, and it has four: </span><span class="font2">©rest, Slargest, Smin, </span><span class="font17">and </span><span class="font2">Smax</span><span class="font17">:</span></p>
<div>
<p><span class="font9" style="font-weight:bold;">CODE LIBRARY</span></p>
</div><br clear="all">
<div>
<p><span class="font0">partition-it-2</span></p>
</div><br clear="all">
<p><span class="font2">sub make_partition { my Sn = shift;</span></p>
<table border="1">
<tr><td>
<p><span class="font2">my ©agenda = ([Sn,</span></p></td><td>
<p><span class="font2">#</span></p></td><td>
<p><span class="font2">Slargest</span></p></td></tr>
<tr><td>
<p><span class="font2">[],</span></p></td><td>
<p><span class="font2">#</span></p></td><td>
<p><span class="font2">\©rest</span></p></td></tr>
<tr><td style="vertical-align:bottom;">
<p><span class="font2">1,</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">#</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">Smin</span></p></td></tr>
<tr><td style="vertical-align:bottom;">
<p><span class="font2">int(Sn/2),</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">#</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">Smax</span></p></td></tr>
</table>
<p><span class="font2">]);</span></p>
<p><span class="font2">return Iterator {</span></p>
<p><span class="font2">while (©agenda) { my Sitem = pop ©agenda; my (Slargest, Srest, Smin, Smax) = ©Sitem; for (Smin .. Smax) {</span></p>
<p><span class="font2">push ©agenda, [Slargest - S_, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Slargest</span></p>
<p><span class="font2">[S_, ©Srest], &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# \©rest</span></p>
<p><span class="font2">S_, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Smin</span></p>
<p><span class="font2">int((Slargest - S_)/2), # Smax</span></p>
<p><span class="font2">];</span></p>
<p><span class="font2">} return [Slargest, ©Srest];</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">return;</span></p>
<p><span class="font2">};</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">The code here has a strong resemblance to the original recursive function. We can see the </span><span class="font2">int(Slargest/2) </span><span class="font17">and the </span><span class="font2">for (Smin .. Smax) </span><span class="font17">loop lurking inside. But it’s rather clumsy. The iterator we’ve just constructed is more closely analogous</span></p>
<h6><a name="bookmark279"></a><span class="font17">to a different version of the recursive function, one that passes all four quantities as arguments:</span></h6>
<p><span class="font2">sub partition { my (Slargest, $rest, $min, Smax) = @_; for (Smin .. Smax) { partition(Slargest-S_, [S_, @Srest], $_, int((Slargest - S_)/2));</span></p>
<p><span class="font2">} return [Slargest, @$rest];</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">This does work, but it’s not how we did it originally. Instead, we derived </span><span class="font2">Smin </span><span class="font17">and </span><span class="font2">Smax </span><span class="font17">from </span><span class="font2">Slargest </span><span class="font17">and </span><span class="font2">Srest</span><span class="font17">, and these in turn were derived from </span><span class="font2">©_</span><span class="font17">, which is the true state of the recursive function. Realizing this leads us to a simpler iterator:</span></p>
<div>
<p><span class="font9" style="font-weight:bold;">CODE LIBRARY</span></p>
</div><br clear="all">
<p class="font2">sub make_partition {</p>
<p><span class="font0"><sup>m</sup>ak<sup>e-</sup>pa<sup>r</sup>t<sup>ition-</sup>i &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="font2">my Sn = shift;</span></p>
<p><span class="font2">my ©agenda = [Sn]; return Iterator { while (©agenda) { my Sitem = pop ©agenda; my (Slargest, ©rest) = ©Sitem; my Smin = Srest[0] || 1; my Smax = int(Slargest/2); for (Smin .. Smax) {</span></p>
<p><span class="font2">push ©agenda, [Slargest-S_, S_, ©rest]; } return Sitem;</span></p>
<p><span class="font2">} return; };</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">The code here is quite similar to that of the original function.</span></p>
<p><span class="font17">Now that we have an iterator, we can play around with it. There’s no point to the </span><span class="font2">while </span><span class="font17">loop, because it executes at most once, and a </span><span class="font2">while </span><span class="font17">loop that executes at most once is just an </span><span class="font2">if </span><span class="font17">in disguise:</span></p>
<div>
<p><span class="font9" style="font-weight:bold;">CODE LIBRARY</span></p>
</div><br clear="all">
<p class="font2">sub make_partition {</p>
<p><span class="font0">■-c--:'<sup>2</sup> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="font2">my Sn = shift;</span></p>
<p><span class="font2">my ©agenda = [Sn]; return Iterator { </span><span class="font2" style="font-weight:bold;">return unless ©agenda;</span></p>
<p><span class="font2">my Sitem = pop @agenda;</span></p>
<p><span class="font2">my (Slargest, ©rest) = @$item;</span></p>
<p><span class="font2">my Smin = Srest[0] || 1;</span></p>
<p><span class="font2">my Smax = int(Slargest/2);</span></p>
<p><span class="font2">for (Smin .. Smax) {</span></p>
<p><span class="font2">push ©agenda, [Slargest-S_, S_, @rest];</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">return Sitem;</span></p>
<p><span class="font2">};</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">Because we return each partition immediately, after putting its children onto the agenda, old nodes are never preempted by new ones, regardless of whether we use </span><span class="font2">pop </span><span class="font17">or </span><span class="font2">shift</span><span class="font17">. Consequently this iterator always produces partitions in breadth-first order. The output lists the partitions in increasing order of number of elements:</span></p>
<p><span class="font17">6</span></p>
<p><span class="font17">5 1</span></p>
<p><span class="font17">4 2</span></p>
<p><span class="font17">33</span></p>
<ul style="list-style:none;"><li>
<p><a href="#bookmark280"><span class="font17">4</span></a></p></li></ul>
<p><span class="font17">3 2 1</span></p>
<ul style="list-style:none;"><li>
<p><a href="#bookmark281"><span class="font17">2</span></a></p></li></ul>
<ul style="list-style:none;"><li>
<p><a href="#bookmark282"><span class="font17">3</span></a></p></li></ul>
<p><span class="font17">2 2 11</span></p>
<ul style="list-style:none;"><li>
<p><a href="#bookmark283"><span class="font17">2</span></a></p></li></ul>
<p><span class="font17">111111</span></p>
<p><span class="font17">We might prefer it to return the partitions in a different order, say one listing all the partitions with large parts before those with small parts:</span></p>
<p><span class="font17">6</span></p>
<ul style="list-style:none;"><li>
<p><a href="#bookmark284"><span class="font17">5</span></a></p></li></ul>
<ul style="list-style:none;"><li>
<p><a href="#bookmark285"><span class="font17">4</span></a></p></li></ul>
<ul style="list-style:none;"><li>
<p class="font17">4 1 1</p></li></ul>
<p><span class="font17">33</span></p>
<ul style="list-style:none;"><li>
<p><a href="#bookmark286"><span class="font17">3</span></a></p></li></ul>
<p><span class="font17">3 111</span></p>
<p><span class="font17">2 2 2</span></p>
<p><span class="font17">2 2 11</span></p>
<p><span class="font17">2 1111</span></p>
<p><span class="font17">111111</span></p>
<div>
<h4><a name="bookmark287"></a><span class="font20">224</span></h4>
</div><br clear="all">
<div>
<p><span class="font15">CHAPTER 5 From Recursion to Iterators</span></p>
</div><br clear="all">
<div>
<p><span class="font17">This is equivalent to sorting the partitions. And we can get this order by sorting the agenda before we process it. To do that, we’ll need a comparison function for partitions:</span></p>
</div><br clear="all">
<div>
<p><span class="font9" style="font-weight:bold;">CODE LIBRARY</span></p>
</div><br clear="all">
<div>
<p><span class="font0">partitions</span></p>
</div><br clear="all">
<div>
<p><span class="font2"># Compare two partitions for preferred order sub partitions {</span></p>
<p><span class="font2">for my Si (0 .. S#Sa) {</span></p>
<p><span class="font2">my Scmp = Sb-&gt;[Si] &lt;=&gt; Sa-&gt;[Si];</span></p>
<p><span class="font2">return Scmp if Scmp;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
</div><br clear="all">
<div>
<p><span class="font17">To compare two partitions, we just scan through them both one element at a time until we find a difference; when we do, that’s the answer. Since two partitions must have a difference somewhere before the end of either, we don’t have to worry what happens if we fall off the end.<sup>4</sup> Now we make a small change to the iterator:</span></p>
</div><br clear="all">
<div>
<p><span class="font9" style="font-weight:bold;">CODE LIBRARY</span></p>
</div><br clear="all">
<div>
<p><span class="font0">make-part-sorted</span></p>
</div><br clear="all">
<div>
<p><span class="font2">sub make_partition {</span></p>
<p><span class="font2">my Sn = shift;</span></p>
<p><span class="font2">my @agenda = [Sn];</span></p>
<p><span class="font2">return Iterator {</span></p>
<p><span class="font2">return unless @agenda;</span></p>
<p><span class="font2">my Sitem = pop @agenda;</span></p>
<p><span class="font2">my (Slargest, @rest) = @$item;</span></p>
<p><span class="font2">my Smin = Srest[0] || 1;</span></p>
<p><span class="font2">my Smax = int(Slargest/2);</span></p>
<p><span class="font2">for (Smin .. Smax) {</span></p>
<p><span class="font2">push @agenda, [Slargest-S_, S_, @rest];</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2" style="font-weight:bold;">©agenda = sort partitions ©agenda;</span></p>
<p><span class="font2">return Sitem;</span></p>
<p><span class="font2">};</span></p>
<p><span class="font2">}</span></p>
</div><br clear="all">
<div>
<p><span class="font17">We sort the agenda into the order we want before extracting items from it. Rather than sorting the entire array so that the item we want is at the end, a computationally cheaper approach is to scan the agenda looking for the maximal element and</span></p>
</div><br clear="all">
<div>
<p><span class="font15">4 With ordinary lexical sorting, we have to worry about cases where one value is a prefix of another, such as </span><span class="font2">“fan” </span><span class="font15">and </span><span class="font2">“fandango”</span><span class="font15">. In suchacase, we </span><span class="font15" style="font-style:italic;">do</span><span class="font15"> fall off the end. But that can’t happen with partitions, because two such sequences of positive numbers can’t possibly add up to the same thing.</span></p>
</div><br clear="all">
<p><span class="font15">5.3 A GENERIC SEARCH ITERATOR</span></p>
<div>
<p><span class="font20">225</span></p>
</div><br clear="all">
<p><span class="font17">then to </span><span class="font2">splice </span><span class="font17">it out once we find it. If we plan to do a lot of heuristically-guided searches, we should invest in building a priority-queue structure for the agenda. A priority queue contains a collection of items, each with an associated priority; it efficiently supports the operations of adding a new item to the collection, and of extracting and removing the item with the largest priority.</span></p>
<ul style="list-style:none;"><li>
<h5><a name="bookmark109"></a><span class="font18">5.3 A GENERIC SEARCH ITERATOR</span></h5></li></ul>
<p><span class="font17">You’ve probably noticed by now that all these agenda-type iterators look more or less the same. We can abstract out the sameness and make a generic tree-search iterator. To do that, we need to describe the tree. The constructor function will receive two arguments: the root node, and a callback function, which, given a node, generates its children in the tree. It will then carry out a tree search, returning the tree nodes one at a time:</span></p>
<div>
<p><span class="font2">use Iterator_Utils 'Iterator';</span></p>
<p><span class="font2">sub make_dfs_search {</span></p>
<p><span class="font2">my ($root, $children) = @_;</span></p>
<p><span class="font2">my @agenda = $root;</span></p>
<p><span class="font2">return Iterator {</span></p>
<p><span class="font2">return unless @agenda;</span></p>
<p><span class="font2">my $node = pop @agenda;</span></p>
<p><span class="font2">push @agenda, $children-&gt;($node);</span></p>
<p><span class="font2">return $node;</span></p>
<p><span class="font2">};</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">With this formulation, </span><span class="font2">make_partition </span><span class="font17">becomes:</span></p>
<p><span class="font2">sub make_partition {</span></p>
<p><span class="font2">my $n = shift;</span></p>
<p><span class="font2">my $root = [$n];</span></p>
<p><span class="font2">my $children = sub {</span></p>
<p><span class="font2">my ($largest, @rest) = @{shift()};</span></p>
<p><span class="font2">my $min = $rest[0] || 1;</span></p>
<p><span class="font2">my $max = int($largest/2);</span></p>
<p><span class="font2">map [$largest-$_, $_, @rest], ($min .. $max); };</span></p>
<p><span class="font2">make_dfs_search($root, $children);</span></p>
<p><span class="font2">}</span></p>
</div><br clear="all">
<div>
<p><span class="font9" style="font-weight:bold;">CODE LIBRARY</span></p>
</div><br clear="all">
<div>
<p><span class="font0">make-dfs-simple</span></p>
</div><br clear="all">
<div>
<p><span class="font9" style="font-weight:bold;">CODE LIBRARY</span></p>
</div><br clear="all">
<div>
<p><span class="font0">make-part-dfs-1</span></p>
</div><br clear="all">
<p><span class="font17">Factoring </span><span class="font2">make_partition </span><span class="font17">into two parts in this way allows us to re-use the </span><span class="font2">make_dfs_search </span><span class="font17">part.</span></p>
<p><span class="font17">We might outfit </span><span class="font2">make_dfs_search </span><span class="font17">with a filter that rejects uninteresting items, since this is sure to be a common usage:</span></p>
<div>
<p><span class="font9" style="font-weight:bold;">CODE LIBRARY</span></p>
</div><br clear="all">
<p class="font2">use Iterator_Utils 'Iterator';</p>
<p><span class="font0">make-dfs</span></p>
<p><span class="font2">sub make_dfs_search {</span></p>
<p><span class="font2" style="font-weight:bold;">my ($root, $children, $is_interesting) = @_;</span></p>
<p><span class="font2">my @agenda = $root;</span></p>
<p><span class="font2">return Iterator { while (@agenda) { my $node = pop @agenda; push @agenda, $children-&gt;($node);</span></p>
<p><span class="font2" style="font-weight:bold;">return $node if !$is_interesting || $is_interesting-&gt;($node);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2" style="font-weight:bold;">return;</span></p>
<p><span class="font2">};</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">1;</span></p>
<p><span class="font17">We don’t need this for </span><span class="font2">make_partition</span><span class="font17">, since every node represents a correct partition. But we might have needed it if we had used a slightly clumsier implementation of the search:</span></p>
<div>
<p><span class="font9" style="font-weight:bold;">CODE LIBRARY</span></p>
</div><br clear="all">
<p><span class="font2">require 'make-dfs-search';</span></p>
<p><span class="font0">make-part-dfs-2</span></p>
<p><span class="font2">sub make_partition { my $n = shift;</span></p>
<p><span class="font2">my $root = [$n, 1, []];</span></p>
<p><span class="font17">Here the nodes will have three parts: </span><span class="font2">$n</span><span class="font17">, the part of the original number that we haven’t yet split off to any of the parts of the partition; a minimum part size, initially 1; and a list of the parts we’ve split off so far, initially empty:</span></p>
<p><span class="font2">my $children = sub { my ($n, $min, $parts) = @{shift()}; map [$n-$_, $_, [@$parts, $_]], ($min .. $n);</span></p>
<p><span class="font2">};</span></p>
<p><span class="font17">For each possible part size </span><span class="font2">$_</span><span class="font17">, from the minimum </span><span class="font2">$min </span><span class="font17">up to the maximum </span><span class="font2">$n</span><span class="font17">, we split off a new part of size </span><span class="font2">$_</span><span class="font17">. To do this, we subtract the size from </span><span class="font2">$n</span><span class="font17">, indicating that we now have to apportion a smaller value among the remaining</span></p>
<p><span class="font15">5.3 A GENERIC SEARCH ITERATOR</span></p>
<div>
<p><span class="font20">227</span></p>
</div><br clear="all">
<p><span class="font17">parts; we adjust the minimum value up to the new part size, so that any future parts are at least that big and therefore the parts will be generated in order of increasing size; and we append the new part to the list of parts.</span></p>
<p><span class="font17">Note that if </span><span class="font2">$n &lt;&nbsp;$min</span><span class="font17">, there’s no possible solution. An example of such a node will occur when we try to partition the number 6 and we first split off parts of sizes 2 and then 3. Then we’re stuck: Only 1 remains, but </span><span class="font2">2, 3, 1 </span><span class="font17">is forbidden because the parts aren’t in increasing order.</span></p>
<p><span class="font2">my $is_complete = sub {</span></p>
<p><span class="font2">my ($n) = @{shift()};</span></p>
<p><span class="font2">$n == 0;</span></p>
<p><span class="font2">};</span></p>
<p><span class="font17">The partition is complete once we’ve reduced </span><span class="font2">$n </span><span class="font17">to exactly 0.</span></p>
<p><span class="font17">By default, </span><span class="font2">make_dfs_search() </span><span class="font17">returns interesting nodes from the agenda. Here the nodes have extraneous information in them in addition to the partitions themselves. So we’ll wrap </span><span class="font2">make_dfs_search() </span><span class="font17">in a call to </span><span class="font2">imap() </span><span class="font17">that strips out the extra data, returning only the partition itself:</span></p>
<p><span class="font2">imap { $_-&gt;[2] }</span></p>
<p><span class="font2">make_dfs_search($root, $children, $is_complete);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">We could similarly outfit </span><span class="font2">make_dfs_search() </span><span class="font17">with a callback to evaluate nodes and allow the most valuable ones to be processed first. If we did, we would want to rename it, because it would no longer be doing DFS. To do this properly requires a good priority-queue implementation, which is outside the scope of this chapter. Here’s an inefficient implementation:</span></p>
<p><span class="font2">sub make_dfs_value_search {</span></p>
<p><span class="font2" style="font-weight:bold;">my ($root, $children, $is_interesting, $evaluate) = @_;</span></p>
<p><span class="font2" style="font-weight:bold;">$evaluate = memoize($evaluate);</span></p>
<p><span class="font2">my @agenda = $root;</span></p>
<p><span class="font2">return Iterator {</span></p>
<p><span class="font2">while (@agenda) {</span></p>
<p><span class="font2" style="font-weight:bold;">my $best_node_so_far = 0;</span></p>
<p><span class="font2" style="font-weight:bold;">my $best_node_value = $evaluate-&gt;($agenda[0]);</span></p>
<p><span class="font2" style="font-weight:bold;">for (0 .. $#agenda) {</span></p>
<p><span class="font2" style="font-weight:bold;">my $val = $evaluate-&gt;($agenda[$_]);</span></p>
<p><span class="font2" style="font-weight:bold;">next unless $val &gt;&nbsp;$best_node_value;</span></p>
<p><span class="font2" style="font-weight:bold;">$best_node_value = $val;</span></p>
<p><span class="font2" style="font-weight:bold;">$best_node_so_far = $_;</span></p>
<div>
<p><span class="font9" style="font-weight:bold;">CODE LIBRARY</span></p>
</div><br clear="all">
<div>
<p><span class="font0">make-dfs-value</span></p>
</div><br clear="all">
<p><span class="font2" style="font-weight:bold;">}</span></p>
<p><span class="font2" style="font-weight:bold;">my $node = splice @agenda, $best_node_so_far, 1;</span></p>
<p><span class="font2">push @agenda, $children-&gt;($node);</span></p>
<p><span class="font2">return $node if !$is_interesting || $is_interesting-&gt;($node); }</span></p>
<p><span class="font2">return;</span></p>
<p><span class="font2">};</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">The inefficient part is the scan over the entire agenda and the </span><span class="font2">splice</span><span class="font17">. There are a number of ways to speed this up, but if it matters, the priority queue is probably the best approach.</span></p>
<p><span class="font17">If we did do this, it would include DFS and BFS as easy special cases, since we could use the following two valuations:</span></p>
<p><span class="font2">{</span></p>
<p><span class="font2">my ($d, $b) = (0, 0);</span></p>
<p><span class="font2">sub dfs_value { return $d++ }</span></p>
<p><span class="font2">sub bfs_value { return $b— }</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">bfs_value</span><span class="font17">, like a cantankerous grandfather, always reports the value of an old node as being greater than that of the newer nodes; </span><span class="font2">dfs_value</span><span class="font17">, like the staff at </span><span class="font17" style="font-style:italic;">Wired</span><span class="font17"> magazine, does just the opposite.</span></p>
<p><span class="font17">One possible trap to be aware of when using </span><span class="font2">make_dfs_search() </span><span class="font17">is that “depth first” doesn’t necessarily define the search order uniquely. Consider the tree shown here.</span></p>
<p><span class="font17">DFS says that once we visit a node, we must visit its children before its siblings. But it doesn’t say what order the siblings must be visited in. Both of the orders shown in Figure 5.7 are depth-first for this tree.</span></p>
<p><span class="font17">Since the nodes generated by the call to </span><span class="font2">$children </span><span class="font17">are pushed onto the end of the agenda and then popped off from the end, the items will be processed in the reverse of the order that </span><span class="font2">$children </span><span class="font17">returned them, with the last item in</span></p>
<div><img src="HigherOrderPerl_files/HigherOrderPerl-37.jpg" alt="" style="width:234pt;height:97pt;">
</div><br clear="all">
<p><span class="font2">Schildren</span><span class="font17">’s return list processed immediately. To prevent surprises, we’ll make one final change to </span><span class="font2">make_dfs_search</span><span class="font17">:</span></p>
<p><span class="font2">sub make_dfs_search {</span></p>
<div>
<p><span class="font9" style="font-weight:bold;">CODE LIBRARY</span></p>
</div><br clear="all">
<div>
<p><span class="font0">make-dfs-final</span></p>
</div><br clear="all">
<p><span class="font2">my (Sroot, Schildren, $is_interesting) = @_;</span></p>
<p><span class="font2">my ©agenda = Sroot;</span></p>
<p><span class="font2">return Iterator {</span></p>
<p><span class="font2">while (©agenda) {</span></p>
<p><span class="font2">my Snode = pop ©agenda;</span></p>
<p><span class="font2" style="font-weight:bold;">push ©agenda, reverse $children-&gt;($node);</span></p>
<p><span class="font2">return Snode if !Sis_interesting || Sis_interesting-&gt;(Snode); } return;</span></p>
<p><span class="font2">};</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">Now branches will be traversed in the order they were generated.</span></p>
<ul style="list-style:none;"><li>
<h5><a name="bookmark110"></a><span class="font18">5.4 OTHER GENERAL TECHNIQUES FOR ELIMINATING RECURSION</span></h5></li></ul>
<ul style="list-style:none;"><li>
<h5><a name="bookmark111"></a><span class="font19">5.4.1 Tail-Call Elimination</span></h5></li></ul>
<p><span class="font17">In addition to the agenda technique we looked at in detail in the previous section, there are a few other techniques that are generally useful for turning recursive functions into iterative ones. One of the most useful is </span><span class="font17" style="font-style:italic;">tail-call elimination.</span></p>
<p><span class="font17">First, let’s consider the implementation of function calls generally. Usually there is a stack. When function </span><span class="font2">B </span><span class="font17">wants to call </span><span class="font2">C</span><span class="font17">, it pushes </span><span class="font2">C</span><span class="font17">’s arguments onto this stack and transfers control to </span><span class="font2">C</span><span class="font17">. </span><span class="font2">C </span><span class="font17">then removes the arguments from the stack, does its computations (possibly including other function calls), pushes its intended return value onto the stack, and transfers control back to </span><span class="font2">B</span><span class="font17">. </span><span class="font2">B </span><span class="font17">then pops the return value off the stack and continues. If there are three functions, as follows:</span></p>
<p><span class="font2">sub A { A1; $B = B(...); A2; }</span></p>
<p><span class="font2">sub B { B1; $C = C(...); B2; return $Bval; } sub C { C1; return $Cval; }</span></p>
<p><span class="font17">then the sequence of events is:</span></p>
<p><span class="font2">A</span><span class="font17">: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="font2">A1</span><span class="font17">;</span></p>
<p><span class="font17">Push </span><span class="font2">B</span><span class="font17">’s arguments</span></p>
<p><span class="font2">B</span><span class="font17">: &nbsp;&nbsp;&nbsp;&nbsp;Pop </span><span class="font2">B</span><span class="font17">’s arguments</span></p>
<p><span class="font2">B1</span><span class="font17">;</span></p>
<p><span class="font17">Push </span><span class="font2">C</span><span class="font17">’s arguments</span></p>
<p><span class="font2">C</span><span class="font17">: &nbsp;&nbsp;&nbsp;&nbsp;Pop </span><span class="font2">C</span><span class="font17">’s arguments</span></p>
<p><span class="font2">C1</span><span class="font17">;</span></p>
<p><span class="font17">Push </span><span class="font2">C</span><span class="font17">’s return value</span></p>
<p><span class="font2">B</span><span class="font17">: &nbsp;&nbsp;&nbsp;&nbsp;Pop </span><span class="font2">C</span><span class="font17">’s return value</span></p>
<p><span class="font2">B2</span><span class="font17">;</span></p>
<p><span class="font17">Push </span><span class="font2">B</span><span class="font17">’s return value</span></p>
<p><span class="font2">A</span><span class="font17">: &nbsp;&nbsp;&nbsp;&nbsp;Pop </span><span class="font2">B</span><span class="font17">’s return value</span></p>
<p><span class="font2">A2</span><span class="font17">;</span></p>
<p><span class="font17">Now let’s suppose that function </span><span class="font2">B </span><span class="font17">is a little simpler, and doesn’t do anything except return after it calls </span><span class="font2">C</span><span class="font17">:</span></p>
<p><span class="font2">sub A { A1; $B = B(...); A2; }</span></p>
<p><span class="font2" style="font-weight:bold;">sub B { B1; return C(...); }</span></p>
<p><span class="font2">sub C { C1; return $Cval; }</span></p>
<p><span class="font17">The sequence of events is as before, up to </span><span class="font2">B2</span><span class="font17">, which was eliminated; and then goes like this:</span></p>
<p><span class="font17">...</span></p>
<p><span class="font2">C</span><span class="font17">: &nbsp;&nbsp;&nbsp;Push </span><span class="font2">C</span><span class="font17">’s return value</span></p>
<p><span class="font2">B</span><span class="font17">: &nbsp;&nbsp;&nbsp;Pop </span><span class="font2">C</span><span class="font17">’s return value</span></p>
<p><span class="font17">(There is no </span><span class="font2">B2 </span><span class="font17">any more)</span></p>
<p><span class="font17">Push </span><span class="font2">B</span><span class="font17">’s return value (the same as </span><span class="font2">C</span><span class="font17">’s)</span></p>
<p><span class="font2">A</span><span class="font17">: &nbsp;&nbsp;&nbsp;Pop </span><span class="font2">B</span><span class="font17">’s return value</span></p>
<p><span class="font2">A2</span><span class="font17">;</span></p>
<p><span class="font17">All of </span><span class="font2">B</span><span class="font17">’s work here is useless. Because </span><span class="font2">B</span><span class="font17">’s return value is the same as </span><span class="font2">C</span><span class="font17">’s, all </span><span class="font2">B </span><span class="font17">is doing is removing </span><span class="font2">C</span><span class="font17">’s return value from the stack and then putting it back again immediately. A common optimization in programming-language implementations is to eliminate the return to </span><span class="font2">B </span><span class="font17">entirely. The final call to </span><span class="font2">C </span><span class="font17">is known as a </span><span class="font17" style="font-style:italic;">tail call,</span><span class="font17"> and the optimization is called </span><span class="font17" style="font-style:italic;">tail-call elimination.</span><span class="font17"> When function </span><span class="font2">B </span><span class="font17">is compiled, the compiler will notice that the call from </span><span class="font2">B </span><span class="font17">to </span><span class="font2">C </span><span class="font17">is a tail call, and will arrange for it to be done in a special way. Normally, </span><span class="font2">B </span><span class="font17">would record its own address so that </span><span class="font2">C </span><span class="font17">would know where to transfer control back to when it was finished. Instead, </span><span class="font2">B </span><span class="font17">erases its own frame from the stack and lets </span><span class="font2">C </span><span class="font17">borrow the return information that </span><span class="font2">B </span><span class="font17">originally got from </span><span class="font2">A</span><span class="font17">. When </span><span class="font2">C </span><span class="font17">returns, it will return directly to </span><span class="font2">A</span><span class="font17">, bypassing </span><span class="font2">B </span><span class="font17">entirely:</span></p>
<p><span class="font2">C</span><span class="font17">: &nbsp;&nbsp;&nbsp;Push </span><span class="font2">C</span><span class="font17">’s return value</span></p>
<p><span class="font2">A</span><span class="font17">: &nbsp;&nbsp;&nbsp;&nbsp;Pop </span><span class="font2">C</span><span class="font17">’s return value (thinking it is </span><span class="font2">B</span><span class="font17">’s)</span></p>
<p><span class="font2">A2;</span></p>
<p><span class="font17">This is the </span><span class="font17" style="font-style:italic;">tail-call optimization.</span><span class="font17"> Perl could in principle perform this optimization, but as of 5.8.6, it doesn’t.</span></p>
<p><span class="font17">Now let’s consider the </span><span class="font17" style="font-style:italic;">greatest common divisor function</span><span class="font17"> or </span><span class="font17" style="font-style:italic;">GCD</span><span class="font17"> function. This function takes two numbers, </span><span class="font17" style="font-style:italic;">m</span><span class="font17"> and </span><span class="font17" style="font-style:italic;">n</span><span class="font17">, and yields the greatest number </span><span class="font17" style="font-style:italic;">g </span><span class="font17">such that </span><span class="font17" style="font-style:italic;">g</span><span class="font17"> divides evenly into both </span><span class="font17" style="font-style:italic;">m</span><span class="font17"> and </span><span class="font17" style="font-style:italic;">n</span><span class="font17">. There is always such a number, since 1 divides evenly into both </span><span class="font17" style="font-style:italic;">m</span><span class="font17"> and </span><span class="font17" style="font-style:italic;">n</span><span class="font17">, although the GCD is often larger than 1. For example, the GCD of 42 and 360 is 6, and the GCD of 48 and 20 is 4. Probably the most well-known application of the GCD is in putting fractions into lowest terms. Given a fraction, say 42/360, one finds the GCD of the numerator and denominator, in this case 6, and then cancels that factor from the top and bottom of the fraction, giving 42/360 </span><span class="font3">= </span><span class="font17">7 </span><span class="font3">• </span><span class="font17">6 / 60 </span><span class="font3">• </span><span class="font17">6 </span><span class="font3">= </span><span class="font17">7/60. Similarly 48/20 </span><span class="font3">= </span><span class="font17">12 </span><span class="font3">• </span><span class="font17">4 / 5 </span><span class="font3">• </span><span class="font17">4 </span><span class="font3">= </span><span class="font17">12/5.</span></p>
<p><span class="font17">There is a simple algorithm for calculating the GCD of two numbers, called </span><span class="font17" style="font-style:italic;">Euclid’s algorithm,</span><span class="font17"> which is in fact the oldest surviving nontrivial numeric algorithm. Here it is translated into Perl:</span></p>
<p><span class="font2">sub gcd {</span></p>
<div>
<p><span class="font9" style="font-weight:bold;">CODE LIBRARY</span></p>
</div><br clear="all">
<div>
<p><span class="font0">gcd</span></p>
</div><br clear="all">
<p><span class="font2">my ($m, $n) = @_;</span></p>
<p><span class="font2">if ($n == 0) { return $m;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">return gcd($n, $m % $n);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">The execution of </span><span class="font2">gcd(48, 20) </span><span class="font17">goes like this:</span></p>
<p><span class="font2">call gcd(48, 20) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Call A</span></p>
<p><span class="font2">call gcd(20, 8)</span></p>
<div>
<ul style="list-style:none;"><li>
<p><span class="font2"># Call B</span></p></li>
<li>
<p><span class="font2"># Call C</span></p></li>
<li>
<p><span class="font2"># Call D</span></p></li></ul>
</div><br clear="all">
<p><span class="font2">call gcd(8, 4)</span></p>
<p><span class="font2">call gcd(4, 0)</span></p>
<p><span class="font2">return 4</span></p>
<p><span class="font2">return 4</span></p>
<p><span class="font2">return 4</span></p>
<p><span class="font2">return 4</span></p>
<p><span class="font17">The stack manipulations are as follows:</span></p>
<p><span class="font17">original</span></p>
<p><span class="font17">caller: &nbsp;&nbsp;&nbsp;push 48, 20 onto stack</span></p>
<p><span class="font17">transfer control to </span><span class="font2">gcd</span></p>
<p><span class="font2">A</span><span class="font17">: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pop 48, 20 from stack</span></p>
<p><span class="font17">...</span></p>
<p><span class="font2">C</span><span class="font17">: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;push 4, 0 onto stack</span></p>
<p><span class="font17">transfer control to </span><span class="font2">gcd</span></p>
<p><span class="font2">D</span><span class="font17">: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pop 4, 0 from stack</span></p>
<p><span class="font17">push 4 onto stack transfer control to </span><span class="font2">gcd</span></p>
<p><span class="font2">C</span><span class="font17">: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pop 4 from stack</span></p>
<p><span class="font17">push 4 onto stack transfer control to </span><span class="font2">gcd</span></p>
<p><span class="font2">B</span><span class="font17">: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pop 4 from stack</span></p>
<p><span class="font17">push 4 onto stack transfer control to </span><span class="font2">gcd</span></p>
<p><span class="font2">A</span><span class="font17">: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pop 4 from stack</span></p>
<p><span class="font17">push 4 onto stack</span></p>
<p><span class="font17">transfer control back to original caller</span></p>
<p><span class="font17">The tail-call optimization allows call D to return the 4 directly back to the original caller, skipping all the steps at the end.</span></p>
<p><span class="font17">Since Perl doesn’t perform the tail-call optimization automatically, we can help it out. The tail-call optimization would normally replace the current call frame with the one for the function being called. Perl won’t do that internally, but since the call frame has nothing in it except a bunch of variable bindings, we can accomplish the same thing by just rebinding the variables to the appropriate variables. “Transfer control to </span><span class="font2">gcd</span><span class="font17">,” which normally means “create a new call frame and activate it” just becomes “transfer control back the top of the current function” — in other words, a local </span><span class="font2">goto</span><span class="font17">. Since </span><span class="font2">goto </span><span class="font17">itself is considered naughty, we’ll use a loop, which is the same thing:</span></p>
<div>
<p><span class="font9" style="font-weight:bold;">CODE LIBRARY</span></p>
</div><br clear="all">
<p><span class="font2">sub gcd {</span></p>
<p><span class="font0"><sup>gcd2</sup> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="font2">my ($m, $n) = @_;</span></p>
<p><span class="font2" style="font-weight:bold;">until ($n == 0) {</span></p>
<p><span class="font2" style="font-weight:bold;">($m, $n) = ($n, $m % $n);</span></p>
<p><span class="font2" style="font-weight:bold;">}</span></p>
<p><span class="font2">return $m;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">The condition for performing the </span><span class="font2">until </span><span class="font17">loop is the same as the one guarding the recursive call in the old code. The original function made a recursive call unless </span><span class="font2">$n </span><span class="font17">was zero; here it performs the loop body. The body of the loop transforms the arguments </span><span class="font2">$m </span><span class="font17">and </span><span class="font2">$n </span><span class="font17">in the same way that the recursive code in the original function did, replacing </span><span class="font2">$m </span><span class="font17">with </span><span class="font2">$n </span><span class="font17">and </span><span class="font2">$n </span><span class="font17">with </span><span class="font2">$m % $n</span><span class="font17">. Thus the </span><span class="font2">until </span><span class="font17">loop sets up the new values of </span><span class="font2">$m </span><span class="font17">and </span><span class="font2">$n </span><span class="font17">that would have been seen by the recursively-called instance of </span><span class="font2">gcd</span><span class="font17">, and then effectively restarts the function. In the case </span><span class="font2">$n == 0</span><span class="font17">, there is no recursively-called instance, so the function skips that step and returns immediately.</span></p>
<p><span class="font17">Here’s another example: printing the elements of a sorted binary tree in order. The recursive code looks like this:</span></p>
<p><span class="font2">sub print_tree { my $t = shift; return unless $t; # Null tree print_tree($t-&gt;left); print $t-&gt;root, &quot;</span><span class="font2" style="font-weight:bold;">\</span><span class="font2">n&quot;;</span></p>
<p><span class="font2">print_tree($t-&gt;right);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">Replacing the tail call with a loop yields this version:</span></p>
<p><span class="font2">sub print_tree { my $t = shift; </span><span class="font2" style="font-weight:bold;">while ($t) { </span><span class="font2">print_tree($t-&gt;left); print $t-&gt;root, &quot;</span><span class="font2" style="font-weight:bold;">\</span><span class="font2">n&quot;; </span><span class="font2" style="font-weight:bold;">$t = $t-&gt;right;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">Here we’ve replaced the tail call, </span><span class="font2">print_tree($t-&gt;right)</span><span class="font17">, with code that modifies </span><span class="font2">$t </span><span class="font17">appropriately, replacing it with </span><span class="font2">$t-&gt;right</span><span class="font17">, and then jumps back up to the top of the function. Since </span><span class="font2">print_tree($t-&gt;left) </span><span class="font17">isn’t a tail call, we can’t eliminate it in this way. We’ll eliminate it in a different way later on.</span></p>
<h6><a name="bookmark288"></a><span class="font17">A variation of </span><span class="font2">print_tree() </span><span class="font17">handles the empty-tree case before the recursive calls, instead of afterwards, potentially optimizing away many such calls:</span></h6>
<p><span class="font2">sub print_tree { my $t = shift; print_tree($t-&gt;left) if $t-&gt;left; print $t-&gt;root, &quot;</span><span class="font2" style="font-weight:bold;">\</span><span class="font2">n&quot;;</span></p>
<p><span class="font2">print_tree($t-&gt;right) if $t-&gt;right; }</span></p>
<h6><a name="bookmark289"></a><span class="font17">Eliminating the tail call yields:</span></h6>
<p><span class="font2">sub print_tree { my $t = shift;</span></p>
<p><span class="font2" style="font-weight:bold;">do {</span></p>
<p><span class="font2">print_tree($t-&gt;left) if $t-&gt;left;</span></p>
<p><span class="font2">print $t-&gt;root, &quot;</span><span class="font2" style="font-weight:bold;">\</span><span class="font2">n&quot;;</span></p>
<p><span class="font2" style="font-weight:bold;">$t = $t-&gt;right;</span></p>
<p><span class="font2" style="font-weight:bold;">} while $t;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">SOMEONE ELSE</span><span class="font20">’</span><span class="font17">S PROBLEM</span></p>
<p><span class="font17">Here’s a particularly interesting example, taken from </span><span class="font17" style="font-style:italic;">Mastering Algorithms with Perl</span><span class="font13"> 5</span><span class="font17">. Given a set of key-value pairs (represented as a hash, of course), it returns the </span><span class="font17" style="font-style:italic;">power set</span><span class="font17"> of that set. This is the set of all hashes that can be obtained from the original hash by deleting zero or more of the pairs.</span></p>
<p><span class="font17">For example, the power set of </span><span class="font2">{apple =&gt; 'red', banana =&gt; 'yellow', grape =&gt; 'purple'} </span><span class="font17">is:</span></p>
<table border="1">
<tr><td>
<p><span class="font2">{apple =&gt;</span></p></td><td>
<p><span class="font2">'red', banana =&gt;</span></p></td><td>
<p><span class="font2">'yellow',</span></p></td><td>
<p><span class="font2">grape =&gt;</span></p></td><td>
<p><span class="font2">'purple'}</span></p></td></tr>
<tr><td style="vertical-align:bottom;">
<p><span class="font2">{apple =&gt;</span></p>
<p><span class="font2">{apple =&gt;</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">'red', banana =&gt;</span></p>
<p><span class="font2">'red',</span></p></td><td>
<p><span class="font2">'yellow'}</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">grape =&gt;</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">'purple'}</span></p></td></tr>
<tr><td>
<p><span class="font2">{apple =&gt;</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">'red'}</span></p>
<p><span class="font2">{banana =&gt;</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">'yellow',</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">grape =&gt;</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">'purple'}</span></p></td></tr>
<tr><td></td><td>
<p><span class="font2">{banana =&gt;</span></p></td><td>
<p><span class="font2">'yellow'}</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">{grape =&gt;</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">'purple'}</span></p></td></tr>
</table>
<p><span class="font2">{}</span></p>
<p><span class="font15">5 This example is taken from Orwant, Hietaniemi, and Macdonald, </span><span class="font15" style="font-style:italic;">Mastering Algorithms with Perl, </span><span class="font15">pp. 237-238. O’Reilly and Associates, 1999.</span></p>
<p><span class="font17">The power set is returned as a hash of hashes. The keys of the return value are unimportant, and the values are the elements of the power set. Here’s the code that Hietaniemi presents:</span></p>
<p><span class="font2">sub powerset_recurse ($;@) {</span></p>
<div>
<p><span class="font9" style="font-weight:bold;">CODE LIBRARY</span></p>
</div><br clear="all">
<div>
<p><span class="font0">powerset-0</span></p>
</div><br clear="all">
<p><span class="font2">my ( Sset, Spowerset, Skeys, Svalues, Sn, Si ) = @_;</span></p>
<p><span class="font2">if ( @_ == 1 ) {# Initialize.</span></p>
<p><a href="#bookmark290"><span class="font2">my Snull &nbsp;&nbsp;= {</span></a></p>
<p><span class="font2">Spowerset &nbsp;= { Snull, Snull };</span></p>
<p><a href="#bookmark291"><span class="font2">Skeys &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= [ keys &nbsp;&nbsp;%{ Sset }</span></a></p>
<p><a href="#bookmark292"><span class="font2">Svalues &nbsp;&nbsp;&nbsp;= [ values %{ Sset }</span></a></p>
<p><span class="font2">Snmembers = keys %{ Sset }; &nbsp;&nbsp;# This many rounds.</span></p>
<p><span class="font2">Si &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= 0; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# The current round.</span></p>
<p><span class="font2">}</span></p>
<ul style="list-style:none;"><li>
<p><span class="font2"># Ready?</span></p></li></ul>
<p><span class="font2">return Spowerset if Si == Snmembers;</span></p>
<ul style="list-style:none;"><li>
<p><span class="font2"># Remap.</span></p></li></ul>
<p><span class="font2">my @powerkeys = keys %{ Spowerset };</span></p>
<p><span class="font2">my @powervalues = values %{ Spowerset };</span></p>
<p><span class="font2">my Spowern = @powerkeys; my Sj;</span></p>
<p><span class="font2">for ( Sj = 0; Sj &lt;&nbsp;Spowern; Sj++ ) { my %subset = ( );</span></p>
<ul style="list-style:none;"><li>
<p><span class="font2"># Copy the old set to the subset.</span></p></li></ul>
<p><span class="font2">@subset{keys %{ Spowerset-&gt;{ Spowerkeys [ Sj ] } }} = values %{ Spowerset-&gt;{ Spowervalues[ Sj ] } };</span></p>
<ul style="list-style:none;"><li>
<p><span class="font2"># Add the new member to the subset.</span></p></li></ul>
<p><span class="font2">Ssubset{Skeys-&gt;[ Si ]} = Svalues-&gt;[ Si ];</span></p>
<ul style="list-style:none;"><li>
<p><span class="font2"># Add the new subset to the powerset.</span></p></li></ul>
<p><span class="font2">Spowerset-&gt;{ </span><span class="font2" style="font-weight:bold;">\</span><span class="font2">%subset } = </span><span class="font2" style="font-weight:bold;">\</span><span class="font2">%subset; }</span></p>
<ul style="list-style:none;"><li>
<p><span class="font2"># Recurse.</span></p>
<div>
<p><span class="font20">236</span></p>
</div><br clear="all"></li></ul>
<p><span class="font15">CHAPTER 5 From Recursion to Iterators</span></p>
<p><span class="font2">powerset_recurse( Sset, Spowerset, Skeys, Svalues, Snmembers, Si+1 );</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">Clearly, the recursive call here is a tail call. Applying the usual tail-call optimization, we can replace the recursive call with a loop. The special case initialization for the last five parameters no longer needs to be a special case; we just take care of the initialization before we enter the loop. The peculiar </span><span class="font2">(S;@) </span><span class="font17">prototype goes away entirely, or maybe becomes </span><span class="font2">(S)</span><span class="font17">:</span></p>
<table border="1">
<tr><td style="vertical-align:bottom;">
<p><span class="font9" style="font-weight:bold;">CODE LIBRARY</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2" style="font-weight:bold;">sub powerset_recurse ($) {</span></p></td></tr>
<tr><td>
<p><span class="font0">powerset-1</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2" style="font-weight:bold;">my ( $set ) = @_;</span></p>
<p><span class="font2">my Snull = { };</span></p>
<p><span class="font2">my Spowerset &nbsp;= { Snull, Snull };</span></p>
<p><span class="font2">my Skeys &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= [ keys &nbsp;&nbsp;%{ Sset } ];</span></p>
<p><span class="font2">my Svalues &nbsp;&nbsp;&nbsp;= [ values %{ Sset } ];</span></p>
<p><span class="font2">my Snmembers &nbsp;= keys %{ Sset }; &nbsp;&nbsp;&nbsp;# This many rounds.</span></p>
<p><span class="font2">my Si &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= 0; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# The current round</span></p></td></tr>
</table>
<p><span class="font2" style="font-weight:bold;">until ($i == Snmembers) {</span></p>
<p><span class="font2"># Remap.</span></p>
<p><span class="font2">my @powerkeys = keys %{ Spowerset };</span></p>
<p><span class="font2">my @powervalues = values %{ Spowerset };</span></p>
<p><span class="font2">my Spowern = @powerkeys;</span></p>
<p><span class="font2">my Sj;</span></p>
<p><span class="font2">for ( Sj = 0; Sj &lt;&nbsp;Spowern; Sj++ ) { my %subset = ( );</span></p>
<ul style="list-style:none;"><li>
<p><span class="font2"># Copy the old set to the subset.</span></p></li></ul>
<p><span class="font2">@subset{keys %{ Spowerset-&gt;{ Spowerkeys [ Sj ] } }} = values %{ Spowerset-&gt;{ Spowervalues[ Sj ] } };</span></p>
<ul style="list-style:none;"><li>
<p><span class="font2"># Add the new member to the subset.</span></p></li></ul>
<p><span class="font2">Ssubset{Skeys-&gt;[ Si ]} = Svalues-&gt;[ Si ];</span></p>
<ul style="list-style:none;"><li>
<p><span class="font2"># Add the new subset to the powerset. Spowerset-&gt;{ </span><span class="font2" style="font-weight:bold;">\</span><span class="font2">%subset } = </span><span class="font2" style="font-weight:bold;">\</span><span class="font2">%subset;</span></p></li></ul>
<p><span class="font2">}</span></p>
<p><span class="font2" style="font-weight:bold;">$i++;</span></p>
<p><span class="font15">5.4 OTHER GENERAL TECHNIQUES FOR ELIMINATING RECURSION</span></p>
<div>
<p><span class="font20">237</span></p>
</div><br clear="all">
<p><span class="font2" style="font-weight:bold;">return Spowerset; </span><span class="font2">}</span></p>
<h6><a name="bookmark293"></a><span class="font17">Now we can see that </span><span class="font2">Si</span><span class="font17">, the loop counter variable, just runs from 0 up to </span><span class="font2">Snmembers-1</span><span class="font17">, so we can rewrite the </span><span class="font2">while </span><span class="font17">loop as a </span><span class="font2">for </span><span class="font17">loop:</span></h6>
<p><span class="font2">sub powerset_recurse (S) {</span></p>
<div>
<p><span class="font9" style="font-weight:bold;">CODE LIBRARY</span></p>
</div><br clear="all">
<p><span class="font0">powerset-2</span></p>
<p><a href="#bookmark294"><span class="font2">my ( Sset ) = @_;</span></a></p>
<p><a href="#bookmark295"><span class="font2">my Snull = {</span></a></p>
<p><span class="font2">my Spowerset &nbsp;= { Snull, Snull };</span></p>
<p><a href="#bookmark296"><span class="font2">my Skeys &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= [ keys &nbsp;&nbsp;%{ Sset }</span></a></p>
<p><a href="#bookmark297"><span class="font2">my Svalues &nbsp;&nbsp;&nbsp;= [ values %{ Sset }</span></a></p>
<p><span class="font2">my Snmembers &nbsp;= keys %{ Sset }; &nbsp;&nbsp;&nbsp;# This many rounds.</span></p>
<p><span class="font2" style="font-weight:bold;">for my Si (0 .. Snmembers-1) {</span></p>
<p><span class="font2"># Remap.</span></p>
<p><a href="#bookmark298"><span class="font2">my @powerkeys &nbsp;&nbsp;= keys &nbsp;&nbsp;%{ Spowerset</span></a></p>
<p><a href="#bookmark299"><span class="font2">my @powervalues = values %{ Spowerset</span></a></p>
<p><span class="font2">my Spowern &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= @powerkeys;</span></p>
<p><span class="font2">my Sj;</span></p>
<p><span class="font2">for ( Sj = 0; Sj &lt;&nbsp;Spowern; Sj++ ) { my %subset = ( );</span></p>
<p><span class="font2"># Copy the old set to the subset.</span></p>
<p><span class="font2">@subset{keys %{ Spowerset-&gt;{ Spowerkeys [ Sj ] } }} = values %{ Spowerset-&gt;{ Spowervalues[ Sj ] } };</span></p>
<p><span class="font2"># Add the new member to the subset.</span></p>
<p><span class="font2">Ssubset{Skeys-&gt;[ Si ]} = Svalues-&gt;[ Si ];</span></p>
<p><span class="font2"># Add the new subset to the powerset. Spowerset-&gt;{ \%subset } = \%subset;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">return Spowerset; }</span></p>
<table border="1">
<tr><td></td><td>
<p><span class="font17">Now that we’ve done this, it appears that the only purpose of </span><span class="font2">$i </span><span class="font17">is to index </span><span class="font2">@$keys and @$values</span><span class="font17">. Since these are precisely the keys and values of </span><span class="font2">%$set</span><span class="font17">, we can eliminate all three variables in favor of a simple </span><span class="font2">while (each %$set) </span><span class="font17">loop:</span></p></td></tr>
<tr><td>
<p><span class="font9" style="font-weight:bold;text-decoration:underline;">CODE LIBRARY </span><span class="font0">powerset-3</span></p></td><td>
<p><span class="font2">sub powerset_recurse ($) {</span></p>
<p><span class="font2">my ( $set ) = @_;</span></p>
<p><span class="font2">my $null = { };</span></p>
<p><span class="font2">my $powerset = { $null, $null };</span></p>
<p><span class="font2" style="font-weight:bold;">while (my ($key, $value) = each %$set) {</span></p>
<p><span class="font2"># Remap.</span></p>
<p><span class="font2">my @powerkeys = keys %{ $powerset };</span></p>
<p><span class="font2">my @powervalues = values %{ $powerset };</span></p>
<p><span class="font2">my $powern &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= @powerkeys;</span></p>
<p><span class="font2">my $j;</span></p>
<p><span class="font2">for ( $j = 0; $j &lt;&nbsp;$powern; $j++ ) { my %subset = ( );</span></p>
<ul style="list-style:none;"><li>
<p><span class="font2"># Copy the old set to the subset.</span></p></li></ul>
<p><span class="font2">@subset{keys %{ $powerset-&gt;{ $powerkeys [ $j ] } }} = values %{ $powerset-&gt;{ $powervalues[ $j ] } };</span></p>
<ul style="list-style:none;"><li>
<p><span class="font2"># Add the new member to the subset.</span></p></li></ul>
<p><span class="font2" style="font-weight:bold;">$subset{$key} = $value;</span></p>
<ul style="list-style:none;"><li>
<p><span class="font2"># Add the new subset to the powerset. $powerset-&gt;{ </span><span class="font2" style="font-weight:bold;">\</span><span class="font2">%subset } = </span><span class="font2" style="font-weight:bold;">\</span><span class="font2">%subset;</span></p></li></ul>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">return $powerset;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">If we’re feeling sharp, we might notice the same thing about </span><span class="font2">$j</span><span class="font17">:</span></p></td></tr>
<tr><td>
<p><span class="font9" style="font-weight:bold;">CODE LIBRARY </span><span class="font0">powerset-4</span></p></td><td>
<p><span class="font2">sub powerset_recurse ($) { my ( $set ) = @_;</span></p>
<p><span class="font2">my $null = { };</span></p></td></tr>
</table>
<p><span class="font2">my Spowerset = { $null, $null };</span></p>
<p><span class="font2">while (my (Skey, Svalue) = each %Sset) {</span></p>
<p><span class="font2" style="font-weight:bold;">my @newitems;</span></p>
<p><span class="font2" style="font-weight:bold;">while (my (Spowerkey, Spowervalue) = each %$powerset) { </span><span class="font2">my %subset = ( );</span></p>
<ul style="list-style:none;"><li>
<p><span class="font2"># Copy the old set to the subset.</span></p></li></ul>
<p><span class="font2" style="font-weight:bold;">@subset{keys %{ $powerset-&gt;{$powerkey} } } = values %{ $powerset-&gt;{$powervalue} };</span></p>
<ul style="list-style:none;"><li>
<p><span class="font2"># Add the new member to the subset.</span></p></li></ul>
<p><span class="font2">Ssubset{Skey} = Svalue;</span></p>
<ul style="list-style:none;"><li>
<p><span class="font2"># Prepare to add the new subset to the powerset.</span></p></li></ul>
<p><span class="font2" style="font-weight:bold;">push @newitems, </span><span class="font2">\</span><span class="font2" style="font-weight:bold;">%subset;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2" style="font-weight:bold;">$powerset-&gt;{ $_}=$_ for @newitems;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">return Spowerset;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">Getting rid of the unnecessary recursion made the state changes of the variables clearer and kicked off a series of simplifications that left the function with about one-third less code.</span></p>
<ul style="list-style:none;"><li>
<h5><a name="bookmark113"></a><span class="font19">5.4.2 Creating Tail Calls</span></h5></li></ul>
<p><span class="font17">Often, a function that doesn’t have a tail call can be easily converted into one that does. For example, consider the decimal-to-binary conversion function of Chapter 1:</span></p>
<p><span class="font2">sub binary {</span></p>
<p><span class="font2">my (Sn) = @_;</span></p>
<p><span class="font2">return Sn if Sn == 0 || Sn == 1;</span></p>
<p><span class="font2">my Sk = int(Sn/2);</span></p>
<p><span class="font2">my Sb = Sn % 2;</span></p>
<p><span class="font2">my SE = binary(Sk);</span></p>
<p><span class="font2">return SE . Sb;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">Here the recursive call isn’t in the tail position. The return value from the recursive call isn’t returned directly, but rather is concatenated to </span><span class="font2">Sb</span><span class="font17">.</span></p>
<p><span class="font17">The general technique for converting such a function to one that does a tail call is to add an auxiliary parameter that records the return value so far. When the other parameters indicate that the recursion is complete, the function returns the return-value parameter. Instead of making a recursive call, waiting for the return value, modifying it, and returning the result, the modified version takes the return value parameter, modifies it appropriately, and passes it along. When we apply this idea to the </span><span class="font2">binary() </span><span class="font17">function, we get this:</span></p>
<div>
<p><span class="font9" style="font-weight:bold;">CODE LIBRARY</span></p>
</div><br clear="all">
<p><span class="font2">sub binary {</span></p>
<p><span class="font0"><sup>binary-1</sup> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="font2">my (Sn, SRETVAL) = @_;</span></p>
<p><span class="font2">SRETVAL = &quot;&quot;&nbsp;unless defined SRETVAL;</span></p>
<p><span class="font2">my Sk = int(Sn/2);</span></p>
<p><span class="font2">my Sb = Sn % 2;</span></p>
<p><span class="font2">SRETVAL = &quot;SbSRETVAL&quot;;</span></p>
<p><span class="font2">return SRETVAL if Sn == 0 || Sn == 1;</span></p>
<p><span class="font2">binary(Sk, SRETVAL);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">SRETVAL </span><span class="font17">records the bit sequence computed so far; if unspecified, it defaults to the empty string. On each call, the function appends a new bit to this bit string. If </span><span class="font2">Sn </span><span class="font17">is 0 or 1, that’s the base case, and the function just returns the bit string; otherwise, it makes a recursive call with the new value of </span><span class="font2">Sn </span><span class="font17">and the new bit string.</span></p>
<p><span class="font17">Applying the tail-call optimization to this version of </span><span class="font2">binary() </span><span class="font17">yields:</span></p>
<div>
<p><span class="font9" style="font-weight:bold;">CODE LIBRARY</span></p>
</div><br clear="all">
<p><span class="font2">sub binary {</span></p>
<p><span class="font0"><sup>binary-2</sup> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="font2">my (Sn, SRETVAL) = @_;</span></p>
<p><span class="font2" style="font-weight:bold;">SRETVAL = &quot;&quot;;</span></p>
<p><span class="font2" style="font-weight:bold;">while (1) </span><span class="font2">{</span></p>
<p><span class="font2">my Sk = int(Sn/2);</span></p>
<p><span class="font2">my Sb = Sn % 2;</span></p>
<p><span class="font2">SRETVAL = &quot;SbSRETVAL&quot;;</span></p>
<p><span class="font2">return SRETVAL if Sn == 0 || Sn == 1;</span></p>
<div>
<p><span class="font15">5.4 OTHER GENERAL TECHNIQUES FOR ELIMINATING RECURSION</span></p>
</div><br clear="all">
<div>
<h4><a name="bookmark300"></a><span class="font20">241</span></h4>
</div><br clear="all">
<div>
<p><span class="font2" style="font-weight:bold;">$n = $k;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
</div><br clear="all">
<div>
<h6><a name="bookmark301"></a><span class="font17">and then optimizing away the unnecessary </span><span class="font2">Sk</span><span class="font17">:</span></h6>
</div><br clear="all">
<div>
<p><span class="font2">sub binary {</span></p>
<p><span class="font2">my (Sn, SRETVAL) = @_;</span></p>
<p><span class="font2">SRETVAL = &quot;&quot;;</span></p>
<p><span class="font2">while (1) {</span></p>
<p><span class="font2">my Sb = Sn % 2;</span></p>
<p><span class="font2">SRETVAL = &quot;SbSRETVAL&quot;;</span></p>
<p><span class="font2">return SRETVAL if Sn == 0 || Sn == 1;</span></p>
<p><span class="font2" style="font-weight:bold;">$n = int($n/2);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
<h6><a name="bookmark302"></a><span class="font17">Adding an extra parameter to the </span><span class="font2">factorial() </span><span class="font17">function of Chapter 1 transforms this:</span></h6>
</div><br clear="all">
<div>
<p><span class="font9" style="font-weight:bold;">CODE LIBRARY</span></p>
</div><br clear="all">
<div>
<p><span class="font0">binary-3</span></p>
</div><br clear="all">
<div>
<p><span class="font2">sub factorial { my (Sn) = @_; return 1 if Sn == 0; return factorial(Sn-l) * Sn;</span></p>
<p><span class="font2">}</span></p>
<h6><a name="bookmark303"></a><span class="font17">into this:</span></h6>
</div><br clear="all">
<div>
<p><span class="font9" style="font-weight:bold;">CODE LIBRARY</span></p>
</div><br clear="all">
<div>
<p><span class="font0">factorial-0</span></p>
</div><br clear="all">
<div>
<p><span class="font2">sub factorial {</span></p>
<p><span class="font2">my (Sn, Sproduct) = @_;</span></p>
<p><span class="font2">Sproduct = 1 unless defined Sproduct; return Sproduct if Sn == 0;</span></p>
<p><span class="font2">return factorial(Sn-1, Sn * Sproduct); }</span></p>
<h6><a name="bookmark304"></a><span class="font17">Then we can eliminate the tail call:</span></h6>
<p><span class="font2">sub factorial { my (Sn) = @_; my Sproduct = 1; until (Sn == 0) { Sproduct *= Sn; Sn--;</span></p>
</div><br clear="all">
<div>
<p><span class="font9" style="font-weight:bold;">CODE LIBRARY</span></p>
</div><br clear="all">
<div>
<p><span class="font0">factorial-1</span></p>
</div><br clear="all">
<div>
<p><span class="font9" style="font-weight:bold;">CODE LIBRARY</span></p>
</div><br clear="all">
<div>
<p><span class="font0">factorial-2</span></p>
</div><br clear="all">
<table border="1">
<tr><td style="vertical-align:bottom;">
<p><span class="font20">242</span></p></td><td style="vertical-align:bottom;">
<p><span class="font15">CHAPTER 5 From Recursion to Iterators</span></p></td></tr>
</table>
<p><span class="font2">}</span></p>
<p><span class="font2">return Sproduct;</span></p>
<p><span class="font2">}</span></p>
<ul style="list-style:none;"><li>
<h5><a name="bookmark114"></a><span class="font19">5.4.3 Explicit Stacks</span></h5></li></ul>
<p><span class="font17">When we last saw the </span><span class="font2">print_tree() </span><span class="font17">example, it looked like this:</span></p>
<p><span class="font2">sub print_tree {</span></p>
<p><span class="font2">my St = shift;</span></p>
<p><span class="font2">do {</span></p>
<p><span class="font2">print_tree(St-&gt;left) if St-&gt;left;</span></p>
<p><span class="font2">print St-&gt;root, &quot;</span><span class="font2" style="font-weight:bold;">\</span><span class="font2">n&quot;;</span></p>
<p><span class="font2">St = St-&gt;right;</span></p>
<p><span class="font2">} while St;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">The original function had two recursive calls, one of which was a tail call, and was eliminated in this version. The other call remains.</span></p>
<p><span class="font17">To get rid of a recursive call embedded in the middle of a function may require heavy machinery. The heaviest machinery is to explicitly simulate the same stack operations that Perl normally performs implicitly on function call and return. Making a recursive call records the function’s current state on the stack, and returning from a call pops the stack. The function’s current state, as we saw earlier, may in general include all of its local variables and parameters.</span></p>
<p><span class="font17">The state of </span><span class="font2">print_tree() </span><span class="font17">comprises nothing more than </span><span class="font2">St</span><span class="font17">, the tree argument itself. So our state-saving operation will be simple. We replace the recursive call </span><span class="font2">print_tree(St-&gt;left) </span><span class="font17">with a stack push:</span></p>
<p><span class="font2">sub print_tree {</span></p>
<p><span class="font2">my St = shift;</span></p>
<p><span class="font2" style="font-weight:bold;">my @STACK;</span></p>
<p><span class="font2">do {</span></p>
<p><span class="font2" style="font-weight:bold;">push(@STACK, $t), $t = $t-&gt;left if $t-&gt;left;</span></p>
<p><span class="font17">and then, in place of the function return, we add a stack pop and a jump back to the line right after the recursive call:</span></p>
<p><span class="font2" style="font-weight:bold;">RETURN:</span></p>
<p><span class="font2">print St-&gt;root, &quot;</span><span class="font2" style="font-weight:bold;">\</span><span class="font2">n&quot;;</span></p>
<p><span class="font2">$t = $t-&gt;right;</span></p>
<p><span class="font2">} while $t;</span></p>
<p><span class="font2" style="font-weight:bold;">return unless @STACK;</span></p>
<p><span class="font2" style="font-weight:bold;">$t = pop @STACK;</span></p>
<p><span class="font2" style="font-weight:bold;">goto RETURN;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">(Or, if the stack is empty, then the function returns for real instead of popping.) One objection to this is likely to be that it uses </span><span class="font2">goto</span><span class="font17">, which people think is naughty. We can get rid of the </span><span class="font2">goto </span><span class="font17">by transforming the code to this:</span></p>
<p><span class="font2">sub print_tree {</span></p>
<p><span class="font2">my $t = shift;</span></p>
<p><span class="font2">my @STACK;</span></p>
<p><span class="font2" style="font-weight:bold;">RIGHT: {</span></p>
<p><span class="font2">push(@STACK, $t), $t = $t-&gt;left while $t-&gt;left;</span></p>
<p><span class="font2" style="font-weight:bold;">do {</span></p>
<p><span class="font2">print $t-&gt;root, &quot;</span><span class="font2" style="font-weight:bold;">\</span><span class="font2">n&quot;;</span></p>
<p><span class="font2">$t = $t-&gt;right;</span></p>
<p><span class="font2" style="font-weight:bold;">redo RIGHT if $t;</span></p>
<p><span class="font2">return unless @STACK;</span></p>
<p><span class="font2">$t = pop @STACK;</span></p>
<p><span class="font2" style="font-weight:bold;">} while 1;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">This is really the same thing, except we have cosmetically disguised the </span><span class="font2">goto </span><span class="font17">as a </span><span class="font2">do-while </span><span class="font17">loop, and turned the old </span><span class="font2">do-while </span><span class="font17">loop into a </span><span class="font2">redo</span><span class="font17">. Loop control statements such as </span><span class="font2">next</span><span class="font17">, </span><span class="font2">last</span><span class="font17">, and </span><span class="font2">redo </span><span class="font17">are no more than </span><span class="font2">goto</span><span class="font17">s in disguise, of course, and in fact so are loops.</span></p>
<p><span class="font17">ELIMINATING RECURSION FROM </span><span class="font3">fib()</span></p>
<p><span class="font17">Let’s apply the same process to the Fibonacci function:</span></p>
<p><span class="font2">sub fib {</span></p>
<div>
<p><span class="font9" style="font-weight:bold;">CODE LIBRARY</span></p>
</div><br clear="all">
<div>
<p><span class="font0">fib-0</span></p>
</div><br clear="all">
<p><span class="font2">my $n = shift;</span></p>
<p><span class="font2">if ($n &lt;&nbsp;2) { return $n } fib($n-2) + fib($n-1);</span></p>
<p><span class="font2">}</span></p>
<div>
<p><span class="font9" style="font-weight:bold;">CODE LIBRARY</span></p>
</div><br clear="all">
<div>
<p><span class="font0">fib-1</span></p>
</div><br clear="all">
<div>
<p><span class="font9" style="font-weight:bold;">CODE LIBRARY</span></p>
</div><br clear="all">
<div>
<p><span class="font0">fib-2</span></p>
</div><br clear="all">
<div>
<p><span class="font17">There are no tail calls here. The </span><span class="font2">fib($n-1) </span><span class="font17">looks like it might be, but it isn’t, because it’s not the very last thing the function does before it returns; the addition is. So we can’t use tail-call elimination. Instead, we’ll roll out the heavy guns and manage the stack explicitly.</span></p>
<p><span class="font17">The state tracked by </span><span class="font2">fib() </span><span class="font17">is more complicated than in the </span><span class="font2">print_tree() </span><span class="font17">example. The parameter </span><span class="font2">$n </span><span class="font17">is clearly part of the state, but there is some additional state that isn’t so obvious. Since there are two recursive calls to </span><span class="font2">fib</span><span class="font17">, after we return from a recursive call, we have to remember how to pick up where we left off: Were we about to make the second call, or were we about to perform the addition? Moreover, during the second recursive call, the function’s state must include the result from the first recursive call.</span></p>
<p><span class="font17">In difficult cases, the first step in eliminating recursive calls is to make this state explicit. We rewrite </span><span class="font2">fib() </span><span class="font17">as follows:</span></p>
</div><br clear="all">
<div>
<p><span class="font2">sub fib {</span></p>
<p><span class="font2">my $n = shift;</span></p>
<p><span class="font2">if ($n &lt;&nbsp;2) { return $n;</span></p>
<p><span class="font2">} else {</span></p>
<p><span class="font2" style="font-weight:bold;">my $s1 = fib($n-2);</span></p>
<p><span class="font2" style="font-weight:bold;">my $s2 = fib($n-1); return $s1 + $s2;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
</div><br clear="all">
<div>
<p><span class="font17">The second step is to introduce a loop to separate the initialization of the function from the body:</span></p>
</div><br clear="all">
<div>
<p><span class="font2">sub fib {</span></p>
<p><span class="font2">my $n = shift;</span></p>
<p><span class="font2" style="font-weight:bold;">while (1) {</span></p>
<p><span class="font2">if ($n &lt;&nbsp;2) { return $n;</span></p>
<p><span class="font2">} else {</span></p>
<p><span class="font2">my $s1 = fib($n-2);</span></p>
<p><span class="font2">my $s2 = fib($n-1); return $s1 + $s2;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2" style="font-weight:bold;">}</span></p>
<p><span class="font2">}</span></p>
</div><br clear="all">
<div>
<p><span class="font17">Eventually, we’ll have a stack that simulates Perl’s call stack; the loop we just introduced is simulating Perl itself.</span></p>
<p><span class="font17">The third step is to break the body into chunks, each of which contains the code from the end of one recursive call to the beginning of the next. Breaks may occur in the middle of a statement. For example, in </span><span class="font2">my $s1 = fib($n-1)</span><span class="font17">, the </span><span class="font2">$n-1 </span><span class="font17">is computed before the call, but the assignment is done after the call, in a separate chunk. Put each chunk in a separate branch of an </span><span class="font2">if-else </span><span class="font17">tree:</span></p>
</div><br clear="all">
<div>
<p><span class="font2">sub fib {</span></p>
<p><span class="font2">my $n = shift;</span></p>
<p><span class="font2" style="font-weight:bold;">my ($s1, $s2, $return);</span></p>
<p><span class="font2">while (1) {</span></p>
<p><span class="font2">if ($n &lt;&nbsp;2) { return $n;</span></p>
<p><span class="font2">} else {</span></p>
<p><span class="font2" style="font-weight:bold;">if ($BRANCH == 0) { $return = fib($n-2);</span></p>
<p><span class="font2" style="font-weight:bold;">} elsif ($BRANCH == 1) { $s1 = $return;</span></p>
<p><span class="font2" style="font-weight:bold;">$return = fib($n-1);</span></p>
<p><span class="font2" style="font-weight:bold;">} elsif ($BRANCH == 2) { $s2 = $return;</span></p>
<p><span class="font2" style="font-weight:bold;">$return = $s1 + $s2;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
</div><br clear="all">
<div>
<p><span class="font9" style="font-weight:bold;">CODE LIBRARY</span></p>
</div><br clear="all">
<div>
<p><span class="font0">fib-3</span></p>
</div><br clear="all">
<div>
<p><span class="font17">Because a statement like </span><span class="font2">$s1 = fib($n-2) </span><span class="font17">was split across chunks, I’ve introduced a temporary value, </span><span class="font2">$return</span><span class="font17">, to hold the return value from </span><span class="font2">fib($n-2) </span><span class="font17">until it can be assigned to </span><span class="font2">$s1</span><span class="font17">. I’ve also moved the declaration of </span><span class="font2">$s1 </span><span class="font17">and </span><span class="font2">$s2 </span><span class="font17">up to the top of the function. Our new </span><span class="font2">fib() </span><span class="font17">function is effectively simulating the behavior of the old one, and </span><span class="font2">$s1 </span><span class="font17">and </span><span class="font2">$s2 </span><span class="font17">represent information about the function’s internal state that are normally traced internally by Perl. They are therefore global to the function itself.</span></p>
<p><span class="font17">Similarly, </span><span class="font2">$BRANCH </span><span class="font17">will record where in the function we left off to make a recursive call. This is another thing Perl normally tracks internally. Initially, it’s 0, indicating that we want to start at the top of the body. When we simulate a return from a recursive call, it will be 1 or 2, telling us to pick up later on in the body where we left off:</span></p>
</div><br clear="all">
<div>
<p><span class="font2">sub fib {</span></p>
<p><span class="font2">my $n = shift;</span></p>
</div><br clear="all">
<div>
<p><span class="font9" style="font-weight:bold;">CODE LIBRARY</span></p>
</div><br clear="all">
<div>
<p><span class="font0">fib-4</span></p>
</div><br clear="all">
<p><span class="font2">my (Ss1, Ss2, Sreturn);</span></p>
<p><span class="font2" style="font-weight:bold;">my SBRANCH = 0;</span></p>
<p><span class="font2">while (1) {</span></p>
<p><span class="font2">if (Sn &lt;&nbsp;2) { return Sn;</span></p>
<p><span class="font2">} else {</span></p>
<p><span class="font2">if (SBRANCH == 0) { Sreturn = fib(Sn-2);</span></p>
<p><span class="font2">} elsif (SBRANCH == 1) { Ss1 = Sreturn;</span></p>
<p><span class="font2">Sreturn = fib(Sn-1);</span></p>
<p><span class="font2">} elsif (SBRANCH == 2) { Ss2 = Sreturn;</span></p>
<p><span class="font2">Sreturn = Ss1 + Ss2;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">Returning directly from the middle of the </span><span class="font2">while </span><span class="font17">loop is inappropriate, because the simulated stack might not be empty. So for step 4, we’ll convert any remaining </span><span class="font2">returns </span><span class="font17">into assignments to </span><span class="font2">Sreturn</span><span class="font17">. Later on in the function, we’ll return the contents of </span><span class="font2">Sreturn </span><span class="font17">if the simulated stack is empty:</span></p>
<div>
<p><span class="font9" style="font-weight:bold;">CODE LIBRARY</span></p>
</div><br clear="all">
<div>
<p><span class="font0">fib-5</span></p>
</div><br clear="all">
<p><span class="font2">sub fib {</span></p>
<p><span class="font2">my Sn = shift;</span></p>
<p><span class="font2">my (Ss1, Ss2, Sreturn);</span></p>
<p><span class="font2">my SBRANCH = 0;</span></p>
<p><span class="font2">while (1) {</span></p>
<p><span class="font2">if (Sn &lt;&nbsp;2) {</span></p>
<p><span class="font2" style="font-weight:bold;">Sreturn = Sn;</span></p>
<p><span class="font2">} else {</span></p>
<p><span class="font2">if (SBRANCH == 0) { Sreturn = fib(Sn-2);</span></p>
<p><span class="font2">} elsif (SBRANCH == 1) {</span></p>
<p><span class="font2">Ss1 = Sreturn;</span></p>
<p><span class="font2">Sreturn = fib(Sn-1);</span></p>
<p><span class="font2">} elsif (SBRANCH == 2) { Sreturn = Ss1 + Ss2;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">Step 5 is the important one: Replace all the recursive calls with code that pushes the function state onto the synthetic stack and then transfers control back to the top of the function:</span></p>
<p><span class="font2">sub fib {</span></p>
<div>
<p><span class="font9" style="font-weight:bold;">CODE LIBRARY</span></p>
</div><br clear="all">
<div>
<p><span class="font0">fib-6</span></p>
</div><br clear="all">
<p><span class="font2">my Sn = shift;</span></p>
<p><span class="font2">my (Ss1, Ss2, Sreturn);</span></p>
<p><span class="font2">my SBRANCH = 0;</span></p>
<p><span class="font2" style="font-weight:bold;">my @STACK;</span></p>
<p><span class="font2">while (1) {</span></p>
<p><span class="font2">if (Sn &lt;&nbsp;2) { Sreturn = Sn;</span></p>
<p><span class="font2">} else {</span></p>
<p><span class="font2">if (SBRANCH == 0) {</span></p>
<p><span class="font2" style="font-weight:bold;">push @STACK, [ SBRANCH, Ss1, Ss2, Sn ];</span></p>
<p><span class="font2" style="font-weight:bold;">Sn -= 2;</span></p>
<p><span class="font2" style="font-weight:bold;">SBRANCH = 0; next;</span></p>
<p><span class="font2">} elsif (SBRANCH == 1) { Ss1 = Sreturn;</span></p>
<p><span class="font2" style="font-weight:bold;">push @STACK, [ SBRANCH, Ss1, Ss2, Sn ];</span></p>
<p><span class="font2" style="font-weight:bold;">Sn -= 1;</span></p>
<p><span class="font2" style="font-weight:bold;">SBRANCH = 0; next;</span></p>
<p><span class="font2">} elsif (SBRANCH == 2) { Ss2 = Sreturn;</span></p>
<p><span class="font2">Sreturn = Ss1 + Ss2; }</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">Since this is important, let’s look at one of the calls in detail. When </span><span class="font2">fib() </span><span class="font17">calls </span><span class="font2">fib(Sn-2)</span><span class="font17">, it saves all its state and then transfers control back to the top of </span><span class="font2">fib()</span><span class="font17">, which starts up just as before, but with argument </span><span class="font2">Sn-2 </span><span class="font17">instead of </span><span class="font2">Sn</span><span class="font17">. The code we put in is doing exactly that. It saves the current state on the stack:</span></p>
<p><span class="font2">push @STACK, [ SBRANCH, Ss1, Ss2, Sn ];</span></p>
<p><span class="font17">Then it adjusts the value of the argument from </span><span class="font2">Sn </span><span class="font17">to </span><span class="font2">Sn-2</span><span class="font17">:</span></p>
<p><span class="font2">Sn -= 2;</span></p>
<p><span class="font17">Then it adjusts the value of </span><span class="font2">SBRANCH </span><span class="font17">to say that control should continue from the top of the function, not the middle:</span></p>
<p><span class="font2">SBRANCH = 0;</span></p>
<p><span class="font17">This was unnecessary in this case, since </span><span class="font2">SBRANCH </span><span class="font17">was already 0, but I left it in for symmetry with the second branch, where it is needed.</span></p>
<p><span class="font17">Finally, we transfer control back up to the top:</span></p>
<p><span class="font2">next;</span></p>
<p><span class="font17">We’re almost done. We’ve simulated the recursive calls, and the last thing we need to do is simulate the returns. The function’s desired return value is in </span><span class="font2">Sreturn</span><span class="font17">. To simulate a function return, check to see if the synthetic stack is empty. If so, then the function is really returning to its caller, and should just return </span><span class="font2">Sreturn</span><span class="font17">. Otherwise, we pop the saved state off the stack and resume execution where we left off:</span></p>
<div>
<p><span class="font9" style="font-weight:bold;">CODE LIBRARY</span></p>
</div><br clear="all">
<div>
<p><span class="font0">fib-7</span></p>
</div><br clear="all">
<p><span class="font2">sub fib {</span></p>
<p><span class="font2">my Sn = shift;</span></p>
<p><span class="font2">my (Ss1, Ss2, Sreturn);</span></p>
<p><span class="font2">my SBRANCH = 0;</span></p>
<p><span class="font2">my @STACK;</span></p>
<p><span class="font2">while (1) {</span></p>
<p><span class="font2">if (Sn &lt;&nbsp;2) {</span></p>
<p><span class="font2">Sreturn = Sn;</span></p>
<p><span class="font2">} else {</span></p>
<p><span class="font2">if (SBRANCH == 0) {</span></p>
<p><span class="font2">push @STACK, [ SBRANCH, Ss1, Ss2, Sn ];</span></p>
<p><span class="font2">Sn -= 2;</span></p>
<p><span class="font2">SBRANCH = 0;</span></p>
<p><span class="font2">next;</span></p>
<p><span class="font2">} elsif (SBRANCH == 1) {</span></p>
<p><span class="font2">Ss1 = Sreturn;</span></p>
<p><span class="font2">push @STACK, [ SBRANCH, Ss1, Ss2, Sn ];</span></p>
<p><span class="font2">Sn -= 1;</span></p>
<p><span class="font2">SBRANCH = 0;</span></p>
<p><span class="font2">next;</span></p>
<p><span class="font2">} elsif (SBRANCH == 2) { Ss2 = Sreturn;</span></p>
<p><span class="font2">Sreturn = Ss1 + Ss2;</span></p>
<p><span class="font2" style="font-weight:bold;">return Sreturn unless @STACK;</span></p>
<p><span class="font2" style="font-weight:bold;">(SBRANCH, Ss1, Ss2, Sn) = @{pop @STACK};</span></p>
<p><span class="font2" style="font-weight:bold;">SBRANCH++;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">We increment </span><span class="font2">SBRANCH </span><span class="font17">so that execution will resume with the chunk </span><span class="font17" style="font-style:italic;">following </span><span class="font17">the one we were in when we made the call.</span></p>
<p><span class="font17">And amazingly, we’re now done. This function does indeed compute Fibonacci numbers.</span></p>
<p><span class="font17">Because I was showing a general transformation of a recursive into a nonrecursive function, the result has some unnecessary code. For example, I included an unnecessary </span><span class="font2">SBRANCH = 0 </span><span class="font17">line for symmetry. In branch 1, we assign </span><span class="font2">Ss1 </span><span class="font17">from </span><span class="font2">Sreturn </span><span class="font17">and then immediately push its value onto the stack; we may as well push </span><span class="font2">Sreturn </span><span class="font17">directly onto the stack without the intervening assignment. In branch 0, we push </span><span class="font2">Ss1 </span><span class="font17">into the stack, but its value is always undefined at this point, so we may as well just push </span><span class="font2">0 </span><span class="font17">directly:</span></p>
<p><span class="font2">sub fib {</span></p>
<div>
<p><span class="font9" style="font-weight:bold;">CODE LIBRARY</span></p>
</div><br clear="all">
<div>
<p><span class="font0">fib-8</span></p>
</div><br clear="all">
<p><span class="font2">my Sn = shift;</span></p>
<p><span class="font2">my (Ss1, Ss2, Sreturn);</span></p>
<p><span class="font2">my SBRANCH = 0;</span></p>
<p><span class="font2">my @STACK;</span></p>
<p><span class="font2">while (1) {</span></p>
<p><span class="font2">if (Sn &lt;&nbsp;2) {</span></p>
<p><span class="font2">Sreturn = Sn;</span></p>
<p><span class="font2">} else {</span></p>
<p><span class="font2">if (SBRANCH == 0) {</span></p>
<p><span class="font2" style="font-weight:bold;">push @STACK, [ SBRANCH, 0, Ss2, Sn ];</span></p>
<p><span class="font2">Sn -= 2;</span></p>
<p><span class="font2">next;</span></p>
<p><span class="font2">} elsif (SBRANCH == 1) {</span></p>
<p><span class="font2" style="font-weight:bold;">push @STACK, [ SBRANCH, Sreturn, Ss2, Sn ];</span></p>
<p><span class="font2">Sn -= 1;</span></p>
<p><span class="font2">SBRANCH = 0;</span></p>
<p><span class="font2">next;</span></p>
<p><span class="font2">} elsif (SBRANCH == 2) { Ss2 = Sreturn;</span></p>
<table border="1">
<tr><td style="vertical-align:bottom;">
<p><span class="font20">250</span></p></td><td style="vertical-align:bottom;">
<p><span class="font15">CHAPTER 5 From Recursion to Iterators</span></p></td></tr>
</table>
<p><span class="font2">Sreturn = $s1 + $s2; }</span></p>
<p><span class="font2">} return Sreturn unless @STACK;</span></p>
<p><span class="font2">(SBRANCH, $s1, $s2, $n) = @{pop @STACK};</span></p>
<p><span class="font2">SBRANCH++;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">Performing the same sort of eliminations for </span><span class="font2">$s2 </span><span class="font17">as we did for </span><span class="font2">$s1</span><span class="font17">, we discover that </span><span class="font2">$s2 </span><span class="font17">is </span><span class="font17" style="font-style:italic;">entirely unnecessary.</span><span class="font17"> The only place it’s used is in branch 2, and it’s used immediately after it’s assigned:</span></p>
<div>
<p><span class="font9" style="font-weight:bold;">CODE LIBRARY</span></p>
</div><br clear="all">
<div>
<p><span class="font0">fib-9</span></p>
</div><br clear="all">
<p><span class="font2">sub fib {</span></p>
<p><span class="font2">my $n = shift;</span></p>
<p><span class="font2" style="font-weight:bold;">my (Ss1, Sreturn);</span></p>
<p><span class="font2">my $BRANCH = 0;</span></p>
<p><span class="font2">my @STACK;</span></p>
<p><span class="font2">while (1) {</span></p>
<p><span class="font2">if ($n &lt;&nbsp;2) {</span></p>
<p><span class="font2">$return = $n;</span></p>
<p><span class="font2">} else {</span></p>
<p><span class="font2">if ($BRANCH == 0) {</span></p>
<p><span class="font2" style="font-weight:bold;">push @STACK, [ SBRANCH, 0, Sn ];</span></p>
<p><span class="font2">$n -= 2;</span></p>
<p><span class="font2">next;</span></p>
<p><span class="font2">} elsif ($BRANCH == 1) {</span></p>
<p><span class="font2" style="font-weight:bold;">push @STACK, [ SBRANCH, Sreturn, Sn ];</span></p>
<p><span class="font2">$n -= 1;</span></p>
<p><span class="font2">$BRANCH = 0;</span></p>
<p><span class="font2">next;</span></p>
<p><span class="font2">} elsif ($BRANCH == 2) {</span></p>
<p><span class="font2" style="font-weight:bold;">Sreturn += Ss1;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">} return $return unless @STACK;</span></p>
<p><span class="font2" style="font-weight:bold;">(SBRANCH, Ss1, Sn) = @{pop @STACK};</span></p>
<p><span class="font2">$BRANCH++;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">We might also optimize branch 0 a little. In branch 0, we push the stack, decrement </span><span class="font2">Sn </span><span class="font17">by 2, and pass control back to the top of the function. Typically, we then come back immediately and do it again, forming a loop. We can tighten up the loop:</span></p>
<p><span class="font2">sub fib {</span></p>
<p><span class="font2">my Sn = shift;</span></p>
<p><span class="font2">my (Ss1, Sreturn);</span></p>
<p><span class="font2">my SBRANCH = 0;</span></p>
<p><span class="font2">my @STACK;</span></p>
<p><span class="font2">while (1) {</span></p>
<p><span class="font2">if (Sn &lt;&nbsp;2) {</span></p>
<p><span class="font2">Sreturn = Sn;</span></p>
<p><span class="font2">} else {</span></p>
<p><span class="font2">if (SBRANCH == 0) {</span></p>
<p><span class="font2" style="font-weight:bold;">push (@STACK, [ SBRANCH, 0, $n ]), $n -= 2 while $n &gt;= 2; Sreturn = Sn;</span></p>
<p><span class="font2">} elsif (SBRANCH == 1) {</span></p>
<p><span class="font2">push @STACK, [ SBRANCH, Sreturn, Sn ];</span></p>
<p><span class="font2">Sn -= 1;</span></p>
<p><span class="font2">SBRANCH = 0;</span></p>
<p><span class="font2">next;</span></p>
<p><span class="font2">} elsif (SBRANCH == 2) { Sreturn += Ss1;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">return Sreturn unless @STACK;</span></p>
<p><span class="font2">(SBRANCH, Ss1, Sn) = @{pop @STACK};</span></p>
<p><span class="font2">SBRANCH++;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">Since that tight loop is more efficient than the large main loop, we’d like to do it as often as possible. As it is, though, we do it only about </span><span class="font17" style="font-style:italic;">n/2</span><span class="font17"> times. Since it doesn’t matter whether </span><span class="font2">fib() </span><span class="font17">makes the </span><span class="font2">fib(Sn-2) </span><span class="font17">or the </span><span class="font2">fib(Sn-1) </span><span class="font17">call first, we can exchange the first and second chunks, giving us:</span></p>
<p><span class="font2">sub fib {</span></p>
<p><span class="font2">my Sn = shift;</span></p>
<p><span class="font2">my (Ss1, Sreturn); my SBRANCH = 0;</span></p>
<div>
<p><span class="font9" style="font-weight:bold;">CODE LIBRARY</span></p>
</div><br clear="all">
<div>
<p><span class="font0">fib-10</span></p>
</div><br clear="all">
<div>
<p><span class="font9" style="font-weight:bold;">CODE LIBRARY</span></p>
</div><br clear="all">
<div>
<p><span class="font0">fib-11</span></p>
</div><br clear="all">
<p><span class="font2">my @STACK;</span></p>
<p><span class="font2">while (1) {</span></p>
<p><span class="font2">if (Sn &lt;&nbsp;2) {</span></p>
<p><span class="font2">Sreturn = Sn;</span></p>
<p><span class="font2">} else {</span></p>
<p><span class="font2">if (SBRANCH == 0) {</span></p>
<p><span class="font2" style="font-weight:bold;">push (@STACK, [ SBRANCH, 0, $n ]), $n -= 1 while $n &gt;= 2;</span></p>
<p><span class="font2">Sreturn = Sn;</span></p>
<p><span class="font2">} elsif (SBRANCH == 1) {</span></p>
<p><span class="font2">push @STACK, [ SBRANCH, Sreturn, Sn ];</span></p>
<p><span class="font2" style="font-weight:bold;">Sn -= 2;</span></p>
<p><span class="font2">SBRANCH = 0;</span></p>
<p><span class="font2">next;</span></p>
<p><span class="font2">} elsif (SBRANCH == 2) { Sreturn += Ss1;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">return Sreturn unless @STACK;</span></p>
<p><span class="font2">(SBRANCH, Ss1, Sn) = @{pop @STACK};</span></p>
<p><span class="font2">SBRANCH++;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">This is a little faster than the previous version.</span></p>
<p><span class="font17">We can also clean up one more line of code by eliminating </span><span class="font2">SBRANCH++ </span><span class="font17">at the bottom. Instead of pushing the old value of </span><span class="font2">SBRANCH </span><span class="font17">onto the stack and then incrementing it after we pop it again, we’ll just push the value of </span><span class="font2">SBRANCH </span><span class="font17">that we want to have when we return:</span></p>
<div>
<p><span class="font9" style="font-weight:bold;">CODE LIBRARY</span></p>
</div><br clear="all">
<div>
<p><span class="font0">fib-12</span></p>
</div><br clear="all">
<p><span class="font2">sub fib {</span></p>
<p><span class="font2">my Sn = shift;</span></p>
<p><span class="font2">my (Ss1, Sreturn);</span></p>
<p><span class="font2">my SBRANCH = 0;</span></p>
<p><span class="font2">my @STACK;</span></p>
<p><span class="font2">while (1) {</span></p>
<p><span class="font2">if (Sn &lt;&nbsp;2) {</span></p>
<p><span class="font2">Sreturn = Sn;</span></p>
<p><span class="font2">} else {</span></p>
<p><span class="font2">if (SBRANCH == 0) {</span></p>
<p><span class="font2" style="font-weight:bold;">push (@STACK, [ 1, 0, Sn ]), Sn -= 1 while Sn &gt;= 2;</span></p>
<p><span class="font2">Sreturn = Sn;</span></p>
<p><span class="font2">} elsif (SBRANCH == 1) {</span></p>
<p><span class="font2" style="font-weight:bold;">push @STACK, [ 2, Sreturn, $n ];</span></p>
<p><span class="font2">Sn -= 2;</span></p>
<p><span class="font2">SBRANCH = 0;</span></p>
<p><span class="font2">next;</span></p>
<p><span class="font2">} elsif (SBRANCH == 2) {</span></p>
<p><span class="font2">Sreturn += Ss1;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">return Sreturn unless @STACK;</span></p>
<p><span class="font2">(SBRANCH, Ss1, Sn) = @{pop @STACK};</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">There are several things we can learn from all of this. Most important, it affords us a detailed look into what is really required to implement recursive calls. Many of the small tweaks and optimizations we applied at the end of the conversion process are directly analogous to optimizations that compilers and interpreters can perform internally.</span></p>
<p><span class="font17">Recursion elimination may also be useful in reducing the memory footprint of a function. With Perl’s built-in recursion, you don’t get a choice about what state is saved on the stack: Absolutely everything is saved. Once we have the stack represented explicitly in the program, it may become clear that not everything needs to be saved on every call, and we may be able to reduce stack usage, as we did by eliminating </span><span class="font2">Ss2.</span></p>
<p><span class="font17">Finally, in some cases it will turn out that the iterative version of the code is faster or simpler than the recursive version. In these cases, such as the power set function example, the simplifications suggested by recursion elimination may lead to a cascade of further simplifications.</span></p>
<p><span class="font14">CHAPTER</span></p>
<h3><a name="bookmark305"></a><span class="font25">INFINITE STREAMS</span></h3>
<p><span class="font17">There’s a special interface that we can put on iterators that makes them easier to deal with in many cases. One drawback of the iterators we’ve seen so far is that they were difficult or impossible to rewind; once data came out of them, there was no easy way to put it back again. Later on, in Chapter 8, we will want to scan forward in an input stream, looking for a certain pattern; if we don’t see it, we might want to rescan the same input, looking for a different pattern. This is inconvenient to do with the iterators of Chapter 4, but the variation in this chapter is just the thing, and we will use it extensively in Chapter 8.</span></p>
<p><span class="font17">What we need is a data structure more like an array or a list. We can make the iterators look like linked lists, and having done so we get another benefit: We can leverage the enormous amount of knowledge and technique that already exists for dealing with linked lists.</span></p>
<p><span class="font17">A linked list is a data structure common in most languages, but seldom used in Perl, because Perl’s arrays usually serve as a good enough replacement. We’ll take a moment to review linked lists.</span></p>
<ul style="list-style:none;"><li>
<p class="font18">6.1 linked lists</p></li></ul>
<p><span class="font17">A </span><span class="font17" style="font-style:italic;">linked list</span><span class="font17"> is made up of </span><span class="font17" style="font-style:italic;">nodes;</span><span class="font17"> each node has two parts: a </span><span class="font17" style="font-style:italic;">head,</span><span class="font17"> which contains some data, and a </span><span class="font17" style="font-style:italic;">tail,</span><span class="font17"> which contains (a pointer to) another linked list node, or possibly an undefined value, indicating that the current node is the last one in the list:</span></p>
<div style="border:solid;">
<table border="1">
<tr><td style="vertical-align:middle;">
<p><span class="font11">12</span></p></td><td style="vertical-align:middle;">
<p><span class="font17">•—</span></p></td></tr>
</table>
</div><br clear="all">
<div style="border:solid;">
<table border="1">
<tr><td rowspan="2" style="vertical-align:middle;">
<p><span class="font11">&quot;foo&quot;</span></p></td><td></td></tr>
<tr><td></td></tr>
</table>
</div><br clear="all">
<div style="border:solid;">
<table border="1">
<tr><td style="vertical-align:middle;">
<p><span class="font11">28</span></p></td><td style="vertical-align:middle;">
<p><span class="font11">undef</span></p></td></tr>
</table>
</div><br clear="all">
<p><span class="font17">Here’s typical Perl code that uses arrays to represent nodes:</span></p>
<p><span class="font2">sub node {</span></p>
<p><span class="font2">my ($h, $t) = @_;</span></p>
<p><span class="font2">[$h, $t];</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">sub head {</span></p>
<p><span class="font2">my ($ls) = @_;</span></p>
<p><span class="font2">$ls-&gt;[0];</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">sub tail {</span></p>
<p><span class="font2">my ($ls) = @_;</span></p>
<p><span class="font2">$ls-&gt;[1];</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">sub set_head {</span></p>
<p><span class="font2">my ($ls, $new_head) = @_;</span></p>
<p><span class="font2">$ls-&gt;[0] = $new_head;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">sub set_tail {</span></p>
<p><span class="font2">my ($ls, $new_tail) = @_;</span></p>
<p><span class="font2">$ls-&gt;[1] = $new_tail;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">Linked lists are one of the data structures that’s ubiquitous in all low-level programming. They hold a sequence of data, the way an array does, but unlike an</span></p>
<p><span class="font17" style="font-style:italic;">6.2. Ykl'i</span><span class="font15"> L I N K E D L IS TS </span><span class="font20">257</span></p>
<p><span class="font17">array they needn’t be allocated all at once. To add a new data item to the front of a linked list, all that’s needed is to allocate a new node, store the new data item in the head of the node, and store the address of the old first node into the tail of the new node; none of the data needs to be moved. This is what </span><span class="font2">node() </span><span class="font17">does:</span></p>
<p><span class="font2">$my_list = node($new_data, $my_list);</span></p>
<p><span class="font17">In contrast, inserting a new item at the start of an array requires all the array elements to be moved over one space to make room.</span></p>
<p><span class="font17">Similarly, it’s easy to splice a data item into the middle of a linked list by tweaking the tail of the node immediately before it:</span></p>
<p><span class="font2">sub insert_after {</span></p>
<p><span class="font2">my ($node, $new_data) = @_;</span></p>
<p><span class="font2">my $new_node = node($new_data, tail($node));</span></p>
<p><span class="font2">set_tail($node, $new_node);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">To splice data into the middle of an array requires that all of the following elements in the array be copied to make room, and the entire array may need to be moved if there isn’t any extra space at the end for the last item to move into.</span></p>
<p><span class="font17">Scanning a linked list takes about twice as long as scanning the corresponding array, since you spend as much time following the pointers as you do looking at the data; with the array, there are no pointers. The big advantage of the array over the list is that the array supports fast indexed access. You can get or set array element </span><span class="font2">$a[$n] </span><span class="font17">instantly, regardless of what </span><span class="font2">$n </span><span class="font17">is, but accessing the </span><span class="font17" style="font-style:italic;">nth </span><span class="font17">element of a list requires scanning the entire list starting from the head, taking time proportional to </span><span class="font17" style="font-style:italic;">n</span><span class="font17">.</span></p>
<ul style="list-style:none;"><li>
<h5><a name="bookmark117"></a><span class="font18">6.2 LAZY LINKED LISTS</span></h5></li></ul>
<p><span class="font17">As you’ll recall from Chapter 4, one of the primary reasons for using iterators is to represent lists that might be enormous, or even infinite. Using a linked list as an implementation of an iterator won’t work if all the list nodes must be in memory at the same time.</span></p>
<p><span class="font17">The lazy computation version of the linked list has a series of nodes, just like a regular linked list. And it might end with an undefined value in the tail of the last node, just like a regular linked list. But the tail might instead be an object called a </span><span class="font17" style="font-style:italic;">promise.</span><span class="font17"> The promise is just that: a promise to compute the rest of the</span></p>
<div>
<h4><a name="bookmark306"></a><span class="font20">258</span></h4>
</div><br clear="all">
<div>
<p><span class="font15" style="font-variant:small-caps;">chapter </span><span class="font2" style="font-style:italic;">6</span><span class="font15"> Infinite Streams</span></p>
</div><br clear="all">
<div>
<p><span class="font17">list, if necessary. We can represent it as an anonymous function, which, if called, will return the rest of the list nodes. We’ll add code to the </span><span class="font2">tail() </span><span class="font17">function so that if it sees it’s about to return a promise, it will collect on the promise and return the head node of the resulting list instead. Nobody accessing the list with the </span><span class="font2">head() </span><span class="font17">or </span><span class="font2">tail() </span><span class="font17">functions will be able to tell that anything strange is going on:</span></p>
</div><br clear="all">
<div>
<p><span class="font9" style="font-weight:bold;">CODE LIBRARY</span></p>
</div><br clear="all">
<div>
<p><span class="font0">Stream.pm</span></p>
</div><br clear="all">
<div>
<p><span class="font2">package Stream;</span></p>
<p><span class="font2">use base Exporter;</span></p>
<p><span class="font2">@EXPORT_OK = qw(node head tail drop upto upfrom show promise filter transform merge list_to_stream cutsort iterate_function cut_loops);</span></p>
<p><span class="font2">%EXPORT_TAGS = ('all' =&gt; \@EXPORT_OK);</span></p>
<p><span class="font2">sub node {</span></p>
<p><span class="font2">my ($h, $t) = @_;</span></p>
<p><span class="font2">[$h, $t];</span></p>
<p><span class="font2">}</span></p>
</div><br clear="all">
<div>
<p><span class="font2">sub head {</span></p>
<p><span class="font2">my ($s) = @_;</span></p>
<p><span class="font2">$s-&gt;[0];</span></p>
<p><span class="font2">}</span></p>
</div><br clear="all">
<div>
<p><span class="font2">sub tail {</span></p>
<p><span class="font2">my ($s) = @_;</span></p>
<p><span class="font2" style="font-weight:bold;">if (is_promise($s-&gt;[1])) { return $s-&gt;[1]-&gt;();</span></p>
<p><span class="font2" style="font-weight:bold;">}</span></p>
<p><span class="font2">$s-&gt;[1];</span></p>
<p><span class="font2">}</span></p>
</div><br clear="all">
<div>
<p><span class="font2" style="font-weight:bold;">sub is_promise {</span></p>
<p><span class="font2" style="font-weight:bold;">UNIVERSAL::isa($_[0], 'CODE');</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">The modified version of the </span><span class="font2">tail() </span><span class="font17">function checks to see if the tail is actually a promise; if so, it invokes the promise function to manufacture the real tail, and returns that. This is sometimes called </span><span class="font17" style="font-style:italic;">forcing</span><span class="font17"> the promise.</span></p>
<p><span class="font17">If nobody ever tries to look at the promise, then so much the better. The code will never be invoked, and we’ll never have to go to the trouble of computing the tail.</span></p>
</div><br clear="all">
<p><span class="font2" style="font-style:italic;">6.1</span><span class="font15"> LAZY LINKED LISTS </span><span class="font20">259</span></p>
<p><span class="font17">We’ll call these trick lists </span><span class="font17" style="font-style:italic;">streams.</span></p>
<p><span class="font17">As is often the case, the most convenient representation of an empty stream is an undefined value. If we do this, we won’t need a special test to see if a stream is empty; a stream value will be true if and only if it’s nonempty. This also means that we can create the last node in a stream by calling </span><span class="font2">node($value)</span><span class="font17">; the result is a stream node whose head contains </span><span class="font2">$value </span><span class="font17">and whose tail is undefined.</span></p>
<p><span class="font17">Finally, we’ll introduce some syntactic sugar for making promises, as we did for making iterators:</span></p>
<p><span class="font2">sub promise (&amp;) { $_[0] }</span></p>
<ul style="list-style:none;"><li>
<h5><a name="bookmark119"></a><span class="font19">6.2.1 A Trivial Stream: </span><span class="font3">upto()</span></h5></li></ul>
<p><span class="font17">To see how this all works, let’s look at a trivial stream. Recall the </span><span class="font2">upto() </span><span class="font17">function from Section 4.2.1: Given two numbers, </span><span class="font17" style="font-style:italic;">m</span><span class="font17"> and </span><span class="font17" style="font-style:italic;">n,</span><span class="font17"> it returned an iterator that would return all the numbers between </span><span class="font17" style="font-style:italic;">m</span><span class="font17"> and </span><span class="font17" style="font-style:italic;">n</span><span class="font17">, inclusive. Here’s the linked list version:</span></p>
<p><span class="font2">sub upto_list {</span></p>
<p><span class="font2">my ($m, $n) = @_;</span></p>
<p><span class="font2">return if $m &gt;&nbsp;$n;</span></p>
<p><span class="font2">node($m, upto_list($m+1, $n));</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">This might consume a large amount of memory if </span><span class="font2">$n </span><span class="font17">is much larger than </span><span class="font2">$m</span><span class="font17">. Here’s the lazy-stream version:</span></p>
<p><span class="font2">sub upto {</span></p>
<p><span class="font2">my ($m, $n) = @_;</span></p>
<p><span class="font2">return if $m &gt;&nbsp;$n;</span></p>
<p><span class="font2" style="font-weight:bold;">node($m, promise { upto($m+1, $n) } );</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">It’s almost exactly the same. The only difference is that instead of immediately making a recursive call to construct the tail of the list, it defers the recursive call and manufactures a promise instead. The node it returns has the right value (</span><span class="font2">$m</span><span class="font17">) in the head, but the tail is an IOU. If someone looks at the tail, the </span><span class="font2">tail() </span><span class="font17">function sees the promise and invokes the anonymous promise function, which in turn invokes </span><span class="font2">upto($m+1, $n)</span><span class="font17">, which returns another stream</span></p>
<div>
<p><span class="font20">260</span></p>
</div><br clear="all">
<p><span class="font15" style="font-variant:small-caps;">chapter </span><span class="font2" style="font-style:italic;">6</span><span class="font15"> Infinite Streams</span></p>
<p><span class="font17">node. The new node’s head is </span><span class="font2">$m+1 </span><span class="font17">(which is what was wanted) and its tail is another IOU.</span></p>
<p><span class="font17">If we keep examining the successive tails of the list, we see node after node, as if they had all been constructed in advance. Eventually we get to the end of the list, and </span><span class="font2">$m </span><span class="font17">is larger than </span><span class="font2">$n</span><span class="font17">; in this case when the </span><span class="font2">tail() </span><span class="font17">function invokes the promise, the call to </span><span class="font2">upto() </span><span class="font17">returns an empty stream instead of another node.</span></p>
<p><span class="font17">If we want an </span><span class="font17" style="font-style:italic;">infinite</span><span class="font17"> sequence of integers, it’s even easier: Get rid of the code that terminates the stream:</span></p>
<p><span class="font2">sub upfrom {</span></p>
<p><span class="font2">my ($m) = @_;</span></p>
<p><span class="font2">node($m, promise { upfrom($m+1) } );</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">Let’s return to </span><span class="font2">upto()</span><span class="font17">. Notice that although the </span><span class="font2">upto() </span><span class="font17">function was obtained by a trivial transformation from the recursive </span><span class="font2">upto_list() </span><span class="font17">function, it is not itself recursive; it returns immediately. A later call to </span><span class="font2">tail() </span><span class="font17">may call it again, but the new call will again return immediately. Streams are therefore another way of transforming recursive list functions into nonrecursive, iterative functions.</span></p>
<p><span class="font17">We could perform the transformation in reverse on </span><span class="font2">upfrom() </span><span class="font17">and come up with a recursive list version:</span></p>
<p><span class="font2">sub upfrom_list {</span></p>
<p><span class="font2">my ($m) = @_;</span></p>
<p><span class="font2">node($m, upfrom_list($m+1) );</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">This function does indeed compute an infinite list of integers, taking an infinite amount of time and memory to do so.</span></p>
<ul style="list-style:none;"><li>
<h5><a name="bookmark120"></a><span class="font19">6.2.2 Utilities for Streams</span></h5></li></ul>
<p><span class="font17">The first function you need when you invent a new data structure is a diagnostic function that dumps out the contents of the data structure. Here’s a stripped-down version:</span></p>
<p><span class="font2">sub show {</span></p>
<p><span class="font2">my $s = shift;</span></p>
<p><span class="font2">while ($s) {</span></p>
<div>
<p><span class="font2" style="font-style:italic;">6.2.</span><span class="font15"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LINKED LISTS</span></p>
</div><br clear="all">
<div>
<h4><a name="bookmark307"></a><span class="font20">261</span></h4>
</div><br clear="all">
<p><span class="font2">print head($s), $&quot;;</span></p>
<p><span class="font2">$s = tail($s);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">print $/;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">If the stream </span><span class="font2">$s </span><span class="font17">is empty, the function exits, printing </span><span class="font2">$/</span><span class="font17">, normally a newline. If not, it prints the head value of </span><span class="font2">$s </span><span class="font17">followed by </span><span class="font2">$&quot; </span><span class="font17">(normally a space), and then sets </span><span class="font2">$s </span><span class="font17">to its tail to repeat the process for the next node.</span></p>
<p><span class="font17">Since this prints every element of a stream, it’s clearly not useful for infinite streams; the </span><span class="font2">while </span><span class="font17">loop will never end. So the version of </span><span class="font2">show() </span><span class="font17">we’ll actually use will accept an optional parameter </span><span class="font17" style="font-style:italic;">n,</span><span class="font17"> which limits the number of elements printed. If </span><span class="font17" style="font-style:italic;">n</span><span class="font17"> is specified, </span><span class="font2">show() </span><span class="font17">will print only the first </span><span class="font17" style="font-style:italic;">n</span><span class="font17"> elements:</span></p>
<p><span class="font2">sub show {</span></p>
<p><span class="font2" style="font-weight:bold;">my ($s, $n) = @_;</span></p>
<p><span class="font2" style="font-weight:bold;">while ($s &amp;&amp;&nbsp;(! defined $n || $n-- &gt;&nbsp;0)) {</span></p>
<p><span class="font2">print head($s), $&quot;;</span></p>
<p><span class="font2">$s = tail($s);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">print $/;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">For example:</span></p>
<p><span class="font2">use Stream 'upfrom', 'show';</span></p>
<div>
<p><span class="font9" style="font-weight:bold;">CODE LIBRARY</span></p>
</div><br clear="all">
<p><span class="font0">show-example-1</span></p>
<p><span class="font2">show(upfrom(7), 10);</span></p>
<p><span class="font17">This prints:</span></p>
<p><span class="font2">7 8 9 10 11 12 13 14 15 16</span></p>
<p><span class="font17">We can omit the second argument of </span><span class="font2">show()</span><span class="font17">, in which case it will print all the elements of the stream. For an infinite stream like </span><span class="font2">upfrom(7)</span><span class="font17">, this takes a long time. For finite streams, there’s no problem:</span></p>
<p><span class="font2">use Stream 'upto', 'show';</span></p>
<div>
<p><span class="font9" style="font-weight:bold;">CODE LIBRARY</span></p>
</div><br clear="all">
<p><span class="font0">show-example-2</span></p>
<p><span class="font2">show(upto(3,6));</span></p>
<p><span class="font17">The output:</span></p>
<p><span class="font17">The line </span><span class="font2">$s = tail($s) </span><span class="font17">in </span><span class="font2">show() </span><span class="font17">is a fairly common operation, so we’ll introduce an abbreviation:</span></p>
<p><span class="font2">sub drop {</span></p>
<p><span class="font2">my $h = head($_[0]);</span></p>
<p><span class="font2">$_[0] = tail($_[0]); return $h;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">Now we can call </span><span class="font2">drop($s)</span><span class="font17">, which is analogous to </span><span class="font2">pop </span><span class="font17">for arrays: It removes the first element from a stream, modifying the stream in place, and returns that element. </span><span class="font2">show() </span><span class="font17">becomes:</span></p>
<p><span class="font2">sub show {</span></p>
<p><span class="font2">my ($s, $n) = @_;</span></p>
<p><span class="font2">while ($s &amp;&amp;&nbsp;(! defined $n || $n-- &gt;&nbsp;0)) { </span><span class="font2" style="font-weight:bold;">print drop($s), $&quot;;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">print $/;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">As with the iterators of Chapter 4, we’ll want a few basic utilities such as versions of </span><span class="font2">map </span><span class="font17">and </span><span class="font2">grep </span><span class="font17">for streams. Once again, the analogue of </span><span class="font2">map </span><span class="font17">is simpler:</span></p>
<p><span class="font2">sub transform (&amp;$) {</span></p>
<p><span class="font2">my $f = shift;</span></p>
<p><span class="font2">my $s = shift;</span></p>
<p><span class="font2">return unless $s;</span></p>
<p><span class="font2">node($f-&gt;(head($s)),</span></p>
<p><span class="font2">promise { transform($f, tail($s)) });</span></p>
<p><span class="font17">This example is prototypical of functions that operate on streams, so you should examine it closely. It’s called in a way that’s similar to </span><span class="font2">map()</span><span class="font17">:</span></p>
<p><span class="font2">transform {...} $s;</span></p>
<p><span class="font17" style="font-style:italic;">6.J</span><span class="font15"> RECURSIVE ST REA</span></p>
<p><span class="font17">For example,</span></p>
<p><span class="font2">my Sevens = transform { S_[0] * 2 } upfrom(1);</span></p>
<p><span class="font17">generates an infinite stream of all positive even integers. Or rather, it generates the first node of such a stream, and a promise to generate more, should we try to examine the later elements.</span></p>
<p><span class="font17">The analog of </span><span class="font2">grep() </span><span class="font17">is only a little more complicated:</span></p>
<p><span class="font2">sub filter (&amp;S) {</span></p>
<p><span class="font2">my Sf = shift;</span></p>
<p><span class="font2">my Ss = shift;</span></p>
<p><span class="font2">until (! Ss || Sf-&gt;(head(Ss))) {</span></p>
<p><span class="font2">drop(Ss);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">return if ! Ss;</span></p>
<p><span class="font2">node(head(Ss),</span></p>
<p><span class="font2">promise { filter(Sf, tail(Ss)) });</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">filter() </span><span class="font17">scans the elements of </span><span class="font2">Ss </span><span class="font17">until either it runs out of nodes (</span><span class="font2">! Ss</span><span class="font17">) or the predicate function </span><span class="font2">Sf </span><span class="font17">returns true (</span><span class="font2">Sf-&gt;(head(Ss))</span><span class="font17">). In the former case, there are no matching elements, so it returns an empty stream; in the latter case, it returns a new stream whose head is the matching element it found and whose tail is a promise to filter the rest of the stream in the same way. It would probably be instructive to compare this with the </span><span class="font2">igrep() </span><span class="font17">function of Section 4.4.2.</span></p>
<p><span class="font17">Another utility that will be useful is one to iterate a function repeatedly. Given an initial value </span><span class="font17" style="font-style:italic;">x</span><span class="font17"> and a function </span><span class="font17" style="font-style:italic;">f,</span><span class="font17"> it produces the (infinite) stream containing </span><span class="font17" style="font-style:italic;">x, f (x</span><span class="font17">), </span><span class="font17" style="font-style:italic;">f (f (x</span><span class="font17">)),</span><span class="font17" style="font-style:italic;">...</span><span class="font17">. We could write it this way:</span></p>
<p><span class="font2">sub iterate_function {</span></p>
<p><span class="font2">my (Sf, Sx) = @_;</span></p>
<p><span class="font2">node(Sx, promise { iterate_function(Sf, Sf-&gt;(Sx)) });</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">But there’s a more interesting and even simpler way to do it that we’ll see in Section 6.6.1.</span></p>
<ul style="list-style:none;"><li>
<h5><a name="bookmark121"></a><span class="font18">6.3 RECURSIVE STREAMS</span></h5></li></ul>
<p><span class="font17">The real power of streams arises from the fact that it’s possible to define a stream in terms of itself. Let’s consider the simplest possible example, a stream that</span></p>
<div>
<p><span class="font20">s 263</span></p>
</div><br clear="all">
<div>
<p><span class="font20">264</span></p>
</div><br clear="all">
<p><span class="font15" style="font-variant:small-caps;">chapter </span><span class="font2" style="font-style:italic;">6</span><span class="font15"> Infinite Streams</span></p>
<p><span class="font17">contains an infinite sequence of carrots. Following the </span><span class="font2">upfrom() </span><span class="font17">example of the previous section, we begin like this:</span></p>
<p><span class="font2">sub carrots {</span></p>
<p><span class="font2">node('carrot', promise { carrots() });</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">my Scarrots = carrots();</span></p>
<p><span class="font17">It’s silly to define a function that we’re going to call from only one place; we might as well do this:</span></p>
<p><span class="font2">my Scarrots = node('carrot', promise { carrots() });</span></p>
<p><span class="font17">except that we now must eliminate the call to </span><span class="font2">carrots() </span><span class="font17">from inside the promise. But that’s easy too, because the </span><span class="font2">carrots() </span><span class="font17">and </span><span class="font2">Scarrots </span><span class="font17">will have the same value:</span></p>
<p><span class="font2">my Scarrots = node('carrot', promise { Scarrots });</span></p>
<p><span class="font17">This looks good, but it doesn’t quite work, because of an oddity in the Perl semantics. The scope of the </span><span class="font2">my </span><span class="font17">variable </span><span class="font2">Scarrots </span><span class="font17">doesn’t begin until the </span><span class="font17" style="font-style:italic;">next </span><span class="font17">statement, and that means that the two mentions of </span><span class="font2">Scarrots </span><span class="font17">refer to different variables. The declaration creates a new lexical variable, which is assigned to, but the </span><span class="font2">Scarrots </span><span class="font17">on the right-hand side of the assignment is the </span><span class="font17" style="font-style:italic;">global </span><span class="font17">variable </span><span class="font2">Scarrots</span><span class="font17">, not the same as the one we’re creating. The line needs a tweak:</span></p>
<p><span class="font2">my Scarrots;</span></p>
<p><span class="font2">Scarrots = node('carrot', promise { Scarrots });</span></p>
<p><span class="font17">We’ve now defined </span><span class="font2">Scarrots </span><span class="font17">as a stream whose head contains </span><span class="font2">'carrot' </span><span class="font17">and whose tail is a promise to produce the rest of the stream — which is identical to the entire stream. And it does work:</span></p>
<p><span class="font2">show(Scarrots, 10);</span></p>
<p><span class="font17">The output:</span></p>
<p><span class="font2">carrot carrot carrot carrot carrot carrot carrot carrot carrot carrot</span></p>
<p><span class="font2" style="font-style:italic;">6..</span><span class="font15"> RECURSIVE ST REA</span></p>
<ul style="list-style:none;"><li>
<h5><a name="bookmark122"></a><span class="font19">6.3.1 Memoizing Streams</span></h5></li></ul>
<p><span class="font17">Let’s look at an example that’s a little less trivial than the one with the carrots: We’ll construct a stream of all powers of 2. We could follow the </span><span class="font2">upfrom() </span><span class="font17">pattern:</span></p>
<p><span class="font2">sub pow2_from { my $n = shift; node($n, promise {pow2_from($n*2)})</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">my $powers_of_2 = pow2_from(1);</span></p>
<p><span class="font17">but again, we can get rid of the special-purpose </span><span class="font2">pow2_from() </span><span class="font17">function in the same way that we did for the carrot stream:</span></p>
<p><span class="font2">my $powers_of_2;</span></p>
<p><span class="font2">$powers_of_2 =</span></p>
<p><span class="font2">node(1, promise { transform {$_[0]*2} $powers_of_2 });</span></p>
<p><span class="font17">This says that the stream of powers of 2 begins with the element 1, and then follows with a copy of itself with every element doubled. The stream itself contains 1, 2, 4, 8, 16, 32, </span><span class="font17" style="font-style:italic;">...</span><span class="font17">; the doubled version contains 2, 4, 8, 16, 32, 64, </span><span class="font17" style="font-style:italic;">...</span><span class="font17">; and if you append a 1 to the beginning of the doubled stream, you get the original stream back. Unfortunately, a serious and subtle problem arises with this definition. It does produce the correct output:</span></p>
<p><span class="font2">show($powers_of_2, 10);</span></p>
<p><span class="font2">1 2 4 8 16 32 64 128 256 512</span></p>
<p><span class="font17">But if we instrument the definition, we can see that the transformation subroutine is being called too many times:</span></p>
<p><span class="font2">$powers_of_2 =</span></p>
<p><span class="font2">node(1, promise {</span></p>
<p><span class="font2">transform {</span></p>
<p><span class="font2" style="font-weight:bold;">warn &quot;Doubling $_[0]</span><span class="font2">\</span><span class="font2" style="font-weight:bold;">n&quot;;</span></p>
<p><span class="font2">$_[0]*2</span></p>
<p><span class="font2">} $powers_of_2</span></p>
<p><span class="font2">});</span></p>
<div>
<p><span class="font15" style="font-variant:small-caps;">m</span><span class="font2"> s </span><span class="font20">265</span></p>
</div><br clear="all">
<p><span class="font4">I</span></p>
<p><span class="font17">The output is now:</span></p>
<ul style="list-style:none;"><li>
<p><span class="font2">1 Doubling 1</span></p></li>
<li>
<p><span class="font2">2 Doubling 1 Doubling 2</span></p></li></ul>
<p><span class="font2">4 Doubling 1 Doubling 2 Doubling 4</span></p>
<p><span class="font2">8 Doubling 1 Doubling 2 Doubling 4 Doubling 8 16 Doubling 1</span></p>
<p><span class="font17">The </span><span class="font2">show() </span><span class="font17">method starts by printing the head of the stream, which is 1. Then it goes to get the tail, using the </span><span class="font2">tail() </span><span class="font17">method:</span></p><img src="HigherOrderPerl_files/HigherOrderPerl-38.jpg" alt="" style="width:172pt;height:72pt;">
<p><span class="font2">sub tail {</span></p>
<p><span class="font2">my ($s) = @_;</span></p>
<p><span class="font2">if (is_promise($s-&gt;[1])) { return $s-&gt;[1]-&gt;();</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">$s-&gt;[1];</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">Since the tail is a promise, this forces the promise, which calls </span><span class="font2">transform {...} $powers_of_2. transform() </span><span class="font17">gets the head of </span><span class="font2">$powers_of_2</span><span class="font17">, which is 1, and doubles it, yielding a stream whose head is 2 and whose tail is a promise to double the rest of the elements of </span><span class="font2">$powers_of_2</span><span class="font17">. This stream is the tail of </span><span class="font2">$powers_of_2</span><span class="font17">, and </span><span class="font2">show() </span><span class="font17">prints its head, which is 2.</span></p>
<div>
<h4><a name="bookmark308"></a><span class="font20">267</span></h4>
</div><br clear="all">
<div>
<p><span class="font2" style="font-style:italic;">6..</span><span class="font15"> RECURSIVE STREAMS</span></p><img src="HigherOrderPerl_files/HigherOrderPerl-39.jpg" alt="" style="width:339pt;height:91pt;">
<p><span class="font11">Print &quot;2&quot;</span></p>
</div><br clear="all">
<p><span class="font2">show() </span><span class="font17">now wants to get the tail of the tail. It applies the </span><span class="font2">tail() </span><span class="font17">method to the tail stream. But the tail of the tail is a promise to double the tail of </span><span class="font2">$powers_of_2</span><span class="font17">. This promise is invoked, and the first thing it needs to do is compute the tail of </span><span class="font2">$powers_of_2</span><span class="font17">. This is the key problem, because computing the tail of </span><span class="font2">$powers_of_2 </span><span class="font17">is something we’ve already done. Nevertheless, the promise is forced a second time, causing another invocation of </span><span class="font2">transform </span><span class="font17">and producing a stream whose head is 2 and whose tail is a promise to double the rest of the elements of </span><span class="font2">$powers_of_2</span><span class="font17">:</span></p>
<div><img src="HigherOrderPerl_files/HigherOrderPerl-40.jpg" alt="" style="width:339pt;height:30pt;">
</div><br clear="all">
<div><img src="HigherOrderPerl_files/HigherOrderPerl-41.jpg" alt="" style="width:339pt;height:124pt;">
</div><br clear="all">
<p><span class="font2">transform </span><span class="font17">doubles the 2 and returns a new stream whose head is 4 and whose tail is (deep breath now) a promise to double the elements of the tail of a stream that was created by doubling the elements of the tail of </span><span class="font2">$powers_of_2</span><span class="font17">, which was itself created by doubling its own tail. </span><span class="font2">show() </span><span class="font17">prints the 4, but when it tries to get the tail of the new stream, it sets off a cascade of called promises, to get the</span></p>
<div>
<p><span class="font20">268</span></p>
</div><br clear="all">
<p><span class="font15" style="font-variant:small-caps;">chapter </span><span class="font2" style="font-style:italic;">6</span><span class="font15"> Infinite Streams</span></p>
<p><span class="font17">tail of the doubled stream, which itself needs to get the tail of another stream, which is the doubled version of the tail of the main stream:</span></p>
<div><img src="HigherOrderPerl_files/HigherOrderPerl-42.jpg" alt="" style="width:394pt;height:208pt;">
</div><br clear="all">
<p><span class="font17">Each element of the stream depends on calculating the tail of the original stream, and every time we look at a new element, we calculate the tail of </span><span class="font2">$powers_of_2</span><span class="font17">, including the act of doubling the first element. We’re essentially computing each element from scratch by building it up from 1, and what we should be doing is building each element on the previous element. Our basic problem is that we’re forcing the same promises over and over. But by now we have a convenient solution to problems that involve repeating the same work over and over: </span><span class="font17" style="font-style:italic;">memoization.</span><span class="font17"> We should remember the result whenever we force a promise, and then if we need the same result again, instead of calling the promise function, we’ll get it from the cache.</span></p>
<p><span class="font17">There’s a really obvious, natural place to cache the result of a promise, too. Since we don’t need the promise itself anymore, we can store the result in the tail of the stream — which was where it would have been if we hadn’t deferred its computation in the first place.</span></p>
<p><span class="font17">The change to the code is simple:</span></p>
<p><span class="font2">sub tail {</span></p>
<p><span class="font2">my ($s) = @_;</span></p>
<p><span class="font2">if (is_promise($s-&gt;[1])) {</span></p>
<p><span class="font2" style="font-weight:bold;">$s-&gt;[1] = $s-&gt;[1]-&gt;();</span></p>
<p><span class="font2" style="font-style:italic;">6.j\</span><span class="font15"> THE HAM MIN G PROBLEM</span></p>
<div>
<p><span class="font20">269</span></p>
</div><br clear="all">
<p><span class="font17">If the tail is a promise, we force the promise, and throw away the promise and replace it with the result, which is the real tail. Then we return the real tail. If we try to look at the tail again, the promise will be gone, and we’ll see just the correct tail.</span></p>
<p><span class="font17">With this change, the </span><span class="font2">$powers_of_2 </span><span class="font17">stream is both correct </span><span class="font17" style="font-style:italic;">and</span><span class="font17"> efficient. The instrumented version produces output that looks like this:</span></p>
<ul style="list-style:none;"><li>
<p><span class="font2">1 Doubling 1</span></p></li>
<li>
<p><span class="font2">2 Doubling 2</span></p></li></ul>
<p><span class="font2">4 Doubling 4</span></p>
<p><span class="font2">8 Doubling 8</span></p>
<p><span class="font2">16 Doubling 16</span></p>
<p><span class="font2">32 Doubling 32</span></p>
<ul style="list-style:none;"><li>
<h5><a name="bookmark123"></a><span class="font18">6.4 THE HAMMING PROBLEM</span></h5></li></ul>
<p><span class="font17">As an example of a problem that’s easy to solve with streams, we’ll turn to an old chestnut of computer science, Hamming’s Problem.<a name="footnote22"></a><sup><a href="#bookmark309">22</a></sup><sup></sup> Hamming’s problem asks for a list of the numbers of the form </span><span class="font17" style="font-style:italic;">2<sup><a href="#bookmark309">22</a></sup><sup></sup> 3 5<sup>k</sup></span><span class="font17">. The list begins as follows:</span></p>
<p><span class="font2">1 2 3 4 5 6 8 9 10 12 15 16 18 20 24 25 27 30 32 36 40 ...</span></p>
<p><span class="font17">It omits all multiples of 7, 11, 13, 17, and any other primes larger than 5.</span></p>
<p><span class="font17">The obvious method for generating this list is to try every number starting with 1. Suppose we want to learn whether the number </span><span class="font17" style="font-style:italic;">n</span><span class="font17"> is on this list. If </span><span class="font17" style="font-style:italic;">n</span><span class="font17"> is a multiple of 2, 3, or 5, then divide it by 2, 3, or 5 (respectively) until the result is no longer a multiple of 2, 3, or 5. If the final result is 1, then the original number </span><span class="font17" style="font-style:italic;">n</span><span class="font17"> was a Hamming number. The code might look like this:</span></p>
<p><span class="font2">sub is_hamming { my $n = shift; $n/=2 while $n%2 == 0;</span></p>
<table border="1">
<tr><td style="vertical-align:bottom;">
<p><span class="font20">270</span></p></td><td style="vertical-align:bottom;">
<p><span class="font15" style="font-variant:small-caps;">chapter </span><span class="font2" style="font-style:italic;">6</span><span class="font15"> Infinite Streams</span></p></td></tr>
</table>
<p><span class="font2">$n/=3 while $n%3 == 0;</span></p>
<p><span class="font2">$n/=5 while $n%5 == 0; return $n == 1;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2"># Return the first $N hamming numbers</span></p>
<p><span class="font2">sub hamming {</span></p>
<p><span class="font2">my $N = shift;</span></p>
<p><span class="font2">my @hamming;</span></p>
<p><span class="font2">my $t = 1;</span></p>
<p><span class="font2">until (@hamming == $N) {</span></p>
<p><span class="font2">push @hamming, $t if is_hamming($t);</span></p>
<p><span class="font2">$t+—+;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">@hamming;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">Unfortunately, this is completely impractical. It starts off well enough. But the example Hamming numbers above are misleading — they’re too close together. As you go further out in the list, the Hamming numbers get farther and farther apart. The 2999th Hamming number is 278,628,139,008. Nobody has time to test 278,628,139,008 numbers; even if they did, they would have to test 314,613,072 more before they found the 3000th Hamming number.</span></p>
<p><span class="font17">But there’s a better way to solve the problem. There are four kinds of Hamming numbers: multiples of 2, multiples of 3, multiples of 5, and 1. And moreover, every Hamming number except 1 is either 2, 3, or 5 times some other Hamming number. Suppose we took the Hamming sequence and doubled it, tripled it, and quintupled it: </span></p>
<div>
<p><a href="#bookmark310"><span class="font17">Hamming: 1</span></a></p>
<p><a href="#bookmark311"><span class="font17">Doubled: 2</span></a></p>
<p><a href="#bookmark312"><span class="font17">Tripled: &nbsp;3</span></a></p>
<p><a href="#bookmark313"><span class="font17">Quintupled: &nbsp;5</span></a></p>
</div><br clear="all">
<div>
<p><a href="#bookmark314"><span class="font17">3 &nbsp;&nbsp;4 &nbsp;&nbsp;5</span></a></p>
<p><a href="#bookmark315"><span class="font17">6 &nbsp;&nbsp;8 &nbsp;10</span></a></p>
<p><span class="font17">9 12 15 18</span></p>
<p><span class="font17">15 20 25 30</span></p>
</div><br clear="all">
<div>
<p><a href="#bookmark316"><span class="font17">8 &nbsp;&nbsp;9 &nbsp;10</span></a></p>
<p><span class="font17">16 18 20 24</span></p>
<p><span class="font17">24 27 30 36</span></p>
<p><span class="font17">40 45 50 60</span></p>
</div><br clear="all">
<div>
<p><a href="#bookmark317"><span class="font17">15 16 18</span></a></p>
<p><a href="#bookmark318"><span class="font17">30 32 36</span></a></p>
<p><a href="#bookmark319"><span class="font17">45 48 54</span></a></p>
<p><span class="font17">75 80 90 100</span></p>
</div><br clear="all">
<p><span class="font17">and then merged the doubled, tripled, and quintupled sequences in order:</span></p>
<p><span class="font17">Merged: 2 3 4 5 6 8 9 10 12 15 16 18 20 24 25 27 30 32 36 40 ...</span></p>
<p><span class="font2" style="font-style:italic;">6.j\</span><span class="font15"> THE HAM MIN G PROBLEM</span></p>
<div>
<p><span class="font20">271</span></p>
</div><br clear="all">
<p><span class="font17">The result would be exactly the Hamming sequence, except for the 1 at the beginning. Except for the merging, this is similar to the way we constructed the sequence of powers of 2 earlier. To do it, we’ll need a merging function:</span></p>
<p><span class="font2">sub merge {</span></p>
<p><span class="font2">my ($S, $T) = @_;</span></p>
<p><span class="font2">return $T unless $S;</span></p>
<p><span class="font2">return $S unless $T;</span></p>
<p><span class="font2">my ($s, $t) = (head($S), head($T));</span></p>
<p><span class="font2">if ($s &gt;&nbsp;$t) {</span></p>
<p><span class="font2">node($t, promise {merge( $S, tail($T))});</span></p>
<p><span class="font2">} elsif ($s &lt;&nbsp;$t) {</span></p>
<p><span class="font2">node($s, promise {merge(tail($S), $T)});</span></p>
<p><span class="font2">} else {</span></p>
<p><span class="font2">node($s, promise {merge(tail($S), tail($T))});</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">This function takes two streams of numbers, </span><span class="font2">$S </span><span class="font17">and </span><span class="font2">$T</span><span class="font17">, which are assumed to be in sorted order, and merges them into a single stream of numbers whose elements are also in sorted order. If either </span><span class="font2">$S </span><span class="font17">or </span><span class="font2">$T </span><span class="font17">is empty, the result of the merge is simply the other stream. (If both are empty, the result is therefore an empty stream.) If neither is empty, the function examines the head elements of </span><span class="font2">$S </span><span class="font17">and </span><span class="font2">$T </span><span class="font17">to decide which one should come out of the merged stream first. It then constructs a stream node whose head is the lesser of the two head elements, and whose tail is a promise to merge the rest of </span><span class="font2">$S </span><span class="font17">and </span><span class="font2">$T </span><span class="font17">in the same way. If the heads of </span><span class="font2">$S </span><span class="font17">and </span><span class="font2">$T </span><span class="font17">are the same number, the duplicate is eliminated in the output.</span></p>
<p><span class="font17">To avoid cluttering up our code with many calls to </span><span class="font2">transform()</span><span class="font17">, we’ll build a utility that multiplies every element of a stream by a constant:</span></p>
<p><span class="font2">use Stream qw(transform promise merge node show);</span></p>
<p><span class="font0">hamming.pl</span></p>
<p><span class="font2">sub scale {</span></p>
<p><span class="font2">my ($s, $c) = @_;</span></p>
<p><span class="font2">transform { $_[0]*$c } $s;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">Now we can define a Hamming stream as a stream that begins with 1 and is otherwise identical to the merge of the doubled, tripled, and quintupled versions</span></p>
<div>
<p><span class="font9" style="font-weight:bold;">CODE LIBRARY</span></p>
</div><br clear="all">
<p><span class="font17">of itself:</span></p>
<p><span class="font2">my Shamming;</span></p>
<p><span class="font2">Shamming = node(1, promise { merge(scale(Shamming, 2), merge(scale(Shamming, 3), scale(Shamming, 5), )) } );</span></p>
<p><span class="font2">show(Shamming, 3000);</span></p>
<p><span class="font17">This stream generates 3000 Hamming numbers (up to 278,942,752,080 </span><span class="font3">= </span><span class="font17">2</span><span class="font15">4 </span><span class="font3">• </span><span class="font17">3<sup>20</sup> </span><span class="font3">• </span><span class="font17">5) in about 14 seconds. Its structure looks like this:</span></p><img src="HigherOrderPerl_files/HigherOrderPerl-43.jpg" alt="" style="width:172pt;height:102pt;">
<ul style="list-style:none;"><li>
<p class="font18">6.5 regex string generation</p></li></ul>
<p><span class="font17">Here’s a question that comes up fairly often on IRC and in Perl-related newsgroups: Given a regex, how can one generate a list of all the strings matched by the regex? The problem can be rather difficult to solve. But the solution with streams is straightforward and compact.</span></p>
<p><span class="font17">There are a few complications that we should note first. In the presence of assertions and other oddities, there may not be any string that matches a given regex. For example, nothing matches the regex </span><span class="font2">/a\bz/</span><span class="font17">, because it requires the letters </span><span class="font2">a </span><span class="font17">and </span><span class="font2">z </span><span class="font17">to be adjacent, with a zero-length word boundary in between, and by definition, a word boundary does not occur between two adjacent letters. Similarly, </span><span class="font2">/a&quot;b/ </span><span class="font17">can’t match any string, because the </span><span class="font2">b </span><span class="font17">must occur </span><span class="font17" style="font-style:italic;">at</span><span class="font17"> the beginning of the string, but the </span><span class="font2">a </span><span class="font17">must occur </span><span class="font17" style="font-style:italic;">before</span><span class="font17"> the beginning of the string.</span></p>
<p><span class="font15">6.5 REGEX STRING GENERATION</span></p>
<div>
<p><span class="font20">273</span></p>
</div><br clear="all">
<p><span class="font17">Also, if our function is going to take a real regex as input, we have to worry about parsing regexes. We’ll ignore this part of the problem until Chapter 8, where we’ll build a parsing system that plugs into the string generator we’ll develop here.</span></p>
<p><span class="font17">Most of the basic regex features can be reduced to combinations of a few primitive operators. These operators are concatenation, union, and </span><span class="font2">*</span><span class="font17">.<a name="footnote23"></a><sup><a href="#bookmark320">23</a></sup><sup></sup> We’ll review; if </span><span class="font17" style="font-style:italic;">A</span><span class="font17"> and </span><span class="font17" style="font-style:italic;">B</span><span class="font17"> are regexes, then:</span></p>
<ul style="list-style:none;"><li>
<p><span class="font17">• &nbsp;&nbsp;</span><span class="font17" style="font-style:italic;">AB</span><span class="font17">, the concatenation of </span><span class="font17" style="font-style:italic;">A</span><span class="font17"> and </span><span class="font17" style="font-style:italic;">B</span><span class="font17">, is a regex that matches any string of the form </span><span class="font17" style="font-style:italic;">ab,</span><span class="font17"> where </span><span class="font17" style="font-style:italic;">a</span><span class="font17"> is a string that matches </span><span class="font17" style="font-style:italic;">A</span><span class="font17"> and </span><span class="font17" style="font-style:italic;">b</span><span class="font17"> is a string that matches </span><span class="font17" style="font-style:italic;">B</span><span class="font17">.</span></p></li>
<li>
<p><span class="font17">• &nbsp;&nbsp;</span><span class="font17" style="font-style:italic;">A</span><span class="font17"> | </span><span class="font17" style="font-style:italic;">B</span><span class="font17">, the union of </span><span class="font17" style="font-style:italic;">A</span><span class="font17"> and </span><span class="font17" style="font-style:italic;">B</span><span class="font17">, is a regex that matches any string </span><span class="font17" style="font-style:italic;">s</span><span class="font17"> that matches </span><span class="font17" style="font-style:italic;">A</span><span class="font17"> or </span><span class="font17" style="font-style:italic;">B</span><span class="font17">.</span></p></li>
<li>
<p><span class="font17">• &nbsp;&nbsp;</span><span class="font17" style="font-style:italic;">A</span><span class="font2">* </span><span class="font17">matches the empty string, or the concatenation of one or more strings that each individually match </span><span class="font17" style="font-style:italic;">A</span><span class="font17">.</span></p></li></ul>
<p><span class="font17">With these operators, and the trivial regexes that match literal strings, we can build most of Perl’s other regex operations. For example, </span><span class="font2">/A+/ </span><span class="font17">is the same as </span><span class="font2">/AA*/</span><span class="font17">, and </span><span class="font2">/A?/ </span><span class="font17">is the same as </span><span class="font2">/|A/</span><span class="font17">. Character classes are equivalent to unions; for example, </span><span class="font2">/[abc]/ </span><span class="font17">and </span><span class="font2">/a|b|c/ </span><span class="font17">are equivalent. Similarly </span><span class="font2">/ ./ </span><span class="font17">is a union of 255 different characters (everything but the newline.)</span></p>
<p><span class="font2">&quot; </span><span class="font17">and </span><span class="font2">$ </span><span class="font17">are easier to remove than to add, so we’ll include them by default, so that all regexes are implicitly anchored at both ends. Our system will be able to generate the strings that match a regex only if the regex begins with </span><span class="font2">&quot;&nbsp;</span><span class="font17">and ends with </span><span class="font2">$</span><span class="font17">. This is really no restriction at all, however. If we want to generate the strings that match </span><span class="font2">/A$/</span><span class="font17">, we can generate the strings that match </span><span class="font2">/&quot;.*A$/ </span><span class="font17">instead; these are exactly the same strings. Similarly the strings that match </span><span class="font2">/&quot;A/ </span><span class="font17">are the same as those that match </span><span class="font2">/&quot;A.*$/ </span><span class="font17">and the strings that match </span><span class="font2">/A/ </span><span class="font17">are the same as those that match </span><span class="font2">/&quot;.*A.*$/</span><span class="font17">. Every regex is therefore equivalent to one that begins with </span><span class="font2">&quot;&nbsp;</span><span class="font17">and ends with </span><span class="font2">$</span><span class="font17">.</span></p>
<p><span class="font17">We’ll represent a regex as a (possibly infinite) stream of the strings that it matches. The </span><span class="font2">Regex </span><span class="font17">class will import from </span><span class="font2">Stream</span><span class="font17">:</span></p>
<p><span class="font2">package Regex;</span></p>
<p><span class="font2">use Stream ':all';</span></p>
<p><span class="font2">use base 'Exporter';</span></p>
<p><span class="font2">@EXPORT_OK = qw(literal union concat star plus charclass show matches);</span></p>
<div>
<p><span class="font9" style="font-weight:bold;">CODE LIBRARY</span></p>
</div><br clear="all">
<div>
<p><span class="font0">Regex.pm</span></p>
</div><br clear="all">
<p><span class="font11">foo undef</span></p>
<p><span class="font14">FIGURE 6.1 </span><span class="font16">The stream generated by </span><span class="font2">literal()</span><span class="font16">.</span></p>
<p><span class="font17">Literal regexes are trivial. The corresponding stream has only one element, as shown in Figure 6.1:</span></p>
<p><span class="font2">sub literal {</span></p>
<p><span class="font2">my $string = shift;</span></p>
<p><span class="font2">node($string, undef);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">show(literal(&quot;foo&quot;));</span></p>
<p><span class="font2" style="font-weight:bold;">foo</span></p>
<p><span class="font17">Union is almost as easy. We have some streams, and we want to merge all their elements into a single stream. We can’t append the streams beginning-to-end as we would with ordinary lists, because the streams might not have ends. Instead, we’ll interleave the elements. Here’s a demonstration function that mingles two streams this way:</span></p>
<p><span class="font2">sub mingle2 {</span></p>
<p><span class="font2">my ($s, $t) = @_;</span></p>
<p><span class="font2">return $t unless $s;</span></p>
<p><span class="font2">return $s unless $t;</span></p>
<p><span class="font2">node(head($s),</span></p>
<p><span class="font2">node(head($t),</span></p>
<p><span class="font2">promise { mingle2(tail($s),</span></p>
<p><span class="font2">tail($t))</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">));</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">Later on it will be more convenient if we have a more general version that can mingle any number of streams:</span></p>
<p><span class="font2">sub union {</span></p>
<p><span class="font2">my ($h, @s) = grep $_, @_;</span></p>
<p><span class="font2">return unless $h;</span></p>
<p><span class="font2">return $h unless @s;</span></p>
<p><span class="font2">node(head($h),</span></p>
<p><span class="font2">promise {</span></p>
<p><span class="font15">6.5 REGEX STRING GENERATIO</span></p>
<p><span class="font2">union(@s, tail($h));</span></p>
<p><span class="font2">});</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">The function starts by throwing out any empty streams from the argument list. Empty streams won’t contribute anything to the output, so we can discard them. If all the input streams are empty, </span><span class="font2">union() </span><span class="font17">returns an empty stream. If there is only one nonempty input stream, </span><span class="font2">union() </span><span class="font17">returns it unchanged. Otherwise, the function does the mingle: The first element of the first stream is at the head of the result, and the rest of the result is obtained by mingling the rest of the streams with the rest of the first stream. The key point here is that the function puts </span><span class="font2">tail($h) </span><span class="font17">at the </span><span class="font17" style="font-style:italic;">end</span><span class="font17"> of the argument list in the recursive call, so that a different stream gets assigned to </span><span class="font2">$h </span><span class="font17">next time around. This will ensure that all the streams get cycled through the </span><span class="font2">$h </span><span class="font17">position in turn. The behavior is depicted in Figure 6.2. Here’s a simple example:</span></p>
<p><span class="font2"># generate infinite stream ($k:1, $k:2, $k:3, ...) sub constant {</span></p>
<p><span class="font2">my $k = shift;</span></p>
<p><span class="font2">my $i = shift || 1;</span></p>
<p><span class="font2">my $s = node(&quot;$k:$i&quot;, promise { constant($k, $i+1) });</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">my $fish = constant('fish');</span></p>
<p><span class="font2">show($fish, 3);</span></p>
<p><span class="font2" style="font-weight:bold;">fish:1 fish:2 fish:3</span></p>
<p><span class="font2">my $soup = union($fish, constant('dog'), constant('carrot'));</span></p>
<p><span class="font2">show($soup, 10);</span></p>
<p><span class="font2">fish:1 dog:1 carrot:1 fish:2 dog:2 carrot:2 fish:3 dog:3 carrot:3 fish:4</span></p>
<p><span class="font17">Now we’ll do concatenation. If either of regexes </span><span class="font17" style="font-style:italic;">S</span><span class="font17"> or </span><span class="font17" style="font-style:italic;">T</span><span class="font17"> never matches anything, then </span><span class="font17" style="font-style:italic;">ST</span><span class="font17"> also can’t match anything. Otherwise, </span><span class="font17" style="font-style:italic;">S</span><span class="font17"> is matched by some list of strings, and this list has ahead </span><span class="font2">s </span><span class="font17">and a tail </span><span class="font17" style="font-style:italic;">r</span><span class="font17">^j; similarly </span><span class="font17" style="font-style:italic;">T</span><span class="font17"> is matched by some other list of strings with head t and tail </span><span class="font17" style="font-style:italic;">r</span><span class="font15"><sub>ta</sub>y</span><span class="font17">. What strings are matched by </span><span class="font17" style="font-style:italic;">ST</span><span class="font17">? We can choose one string that matches </span><span class="font17" style="font-style:italic;">S</span><span class="font17"> and one that matches </span><span class="font17" style="font-style:italic;">T</span><span class="font17">, and their concatenation is one of the strings that matches </span><span class="font17" style="font-style:italic;">ST.</span><span class="font17"> Since we split each of the two lists into two parts, we have four choices for how to construct a string that matches </span><span class="font17" style="font-style:italic;">ST</span><span class="font17">:</span></p>
<ul style="list-style:none;"><li>
<p><span class="font17">1. &nbsp;</span><span class="font2">st </span><span class="font17">matches </span><span class="font17" style="font-style:italic;">ST</span></p></li>
<li>
<p><span class="font17">2. &nbsp;</span><span class="font2">s </span><span class="font17">followed by any string from </span><span class="font17" style="font-style:italic;">r</span><span class="font2">^l </span><span class="font17">matches </span><span class="font17" style="font-style:italic;">ST</span></p>
<div>
<p><span class="font20">275</span></p>
</div><br clear="all"></li></ul><img src="HigherOrderPerl_files/HigherOrderPerl-44.jpg" alt="" style="width:247pt;height:338pt;">
<p><span class="font14">FIGURE 6.2 </span><span class="font16">The behavior of </span><span class="font2">union()</span><span class="font16">.</span></p>
<ul style="list-style:none;"><li>
<p><span class="font17">3. &nbsp;Any string from </span><span class="font17" style="font-style:italic;">T</span><span class="font17"><sub>ta</sub></span><span class="font15">ii </span><span class="font17">followed by t matches </span><span class="font17" style="font-style:italic;">ST</span></p></li>
<li>
<p><span class="font17">4. &nbsp;Any string from </span><span class="font17" style="font-style:italic;">T</span><span class="font17"><sub>ta</sub></span><span class="font15">il </span><span class="font17">followed by any string from </span><span class="font15">^l </span><span class="font17">matches </span><span class="font17" style="font-style:italic;">ST</span></p></li></ul>
<p><span class="font17">Notationally, we write:</span></p>
<p><span class="font17"><sup>(s</sup> | <sup>s</sup></span><span class="font15">tail</span><span class="font17">).<sup>(t</sup> | <sup>t</sup></span><span class="font15">tail</span><span class="font17"><sup>)</sup> = <sup>s.t</sup> | <sup>s.t</sup></span><span class="font15">tail </span><span class="font17">| <sup>s</sup></span><span class="font15">tail</span><span class="font17"><sup>.t</sup> | <sup>s</sup></span><span class="font15">tail</span><span class="font17"><sup>.t</sup></span><span class="font15">tail</span></p>
<p><span class="font17">The first of these contains only one string. The middle two are simple transformations of the tails of </span><span class="font17" style="font-style:italic;">S</span><span class="font17"> and </span><span class="font17" style="font-style:italic;">T.</span><span class="font17"> The last one is a recursive call to the </span><span class="font2">concat() </span><span class="font17">function itself. So the code is simple:</span></p>
<p><span class="font2">sub concat {</span></p>
<p><span class="font2">my ($S, $T) = @_;</span></p>
<ul style="list-style:none;"><li>
<p><span class="font2" style="font-style:italic;">6..</span><span class="font15"> REGEX STRING GENERATION</span></p>
<div>
<p><span class="font20">277</span></p>
</div><br clear="all"></li></ul>
<p><span class="font2">return unless $S &amp;&amp;&nbsp;$T;</span></p>
<p><span class="font2">my ($s, $t) = (head($S), head($T));</span></p>
<p><span class="font2">node(&quot;$s$t&quot;, promise { union(postcat(tail($S), $t), precat(tail($T), $s), concat(tail($S), tail($T)), ) });</span></p>
<p><span class="font2">}</span></p>
<h6><a name="bookmark321"></a><span class="font2">precat() </span><span class="font17">and </span><span class="font2">postcat() </span><span class="font17">are simple utility functions that concatenate a string to the beginning or end of every element of a stream:</span></h6>
<p><span class="font2">sub precat { my ($s, $c) = @_; transform {&quot;$c$_[0]&quot;} $s;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">sub postcat { my ($s, $c) = @_; transform {&quot;$_[0]$c&quot;} $s;</span></p>
<p><span class="font2">}</span></p>
<h6><a name="bookmark322"></a><span class="font17">An example:</span></h6>
<p><span class="font2"># I’m /~(a|b)(c|d)$/</span></p>
<p><span class="font2">my $z = concat(union(literal(&quot;a&quot;), literal(&quot;b&quot;)), union(literal(&quot;c&quot;), literal(&quot;d&quot;)), );</span></p>
<p><span class="font2">show($z);</span></p>
<p><span class="font2" style="font-weight:bold;">ac bc ad bd</span></p>
<p><span class="font17">The behavior of </span><span class="font2">concat() </span><span class="font17">is illustrated in Figure 6.3.</span></p>
<p><span class="font17">Now that we have </span><span class="font2">concat()</span><span class="font17">, the </span><span class="font2">* </span><span class="font17">operator is trivial, because of this simple identity:</span></p>
<p><span class="font2">s* = &quot;&quot;&nbsp;| ss*</span></p>
<p><span class="font17">That is, </span><span class="font17" style="font-style:italic;">s</span><span class="font2" style="font-style:italic;">*</span><span class="font17"> is either the empty string or else something that matches </span><span class="font17" style="font-style:italic;">s</span><span class="font17"> followed by something else that matches </span><span class="font17" style="font-style:italic;">s</span><span class="font2">*</span><span class="font17">. We want to generate </span><span class="font17" style="font-style:italic;">s</span><span class="font2">*</span><span class="font17">; let’s call this result </span><span class="font17" style="font-style:italic;">r.</span></p><img src="HigherOrderPerl_files/HigherOrderPerl-45.jpg" alt="" style="width:187pt;height:42pt;"><img src="HigherOrderPerl_files/HigherOrderPerl-46.jpg" alt="" style="width:240pt;height:125pt;"><img src="HigherOrderPerl_files/HigherOrderPerl-47.jpg" alt="" style="width:330pt;height:278pt;"><img src="HigherOrderPerl_files/HigherOrderPerl-48.jpg" alt="" style="width:410pt;height:441pt;">
<p><span class="font14">FIGURE 6.3 </span><span class="font16">The behavior and internals of </span><span class="font2">concat()</span><span class="font16">, continued.</span></p><img src="HigherOrderPerl_files/HigherOrderPerl-49.jpg" alt="" style="width:185pt;height:46pt;">
<p><span class="font14">FIGURE </span><span class="font17" style="font-style:italic;">6.4</span><span class="font16"> The behavior and internals of </span><span class="font2">star()</span><span class="font16">.</span></p>
<p><span class="font17">Then:</span></p>
<p><span class="font2">r = &quot;&quot;&nbsp;| sr</span></p>
<p><span class="font17">Now we can use the wonderful recursive definition capability of streams:</span></p>
<p><span class="font2">sub star {</span></p>
<p><span class="font2">my $s = shift;</span></p>
<p><span class="font2">my $r;</span></p>
<p><span class="font2">$r = node(&quot;&quot;, promise { concat($s, $r) });</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">$r</span><span class="font17">, the result, will be equal to the </span><span class="font2">* </span><span class="font17">of </span><span class="font2">$s</span><span class="font17">. It begins with the empty string, and the rest of </span><span class="font2">$r </span><span class="font17">is formed by concatenating something in </span><span class="font2">$s </span><span class="font17">with </span><span class="font2">$r </span><span class="font17">itself: Figure 6.4 shows how it works; here’s an example:</span></p>
<p><span class="font2"># I’m /~(HONK)*$/</span></p>
<p><span class="font2">show(star(literal('HONK')), 6)</span></p>
<p><span class="font2">HONK HONKHONK HONKHONKHONK HONKHONKHONKHONK HONKHONKHONKHONKHONK</span></p>
<p><span class="font17">The empty string is hiding at the beginning of that output line. Let’s use a modified version of </span><span class="font2">show() </span><span class="font17">to make it visible:</span></p>
<p><span class="font2">sub show {</span></p>
<p><span class="font2">my ($s, $n) = @_;</span></p>
<p><span class="font2">while ($s &amp;&amp;&nbsp;(! defined $n || $n-- &gt;&nbsp;0)) {</span></p>
<p><span class="font2" style="font-weight:bold;">print qq{&quot;}, drop($s), qq{&quot;\n};</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2" style="font-weight:bold;">print &quot;</span><span class="font2">\</span><span class="font2" style="font-weight:bold;">n&quot;;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">Now the output is:</span></p>
<p><span class="font2">&quot;HONK&quot;</span></p>
<ul style="list-style:none;"><li>
<p><span class="font2" style="font-style:italic;">6..</span><span class="font15"> REGEX STRING GENERATION</span></p>
<div>
<p><span class="font20">281</span></p>
</div><br clear="all"></li></ul>
<p><span class="font2">&quot;HONKHONK&quot;</span></p>
<p><span class="font2">&quot;HONKHONKHONK&quot;</span></p>
<p><span class="font2">&quot;HONKHONKHONKHONK&quot;</span></p>
<p><span class="font2">&quot;HONKHONKHONKHONKHONK&quot;</span></p>
<h6><a name="bookmark323"></a><span class="font17">We can throw in a couple of extra utilities if we like:</span></h6>
<ul style="list-style:none;"><li>
<p><span class="font2"># charclass('abc') = /~[abc]$/ sub charclass {</span></p></li></ul>
<p><span class="font2">my $class = shift;</span></p>
<p><span class="font2">union(map literal($_), split(//, $class));</span></p>
<p><span class="font2">}</span></p>
<ul style="list-style:none;"><li>
<p><span class="font2"># plus($s) = /~s+$/</span></p></li></ul>
<p><span class="font2">sub plus {</span></p>
<p><span class="font2">my $s = shift;</span></p>
<p><span class="font2">concat($s, star($s));</span></p>
<p><span class="font2">}</span></p>
<h6><a name="bookmark324"></a><span class="font17">And now a demonstration:</span></h6>
<p><span class="font2">use Regex qw(concat star literal show);</span></p>
<ul style="list-style:none;"><li>
<p><span class="font2"># I represent /~ab*$/</span></p></li></ul>
<p><span class="font2">my Sregexl = concat( literal(&quot;a&quot;),</span></p>
<p><span class="font2">star(literal(&quot;b&quot;))</span></p>
<p><span class="font2">);</span></p>
<p><span class="font2">show($regex1, 10);</span></p>
<h6><a name="bookmark325"></a><span class="font17">The output is:</span></h6>
<p><span class="font2">&quot;a&quot;</span></p>
<p><span class="font2">&quot;ab&quot;</span></p>
<p><span class="font2">&quot;abb&quot;</span></p>
<p><span class="font2">&quot;abbb&quot;</span></p>
<p><span class="font2">&quot;abbbb&quot;</span></p>
<p><span class="font2">&quot;abbbbb&quot;</span></p>
<p><span class="font2">&quot;abbbbbb&quot;</span></p>
<p><span class="font2">&quot;abbbbbbb&quot;</span></p>
<p><span class="font2">&quot;abbbbbbbb&quot;</span></p>
<p><span class="font2">&quot;abbbbbbbbb&quot;</span></p>
<p><span class="font20">282 </span><span class="font15">CHAPTER 6 Infinite Streams</span></p>
<h6><a name="bookmark326"></a><span class="font17">Let’s try something a little more interesting:</span></h6>
<p><span class="font2"># I represent /~(aa|b)*$/</span></p>
<p><span class="font2">my $regex2 = star(union(literal(&quot;aa&quot;), literal(&quot;b&quot;), ));</span></p>
<p><span class="font2">show($regex2, 16);</span></p>
<h6><a name="bookmark327"></a><span class="font17">The output is:</span></h6>
<p><span class="font2">&quot;aa&quot;</span></p>
<p><span class="font2">&quot;b&quot;</span></p>
<p><span class="font2">&quot;aaaa&quot;</span></p>
<p><span class="font2">&quot;baa&quot;</span></p>
<p><span class="font2">&quot;aab&quot;</span></p>
<p><span class="font2">&quot;bb&quot;</span></p>
<p><span class="font2">&quot;aaaaaa&quot;</span></p>
<p><span class="font2">&quot;baaaa&quot;</span></p>
<p><span class="font2">&quot;aabaa&quot;</span></p>
<p><span class="font2">&quot;bbaa&quot;</span></p>
<p><span class="font2">&quot;aaaab&quot;</span></p>
<p><span class="font2">&quot;baab&quot;</span></p>
<p><span class="font2">&quot;aabb&quot;</span></p>
<p><span class="font2">&quot;bbb&quot;</span></p>
<p><span class="font2">&quot;aaaaaaaa&quot;</span></p>
<h6><a name="bookmark328"></a><span class="font17">One last example:</span></h6>
<p><span class="font2"># I represent /~(ab+|c)*$/</span></p>
<p><span class="font2">my $regex3 = star(union(concat( literal(&quot;a&quot;), plus(literal(&quot;b&quot;))), literal(&quot;c&quot;)</span></p>
<p><span class="font2">));</span></p>
<p><span class="font2">show($regex3, 20);</span></p>
<h6><a name="bookmark329"></a><span class="font17">The output is:</span></h6>
<p><span class="font2">&quot;ab&quot;</span></p>
<p><span class="font2">&quot;c&quot;</span></p>
<p><span class="font2">&quot;abab&quot;</span></p>
<p><span class="font2">&quot;cab&quot;</span></p>
<p><span class="font2">&quot;abb&quot;</span></p>
<p><span class="font2">&quot;abc&quot;</span></p>
<p><span class="font2">&quot;abbab&quot;</span></p>
<p><span class="font2">&quot;abbb&quot;</span></p>
<p><span class="font2">&quot;ababab&quot;</span></p>
<p><span class="font2">&quot;cc&quot;</span></p>
<p><span class="font2">&quot;abbbb&quot;</span></p>
<p><span class="font2">&quot;abcab&quot;</span></p>
<p><span class="font2">&quot;abbc&quot;</span></p>
<p><span class="font2">&quot;abbbbb&quot;</span></p>
<p><span class="font2">&quot;ababb&quot;</span></p>
<p><span class="font2">&quot;abbbab&quot;</span></p>
<p><span class="font2">&quot;abbbbbb&quot;</span></p>
<p><span class="font2">&quot;ababc&quot;</span></p>
<p><span class="font2">&quot;cabab&quot;</span></p>
<ul style="list-style:none;"><li>
<h5><a name="bookmark125"></a><span class="font19">6.5.1 Generating Strings in Order</span></h5></li></ul>
<p><span class="font17">It’s hard to be sure, from looking at this last output, that it really is generating all the strings that will match </span><span class="font2">/&quot;(ab+|c)*/</span><span class="font17">. Will </span><span class="font2">cccc </span><span class="font17">really show up? Where’s </span><span class="font2">cabb</span><span class="font17">? We might prefer the strings to come out in some order, say in order by length. It happens that this is also rather easy to do. Let’s say that a stream of strings is “ordered” if no string comes out after a longer string has come out, and see what will be necessary to generate ordered streams.</span></p>
<p><span class="font17">The streams produced by </span><span class="font2">literal() </span><span class="font17">contain only one string, so those streams are already ordered, because one item can’t be disordered.<a name="footnote24"></a><sup><a href="#bookmark330">24</a></sup><sup></sup> </span><span class="font2">concat()</span><span class="font17">, it turns out, is already generating its elements in order as best it can. The business end is:</span></p>
<p><span class="font2">my ($s, $t) = (head($S), head($T));</span></p>
<p><span class="font2">node(&quot;$s$t&quot;, promise { union( precat(tail($T), $s),</span></p>
<div>
<p><span class="font20">284</span></p>
</div><br clear="all">
<p><span class="font15">CHAPTER 6 Infinite Streams</span></p>
<p><span class="font2">postcat(tail(SS), St), concat(tail($S), tail(ST)),</span></p>
<p><span class="font2">)</span></p>
<p><span class="font2">});</span></p>
<p><span class="font17">Let’s suppose that the inputs, </span><span class="font2">SS </span><span class="font17">and </span><span class="font2">ST</span><span class="font17">, are already ordered. In that case, </span><span class="font2">Ss </span><span class="font17">is one of the shortest elements of </span><span class="font2">SS</span><span class="font17">, and </span><span class="font2">St </span><span class="font17">is one of the shortest elements of </span><span class="font2">ST</span><span class="font17">. </span><span class="font2">SsSt </span><span class="font17">therefore can’t be any longer than any other concatenation of elements from </span><span class="font2">SS </span><span class="font17">and </span><span class="font2">ST</span><span class="font17">, so it’s all right that it will come out first. As long as the output of the </span><span class="font2">union() </span><span class="font17">call is ordered, the output of </span><span class="font2">concat() </span><span class="font17">will be too.</span></p>
<p><span class="font2">union() </span><span class="font17">does need some rewriting. It currently cycles through its input streams in sequence. We need to modify it to find the input stream whose head element is shortest and to process that stream first:</span></p>
<p><span class="font2">sub union {</span></p>
<p><span class="font2">my (@s) = grep $_, @_;</span></p>
<p><span class="font2">return unless @s;</span></p>
<p><span class="font2">return $s[0] if @s == 1;</span></p>
<p><span class="font2">my Ssi = index_of_shortest(@s);</span></p>
<p><span class="font2">node(head($s[$si]),</span></p>
<p><span class="font2">promise {</span></p>
<p><span class="font2">union(map $_ == Ssi ? tail($s[$_]) : $s[$_], 0 .. $#s);</span></p>
<p><span class="font2">});</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">The first two </span><span class="font2">returns </span><span class="font17">correspond to the early </span><span class="font2">returns </span><span class="font17">in the original version of </span><span class="font2">union()</span><span class="font17">, handling the special cases ofzero or one argument stream. If there’s more than one argument stream, the function calls </span><span class="font2">index_of_shortest()</span><span class="font17">, which will examine the heads of the streams to find the shortest string. </span><span class="font2">index_of_shortest() </span><span class="font17">returns </span><span class="font2">Ssi</span><span class="font17">, the indexnumber of the stream with the shortest head string. </span><span class="font2">union() </span><span class="font17">pulls off this string and puts it first in the output, then calls itself recursively to process the remaining data. </span><span class="font2">index_of_shortest() </span><span class="font17">is quite ordinary:</span></p>
<p><span class="font2">sub index_of_shortest {</span></p>
<p><span class="font2">my @s = @_;</span></p>
<p><span class="font2">my Sminlen = length(head(Ss[0]));</span></p>
<p><span class="font2">my Ssi = 0;</span></p>
<p><span class="font2">for (1 .. S#s) {</span></p>
<p><span class="font2">my Sh = head(Ss[S_]);</span></p>
<p><span class="font2">if (length(Sh) &lt;&nbsp;Sminlen) {</span></p>
<p><span class="font15">6.5 REGEX STRING GENERATION</span></p>
<div>
<p><span class="font20">285</span></p>
</div><br clear="all">
<p><span class="font2">Sminlen = length(Sh);</span></p>
<p><span class="font2">Ssi = S_;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">Ssi;</span></p>
<p><span class="font2">}</span></p>
<h6><a name="bookmark331"></a><span class="font17">The last function to take care of is </span><span class="font2">star()</span><span class="font17">. But </span><span class="font2">star()</span><span class="font17">, it turns out, has taken care of itself:</span></h6>
<p><span class="font2">sub star {</span></p>
<p><span class="font2">my Ss = shift;</span></p>
<p><span class="font2">my Sr;</span></p>
<p><span class="font2">Sr = node(&quot;&quot;, promise { concat(Ss, Sr) });</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">The empty string, which comes out first, is certainly no longer than any other element in </span><span class="font2">Sr</span><span class="font17">’s output. And since we already know that </span><span class="font2">concat </span><span class="font17">produces an ordered stream, we’re finished.</span></p>
<p><span class="font17">That last example again:</span></p>
<p><span class="font2"># I represent /~(ab+|c)*S/</span></p>
<p><span class="font2">my Sregex3 = star(union(concat( literal(&quot;a&quot;),</span></p>
<p><span class="font2">plus(literal(&quot;b&quot;))),</span></p>
<p><span class="font2">literal(&quot;c&quot;)</span></p>
<p><span class="font2">));</span></p>
<p><span class="font2">show(Sregex3, 30);</span></p>
<h6><a name="bookmark332"></a><span class="font17">And the now-sorted output:</span></h6>
<p><span class="font2">&quot;c&quot;</span></p>
<p><span class="font2">&quot;ab&quot;</span></p>
<p><span class="font2">&quot;cc&quot;</span></p>
<p><span class="font2">&quot;abb&quot;</span></p>
<p><span class="font2">&quot;cab&quot;</span></p>
<p><span class="font2">&quot;ccc&quot;</span></p>
<p><span class="font2">&quot;abc&quot;</span></p>
<p><span class="font2">&quot;abbb&quot;</span></p>
<p><span class="font2">&quot;cabb&quot;</span></p>
<p><span class="font2">&quot;ccab&quot;</span></p>
<p><span class="font2">&quot;cccc&quot;</span></p>
<p><span class="font2">&quot;cabc&quot;</span></p>
<p><span class="font2">&quot;abbc&quot;</span></p>
<p><span class="font2">&quot;abab&quot;</span></p>
<p><span class="font2">&quot;abcc&quot;</span></p>
<p><span class="font2">&quot;abbbb&quot;</span></p>
<p><span class="font2">&quot;cabbb&quot;</span></p>
<p><span class="font2">&quot;ccabb&quot;</span></p>
<p><span class="font2">&quot;cccab&quot;</span></p>
<p><span class="font2">&quot;ccccc&quot;</span></p>
<p><span class="font2">&quot;ccabc&quot;</span></p>
<p><span class="font2">&quot;cabbc&quot;</span></p>
<p><span class="font2">&quot;cabab&quot;</span></p>
<p><span class="font2">&quot;cabcc&quot;</span></p>
<p><span class="font2">&quot;abbbc&quot;</span></p>
<p><span class="font2">&quot;ababb&quot;</span></p>
<p><span class="font2">&quot;abcab&quot;</span></p>
<p><span class="font2">&quot;abccc&quot;</span></p>
<p><span class="font2">&quot;ababc&quot;</span></p>
<p><span class="font17">Aha, </span><span class="font2">cccc </span><span class="font17">and </span><span class="font2">cabb </span><span class="font17" style="font-style:italic;">were</span><span class="font17"> produced, after all.</span></p>
<ul style="list-style:none;"><li>
<h5><a name="bookmark126"></a><span class="font19">6.5.2 Regex Matching</span></h5></li></ul>
<p><span class="font17">At this point we’ve built a system that can serve as a regex engine: Given a regex and a target string, it can decide whether the string matches the regex. A regex is a representation of a set of strings that supports operations like concatenation, union, and closure. Our regex-string-streams fit the bill. Here’s a regex-matching engine:</span></p>
<p><span class="font2">sub matches {</span></p>
<p><span class="font2">my (Sstring, Sregex) = @_;</span></p>
<p><span class="font2">while (Sregex) {</span></p>
<p><span class="font2">my Ss = drop(Sregex);</span></p>
<p><span class="font2">return 1 if Ss eq Sstring;</span></p>
<p><span class="font2">return 0 if length(Ss) &gt;&nbsp;length(Sstring);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">return 0;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">The </span><span class="font2">$regex </span><span class="font17">argument here is one of our regex streams. (After we attach the parser from Chapter 8, we’ll be able to pass in a regex in standard Perl notation instead.) The function looks at the shortest string matched by the regex; if it’s the target string, then we have a match. If it’s longer than the target string, then the match fails, because every other string in the regex is also too long. Otherwise, the function throws away the head and repeats with the next string. If the regex runs out of strings, the match fails.</span></p>
<p><span class="font17">This is just an example; it should be emphasized that, in general, streams are </span><span class="font17" style="font-style:italic;">not</span><span class="font17"> a good way to do regex matching. To determine whether a string matches </span><span class="font2">/&quot;[ab]*$/</span><span class="font17">, this method generates all possible strings of </span><span class="font2">a</span><span class="font17">’s and </span><span class="font2">b</span><span class="font17">’s and checks each one to see if it is the target string. This is obviously a silly way to do it. The amount of time it takes is exponential in the length of the target string; an obviously better algorithm is to scan the target string left to right, checking each character to make sure it is an </span><span class="font2">a </span><span class="font17">or a </span><span class="font2">b</span><span class="font17">, which requires only linear time.</span></p>
<p><span class="font17">Nevertheless, in some ways this implementation of regex matching is actually </span><span class="font17" style="font-style:italic;">more</span><span class="font17"> powerful than Perl’s built-in matcher. For example, there’s no convenient way to ask Perl if a string contains a balanced arrangement of parentheses. (Starting in 5.005, you can use the </span><span class="font2">(?{...}) </span><span class="font17">operator, but it’s nasty.<a name="footnote25"></a><sup><a href="#bookmark333">25</a></sup><sup></sup>) But our “regexes” are just lists of strings, and the lists can contain whatever we want. If we want a regex that represents balanced arrangements of parentheses, all we need to do is construct a stream that contains the strings we want.</span></p>
<p><span class="font17">Let’s say that we would like to match strings of </span><span class="font2">a</span><span class="font17">, </span><span class="font2">(</span><span class="font17">, and </span><span class="font2">) </span><span class="font17">in which the parentheses are balanced. That is, we’d like to match the following strings:</span></p>
<p><span class="font2">&quot;a&quot;</span></p>
<p><span class="font2">&quot;aa&quot;</span></p>
<p><span class="font2">&quot;()&quot;</span></p>
<p><span class="font2">&quot;aaa&quot;</span></p>
<p><span class="font2">&quot;a()&quot;</span></p>
<p><span class="font2">&quot;()a&quot;</span></p>
<p><span class="font2">&quot;(a)&quot;</span></p>
<p><span class="font2">&quot;aaaa&quot;</span></p>
<p><span class="font2">&quot;aa()&quot;</span></p>
<p><span class="font2">&quot;a()a&quot;</span></p>
<p><span class="font2">&quot;()aa&quot;</span></p>
<p><span class="font2">&quot;a(a)&quot;</span></p>
<p><span class="font2">&quot;(a)a&quot;</span></p>
<table border="1">
<tr><td style="vertical-align:bottom;">
<p><span class="font20">288</span></p></td><td style="vertical-align:bottom;">
<p><span class="font15" style="font-variant:small-caps;">chapter </span><span class="font2" style="font-style:italic;">6</span><span class="font15"> Infinite Streams</span></p></td></tr>
</table>
<p><span class="font2">&quot;(aa)&quot; &quot;00&quot; &quot;(())&quot; &quot;aaaaa&quot;</span></p>
<p><span class="font17">Suppose </span><span class="font17" style="font-style:italic;">s</span><span class="font17"> is a regex that matches the expressions that are legal between parentheses. Then a sequence of these expressions with properly balanced parentheses is one of the following:</span></p>
<ul style="list-style:none;"><li>
<p><span class="font17">• &nbsp;&nbsp;the empty string, or</span></p></li>
<li>
<p><span class="font17">• &nbsp;&nbsp;something that matches </span><span class="font17" style="font-style:italic;">s</span><span class="font17">, or</span></p></li>
<li>
<p><span class="font17">• &nbsp;&nbsp;</span><span class="font17" style="font-style:italic;">(b),</span><span class="font17"> where </span><span class="font17" style="font-style:italic;">b</span><span class="font17"> is some balanced string, or</span></p></li>
<li>
<p><span class="font17">• &nbsp;&nbsp;a balanced string followed by one of the above</span></p></li></ul>
<p><span class="font17">Then we can almost read off the definition:</span></p>
<p><span class="font2">sub bal { my Scontents = shift; my Sbal;</span></p>
<p><span class="font2">Sbal = node(&quot;&quot;, promise { concat(Sbal, union(Scontents, transform {&quot;($_[0])&quot;} Sbal, ) ) });</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">And now the question “Does </span><span class="font2">$s </span><span class="font17">contain a balanced sequence of parentheses, </span><span class="font2">a</span><span class="font17">’s, and </span><span class="font2">b</span><span class="font17">’s” is answered by:</span></p>
<p><span class="font2">if (matches($s, bal(charclass('ab')))) {</span></p>
<p><span class="font2">■ ■■ }</span></p>
<ul style="list-style:none;"><li>
<h5><a name="bookmark127"></a><span class="font19">6.5.3 Cutsorting</span></h5></li></ul>
<p><span class="font17">The regex-string generator suggests another problem that sometimes comes up. At present, it generates strings in order by length, but strings of the same length come out in no particular order, as in the following column on the left. Suppose we want the strings of the same length to come out in sorted order, as in the column on the right:</span></p>
<table border="1">
<tr><td>
<p><span class="font2">c</span></p></td><td>
<p><span class="font2">&quot;c&quot;</span></p></td></tr>
<tr><td>
<p><span class="font2">&quot;ab&quot;</span></p></td><td>
<p><span class="font2">&quot;ab&quot;</span></p></td></tr>
<tr><td>
<p><span class="font2">&quot;cc&quot;</span></p></td><td>
<p><span class="font2">&quot;cc&quot;</span></p></td></tr>
<tr><td>
<p><span class="font2">&quot;abb&quot;</span></p></td><td>
<p><span class="font2">&quot;abb&quot;</span></p></td></tr>
<tr><td>
<p><span class="font2">&quot;cab&quot;</span></p></td><td>
<p><span class="font2">&quot;abc&quot;</span></p></td></tr>
<tr><td>
<p><span class="font2">&quot;ccc&quot;</span></p></td><td>
<p><span class="font2">&quot;cab&quot;</span></p></td></tr>
<tr><td>
<p><span class="font2">&quot;abc&quot;</span></p></td><td>
<p><span class="font2">&quot;ccc&quot;</span></p></td></tr>
<tr><td>
<p><span class="font2">&quot;abbb&quot;</span></p></td><td>
<p><span class="font2">&quot;abab&quot;</span></p></td></tr>
<tr><td>
<p><span class="font2">&quot;cabb&quot;</span></p></td><td>
<p><span class="font2">&quot;abbb&quot;</span></p></td></tr>
<tr><td>
<p><span class="font2">&quot;ccab&quot;</span></p></td><td>
<p><span class="font2">&quot;abbc&quot;</span></p></td></tr>
<tr><td>
<p><span class="font2">&quot;cccc&quot;</span></p></td><td>
<p><span class="font2">&quot;abcc&quot;</span></p></td></tr>
<tr><td>
<p><span class="font2">&quot;cabc&quot;</span></p></td><td>
<p><span class="font2">&quot;cabb&quot;</span></p></td></tr>
<tr><td>
<p><span class="font2">&quot;abbc&quot;</span></p></td><td>
<p><span class="font2">&quot;cabc&quot;</span></p></td></tr>
<tr><td>
<p><span class="font2">&quot;abab&quot;</span></p></td><td>
<p><span class="font2">&quot;ccab&quot;</span></p></td></tr>
<tr><td>
<p><span class="font2">&quot;abcc&quot;</span></p></td><td>
<p><span class="font2">&quot;cccc&quot;</span></p></td></tr>
<tr><td>
<p><span class="font2">&quot;abbbb&quot;</span></p></td><td>
<p><span class="font2">&quot;ababb&quot;</span></p></td></tr>
<tr><td>
<p><span class="font2">&quot;cabbb&quot;</span></p></td><td>
<p><span class="font2">&quot;ababc&quot;</span></p></td></tr>
<tr><td style="vertical-align:bottom;">
<p><span class="font2">&quot;ccabb&quot;</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">&quot;abbab&quot;</span></p></td></tr>
<tr><td>
<p><span class="font2">&quot;cccab&quot;</span></p></td><td>
<p><span class="font2">&quot;abbbb&quot;</span></p></td></tr>
<tr><td>
<p><span class="font2">&quot;ccccc&quot;</span></p></td><td>
<p><span class="font2">&quot;abbbc&quot;</span></p></td></tr>
<tr><td>
<p><span class="font2">&quot;ccabc&quot;</span></p></td><td>
<p><span class="font2">&quot;abbcc&quot;</span></p></td></tr>
<tr><td>
<p><span class="font2">&quot;cabbc&quot;</span></p></td><td>
<p><span class="font2">&quot;abcab&quot;</span></p></td></tr>
<tr><td>
<p><span class="font2">&quot;cabab&quot;</span></p></td><td>
<p><span class="font2">&quot;abccc&quot;</span></p></td></tr>
<tr><td>
<p><span class="font2">&quot;cabcc&quot;</span></p></td><td>
<p><span class="font2">&quot;cabab&quot;</span></p></td></tr>
<tr><td>
<p><span class="font2">&quot;abbbc&quot;</span></p></td><td>
<p><span class="font2">&quot;cabbb&quot;</span></p></td></tr>
<tr><td>
<p><span class="font2">&quot;ababb&quot;</span></p></td><td>
<p><span class="font2">&quot;cabbc&quot;</span></p></td></tr>
<tr><td>
<p><span class="font2">&quot;abcab&quot;</span></p></td><td>
<p><span class="font2">&quot;cabcc&quot;</span></p></td></tr>
<tr><td>
<p><span class="font2">&quot;abccc&quot;</span></p></td><td>
<p><span class="font2">&quot;ccabb&quot;</span></p></td></tr>
<tr><td>
<p><span class="font2">&quot;ababc&quot;</span></p></td><td>
<p><span class="font2">&quot;ccabc&quot;</span></p></td></tr>
<tr><td>
<p><span class="font2">&quot;abbab&quot;</span></p></td><td>
<p><span class="font2">&quot;cccab&quot;</span></p></td></tr>
<tr><td style="vertical-align:bottom;">
<p><span class="font2">&quot;abbcc&quot;</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">&quot;ccccc&quot;</span></p></td></tr>
</table>
<p><span class="font17">We should note first that although it’s reasonable to ask for the strings sorted into groups by length and then lexicographically within each group, it’s </span><span class="font17" style="font-style:italic;">not</span><span class="font17"> reasonable to ask for </span><span class="font17" style="font-style:italic;">all</span><span class="font17"> the strings to be sorted lexicographically. This is for two reasons.</span></p>
<p><span class="font17">First, even if we could do it, the result wouldn’t be useful:</span></p>
<p><span class="font2">&quot;ab&quot;</span></p>
<p><span class="font2">&quot;abab&quot;</span></p>
<p><span class="font2">&quot;ababab&quot;</span></p>
<p><span class="font2">&quot;abababab&quot;</span></p>
<p><span class="font2">&quot;ababababab&quot;</span></p>
<p><span class="font2">&quot;abababababab&quot;</span></p>
<p><span class="font2">■ ■■</span></p>
<p><span class="font17">None of the strings that contains </span><span class="font2">c </span><span class="font17">would ever appear, because there would always be some other string that was lexicographically earlier that we had not yet emitted. But the second reason is that in general it’s not possible to sort an infinite stream at all. In this example, the first string to be emitted is clearly the emptystring. The second string out should be </span><span class="font2">&quot;ab&quot;</span><span class="font17">. But the sorting process can’t know that. It can’t emit the </span><span class="font2">&quot;ab&quot; </span><span class="font17">unless it’s sure that no other string would come between </span><span class="font2">&quot;&quot;&nbsp;</span><span class="font17">and </span><span class="font2">&quot;ab&quot;</span><span class="font17">. It doesn’t know that the one-billionth string in the input won’t be </span><span class="font2">&quot;a&quot;</span><span class="font17">. So it can never emit the </span><span class="font2">&quot;ab&quot;</span><span class="font17">, because no matter how long it waits to do so, there’s always a possibility that </span><span class="font2">&quot;a&quot; </span><span class="font17">will be right around the corner.</span></p>
<p><span class="font17">But if we know in advance that the input stream will be sorted by string length, and that there will be only a finite number of strings of each length, then we certainly can sort each group of strings of the same length.</span></p>
<p><span class="font17">In general, the problem with sorting is that, given some string we want to emit, we don’t know whether it’s safe to emit it without examining the entire rest of the stream, which might be infinite. But suppose we could supply a function that would say whether or not it was safe. If the input stream is already sorted by length, then at the moment we see the first length—3 string in the input, we know it’s safe to emit all the length—2 strings that we’ve seen already; the function could tell us this. The function effectively “cuts” the stream off, saying that enough of the input has been examined to determine the next part of the output, and that the cut-off part of the input doesn’t matter yet.</span></p>
<p><span class="font17">This idea is the basis of </span><span class="font17" style="font-style:italic;">cutsorting.</span><span class="font17"> The cutting function will get two arguments: the element we would like to emit, which should be the smallest one we have seen so far, and the current element of the input stream. The cutting function will return true if we have seen enough of the input stream to be sure that it’s safe to emit the element we want to, and false if the rest of the input stream might contain an element that precedes the one we want the function to emit.</span></p>
<p><span class="font17">For sorting by length, the cutting function is trivial:</span></p>
<p><span class="font2">sub cut_bylen {</span></p>
<p><span class="font2">my ($a, $b) = @_;</span></p>
<p><span class="font2" style="font-style:italic;">6..</span><span class="font15"> REGEX STRUNG GENERATION </span><span class="font20">291</span></p>
<p><span class="font2"># It’s OK to emit item Sa if the next item in the stream is Sb length(Sa) &lt;&nbsp;length(Sb);</span></p>
<p><span class="font2">}</span></p>
<h6><a name="bookmark334"></a><span class="font17">Since the cutsorter may need to emit several items at a time, we’ll build a utility function for doing that:</span></h6>
<p><span class="font2">sub list_to_stream { my Snode = pop;</span></p>
<p><span class="font2">while (©_) { Snode = node(pop, Snode);</span></p>
<p><span class="font2">} Snode;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">list_to_stream(h1, h2, ... t) </span><span class="font17">returns a stream that starts with </span><span class="font2">hl</span><span class="font17">, </span><span class="font2">h2</span><span class="font17">, </span><span class="font2">...</span></p>
<p><span class="font17">and whose final tail is </span><span class="font2">t</span><span class="font17">. </span><span class="font2">t </span><span class="font17">may be another (possibly empty) stream or a promise. </span><span class="font2">list_to_stream(h, t) </span><span class="font17">is equivalent to </span><span class="font2">node(h, t)</span><span class="font17">.</span></p>
<p><span class="font17">The cutsorting function gets four arguments: </span><span class="font2">Ss</span><span class="font17">, the stream to sort; </span><span class="font2">Scmp</span><span class="font17">, the sorting comparator (analogous to the comparator function of </span><span class="font2">sort()</span><span class="font17">); and </span><span class="font2">Scut</span><span class="font17">, the cutting test. It also gets an auxiliary argument </span><span class="font2">@pending </span><span class="font17">that we’ll see in a moment:</span></p>
<p><span class="font2">sub insert (\©SS);</span></p>
<p><span class="font2">sub cutsort {</span></p>
<p><span class="font2">my (Ss, Scmp, Scut, ©pending) = @_; my ©emit;</span></p>
<p><span class="font2">while (Ss) {</span></p>
<p><span class="font2">while (©pending &amp;&amp;&nbsp;Scut-&gt;(Spending[0], head(Ss))) { push ©emit, shift ©pending;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">if (©emit) {</span></p>
<p><span class="font2">return list_to_stream(©emit,</span></p>
<p><span class="font2">promise { cutsort(Ss, Scmp, Scut, ©pending) });</span></p>
<p><span class="font2">} else { insert(©pending, head(Ss), Scmp);</span></p>
<p><span class="font2">Ss = tail(Ss); }</span></p>
<p><span class="font2">}</span></p>
<div>
<p><span class="font20">292</span></p>
</div><br clear="all">
<p><span class="font15">CHAPTER 6 Infinite Streams</span></p>
<p><span class="font2">return list_to_stream(©pending, undef);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">The idea of the cutsorter is to scan through the input stream, maintaining a buffer of items that have been seen so far but not yet emitted; this is </span><span class="font2">©pending. ©pending </span><span class="font17">is kept in sorted order, so that if any element is ready to come out, it will be </span><span class="font2">$pending[0]</span><span class="font17">. The </span><span class="font2">while (©pending...) </span><span class="font17">loop checks to see if any elements can be emitted; if so, the emittable elements are transferred to </span><span class="font2">©emit</span><span class="font17">. If there are any such elements, they are emitted immediately: </span><span class="font2">cutsort() </span><span class="font17">returns a stream that begins with these elements and that ends with a promise to cutsort the remaining elements of </span><span class="font2">$s</span><span class="font17">. Any unemitted elements of </span><span class="font2">©pending </span><span class="font17">are passed along in the promise to be emitted later.</span></p>
<p><span class="font17">If no elements are ready for emission, the function discards the head element of the stream after inserting it into </span><span class="font2">©pending. insert() </span><span class="font17">takes care of inserting </span><span class="font2">head($s) </span><span class="font17">into the appropriate place in </span><span class="font2">©pending </span><span class="font17">so that </span><span class="font2">©pending </span><span class="font17">is always properly sorted.</span></p>
<p><span class="font17">If </span><span class="font2">$s </span><span class="font17">is exhausted, all items in </span><span class="font2">©pending </span><span class="font17">immediately become emittable, so the function calls </span><span class="font2">list_to_stream() </span><span class="font17">to build a finite stream that contains them and that ends with an empty tail.</span></p>
<p><span class="font17">Now if we’d like to generate strings in sorted order, we call </span><span class="font2">cutsort() </span><span class="font17">like this:</span></p>
<p><span class="font2">my $sorted =</span></p>
<p><span class="font2">cutsort($regex3, sub { $_[0] cmp $_[1] }, # comparator \&amp;cut_bylen &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# cutting function</span></p>
<p><span class="font2">);</span></p>
<p><span class="font17">The one piece of this that we haven’t seen is </span><span class="font2">insert()</span><span class="font17">, which inserts an element into the appropriate place in a sorted array:</span></p>
<p><span class="font2">sub insert (\©$$) {</span></p>
<p><span class="font2">my ($a, $e, $cmp) = ©_;</span></p>
<p><span class="font2">my ($lo, $hi) = (0, scalar(©$a));</span></p>
<p><span class="font2">while ($lo &lt;&nbsp;$hi) {</span></p>
<p><span class="font2">my $med = int(($lo + $hi) / 2);</span></p>
<p><span class="font2">my $d = $cmp-&gt;($a-&gt;[$med], $e);</span></p>
<p><span class="font2">if ($d &lt;= 0) { $lo = $med+1;</span></p>
<p><span class="font2">} else {</span></p>
<p><span class="font2">$hi = $med;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">splice(@$a, $lo, 0, $e);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">This is straightforward, except possibly for the prototype. The prototype </span><span class="font2">(\@$$) </span><span class="font17">says that </span><span class="font2">insert() </span><span class="font17">will be called with three arguments: an array and two scalars, and that it will be passed a reference to the array argument instead of a list of its elements. It then performs a binary search on the array </span><span class="font2">@$a</span><span class="font17">, looking for the appropriate place to splice in the new element </span><span class="font2">$e</span><span class="font17">. A linear scan is simpler to write and to understand than the binary search, but it’s not efficient enough for heavy-duty use.</span></p>
<p><span class="font17">At all times, </span><span class="font2">$lo </span><span class="font17">and </span><span class="font2">$hi </span><span class="font17">record the indices of elements of </span><span class="font2">@$a </span><span class="font17">that are known to satisfy </span><span class="font2">$a-&gt;[$lo] </span><span class="font3">&lt;&nbsp;</span><span class="font2">$e </span><span class="font17" style="font-style:italic;">&lt;</span><span class="font2">&nbsp;$a-&gt;[$hi]</span><span class="font17">, where </span><span class="font3">&lt;&nbsp;</span><span class="font17">here represents the comparison defined by the </span><span class="font2">$cmp </span><span class="font17">function. Each time through the </span><span class="font2">while </span><span class="font17">loop, the function compares </span><span class="font2">$e </span><span class="font17">to the element of the array at the position halfway between </span><span class="font2">$lo </span><span class="font17">and </span><span class="font2">$hi</span><span class="font17">. Depending on the outcome of the comparison, the function now knows a new element </span><span class="font2">$a-&gt;[$med] </span><span class="font17">with </span><span class="font2">$a-&gt;[$med] </span><span class="font3">&lt;&nbsp;</span><span class="font2">$e </span><span class="font17">or with </span><span class="font2">$e </span><span class="font17" style="font-style:italic;">&lt;</span><span class="font2">&nbsp;$a-&gt;[$med]</span><span class="font17">. We can then replace either </span><span class="font2">$hi </span><span class="font17">or </span><span class="font2">$lo </span><span class="font17">with </span><span class="font2">$med </span><span class="font17">while still preserving the condition </span><span class="font2">$a-&gt;[$lo] </span><span class="font3">&lt;&nbsp;</span><span class="font2">$e </span><span class="font17" style="font-style:italic;">&lt;</span><span class="font2">&nbsp;$a-&gt;[$hi]</span><span class="font17">. When </span><span class="font2">$lo </span><span class="font17">and </span><span class="font2">$hi </span><span class="font17">are the same, the function has located the correct position for </span><span class="font2">$e </span><span class="font17">in the array, and uses </span><span class="font2">splice() </span><span class="font17">to insert </span><span class="font2">$e </span><span class="font17">in the appropriate place. For further discussion of binary search, see </span><span class="font17" style="font-style:italic;">Mastering Algorithms with Perl,</span><span class="font17"> pp. 162—165.</span></p>
<p><span class="font17">LOG FILES</span></p>
<p><span class="font17">For a more practical example of the usefulness of cutsorting, consider a program to process a mail log file. The popular </span><span class="font2">qmail </span><span class="font17">mail system generates a log in the following format:</span></p>
<p><span class="font1">@400000003e382910351ebf4c new msg 706430</span></p>
<p><span class="font1">@400000003e3829103573e42c info msg 706430: bytes 2737 from &lt;</span><a href="mailto:boehm5@email.com"><span class="font1">boehm5@email.com</span></a><span class="font1">&gt; qp 31064 uid 1001</span></p>
<p><span class="font1">@400000003e38291035d359ac starting delivery 190552: msg 706430 to local </span><a href="mailto:guitar-tpj-regex@plover.com"><span class="font1">guitar-tpj-regex@plover.com</span></a></p>
<p><span class="font1">@400000003e38291035d3cedc status: local 1/5 remote 2/10</span></p>
<p><span class="font1">@400000003e3829113084e7f4 delivery 190552: success: did_0+1+0/qp_31067/</span></p>
<p><span class="font1">@400000003e38291130aa3aa4 status: local 1/5 remote 2/10</span></p>
<p><span class="font1">@400000003e3829120762c51c end msg 706430</span></p>
<p><span class="font17">The first field in each line is a time stamp in </span><span class="font17" style="font-style:italic;">tai64n</span><span class="font17"> format. The rest of the line describes what the mail system is doing. </span><span class="font2">new msg </span><span class="font17">indicates that a new message has</span></p>
<p><span class="font17">been added to one of the delivery queues and includes the ID number of the new message. </span><span class="font2">info msg </span><span class="font17">records the sender of the new message. (A message always has exactly one sender, but may have any number of recipients.) </span><span class="font2">starting delivery </span><span class="font17">indicates that a delivery attempt is being started, the address of the intended recipient, and a unique delivery ID number. </span><span class="font2">delivery </span><span class="font17">indicates the outcome of the delivery attempt, which may be a successful delivery, or a temporary or permanent failure, and includes the delivery ID number. </span><span class="font2">end msg </span><span class="font17">indicates that delivery attempts to all the recipients of a message have ended in success or permanent failure, and that the message is being removed from the delivery queue. </span><span class="font2">status </span><span class="font17">lines indicate the total number of deliveries currently in progress.</span></p>
<p><span class="font17">This log format is complete and not too difficult to process, but it is difficult for humans to read quickly. We might like to generate summary reports in different formats; for example, we might like to reduce the life of the previous message to a single line:</span></p>
<p><span class="font2">706430 29/Jan/2003:14:18:30 29/Jan/2003:14:18:32 &lt;</span><a href="mailto:boehm5@email.com"><span class="font2">boehm5@email.com</span></a><span class="font2">&gt; 1100</span></p>
<p><span class="font17">This records the message ID number, the times at which the message was inserted into and removed from the queue, the sender, the total number of delivery attempts, and the number of attempts that were respectively successful, permanent failures, and temporary failures.</span></p>
<p><span class="font2">qmail </span><span class="font17">writes its logs to a file called </span><span class="font2">current</span><span class="font17">; when </span><span class="font2">current </span><span class="font17">gets sufficiently large, it is renamed and a new </span><span class="font2">current </span><span class="font17">file is started. We’ll build a stream that follows the </span><span class="font2">current </span><span class="font17">file, notices when a new </span><span class="font2">current </span><span class="font17">is started, and switches files when necessary. First we need a way to detect when a file’s identity has changed. On Unix systems, a file’s identity is captured by two numbers: the device number of the device on which it resides, and an </span><span class="font17" style="font-style:italic;">i-number</span><span class="font17"> which is a per-device identification number. Both numbers can be obtained with the Perl </span><span class="font2">stat() </span><span class="font17">function:</span></p>
<div>
<p><span class="font9" style="font-weight:bold;">CODE LIBRARY</span></p>
</div><br clear="all">
<p><span class="font2">sub _devino {</span></p>
<p><span class="font0"><sup>logfile-process</sup> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="font2">my $f = shift;</span></p>
<p><span class="font2">my ($dev, $ino) = stat($f); return unless defined $dev; &quot;$dev;$ino&quot;;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">The next function takes an open filehandle, a filename, and a device and i-number pair and returns the next record from the filehandle. If the handle is at the end of its file, the function checks to see if the filename now refers to a different file.</span></p>
<h6><a name="bookmark335"></a><span class="font17">If so, the function opens the handle to the new file and continues; otherwise it waits and tries again:</span></h6>
<p><span class="font2">sub _next_record {</span></p>
<p><span class="font2">while (1) {</span></p>
<p><span class="font2">my (Sfh, Sfilename, Sdevino, $wait) = @_;</span></p>
<p><span class="font2">$wait = 1 unless defined Swait;</span></p>
<p><span class="font2">my Srec = &lt;Sfh&gt;;</span></p>
<p><span class="font2">return Srec if defined Srec;</span></p>
<p><span class="font2">if (_devino(Sfilename) eq Sdevino) {</span></p>
<ul style="list-style:none;"><li>
<p><span class="font2"># File has not moved</span></p></li></ul>
<p><span class="font2">sleep Swait;</span></p>
<p><span class="font2">} else {</span></p>
<ul style="list-style:none;"><li>
<p><span class="font2"># Sfilename refers to a different file</span></p></li></ul>
<p><span class="font2">open S_[0], &quot;&lt;&quot;, Sfilename or return;</span></p>
<p><span class="font2">S_[2] = _devino(S_[0]);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">Note that if </span><span class="font2">Sfh </span><span class="font17">and </span><span class="font2">Sdevino </span><span class="font17">are initially unspecified, </span><span class="font2">_next_record </span><span class="font17">will initialize them when it is first called.</span></p>
<p><span class="font17">The next function takes a filename and returns a stream of records from the</span></p>
<p><span class="font17">file, using </span><span class="font2">_next_record </span><span class="font17">to follow the file if it is replaced:</span></p>
<p><span class="font2">sub follow_file {</span></p>
<p><span class="font2">my Sfilename = shift;</span></p>
<p><span class="font2">my (Sdevino, Sfh);</span></p>
<p><span class="font2">tail(iterate_function(sub { _next_record(Sfh, Sfilename, Sdevino) }));</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">my Sraw_mail_log = follow_file('/service/qmail/log/main/current');</span></p>
<h6><a name="bookmark336"></a><span class="font17">Now we can write functions to transform this stream. For example, a quick-and-</span></h6>
<h6><span class="font17">dirty function to convert tai64n format timestamps to Unix epoch format is:</span></h6>
<p><span class="font2">sub tai64n_to_unix_time { my Srec = shift;</span></p>
<p><span class="font2">return [undef, Srec] unless Srec =- s/~\®([a-f0-9]{24})\s+//;</span></p>
<p><span class="font2">[hex(substr(S1, 8, 8)) + 10, Srec];</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">my Smail_log = &amp;transform(\&amp;tai64n_to_unix_time, Sraw_mail_log);</span></p>
<p><span class="font17">Next is the function to analyze the log. Its input is a stream of log records from which the timestamps have been preprocessed by </span><span class="font2">tai64n_to_unix_time()</span><span class="font17">, and its output is a stream of hashes, each of which represents a single email message. The function gets two auxiliary arguments, </span><span class="font2">$msg </span><span class="font17">and </span><span class="font2">$del</span><span class="font17">, which are hashes that represent the current state of the delivery queue. The keys of </span><span class="font2">$del </span><span class="font17">are delivery ID numbers; each value is the ID number of the message with which the delivery is associated. The keys of </span><span class="font2">$msg </span><span class="font17">are message ID numbers; the values are structures that record information about the corresponding message, including the time it was placed in the queue, the sender, the total number of delivery attempts, and other information. A complete message structure looks like this:</span></p>
<p><span class="font2">'id' =&gt; 706430, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Message id number</span></p>
<p><span class="font2">'bytes' =&gt; 2737, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Message length</span></p>
<p><span class="font2">'from' =&gt; '&lt;</span><a href="mailto:boehm5@email.com"><span class="font2">boehm5@email.com</span></a><span class="font2">&gt;', # Sender</span></p>
<p><span class="font2">'deliveries' =&gt; [190552], # List of associated delivery ids 'start' =&gt; 1043867776, # Start time</span></p>
<p><span class="font2">'end' =&gt; 1043867778, &nbsp;&nbsp;&nbsp;# End time</span></p>
<p><span class="font2">'success' =&gt; 1, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Number of successful delivery attempts</span></p>
<p><span class="font2">'failure' =&gt; 0, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Number of permanently failed delivery attempts</span></p>
<p><span class="font2">'deferral' =&gt; 0, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Number of temporarily failed delivery attempts</span></p>
<p><span class="font2">'total_deliveries' =&gt; 1,# Total number of delivery attempts</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">The stream produced by </span><span class="font2">digest_maillog() </span><span class="font17">is a sequence of these structures. To produce a structure, </span><span class="font2">digest_maillog() </span><span class="font17">scans the input records, adjusting </span><span class="font2">$msg </span><span class="font17">and </span><span class="font2">$del </span><span class="font17">as necessary, until it sees an </span><span class="font2">end msg </span><span class="font17">line; at that point it knows that it has complete information about a message, and it emits a single data item representing that message. If the input stream is exhausted, </span><span class="font2">digest_maillog() </span><span class="font17">terminates the output:</span></p>
<p><span class="font2">sub digest_maillog {</span></p>
<p><span class="font2">my ($s, $msg, $del) = @_;</span></p>
<p><span class="font2">for ($msg, $del) {$_={} unless $_ }</span></p>
<p><span class="font2">while ($s) {</span></p>
<p><span class="font2">my ($date, $rec) = @{drop($s)};</span></p>
<p><span class="font2">next unless defined $date;</span></p>
<p><span class="font2">if ($rec =- /“new msg (\d+)/) {</span></p>
<p><span class="font2">$msg-&gt;{$1} = {start =&gt; $date, id =&gt; $1,</span></p>
<p><span class="font2" style="font-style:italic;">6..</span><span class="font15"> REGEX STRUNG GENERATION </span><span class="font20">297</span></p>
<p><span class="font2">success =&gt; 0, failure =&gt; 0, deferral =&gt; 0};</span></p>
<p><span class="font2">} elsif ($rec =- /“info msg (\d+): bytes (\d+) from (&lt;[“\&gt;]*&gt;)/) { next unless exists $msg-&gt;{$1};</span></p>
<p><span class="font2">$msg-&gt;{$1}{bytes} = $2;</span></p>
<p><span class="font2">$msg-&gt;{$1}{from} = $3;</span></p>
<p><span class="font2">} elsif ($rec =- /“starting delivery (\d+): msg (\d+)/) { next unless exists $msg-&gt;{$2};</span></p>
<p><span class="font2">$del-&gt;{$1} = $2;</span></p>
<p><span class="font2">push @{$msg-&gt;{$2}{deliveries}}, $1;</span></p>
<p><span class="font2">} elsif ($rec =- /“delivery (\d+): (success|failure|deferral)/) { next unless exists $del-&gt;{$1} &amp;&amp;&nbsp;exists $msg-&gt;{$del-&gt;{$1}};</span></p>
<p><span class="font2">$msg-&gt;{$del-&gt;{$1}}{$2}++;</span></p>
<p><span class="font2">} elsif ($rec =- /“end msg (\d+)/) { next unless exists $msg-&gt;{$1};</span></p>
<p><span class="font2">my $m = delete $msg-&gt;{$1};</span></p>
<p><span class="font2">$m-&gt;{total_deliveries} = @{$m-&gt;{deliveries}};</span></p>
<p><span class="font2">for (@{$m-&gt;{deliveries}}) { delete $del-&gt;{$_} };</span></p>
<p><span class="font2">$m-&gt;{end} = $date;</span></p>
<p><span class="font2">return node($m, promise { digest_maillog($s, $msg, $del) });</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">return;</span></p>
<p><span class="font2">}</span></p>
<h6><a name="bookmark337"></a><span class="font17">Now we can generate reports by transforming the stream of message structures</span></h6>
<h6><span class="font17">into a stream of log records:</span></h6>
<p><span class="font2">use POSIX 'strftime';</span></p>
<p><span class="font2">sub format_digest {</span></p>
<p><span class="font2">my $h = shift;</span></p>
<p><span class="font2">join &quot;&nbsp;&quot;,</span></p>
<p><span class="font2">$h-&gt;{id},</span></p>
<p><span class="font2">strftime(&quot;%d/%b/%Y:%T&quot;, localtime($h-&gt;{start})),</span></p>
<p><span class="font2">strftime(&quot;%d/%b/%Y:%T&quot;, localtime($h-&gt;{end})),</span></p>
<p><span class="font2">$h-&gt;{from},</span></p>
<p><span class="font2">$h-&gt;{total_deliveries},</span></p>
<div>
<p><span class="font20">298 </span><span class="font15">CHAPTER 6</span></p>
</div><br clear="all">
<p><span class="font15">Infinite Streams</span></p>
<p><span class="font2">$h-&gt;{success}, $h-&gt;{failure}, $h-&gt;{deferral}</span></p>
<p><span class="font2">;</span></p>
<p><span class="font2">} show(&amp;transform(\&amp;format_digest, digest_maillog($mail_log)));</span></p>
<h6><a name="bookmark338"></a><span class="font17">Typical output looks like this:</span></h6>
<p><span class="font1">707045 28/Jan/2003:12:10:03 28/Jan/2003:12:10:03 &lt;</span><a href="mailto:Paulmc@371.net"><span class="font1">Paulmc@371.net</span></a><span class="font1">&gt; 1100</span></p>
<p><span class="font1">707292 28/Jan/2003:12:10:03 28/Jan/2003:12:10:06 &lt;</span><a href="mailto:Paulmc@371.net"><span class="font1">Paulmc@371.net</span></a><span class="font1">&gt; 1100</span></p>
<p><span class="font1">707046 28/Jan/2003:12:10:06 28/Jan/2003:12:10:07 &lt;</span><a href="mailto:Paulmc@371.net"><span class="font1">Paulmc@371.net</span></a><span class="font1">&gt; 4310</span></p>
<p><span class="font1">707293 28/Jan/2003:12:10:07 28/Jan/2003:12:10:07 &lt;</span><a href="mailto:guido@odiug.zope.com"><span class="font1">guido@odiug.zope.com</span></a><span class="font1">&gt; 1100</span></p>
<p><span class="font1">707670 28/Jan/2003:12:10:06 28/Jan/2003:12:10:08 &lt;spam-return-133409-@plover.com-@[]&gt; 2200</span></p>
<p><span class="font1">707045 28/Jan/2003:12:10:07 28/Jan/2003:12:10:11 &lt;</span><a href="mailto:guido@odiug.zope.com"><span class="font1">guido@odiug.zope.com</span></a><span class="font1">&gt; 1100</span></p>
<p><span class="font1">707294 28/Jan/2003:12:10:11 28/Jan/2003:12:10:11 &lt;</span><a href="mailto:guido@odiug.zope.com"><span class="font1">guido@odiug.zope.com</span></a><span class="font1">&gt; 1100</span></p>
<p><span class="font1">707047 28/Jan/2003:12:10:22 28/Jan/2003:12:10:23 &lt;ezmlm-return-10817-mjd-ezmlm=</span><a href="mailto:plover.com@list.cr.yp.to"><span class="font1">plover.com@list.cr.yp.to</span></a><span class="font1">&gt; 1100</span></p>
<p><span class="font1">707048 28/Jan/2003:12:11:02 28/Jan/2003:12:11:02</span></p>
<p><span class="font1">&lt;perl5-porters-return-71265-mjd-p5p2=</span><a href="mailto:plover.com@perl.org"><span class="font1">plover.com@perl.org</span></a><span class="font1">&gt; 1100</span></p>
<p><span class="font1">707503 24/Jan/2003:11:29:49 28/Jan/2003:12:11:35 &lt;perl-qotw-discuss-return-1200-@plover.com-@[]&gt; 388 322 2 64</span></p>
<p><span class="font1">707049 28/Jan/2003:12:11:35 28/Jan/2003:12:11:45 &lt;&gt;1100</span></p>
<p><span class="font1">707295 28/Jan/2003:12:11:41 28/Jan/2003:12:11:46 &lt;perl6-internals-return-14784-mjd-perl6-internals=</span><a href="mailto:plover.com@perl.org"><span class="font1">plover.com@perl.org</span></a><span class="font1">&gt; 1100</span></p>
<p><span class="font17">That was all a lot of work, and at this point it’s probably not clear why the stream method has any advantage over the more usual method of reading the file one record at a time, tracking the same data structures, and printing output records as we go, something like this:</span></p>
<p><span class="font2">while (&lt;LOG&gt;) {</span></p>
<ul style="list-style:none;"><li>
<p><span class="font2"># analyze current record</span></p></li>
<li>
<p><span class="font2"># update $msg and $del</span></p></li></ul>
<p><span class="font2">if (/“end msg/) {</span></p>
<p><span class="font2">print ...;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
<p><span class="font15">6.5 REGEX STRING GENERATION </span><span class="font20">299</span></p>
<p><span class="font17">One advantage was that we could encapsulate the follow-the-changing-file behavior inside its own stream. In a more conventionally structured program, the logic to track the moving file would probably have been threaded throughout the rest of the program. But we could also have accomplished this encapsulation by using a tied filehandle.</span></p>
<p><span class="font17">A bigger advantage of the stream approach comes if we want to reorder the output records. As written, the output stream contains message records in the order in which the messages were removed from the queue; that is, the output is sorted by the third field. Suppose we want to see the messages sorted by the second field, the time at which each message was first sent. In the preceding example output, notice the line for message 707503. Although the time at which it was removed from the queue (12:11:35 on 28 January) is in line with the surrounding messages, the time it was sent (11:29:49 on 24 January) is quite different. Most messages are delivered almost immediately, but this one took more than four days to complete. It represents a message that was sent to a mailing list with 324 subscribers. Two of the subscribers had full mailboxes, causing their mail systems to temporararily refuse new message for these subscribers. After four days, the mail system finally gave up and removed the message from the queue. Similarly, message 707670 arrived a second earlier but was delivered (to India) a second later than message 707293, which was delivered (locally) immediately after it arrived.</span></p>
<p><span class="font17">The ordinary procedural loop provides no good way to emit the log entries sorted in order by the date the messages were sent rather than by the date that delivery was completed. We can’t simply use Perl’s </span><span class="font2">sort() </span><span class="font17">function, since it works only on arrays, and we can’t put the records into an array, because they extend into the indefinite future.</span></p>
<p><span class="font17">But in the stream-based solution, we can order the records with the cutsorting method, using the prefabricated cutsorting function we have already. There’s an upper bound on how long messages can remain in the delivery queue; after four days any temporary delivery failures are demoted to permanent failures, and the message bounces. Suppose we have in hand the record for a message that was first queued on January 1 and that has been completely delivered. We can’t emit it immediately, since the next item out of the stream might be the record for a message that was first queued on December 28 whose delivery didn’t complete until January 2; this record should come out before the January 1 record because we’re trying to sort the output by the start date rather than the end date. But we can tell the cutsorter that it’s safe to emit the January 1 record once we see a January 5 record in the stream, because by January 5 any messages queued before January 1 will have been delivered one way or another:</span></p>
<p><span class="font2">my $QUEUE_LIFETIME =4; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Days</span></p>
<p><span class="font2">my $by_entry_date =</span></p>
<div>
<p><span class="font20">300</span></p>
</div><br clear="all">
<p><span class="font15">CHAPTER 6 Infinite Streams</span></p>
<p><span class="font2">cutsort($mail_log,</span></p>
<p><span class="font2">sub { $_[0]{start} &lt;&nbsp;= &gt;&nbsp;$_[1]{start} },</span></p>
<p><span class="font2">sub { $_[1]{end} - $_[0]{end} &gt;= $QUEUE_LIFETIME*86400 }, );</span></p>
<p><span class="font17">The first anonymous function argument to </span><span class="font2">cutsort() </span><span class="font17">says how to order the elements of the output; we want them ordered by </span><span class="font2">{start}</span><span class="font17">, the date each message was placed into the queue. The second anonymous function argument is the cutting function; this function says that it’s safe to emit a record </span><span class="font17" style="font-style:italic;">R</span><span class="font17"> with a certain start date if the next record in the stream was for a message that was completed at least </span><span class="font2">$QUEUE_LIFETIME </span><span class="font17">days after </span><span class="font17" style="font-style:italic;">R</span><span class="font17">; any record that was queued before </span><span class="font17" style="font-style:italic;">R</span><span class="font17"> would have to be removed less than </span><span class="font2">$QUEUE_LIFETIME </span><span class="font17">days later, and therefore there are no such records remaining in the stream. The output from </span><span class="font2">$by_entry_date </span><span class="font17">includes the records in the preceding sample, but in a different order:</span></p>
<p><span class="font1">707503 24/Jan/2003:11:29:49 28/Jan/2003:12:11:35 &lt;perl-qotw-discuss-return-1200-@plover.com-@[]&gt;</span></p>
<p><span class="font1">388 322 2 64</span></p>
<p><span class="font1">... (many records omitted) ...</span></p>
<p><span class="font1">707045 28/Jan/2003:12:10:03 28/Jan/2003:12:10:03 &lt;</span><a href="mailto:Paulmc@371.net"><span class="font1">Paulmc@371.net</span></a><span class="font1">&gt; 1100</span></p>
<p><span class="font1">707292 28/Jan/2003:12:10:03 28/Jan/2003:12:10:06 &lt;</span><a href="mailto:Paulmc@371.net"><span class="font1">Paulmc@371.net</span></a><span class="font1">&gt; 1100</span></p>
<p><span class="font1">707046 28/Jan/2003:12:10:06 28/Jan/2003:12:10:07 &lt;</span><a href="mailto:Paulmc@371.net"><span class="font1">Paulmc@371.net</span></a><span class="font1">&gt; 4310</span></p>
<p><span class="font1">707670 28/Jan/2003:12:10:06 28/Jan/2003:12:10:08 &lt;spam-return-133409-@plover.com-@[]&gt; 2200</span></p>
<p><span class="font1">707293 28/Jan/2003:12:10:07 28/Jan/2003:12:10:07 &lt;</span><a href="mailto:guido@odiug.zope.com"><span class="font1">guido@odiug.zope.com</span></a><span class="font1">&gt; 1100</span></p>
<p><span class="font1">707045 28/Jan/2003:12:10:07 28/Jan/2003:12:10:11 &lt;</span><a href="mailto:guido@odiug.zope.com"><span class="font1">guido@odiug.zope.com</span></a><span class="font1">&gt; 1100 ...</span></p>
<p><span class="font17">Even on a finite segment of the log file, cutsorting offers advantages over a regular sort. To use regular sort, the program must first read the entire log file into memory. With cutsorting, the program can begin producing output after only </span><span class="font2">$QUEUE_LIFETIME </span><span class="font17">days worth of records have been read in.</span></p>
<ul style="list-style:none;"><li>
<h5><a name="bookmark129"></a><span class="font18">6.6 THE NEWTON-RAPHSON METHOD</span></h5></li></ul>
<p><span class="font17">How does Perl’s </span><span class="font2">sqrt() </span><span class="font17">function work? It probably uses some variation of the </span><span class="font17" style="font-style:italic;">Newton-Raphson method.</span><span class="font17"> You may have spent a lot of time toiling in high school to solve equations; if so, rejoice, because the Newton-Raphson method is a general technique for solving any equation whatsoever.<a name="footnote26"></a><sup><a href="#bookmark339">26</a></sup><sup></sup></span></p>
<p><span class="font17">Suppose we’re trying to calculate </span><span class="font2">sqrt(2)</span><span class="font17">. This is a number, which, when multiplied by itself, will give 2. That is, it’s a number </span><span class="font17" style="font-style:italic;">x</span><span class="font17"> such that </span><span class="font17" style="font-style:italic;">x</span><span class="font15"><sup>2</sup> </span><span class="font3">= </span><span class="font17">2, or, equivalently, such that </span><span class="font17" style="font-style:italic;">x</span><span class="font15"><sup>2</sup> </span><span class="font3">— </span><span class="font17">2 </span><span class="font3">= </span><span class="font17">0.</span></p>
<p><span class="font17">If you plot the graph of </span><span class="font17" style="font-style:italic;">y = x</span><span class="font15"><sup>2</sup> </span><span class="font3">— </span><span class="font17">2 you get a parabola illustrated in Figure 6.5. Every point on the parabola has </span><span class="font17" style="font-style:italic;">x</span><span class="font15"><sup>2</sup> </span><span class="font3">— </span><span class="font17">2 </span><span class="font3">= </span><span class="font17" style="font-style:italic;">y</span><span class="font17">. Points on the </span><span class="font17" style="font-style:italic;">x</span><span class="font17">-axis have </span><span class="font17" style="font-style:italic;">y</span><span class="font3"> = </span><span class="font17">0. Where the parabola crosses the </span><span class="font17" style="font-style:italic;">x</span><span class="font17">-axis, we have </span><span class="font17" style="font-style:italic;">x</span><span class="font15"><sup>2</sup> </span><span class="font3">— </span><span class="font17">2 </span><span class="font3">= </span><span class="font17">0, and so the </span><span class="font17" style="font-style:italic;">x</span><span class="font17">-coordinate of the crossing point is equal to 2. This value is the solution, or </span><span class="font17" style="font-style:italic;">root,</span><span class="font17"> of the equation.</span></p><img src="HigherOrderPerl_files/HigherOrderPerl-50.jpg" alt="" style="width:305pt;height:321pt;">
<p><span class="font17">The Newton-Raphson method takes an approximation to the root and produces a closer approximation. We get the method started by guessing a root. Techniques for making a good first guess are an entire field of study themselves, but for the parabola in Figure 6.5, any guess except 0 will work. To show that the initial guess doesn’t have to be particularly good, we’ll guess that ^/2 </span><span class="font3">= </span><span class="font17">2. The method works by observing that a smooth curve, such as the parabola, can be approximated by a straight line, and constructs the tangent line to the curve at the current guess, which is </span><span class="font17" style="font-style:italic;">x =</span><span class="font17"> 2. This is the straight line that touches the curve at that point, and that proceeds in the same direction that the curve was going. The curve will veer away from the straight line (because it’s a curve) and eventually intersect the </span><span class="font17" style="font-style:italic;">x</span><span class="font17">-axis in a different place than the straight line does. But if the curve is reasonably well-behaved, it won’t veer away too much, so the line’s intersection point will be close to the curve’s intersection point, and closer than the original guess.</span></p>
<p><span class="font17">The tangent line in this case happens to be the line </span><span class="font17" style="font-style:italic;">y = 4x —</span><span class="font17"> 6. This line intersects the </span><span class="font17" style="font-style:italic;">x</span><span class="font17">-axis at </span><span class="font17" style="font-style:italic;">x =</span><span class="font17"> 1.5, as shown in Figure 6.6. This value, 1.5, is our new guess for the value of 2. It is indeed more accurate than the original guess.</span></p>
<p><span class="font17">To get a better approximation, we repeat the process. The tangent line to the parabola at the point (1.5, 0.25) has the equation</span><span class="font17" style="font-style:italic;">y = 3x —</span><span class="font17"> 4.25. This line intersects the </span><span class="font17" style="font-style:italic;">x</span><span class="font17">-axis at 1.41667, which is correct to two decimal places.</span></p>
<p><span class="font17">Now we’ll see how these calculations were done. Let’s suppose our initial guess is </span><span class="font17" style="font-style:italic;">g,</span><span class="font17"> so we want to construct the tangent at (</span><span class="font17" style="font-style:italic;">g</span><span class="font17">, </span><span class="font17" style="font-style:italic;">g</span><span class="font17"><sup>2</sup> </span><span class="font3">— </span><span class="font17">2). If a line has slope </span><span class="font17" style="font-style:italic;">m</span><span class="font17"> and passes through the point </span><span class="font17" style="font-style:italic;">(p, q</span><span class="font17">), its equation is </span><span class="font17" style="font-style:italic;">y — q = m(x — p). </span><span class="font17">We’ll see later how to figure out the slope of the tangent line without calculus, but in the meantime calculus tells us that the slope of the tangent line to the parabola at the point ( </span><span class="font17" style="font-style:italic;">g</span><span class="font17">, </span><span class="font17" style="font-style:italic;">g</span><span class="font17"><sup>2</sup> </span><span class="font3">— </span><span class="font17">2) is 2</span><span class="font17" style="font-style:italic;">g</span><span class="font17">, and therefore that the tangent line itself has the equation </span><span class="font17" style="font-style:italic;">(y —</span><span class="font17"> (</span><span class="font17" style="font-style:italic;">g<sup>1</sup> —</span><span class="font17"> 2)) </span><span class="font3">= </span><span class="font17">2</span><span class="font17" style="font-style:italic;">g</span><span class="font17">(</span><span class="font17" style="font-style:italic;">x</span><span class="font3"> — </span><span class="font17" style="font-style:italic;">g</span><span class="font17">). We want to find the value of </span><span class="font17" style="font-style:italic;">x</span><span class="font17"> for which this line intersects the </span><span class="font17" style="font-style:italic;">x</span><span class="font17">-axis; that is, we want to find the value of </span><span class="font17" style="font-style:italic;">x</span><span class="font17"> for which </span><span class="font17" style="font-style:italic;">y</span><span class="font17"> is 0. This gives us the equation (0 </span><span class="font3">— </span><span class="font17">(</span><span class="font17" style="font-style:italic;">g</span><span class="font17"><sup>2</sup> </span><span class="font3">— </span><span class="font17">2)) </span><span class="font3">= </span><span class="font17">2</span><span class="font17" style="font-style:italic;">g</span><span class="font17">(</span><span class="font17" style="font-style:italic;">x</span><span class="font3"> — </span><span class="font17" style="font-style:italic;">g</span><span class="font17">). Solving for </span><span class="font17" style="font-style:italic;">x</span><span class="font17"> yields </span><span class="font17" style="font-style:italic;">x = g —</span><span class="font17"> (</span><span class="font17" style="font-style:italic;">g<sup>1</sup> —</span><span class="font17"> 2)/2</span><span class="font17" style="font-style:italic;">g</span><span class="font3"> = </span><span class="font17">(</span><span class="font17" style="font-style:italic;">g<sup>1</sup></span><span class="font3"> + </span><span class="font17">2)/2</span><span class="font17" style="font-style:italic;">g</span><span class="font17">. That is, if our initial guess is </span><span class="font17" style="font-style:italic;">g</span><span class="font17">, a better guess will be (</span><span class="font17" style="font-style:italic;">g<sup>1</sup></span><span class="font3"> + </span><span class="font17">2)/2</span><span class="font17" style="font-style:italic;">g</span><span class="font17">. A function that computes </span><span class="font3">^</span><span class="font17">2 is therefore:</span></p>
<div>
<p><span class="font9" style="font-weight:bold;">CODE LIBRARY</span></p>
</div><br clear="all">
<div>
<p><span class="font0">Newton.pm</span></p>
</div><br clear="all">
<p><span class="font2">sub sqrt2 {</span></p>
<p><span class="font2">my $g = 2; # Initial guess</span></p>
<p><span class="font2">until (close_enough($g*$g, 2)) { $g = ($g*$g + 2) / (2*$g);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">$g;</span></p>
<p><span class="font2">}</span></p><img src="HigherOrderPerl_files/HigherOrderPerl-51.jpg" alt="" style="width:305pt;height:321pt;">
<p><span class="font2">sub close_enough {</span></p>
<p><span class="font2">my ($a, $b) = @_;</span></p>
<p><span class="font2">return abs($a - $b) &lt;&nbsp;1e-12; }</span></p>
<p><span class="font17">This code rapidly produces a good approximation to </span><span class="font17" style="font-style:italic;">^/2,</span><span class="font17"> returning 1.414213562373095 after only five iterations. (This is correct to 15 decimal places.) To calculate the square root of a different number, we do the mathematics the same way, this time replacing the 2 with a variable </span><span class="font17" style="font-style:italic;">n;</span><span class="font17"> the result is:</span></p>
<p><span class="font2">sub sqrtn {</span></p>
<p><span class="font2">my $n = shift;</span></p>
<p><span class="font2">my $g = $n; &nbsp;&nbsp;# Initial guess</span></p>
<p><span class="font2">until (close_enough($g*$g, $n)) {</span></p>
<p><span class="font2">$g = ($g*$g + $n) / (2*$g);</span></p>
<table border="1">
<tr><td style="vertical-align:bottom;">
<p><span class="font20">304</span></p></td><td style="vertical-align:bottom;">
<p><span class="font15" style="font-variant:small-caps;">chapter </span><span class="font2" style="font-style:italic;">6</span><span class="font15"> Infinite Streams</span></p></td></tr>
</table>
<p><span class="font2">}</span></p>
<p><span class="font2">$g;</span></p>
<p><span class="font2">}</span></p>
<ul style="list-style:none;"><li>
<h5><a name="bookmark130"></a><span class="font19">6.6.1 Approximation Streams</span></h5></li></ul>
<p><span class="font17">But what does all this have to do with streams? One of the most useful and interesting uses for streams is to represent the results of an approximate calculation. Consider the following stream definition, which delivers the same sequence of approximations that the </span><span class="font2">sqrtn() </span><span class="font17">function would compute:</span></p>
<p><span class="font2">use Stream 'iterate_function';</span></p>
<p><span class="font2">sub sqrt_stream {</span></p>
<p><span class="font2">my $n = shift;</span></p>
<p><span class="font2">iterate_function (sub { my $g = shift;</span></p>
<p><span class="font2">($g*$g + $n) / (2*$g);</span></p>
<p><span class="font2">},</span></p>
<p><span class="font2">$n);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">1;</span></p>
<p><span class="font17">We saw </span><span class="font2">iterate_function() </span><span class="font17">back in Section 6.2.2. At the time, I promised a simpler and more interesting version. Here it is:</span></p>
<p><span class="font2">sub iterate_function {</span></p>
<p><span class="font2">my ($f, $x) = @_;</span></p>
<p><span class="font2">my $s;</span></p>
<p><span class="font2">$s = node($x, promise { &amp;transform($f, $s) });</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">Recall that </span><span class="font2">iterate_function($f, $x) </span><span class="font17">produces the stream </span><span class="font2">$x</span><span class="font17">, </span><span class="font2">$f-&gt;($x), $f-&gt;($f-&gt;($x))</span><span class="font17">,</span><span class="font2">... </span><span class="font17">. The preceding recursive version relies on the observation that the stream begins with </span><span class="font2">$x</span><span class="font17">, and the rest of the stream can be gotten by applying the function </span><span class="font2">$f </span><span class="font17">to each element in turn. The </span><span class="font2">&amp;&nbsp;</span><span class="font17">on the call to </span><span class="font2">transform() </span><span class="font17">disables </span><span class="font2">transform()</span><span class="font17">’s prototype-derived special syntax. Without it, we’d have to write:</span></p>
<p><span class="font2">transform { $f-&gt;($_[0]) } $s</span></p>
<p><span class="font17">which would introduce an unnecessary additional function call.</span></p>
<p><span class="font17" style="font-style:italic;">6.6</span><span class="font15"> THE N EWT O N - R A P H S O N M E T H O D </span><span class="font20">305</span></p>
<ul style="list-style:none;"><li>
<h5><a name="bookmark131"></a><span class="font19">6.6.2 Derivatives</span></h5></li></ul>
<p><span class="font17">The problem with the Newton-Raphson method as I described it in the previous section is that it requires someone to calculate the slope of the tangent line to the curve at any point. When we needed the slope at any point of the parabola </span><span class="font17" style="font-style:italic;">g<sup>1</sup> —</span><span class="font17"> 2, I magically pulled out the formula </span><span class="font17" style="font-style:italic;">2g.</span><span class="font17"> The function </span><span class="font17" style="font-style:italic;">2g</span><span class="font17"> that describes the slope at the tangent line at any point of the parabola </span><span class="font17" style="font-style:italic;">g<sup>2</sup> —</span><span class="font17"> 2 is called the </span><span class="font17" style="font-style:italic;">derivative function</span><span class="font17"> of the parabola; in general, for any function, the related function that describes the slope is called the </span><span class="font17" style="font-style:italic;">derivative.</span><span class="font17"> Algebraic computation of derivative functions is the subject of the branch of mathematics called </span><span class="font17" style="font-style:italic;">differential calculus.</span></p>
<p><span class="font17">Fortunately, though, you don’t need to know differential calculus to apply the Newton-Raphson method. There’s an easy way to compute the slope of a curve at any point. What we really want is the slope of the tangent line at a certain point. But if we pick two points that are close to the point we want, and compute the slope of the line between them, it won’t be too different from the slope of the actual tangent line.</span></p>
<p><span class="font17">For example, suppose we want to find the slope of the parabola </span><span class="font17" style="font-style:italic;">y = x<sup>2</sup> —</span><span class="font17"> 2 at the point (2, 2). We’ll pick two points close to that and find the slope of the line that passes through them. Say we choose (2.001, 2.004001) and (1.999, 1.996001). The slope of the line through two points is the </span><span class="font17" style="font-style:italic;">y</span><span class="font17"> difference divided by the </span><span class="font17" style="font-style:italic;">x</span><span class="font17"> difference; in this case, 0.008/0.002 </span><span class="font3">= </span><span class="font17">4. And this does match the</span></p>
<div>
<p><span class="font17">answer from calculus exactly. It won’t always be an exact match, but it will always be close, because differential calculus uses exactly the same strategy, augmented with algebraic techniques to analyze what happens to the slope as the two points get closer and closer together.</span></p>
<p><span class="font17">It’s not hard to write code that, given a function, calculates the slope at any</span></p>
</div><br clear="all">
<div>
<p><span class="font17">point:</span></p>
</div><br clear="all">
<p><span class="font2">sub slope {</span></p>
<p><span class="font2">my ($f, $x) = @_;</span></p>
<p><span class="font2">my $e = 0.00000095367431640625;</span></p>
<p><span class="font2">($f-&gt;($x+$e) - $f-&gt;($x-$e)) / (2*$e);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">The value of </span><span class="font2">$e </span><span class="font17">that I chose is exactly 2</span><span class="font2"><sup>—</sup></span><span class="font17"><sup>20</sup>; I picked it because it was the power of 2 closest to one one-millionth. Powers of 2 work better than powers of 10 because they can be represented exactly; with a power of 10 you’re introducing round-off error before you even begin. Smaller values of </span><span class="font2">$e </span><span class="font17">will give us more accurate answers, up to a point. The computer’s floating-point numbers have only a fixed amount of accuracy, and as the numbers we deal with get smaller,</span></p>
<p><span class="font17">the round-off error will tend to dominate the answer. For the function </span><span class="font2">$f = sub { $_[0] * $_[0] - 2 } </span><span class="font17">and </span><span class="font2">$x = 2 </span><span class="font17">our </span><span class="font2">slope() </span><span class="font17">function produces the correct answer (4) for values of </span><span class="font2">$e </span><span class="font17">down to 2</span><span class="font2"><sup>-</sup></span><span class="font17"><sup>52</sup>; at that point the round-off error takes over, and when </span><span class="font2">$e </span><span class="font17">is 2</span><span class="font2"><sup>-</sup></span><span class="font17"><sup>54</sup>, the calculated slope is 0 instead of 4. It’s not hard to see what has happened: </span><span class="font2">$e </span><span class="font17">has become so small that when it’s added to or subtracted from </span><span class="font2">$x</span><span class="font17">, and the result is rounded off to the computer’s precision, the </span><span class="font2">$e </span><span class="font17">disappears entirely and we’re left with exactly 2. So the calculated values of </span><span class="font2">$f-&gt;($x+$e) </span><span class="font17">and </span><span class="font2">$f-&gt;($x-$e) </span><span class="font17">are both exactly the same, and the </span><span class="font2">slope() </span><span class="font17">function returns 0.</span></p>
<p><span class="font17">Once we have this </span><span class="font2">slope() </span><span class="font17">function, it’s easy to write a generic equation solver using the Newton-Raphson method:</span></p>
<p><span class="font2"># Return a stream of numbers $x that make $f-&gt;($x) close to 0 sub solve { my $f = shift;</span></p>
<p><span class="font2">my $guess = shift || 1;</span></p>
<p><span class="font2">iterate_function(sub { my $g = shift;</span></p>
<p><span class="font2">$g - $f-&gt;($g)/slope($f, $g);</span></p>
<p><span class="font2">}, $guess);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">Now if we want to find ^/2, we do:</span></p>
<p><span class="font2">my $sqrt2 = solve(sub { $_[0] * $_[0] - 2 });</span></p>
<p><span class="font2">{ local $&quot; = &quot;\n&quot;; show($sqrt2, 10);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">This produces the following output:</span></p>
<p><span class="font2">1</span></p>
<p><span class="font2">1.5</span></p>
<p><span class="font2">1.41666666666667</span></p>
<p><span class="font2">1.41421568627464</span></p>
<p><span class="font2">1.41421356237469</span></p>
<p><span class="font2">1.4142135623731</span></p>
<p><span class="font2">1.41421356237309</span></p>
<p><span class="font2">1.4142135623731</span></p>
<p><span class="font2">1.41421356237309</span></p>
<p><span class="font2">1.4142135623731</span></p>
<p><span class="font17">At this point the round-off error in the calculations has caused the values to alternate between 1.41421356237309 and 1.4142135623731.</span><span class="font13">6 </span><span class="font17">The correct value is 1.41421356237309504880, so our little bit of code has produced an answer that is accurate to better than four parts per quadrillion.</span></p>
<p><span class="font17">If we want more accurate answers, we can use the standard Perl multiprecision floating-point library, </span><span class="font2">Math::BigFloat</span><span class="font17">. Doing so requires only a small change to the code:</span></p>
<p><span class="font2" style="font-weight:bold;">use Math::BigFloat;</span></p>
<p><span class="font2">my $sqrt2 = solve(sub { $_[0] * $_[0] - 2 },</span></p>
<p><span class="font2" style="font-weight:bold;">Math::BigFloat-&gt;new(2));</span></p>
<p><span class="font17">Using </span><span class="font2">Math::BigFloat </span><span class="font17">produces extremely accurate answers, but after only a few iterations, the numbers start coming out more and more slowly.</span></p>
<p><span class="font17">Because </span><span class="font2">Math::BigFloat </span><span class="font17" style="font-style:italic;">never</span><span class="font17"> rounds off, every multiplication of two numbers produces a number twice as long. The results increase in size exponentially, and so do the calculation times. The third iteration produces 1.41666666666666666666666666666666666666667, which is an extremely precise but rather inaccurate answer. There’s no point in retaining or calculating with all the 6’s at the end, because we know they’re wrong, but </span><span class="font2">Math::BigFloat </span><span class="font17">does it anyway, and the fourth iteration produces a result that has five accurate digits followed by 80 inaccurate digits.</span></p>
<p><span class="font17">One solution to this is to do more mathematics to produce an estimate of how many digits are accurate, and to round off the approximations to leave only the correct digits for later calculations. But this requires sophisticated technique. A simple solution is to improve the initial guess. Since Perl has a built-in square root function that is fast, we’ll use it to generate our initial guess, which will already be accurate to about thirteen decimal places. Any work done by </span><span class="font2">Math::BigFloat </span><span class="font17">afterwards will only improve this:</span></p>
<p><span class="font2">my $sqrt2 = solve(sub { $_[0] * $_[0] - 2 },</span></p>
<p><span class="font2" style="font-weight:bold;">Math::BigFloat-&gt;new(sqrt(2)));</span></p>
<p><span class="font17">The approximations still double in size at every step, and each one still takes twice as long as the previous one, but many more of the digits are correct, so the extra time spent isn’t being wasted as it was before.</span></p>
<ul style="list-style:none;"><li>
<p class="font15">6 Actually they’re alternating between 1.414213562373094923430016933708 and 1.414213562373095145474621858739, but who’s counting?</p></li></ul>
<p><span class="font17">You may wait twice as long to get the answer, but you get an answer that has twice as many correct digits. The second element of the stream is 1.</span><span class="font17" style="font-weight:bold;">4142135623730950488016887242</span><span class="font17">183652153338124600441037, of which the first 28 digits after the decimal point are correct. The next element has 58 correct digits. In general, the Newton-Raphson method will double the number of correct digits at every step, so if you start with a reasonably good guess, you can get extremely accurate results very quickly.</span></p>
<ul style="list-style:none;"><li>
<h5><a name="bookmark132"></a><span class="font19">6.6.3 The Tortoise and the Hare</span></h5></li></ul>
<p><span class="font17">The </span><span class="font2">$sqrt2 </span><span class="font17">stream we built in the previous section is infinite, but after a certain point the approximations it produces won’t get any more accurate because they’ll be absorbed by the inherent error in the computer’s floating-point numbers. The output of </span><span class="font2">$sqrt2 </span><span class="font17">was:</span></p>
<p><span class="font2">1</span></p>
<p><span class="font2">1.5</span></p>
<p><span class="font2">1.41666666666667</span></p>
<p><span class="font2">1.41421568627464</span></p>
<p><span class="font2">1.41421356237469</span></p>
<p><span class="font2">1.4142135623731</span></p>
<p><span class="font2">1.41421356237309</span></p>
<p><span class="font2">1.4142135623731</span></p>
<p><span class="font2">1.41421356237309</span></p>
<p><span class="font2">$sqrt2 </span><span class="font17">is stuck in a loop. A process that was trying to use </span><span class="font2">$sqrt2 </span><span class="font17">might decide that it needs more than 13 places of precision, and might search further and further down the stream, hoping for a better approximation that never arrives. It would be better if we could detect the loop in </span><span class="font2">$sqrt2 </span><span class="font17">and cut off its tail.</span></p>
<p><span class="font17">The obvious way to detect a loop is to record every number that comes out of the stream and compare it to the items that came out before; if there is a repeat, then cut off the tail:</span></p>
<p><span class="font2">sub cut_loops { my $s = shift; return unless $s; my @previous_values = @_; for (@previous_values) { if (head($s) == $_) { return;</span></p>
<p><span class="font15">6.&lt;5 THE NEWTON-RAPHSON M E T H O D </span><span class="font20">309</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">node(head(Ss), promise { cut_loops(tail(Ss), head(Ss), @previous_values) });</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">cut_loops(Ss) </span><span class="font17">constructs a stream that is the same as </span><span class="font2">Ss</span><span class="font17">, but that stops at the point where the first loop begins. Unfortunately, it does this with a large time and memory cost. If the argument stream doesn’t loop, the </span><span class="font2">@previous_values </span><span class="font17">array will get bigger and bigger and take longer and longer to search. There is a better method, sometimes called the </span><span class="font17" style="font-style:italic;">tortoise and hare algorithm.</span></p>
<p><span class="font17">Imagine that each value in the stream is connected to the next value by an arrow. If the values form a loop, the arrows will too. Now imagine that a tortoise and a hare both start at the first value and proceed along the arrows. The tortoise crawls from one value to the next, following the arrows, but the hare travels twice as fast, leaping over every other value. If there is a loop, the hare will speed around the loop and catch up to the tortoise from behind. When this happens, you know that the hare has gone all the way around the loop once.<a name="footnote27"></a><sup><a href="#bookmark340">27</a></sup><sup></sup> If there is no loop, the hare will vanish into the distance and will never meet the tortoise again:</span></p>
<p><span class="font2">sub cut_loops {</span></p>
<p><span class="font2">my (Stortoise, Share) = @_;</span></p>
<p><span class="font2">return unless Stortoise;</span></p>
<ul style="list-style:none;"><li>
<p><span class="font2"># The hare and tortoise start at the same place</span></p></li></ul>
<p><span class="font2">Share = Stortoise unless defined Share;</span></p>
<ul style="list-style:none;"><li>
<p><span class="font2"># The hare moves two steps every time the tortoise moves one Share = tail(tail(Share));</span></p></li>
<li>
<p><span class="font2"># If the hare and the tortoise are in the same place, cut the loop return if head(Stortoise) == head(Share);</span></p></li></ul>
<p><span class="font2">return node(head(Stortoise),</span></p>
<p><span class="font2">promise { cut_loops(tail(Stortoise), Share) });</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">show(cut_loops(Ssqrt2)) </span><span class="font17">now generates:</span></p>
<p><span class="font2">1</span></p>
<p><span class="font2">1.5</span></p>
<p><span class="font2">1.41666666666667</span></p>
<p><span class="font2">1.41421568627464</span></p>
<p><span class="font2">1.41421356237469</span></p>
<p><span class="font2">1.4142135623731</span></p>
<p><span class="font17">and nothing else.</span></p>
<p><span class="font17">Notice that the entire loop didn’t appear in the output. The loop consists of:</span></p>
<p><span class="font2">1.4142135623731</span></p>
<p><span class="font2">1.41421356237309</span></p>
<p><span class="font17">but we saw only the first of these. The tortoise and hare algorithm guarantees to cut the stream somewhere in the loop, </span><span class="font17" style="font-style:italic;">before</span><span class="font17"> the values start to repeat; it might therefore place the cut sometime before all of the values in the loop have appeared. Sometimes this is acceptable behavior. If not, send the hare around the loop an extra time:</span></p>
<p><span class="font2">sub cut_loops2 {</span></p>
<p><span class="font2" style="font-weight:bold;">my (Stortoise, Share, Sn) = @_;</span></p>
<p><span class="font2">return unless Stortoise;</span></p>
<p><span class="font2">Share = Stortoise unless defined Share;</span></p>
<p><span class="font2">Share = tail(tail(Share));</span></p>
<p><span class="font2">return if head(Stortoise) == head(Share)</span></p>
<p><span class="font2" style="font-weight:bold;">&amp;&amp; Sn++;</span></p>
<p><span class="font2">return node(head(Stortoise),</span></p>
<p><span class="font2">promise { cut_loops(tail(Stortoise), Share, Sn) }); }</span></p>
<ul style="list-style:none;"><li>
<h5><a name="bookmark133"></a><span class="font19">6.6.4 Finance</span></h5></li></ul>
<p><span class="font17">The square root of two is beloved by the mathematics geeks, but normal humans are motivated by other things, such as money. Let’s suppose I am paying off a loan, say a mortgage. Initially I owe </span><span class="font17" style="font-style:italic;">P</span><span class="font17"> dollars. </span><span class="font17" style="font-style:italic;">(P</span><span class="font17"> is for “principal”, which is the finance geeks’ jargon word for it.) Each month, I pay </span><span class="font17" style="font-style:italic;">pmt</span><span class="font17"> dollars, of which some goes to pay the interest and some goes to reduce the principal. When the principal reaches zero, I own the house.</span></p>
<p><span class="font4">I</span></p>
<p><span class="font17">For concreteness, let’s say that the principal is $100,000, the interest rate is 6% per year, or 0.5% per month, and the monthly payment is $1,000. At the end of the first month, I’ve racked up $500 in interest, so my $1,000 payment reduces the principal to $99,500. At the end of the second month, the interest is a little lower, only $99, 500 </span><span class="font3">X </span><span class="font17">0.5% </span><span class="font3">= </span><span class="font17">$495.50, so my payment reduces the principal by $504.50, to $98,995.50. Each month, my progress is a little faster. How long will it take me to pay off the mortgage at this rate?</span></p>
<p><span class="font17">First let’s figure out how to calculate the amount owed at the end of any month. The first two months are easy:</span></p>
<p><span class="font17">Month Amount owed</span></p>
<p><span class="font17">0 </span><span class="font17" style="font-style:italic;">P</span></p>
<p><span class="font17">In the first month, we pay interest on the principal in the amount of </span><span class="font17" style="font-style:italic;">P X</span><span class="font17"> .005, bringing the total to </span><span class="font17" style="font-style:italic;">P X</span><span class="font17"> 1.005. But we also make a payment of</span><span class="font17" style="font-style:italic;">pmt</span><span class="font17"> dollars, so that at the end of month 1, the amount owed is:</span></p>
<ul style="list-style:none;"><li>
<p><span class="font17">1 &nbsp;&nbsp;&nbsp;&nbsp;</span><span class="font17" style="font-style:italic;">P</span><span class="font3"> • </span><span class="font17">1.005 </span><span class="font3">— </span><span class="font17" style="font-style:italic;">pmt</span></p></li></ul>
<p><span class="font17">The next month, we pay interest on the amount still owed. That amount is </span><span class="font17" style="font-style:italic;">P X</span><span class="font17"> 1.005 </span><span class="font3">— </span><span class="font17" style="font-style:italic;">pmt</span><span class="font17">, so the interest is (</span><span class="font17" style="font-style:italic;">P</span><span class="font3"> X </span><span class="font17">1.005 </span><span class="font3">— </span><span class="font17" style="font-style:italic;">pmt) X</span><span class="font17"> .005, and the total is (</span><span class="font17" style="font-style:italic;">P</span><span class="font3"> X </span><span class="font17">1.005 </span><span class="font3">— </span><span class="font17" style="font-style:italic;">pmt</span><span class="font17">) </span><span class="font3">+ </span><span class="font17">(</span><span class="font17" style="font-style:italic;">P</span><span class="font3"> X </span><span class="font17">1.005 </span><span class="font3">— </span><span class="font17" style="font-style:italic;">pmt</span><span class="font17">) </span><span class="font3">X </span><span class="font17">0.005, or (</span><span class="font17" style="font-style:italic;">P</span><span class="font3"> X </span><span class="font17">1.005</span><span class="font15">2 </span><span class="font17" style="font-style:italic;">—pmt X</span><span class="font17"> 1.005).</span></p>
<p><span class="font17">Then we make another payment, bringing the total down to:</span></p>
<ul style="list-style:none;"><li>
<p><span class="font17">2 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="font17" style="font-style:italic;">P •</span><span class="font17"> (1.005)</span><span class="font15">2 </span><span class="font3">— </span><span class="font17" style="font-style:italic;">pmt •</span><span class="font17"> (1 </span><span class="font3">+ </span><span class="font17">1.005)</span></p></li></ul>
<p><span class="font17">The pattern continues in the third month:</span></p>
<ul style="list-style:none;"><li>
<p><span class="font17">3 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="font17" style="font-style:italic;">P •</span><span class="font17"> (1.005)</span><span class="font15">3 </span><span class="font3">— </span><span class="font17" style="font-style:italic;">pmt •</span><span class="font17"> (1 </span><span class="font3">+ </span><span class="font17">1.005 </span><span class="font3">+ </span><span class="font17">(1.005)</span><span class="font15">2</span><span class="font17">)</span></p></li>
<li>
<p><span class="font17">4 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="font17" style="font-style:italic;">P •</span><span class="font17"> (1.005)<sup>4</sup> </span><span class="font3">— </span><span class="font17" style="font-style:italic;">pmt •</span><span class="font17"> (1 </span><span class="font3">+ </span><span class="font17">1.005 </span><span class="font3">+ </span><span class="font17">(1.005)</span><span class="font15">2 </span><span class="font3">+ </span><span class="font17">(1.005)<sup>3</sup>)</span></p></li></ul>
<p><span class="font17">This pattern is simple enough that we can program it without much trouble:</span></p>
<p><span class="font2">sub owed {</span></p>
<p><span class="font2">my ($P, $N, $pmt, $i) = @_;</span></p>
<p><span class="font2">my $payment_factor = 0;</span></p>
<p><span class="font2">for (0 .. $N-1) {</span></p>
<p><span class="font2">$payment_factor += (1+$i) ** $_;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">return $P * (1+$i)**$N - $pmt * $payment_factor;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">It requires a little high school algebra to abbreviate the formula.<a name="footnote28"></a><sup><a href="#bookmark341">28</a></sup><sup></sup> 1 </span><span class="font3">+ </span><span class="font17">1.005 </span><span class="font3">+ </span><span class="font17">(1.005)<sup>2</sup> </span><span class="font3">+ • • • + </span><span class="font17">1.005</span><span class="font17" style="font-style:italic;"><sup>N</sup></span><span class="font2"><sup>-</sup></span><span class="font17"><sup>1</sup> is equal to (1.005</span><span class="font17" style="font-style:italic;"><sup>N</sup></span><span class="font3"> — </span><span class="font17">1)/.005, which is quicker to calculate:</span></p>
<table border="1">
<tr><td></td><td>
<ul style="list-style:none;"><li>
<p><span class="font17">4 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="font17" style="font-style:italic;">P •</span><span class="font17"> (1.005)<sup>4</sup> </span><span class="font3">— </span><span class="font17" style="font-style:italic;">pmt •</span><span class="font17"> ((1.005)<sup>4</sup> </span><span class="font3">— </span><span class="font17">1)/0.005</span></p></li>
<li>
<p><span class="font17">5 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="font17" style="font-style:italic;">P •</span><span class="font17"> (1.005)<sup>5</sup> </span><span class="font3">— </span><span class="font17" style="font-style:italic;">pmt •</span><span class="font17"> ((1.005)<sup>5</sup> </span><span class="font3">— </span><span class="font17">1)/0.005</span></p></li>
<li>
<p><span class="font17">6 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="font17" style="font-style:italic;">P •</span><span class="font17"> (1.005)</span><span class="font15">6 </span><span class="font3">— </span><span class="font17" style="font-style:italic;">pmt •</span><span class="font17"> ((1.005)<sup>6</sup> </span><span class="font3">— </span><span class="font17">1)/0.005</span></p></li></ul>
<p><span class="font17">so the code gets simpler:</span></p></td></tr>
<tr><td>
<p><span class="font9" style="font-weight:bold;">CODE LIBRARY</span></p></td><td>
<p><span class="font2">sub owed {</span></p></td></tr>
<tr><td>
<p><span class="font0">owed</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">my (SP, SN, Spmt, Si) = @_;</span></p>
<p><span class="font2">return SP * (1+Si)**SN - Spmt * ((1+Si)**SN - 1) / Si;</span></p></td></tr>
</table>
<p><span class="font2">}</span></p>
<p><span class="font17">Now, the question that everyone with a mortgage wants answered: How long before my house is paid off ?</span></p>
<p><span class="font17">We could try solving the equation </span><span class="font17" style="font-style:italic;">P •</span><span class="font17"> (1 </span><span class="font3">+ </span><span class="font17" style="font-style:italic;">i</span><span class="font17">)</span><span class="font17" style="font-style:italic;"><sup>N</sup></span><span class="font3"> — </span><span class="font17" style="font-style:italic;">pmt • </span><span class="font14" style="text-decoration:line-through;"><sup>(1+</sup>2</span><span class="font17"> <sup>1</sup> for </span><span class="font17" style="font-style:italic;">N</span><span class="font17">, but doing that requires a lot of mathematical sophistication, much more than coming up with the formula in the first place.<a name="footnote29"></a><sup><a href="#bookmark342">29</a></sup><sup></sup> It’s much easier to hand the </span><span class="font2">owed() </span><span class="font17">function to </span><span class="font2">solve() </span><span class="font17">and let it find the answer:</span></p>
<p><span class="font2">sub owed_after_n_months { my SN = shift;</span></p>
<p><span class="font2">owed(100_000, SN, 1_000, 0.005);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">my Sstream = cut_loops(solve(\&amp;owed_after_n_months));</span></p>
<p><span class="font2">my Sn;</span></p>
<p><span class="font2">Sn = drop(Sstream) while Sstream;</span></p>
<p><span class="font2">print &quot;You will be paid off in only Sn months!\n&quot;;</span></p>
<p><span class="font17">According to this, we’ll be paid off in 138.9757 months, or eleven and a half years. This is plausible, since if there were no interest we would clearly have</span></p>
<p><span class="font2" style="font-style:italic;">6.7</span><span class="font15"> POWER SERIES </span><span class="font20">313</span></p>
<p><span class="font17">the loan paid off in exactly 100 months. Indeed, after the 138th payment, the principal remains at $970.93, and a partial payment the following month finishes off the mortgage.</span></p>
<p><span class="font17">But we can ask more interesting questions. I want a thirty-year mortgage, and I can afford to pay $1,300 per month, or $15,600 per year. The bank is offering a 6.75% annual interest rate. How large a mortgage can I afford?</span></p>
<p><span class="font2">sub affordable_mortgage {</span></p>
<p><span class="font2">my Smortgage = shift;</span></p>
<p><span class="font2">owed(Smortgage, 30, 15_600, 0.0675);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">my Sstream = cut_loops(solve(\&amp;affordable_mortgage));</span></p>
<p><span class="font2">my Sn;</span></p>
<p><span class="font2">Sn = drop(Sstream) while Sstream;</span></p>
<p><span class="font2">print &quot;You can afford a \SSn mortgage.\n&quot;;</span></p>
<p><span class="font17">Apparently with a $1,300 payment I can pay off any mortgage up to $198,543.62 in 30 years.</span></p>
<ul style="list-style:none;"><li>
<h5><a name="bookmark134"></a><span class="font18">6.7 POWER SERIES</span></h5></li></ul>
<p><span class="font17">We’ve seen that the Newton-Raphson method can be used to evaluate the </span><span class="font2">sqrt() </span><span class="font17">function. What about other built-in functions, such as </span><span class="font2">sin() </span><span class="font17">and </span><span class="font2">cos()</span><span class="font17">?</span></p>
<p><span class="font17">The Newton-Raphson method won’t work here. To evaluate something like </span><span class="font2">sqrt(2)</span><span class="font17">, we needed to find a number </span><span class="font17" style="font-style:italic;">x</span><span class="font17"> with </span><span class="font17" style="font-style:italic;">x<sup>2</sup> =</span><span class="font17"> 2. Then we used the Newton-Raphson method, which required only simple arithmetic to approximate a solution. To evaluate something like </span><span class="font2">sin(2)</span><span class="font17">, we would need to find a number </span><span class="font17" style="font-style:italic;">x</span><span class="font17"> with sin</span><span class="font2"><sup>-</sup></span><span class="font17"><sup>1</sup> (</span><span class="font17" style="font-style:italic;">x</span><span class="font17">) </span><span class="font3">= </span><span class="font17">2. This is at least as difficult as the original problem. </span><span class="font17" style="font-style:italic;">x</span><span class="font17"><sup>2</sup> is easy to compute; sin</span><span class="font2"><sup>-</sup></span><span class="font17"><sup>1</sup>(</span><span class="font17" style="font-style:italic;">x</span><span class="font17">) isn’t.</span></p>
<p><span class="font17">To compute values of the so-called “transcendental functions” like </span><span class="font2">sin() </span><span class="font17">and </span><span class="font2">cos()</span><span class="font17">, the computer uses another strategy called </span><span class="font17" style="font-style:italic;">power series expansion}<a name="footnote30"></a><sup><a href="#bookmark343">30</a></sup><sup></sup></span></p>
<p><span class="font17">A </span><span class="font17" style="font-style:italic;">power series</span><span class="font17"> is an expression of the form:</span></p>
<p><span class="font17" style="font-style:italic;">a</span><span class="font15">g </span><span class="font3">—- </span><span class="font17" style="font-style:italic;">a</span><span class="font8" style="font-style:italic;">1</span><span class="font17" style="font-style:italic;">x</span><span class="font3"> —- </span><span class="font17" style="font-style:italic;">a</span><span class="font8" style="font-style:italic;">2</span><span class="font17" style="font-style:italic;">x</span><span class="font3"> —- </span><span class="font17" style="font-style:italic;">a</span><span class="font8" style="font-style:italic;">3</span><span class="font17" style="font-style:italic;">x^</span><span class="font3"> -— • • • </span><span class="font17">for some numbers </span><span class="font17" style="font-style:italic;">a</span><span class="font8" style="font-style:italic;">o</span><span class="font17" style="font-style:italic;">, a</span><span class="font8" style="font-style:italic;">i</span><span class="font17" style="font-style:italic;">, a</span><span class="font8" style="font-style:italic;">^</span><span class="font17" style="font-style:italic;">, ....</span><span class="font17"> Many common functions can be expressed as power series, and in particular, it turns out that for all </span><span class="font17" style="font-style:italic;">x,</span><span class="font17"> sin(</span><span class="font17" style="font-style:italic;">x</span><span class="font17">) </span><span class="font3">= </span><span class="font17" style="font-style:italic;">x — x<sup>3</sup>/3!</span><span class="font3"> + </span><span class="font17" style="font-style:italic;">x</span><span class="font15">5</span><span class="font17">/5</span><span class="font3">! — </span><span class="font17" style="font-style:italic;">x</span><span class="font15">7</span><span class="font17">/7</span><span class="font3">! + • • •</span><span class="font17">. (Here </span><span class="font17" style="font-style:italic;">a</span><span class="font8" style="font-style:italic;">^ </span><span class="font17" style="font-style:italic;">=</span><span class="font17"> 0, </span><span class="font17" style="font-style:italic;">a</span><span class="font8" style="font-style:italic;">1 </span><span class="font17" style="font-style:italic;">=</span><span class="font17"> 1, </span><span class="font17" style="font-style:italic;">a</span><span class="font8" style="font-style:italic;">^ </span><span class="font17" style="font-style:italic;">=</span><span class="font17"> 0, </span><span class="font17" style="font-style:italic;">a</span><span class="font8" style="font-style:italic;">3 </span><span class="font17" style="font-style:italic;">=</span><span class="font3"> —</span><span class="font17">1/3</span><span class="font3">!</span><span class="font17">, etc.) The formula is most accurate for </span><span class="font17" style="font-style:italic;">x</span><span class="font17"> close to 0, but if you carry it out to enough terms, it works for any </span><span class="font17" style="font-style:italic;">x</span><span class="font17"> at all. The terms themselves get small rather quickly in this case, because the factorial function in the denominator increases more rapidly than the power of </span><span class="font17" style="font-style:italic;">x</span><span class="font17"> in the numerator, particularly for small </span><span class="font17" style="font-style:italic;">x</span><span class="font17">. For example, 0.1 </span><span class="font3">— </span><span class="font17">(0.1)<sup>3</sup>/3</span><span class="font3">! + </span><span class="font17">(0.1)</span><span class="font15">5</span><span class="font17">/5</span><span class="font3">! — </span><span class="font17">(0.1)</span><span class="font15">7</span><span class="font17">/7</span><span class="font3">! </span><span class="font17">is </span><span class="font17" style="font-weight:bold;">.09983341664682</span><span class="font17">539683; the value ofsin(0.1) is </span><span class="font17" style="font-weight:bold;">.09983341664682</span><span class="font17">815230. When the computer wants to calculate the sine of some number, it plugs the number into the power series and calculates an approximation. The code to do this is simple:</span></p>
<div>
<p><span class="font9" style="font-weight:bold;">CODE LIBRARY</span></p>
</div><br clear="all">
<p><span class="font2"># Approximate sin(x) using the first n terms of the power series sub approx_sin {</span></p>
<p><span class="font2">my $n = shift;</span></p>
<p><span class="font2">my $x = shift;</span></p>
<p><span class="font2">my ($denom, $c, $num, $total) = (1, 1, $x, 0);</span></p>
<p><span class="font2">while ($n—) {</span></p>
<p><span class="font2">$total += $num / $denom;</span></p>
<p><span class="font2">$num *= $x*$x * -1;</span></p>
<p><span class="font2">$denom *= ($c+1) * ($c+2);</span></p>
<p><span class="font2">$c += 2;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">$total;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">1;</span></p>
<p><span class="font17">At each step, </span><span class="font2">$num </span><span class="font17">holds the numerator of the current term and </span><span class="font2">$denom </span><span class="font17">holds the denominator. This is so simple that it’s even easy in assembly language.</span></p>
<p><span class="font17">Similarly, cos(</span><span class="font17" style="font-style:italic;">x</span><span class="font17">) </span><span class="font3">= </span><span class="font17">1 </span><span class="font3">— </span><span class="font17" style="font-style:italic;">x</span><span class="font15">2</span><span class="font17">/2</span><span class="font3">! + </span><span class="font17" style="font-style:italic;">x</span><span class="font17"><sup>4</sup>/4</span><span class="font3">! — </span><span class="font17" style="font-style:italic;">x</span><span class="font15">6</span><span class="font17">/6</span><span class="font3">! + • • •</span><span class="font17">.</span></p>
<p><span class="font17">Streams seem almost tailor-made for power series computations, because the power series itself is infinite, and with a stream representation we can look at as many terms as are necessary to get the accuracy we want. Once the terms become sufficiently small, we know that the rest of the stream won’t make a significant contribution to the result.<a name="footnote31"></a><sup><a href="#bookmark344">31</a></sup><sup></sup></span></p>
<p><span class="font17">We could build a </span><span class="font2">sin </span><span class="font17">function that, given a numeric argument, used the power series expansion to produce approximations to sin(</span><span class="font17" style="font-style:italic;">x</span><span class="font17">). But we can do better. We can use a stream to represent the entire power series itself, and then manipulate it as a single unit.</span></p>
<p><span class="font17">We will represent the power series </span><span class="font17" style="font-style:italic;">a</span><span class="font8" style="font-style:italic;">0</span><span class="font3"> + </span><span class="font17" style="font-style:italic;">a</span><span class="font8" style="font-style:italic;">1</span><span class="font17" style="font-style:italic;">X</span><span class="font3"> + </span><span class="font17" style="font-style:italic;">a</span><span class="font8" style="font-style:italic;">2</span><span class="font17" style="font-style:italic;">x</span><span class="font17"><sup>2</sup> </span><span class="font3">+ • • • </span><span class="font17">with a stream that contains </span><span class="font17" style="font-style:italic;">(a.</span><span class="font8" style="font-style:italic;">0</span><span class="font17" style="font-style:italic;">, a.</span><span class="font8" style="font-style:italic;">1</span><span class="font17" style="font-style:italic;">, a</span><span class="font8" style="font-style:italic;">2</span><span class="font17" style="font-style:italic;">,...</span><span class="font17">). With this interpretation, we can build a function that evaluates a power series for a particular argument by substituting the argument into the series in place of </span><span class="font17" style="font-style:italic;">x.</span></p>
<p><span class="font17">Since the </span><span class="font17" style="font-style:italic;">nth</span><span class="font17"> terms of these power series depend in simple ways on </span><span class="font17" style="font-style:italic;">n</span><span class="font17"> itself, we’ll make a small utility function to generate such a series:</span></p>
<p class="font2">package PowSeries;</p>
<div>
<p><span class="font9" style="font-weight:bold;">CODE LIBRARY</span></p>
</div><br clear="all">
<p><span class="font2">use base 'Exporter'; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="font0"><sup>PowSeries</sup>.<sup>p</sup>m</span></p>
<p><span class="font2">@EXPORT_OK = qw(add2 mul2 partial_sums powers_of term_values evaluate derivative multiply recip divide $sin $cos $exp $log_ $tan); use Stream ':all'; sub tabulate { my $f = shift; &amp;transform($f, upfrom(0)); }</span></p>
<p><span class="font17">Given a function </span><span class="font17" style="font-style:italic;">f,</span><span class="font17"> this produces the infinite stream </span><span class="font17" style="font-style:italic;">f</span><span class="font17"> (0), </span><span class="font17" style="font-style:italic;">f</span><span class="font17"> (1), </span><span class="font17" style="font-style:italic;">f</span><span class="font17"> (2), </span><span class="font17" style="font-style:italic;">...</span><span class="font17">. Now we can define </span><span class="font2">sin() </span><span class="font17">and </span><span class="font2">cos()</span><span class="font17">: </span><span class="font2">my @fact = (1); sub factorial { my $n = shift; return $fact[$n] if defined $fact[$n]; $fact[$n] = $n * factorial($n-1); } $sin = tabulate(sub { my $N = shift;</span></p>
<p><span class="font2">return 0 if $N % 2 == 0;</span></p>
<p><span class="font2">my $sign = int($N/2) % 2 ? -1 : 1;</span></p>
<p><span class="font2">$sign/factorial($N) });</span></p>
<p><span class="font2">$cos = tabulate(sub { my $N = shift; return 0 if $N % 2 != 0;</span></p>
<p><span class="font2">my $sign = int($N/2) % 2 ? -1 : 1;</span></p>
<p><span class="font2">$sign/factorial($N)</span></p>
<p><span class="font2">});</span></p>
<p><span class="font2">$sin </span><span class="font17">is now a stream that begins (0, 1, 0, </span><span class="font3">-</span><span class="font17">0.16667, 0, 0.00833, 0, </span><span class="font17" style="font-style:italic;">...</span><span class="font17">); </span><span class="font2">$cos </span><span class="font17">begins (1, 0, </span><span class="font3">-</span><span class="font17">0.5, 0, 0.041667,</span><span class="font17" style="font-style:italic;">...</span><span class="font17">).</span></p>
<p><span class="font17">Before we evaluate these functions, we’ll build a few utilities for performing arithmetic on power series. First is </span><span class="font2">add2()</span><span class="font17">, which adds together the elements of two streams, element-by-element:</span></p>
<p><span class="font2">sub add2 {</span></p>
<p><span class="font2">my ($s, $t) = @_;</span></p>
<p><span class="font2">return $s unless $t;</span></p>
<p><span class="font2">return $t unless $s;</span></p>
<p><span class="font2">node(head($s) + head($t),</span></p>
<p><span class="font2">promise { add2(tail($s), tail($t)) });</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">add2($s, $t) </span><span class="font17">corresponds to the addition of two power series. (Multiplication of power series is more complicated, as we will see later.) Similarly, </span><span class="font2">scale($s, $c)</span><span class="font17">, which we’ve seen before, corresponds to the multiplication of the power series </span><span class="font2">$s </span><span class="font17">by the constant </span><span class="font2">$c</span><span class="font17">.</span></p>
<p><span class="font2">mul2()</span><span class="font17">, which multiplies streams element-by-element, is similar to </span><span class="font2">add2()</span><span class="font17">:</span></p>
<p><span class="font2">sub mul2 {</span></p>
<p><span class="font2">my ($s, $t) = @_;</span></p>
<p><span class="font2">return unless $s &amp;&amp;&nbsp;$t;</span></p>
<p><span class="font2">node(head($s) * head($t),</span></p>
<p><span class="font2">promise { mul2(tail($s), tail($t)) }); }</span></p>
<p><span class="font17">We will also need a utility function for summing up a series. Given a stream </span><span class="font19" style="font-style:italic;font-variant:small-caps;">(</span><span class="font18" style="font-style:italic;font-variant:small-caps;">a</span><span class="font16" style="font-style:italic;font-variant:small-caps;">q</span><span class="font19" style="font-style:italic;font-variant:small-caps;">, </span><span class="font17" style="font-style:italic;">a.</span><span class="font8" style="font-style:italic;">1</span><span class="font17" style="font-style:italic;">, a.</span><span class="font8" style="font-style:italic;">2</span><span class="font17" style="font-style:italic;">, ...</span><span class="font17">), it should produce the stream </span><span class="font17" style="font-variant:small-caps;">(</span><span class="font18" style="font-style:italic;font-variant:small-caps;">a</span><span class="font17" style="font-variant:small-caps;">q, </span><span class="font18" style="font-style:italic;font-variant:small-caps;">A</span><span class="font17" style="font-variant:small-caps;">q</span><span class="font3"> + </span><span class="font17" style="font-style:italic;">A</span><span class="font8" style="font-style:italic;">1</span><span class="font17" style="font-style:italic;">, </span><span class="font18" style="font-style:italic;font-variant:small-caps;">A</span><span class="font16" style="font-style:italic;font-variant:small-caps;">q</span><span class="font3"> + </span><span class="font17" style="font-style:italic;">A</span><span class="font8" style="font-style:italic;">1</span><span class="font3"> + </span><span class="font18" style="font-style:italic;font-variant:small-caps;">a</span><span class="font16" style="font-style:italic;font-variant:small-caps;">^</span><span class="font19" style="font-style:italic;font-variant:small-caps;">,</span><span class="font17" style="font-style:italic;"> ...)</span><span class="font17"> of successive partial sums of elements of the first stream. This function is similar to several others we’ve already defined:</span></p>
<p><span class="font2">sub partial_sums {</span></p>
<p><span class="font2">my $s = shift;</span></p>
<p><span class="font2">my $r;</span></p>
<p><span class="font2">$r = node(head($s), promise { add2($r, tail($s)) });</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2" style="font-style:italic;">6.7</span><span class="font15"> P OWE R SERIES </span><span class="font20">317</span></p>
<p><span class="font17">One of the eventual goals of all this machinery is to compute sines and cosines. To do that, we will need to evaluate the partial sums of a power series for a particular value of </span><span class="font17" style="font-style:italic;">x.</span><span class="font17"> This function takes a number </span><span class="font17" style="font-style:italic;">x</span><span class="font17"> and produces the stream (1, </span><span class="font17" style="font-style:italic;">x</span><span class="font17">, </span><span class="font17" style="font-style:italic;">x</span><span class="font15">2</span><span class="font17">, </span><span class="font17" style="font-style:italic;">x</span><span class="font17"><sup>3</sup>, </span><span class="font17" style="font-style:italic;">...</span><span class="font17">):</span></p>
<p><span class="font2">sub powers_of { my $x = shift; iterate_function(sub {$_[0] * $x}, 1);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">When we multiply this stream element-wise by the stream of coefficients that represents a power series, the result is a stream of the terms of the power series evaluated at a point </span><span class="font17" style="font-style:italic;">x</span><span class="font17">:</span></p>
<p><span class="font2">sub term_values { my ($s, $x) = @_; mul2($s, powers_of($x));</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">Given a power series stream </span><span class="font2">$s </span><span class="font3">= </span><span class="font17" style="font-style:italic;">(a.</span><span class="font8" style="font-style:italic;">0</span><span class="font17" style="font-style:italic;">, a.</span><span class="font8" style="font-style:italic;">1</span><span class="font17" style="font-style:italic;">, a</span><span class="font8" style="font-style:italic;">2</span><span class="font17" style="font-style:italic;">,...</span><span class="font17">), and a value </span><span class="font2">$x</span><span class="font17">, </span><span class="font2">term_values() </span><span class="font17">produces the stream (</span><span class="font17" style="font-style:italic;">a</span><span class="font15">0</span><span class="font17">, </span><span class="font17" style="font-style:italic;">a</span><span class="font8" style="font-style:italic;">1</span><span class="font17" style="font-style:italic;">x</span><span class="font17">, </span><span class="font17" style="font-style:italic;">a</span><span class="font8" style="font-style:italic;">2</span><span class="font17" style="font-style:italic;">x</span><span class="font17"><sup>2</sup>,</span><span class="font17" style="font-style:italic;">...</span><span class="font17">).</span></p>
<p><span class="font17">Finally, </span><span class="font2">evaluate() </span><span class="font17">takes a function, as represented by a power series, and evaluates it at a particular value of </span><span class="font17" style="font-style:italic;">x</span><span class="font17">:</span></p>
<p><span class="font2">sub evaluate {</span></p>
<p><span class="font2">my ($s, $x) = @_;</span></p>
<p><span class="font2">partial_sums(term_values($s, $x));</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">And lo and behold, all our work pays off:</span></p>
<p><span class="font2">my $pi = 3.1415926535897932;</span></p>
<p><span class="font2">show(evaluate($cos, $pi/6), 20);</span></p>
<p><span class="font17">producing the following approximations to cos(.</span><span class="font17" style="font-style:italic;">T</span><span class="font17">/6):</span></p>
<p><span class="font17">1</span></p>
<p><span class="font17">1</span></p>
<p><span class="font17">0.862922161095981</span></p>
<p><span class="font17">0.862922161095981</span></p>
<p><span class="font17">0.866053883415747</span></p>
<table border="1">
<tr><td>
<p><span class="font20">318</span></p></td><td style="vertical-align:bottom;">
<p><span class="font15">CHAPTER 6 Infinite Streams</span></p>
<p><span class="font17">0.866053883415747</span></p>
<p><span class="font17">0.866025264100571</span></p>
<p><span class="font17">0.866025264100571</span></p>
<p><span class="font17">0.866025404210352</span></p>
<p><span class="font17">0.866025404210352</span></p>
<p><span class="font17">0.866025403783554</span></p>
<p><span class="font17">0.866025403783554</span></p>
<p><span class="font17">0.866025403784440</span></p>
<p><span class="font17">0.866025403784440</span></p>
<p><span class="font17">0.866025403784439</span></p>
<p><span class="font17">0.866025403784439</span></p>
<p><span class="font17">0.866025403784439</span></p>
<p><span class="font17">0.866025403784439</span></p>
<p><span class="font17">0.866025403784439</span></p>
<p><span class="font17">0.866025403784439</span></p>
<p><span class="font17">This is correct. (The answer happens to be exactly ^3/2.) We can even work it in reverse to calculate </span><span class="font17" style="font-style:italic;">n</span><span class="font17">:</span></p>
<ul style="list-style:none;"><li>
<p><span class="font2"># Get the n'th term from a stream</span></p></li></ul>
<p><span class="font2">sub nth {</span></p>
<p><span class="font2">my $s = shift;</span></p>
<p><span class="font2">my $n = shift;</span></p>
<p><span class="font2">return $n == 0 ? head($s) : nth(tail($s), $n-1);</span></p>
<p><span class="font2">}</span></p>
<ul style="list-style:none;"><li>
<p><span class="font2"># Calculate the approximate cosine of x</span></p></li></ul>
<p><span class="font2">sub cosine {</span></p>
<p><span class="font2">my $x = shift;</span></p>
<p><span class="font2">nth(evaluate($cos, $x), 20);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">If we know that cos(</span><span class="font17" style="font-style:italic;">n</span><span class="font17">/6) </span><span class="font3">= </span><span class="font17">^/3/2, then to find </span><span class="font17" style="font-style:italic;">n</span><span class="font17"> we need only solve the equation cos(</span><span class="font17" style="font-style:italic;">x</span><span class="font17">/6) </span><span class="font3">= ^</span><span class="font17">3/2, or equivalently, cos<sup>2</sup>(</span><span class="font17" style="font-style:italic;">x</span><span class="font17">/6) </span><span class="font3">= </span><span class="font17">3/4:</span></p>
<p><span class="font2">sub is_zero_when_x_is_pi {</span></p>
<p><span class="font2">my $x = shift;</span></p>
<p><span class="font2">my $c = cosine($x/6);</span></p>
<p><span class="font2">$c * $c - 3/4;</span></p>
<p><span class="font2">}</span></p></td></tr>
</table>
<p><span class="font2">show(solve(\&amp;is_zero_when_x_is_pi), 20);</span></p>
<p><span class="font17">And the output from this is:</span></p>
<p><span class="font17">1</span></p>
<p><span class="font17">5.07974473179368</span></p>
<p><span class="font17">3.19922525384188</span></p>
<p><span class="font17">3.14190177620487</span></p>
<p><span class="font17">3.14159266278343</span></p>
<p><span class="font17">3.14159265358979</span></p>
<p><span class="font17">3.14159265358979 which is correct. The initial guess of 1, you will recall, is the default for </span><span class="font2">solve()</span><span class="font17">. Had we explicitly specified a better guess, such as 3, the process would have converged more quickly; had we specified a much larger guess, like 10, the results would have converged to a different solution, such as 11</span><span class="font17" style="font-style:italic;">^</span><span class="font17">.</span></p>
<ul style="list-style:none;"><li>
<h5><a name="bookmark135"></a><span class="font19">6.7.1 Derivatives</span></h5></li></ul>
<p><span class="font17">We used </span><span class="font2">slope() </span><span class="font17">to calculate the slope of the curve cos<sup>2</sup>(</span><span class="font17" style="font-style:italic;">x</span><span class="font17">/6) </span><span class="font3">— </span><span class="font17">3/4 at various points; recall that </span><span class="font2">slope() </span><span class="font17">calculates an approximation of the slope by picking two points close together on the curve and calculating the slope of the line between them. If we had known the derivative function of cos<sup>2</sup>(</span><span class="font17" style="font-style:italic;">x</span><span class="font17">/6) </span><span class="font3">— </span><span class="font17">3/4, we could have plugged it in directly. But calculating a derivative function requires differential calculus.</span></p>
<p><span class="font17">However, if you know a power series for a function, calculating its derivative is trivial. If the power series for the function is </span><span class="font17" style="font-style:italic;">a.</span><span class="font8" style="font-style:italic;">0</span><span class="font3"> + </span><span class="font17" style="font-style:italic;">a</span><span class="font8" style="font-style:italic;">1</span><span class="font17" style="font-style:italic;">x</span><span class="font3"> + </span><span class="font17" style="font-style:italic;">a</span><span class="font8" style="font-style:italic;">^</span><span class="font17" style="font-style:italic;">x</span><span class="font17"><sup>2</sup> </span><span class="font3">+ • • •</span><span class="font17">, the power series for the derivative is </span><span class="font17" style="font-style:italic;">a</span><span class="font8" style="font-style:italic;">1</span><span class="font3"> + </span><span class="font17" style="font-style:italic;">2a</span><span class="font8" style="font-style:italic;">2</span><span class="font17" style="font-style:italic;">x</span><span class="font3"> + </span><span class="font17" style="font-style:italic;">3a</span><span class="font8" style="font-style:italic;">3</span><span class="font17" style="font-style:italic;">x</span><span class="font17"><sup>2</sup> </span><span class="font3">+ • • •</span><span class="font17">. That is, it’s simply:</span></p>
<p><span class="font2">sub derivative { my $s = shift; mul2(upfrom(1), tail($s));</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">If we do:</span></p>
<p><span class="font2">show(derivative($sin), 20);</span></p>
<p><span class="font17">we get exactly the same output as for:</span></p>
<p><span class="font2">show($cos, 20);</span></p>
<p><span class="font17">demonstrating that the cosine function is the derivative of the sine function.</span></p>
<ul style="list-style:none;"><li>
<h5><a name="bookmark136"></a><span class="font19">6.7.2 Other Functions</span></h5></li></ul>
<p><span class="font17">Many other common functions can be calculated with the power series method. For example, Perl’s built-in </span><span class="font2">exp() </span><span class="font17">function is:</span></p>
<p><span class="font2">$exp = tabulate(sub { my $N = shift; 1/factorial($N) });</span></p>
<p><span class="font17">The hyperbolic functions </span><span class="font2">sinh() </span><span class="font17">and </span><span class="font2">cosh() </span><span class="font17">are like </span><span class="font2">sin() </span><span class="font17">and </span><span class="font2">cos() </span><span class="font17">except without the extra </span><span class="font2">$sign </span><span class="font17">factor in the terms. Perl’s built-in </span><span class="font2">log() </span><span class="font17">function is almost:</span></p>
<p><span class="font2">$log_ = tabulate(sub { my $N = shift;</span></p>
<p><span class="font2">$N==0 ? 0 : (-1)**$N/-$N });</span></p>
<p><span class="font17">This actually calculates log(</span><span class="font17" style="font-style:italic;">x</span><span class="font3"> + </span><span class="font17">1); to get log(</span><span class="font17" style="font-style:italic;">x</span><span class="font17">), subtract 1 from </span><span class="font17" style="font-style:italic;">x</span><span class="font17"> before plugging it in. (Unlike the others, it works only for </span><span class="font17" style="font-style:italic;">x</span><span class="font17"> between </span><span class="font3">—</span><span class="font17">1 and 1.) The power series method we’ve been using won’t work for an unmodified </span><span class="font2">log() </span><span class="font17">function, because it approximates every function’s behavior close to 0, and log(0) is undefined.</span></p>
<p><span class="font17">The tangent function is more complicated. One way to compute tan(</span><span class="font17" style="font-style:italic;">x</span><span class="font17">) is by computing sin(</span><span class="font17" style="font-style:italic;">x</span><span class="font17">)/ cos(</span><span class="font17" style="font-style:italic;">x</span><span class="font17">). We’ll see another way in the next section.</span></p>
<ul style="list-style:none;"><li>
<h5><a name="bookmark137"></a><span class="font19">6.7.3 Symbolic Computation</span></h5></li></ul>
<p><span class="font17">As one final variation on power series computations, we’ll forget about the numbers themselves and deal with the series as single units that can be manipulated algebraically. We’ve already seen hints of this earlier. If </span><span class="font2">$f </span><span class="font17">and </span><span class="font2">$g </span><span class="font17">are streams that represent the power series for functions </span><span class="font17" style="font-style:italic;">f (x)</span><span class="font17"> and </span><span class="font17" style="font-style:italic;">g(x</span><span class="font17">), then </span><span class="font2">add2($f,$g) </span><span class="font17">is the power series for the function </span><span class="font17" style="font-style:italic;">f (x)</span><span class="font3"> + </span><span class="font17" style="font-style:italic;">g</span><span class="font17">(</span><span class="font17" style="font-style:italic;">x</span><span class="font17">), </span><span class="font2">scale($f,$c) </span><span class="font17">is the power series for the function </span><span class="font17" style="font-style:italic;">c • f</span><span class="font17"> (</span><span class="font17" style="font-style:italic;">x</span><span class="font17">), and </span><span class="font2">derivative($f) </span><span class="font17">is the power series for the function </span><span class="font17" style="font-style:italic;">f '(x</span><span class="font17">), the derivative of</span><span class="font17" style="font-style:italic;">f.</span></p>
<p><span class="font17">Multiplying and dividing power series is more complex. In fact, it’s not immediately clear how to divide one infinite power series by another. Or even, for that matter, how to multiply them. </span><span class="font2">mul2() </span><span class="font17">is </span><span class="font17" style="font-style:italic;">not</span><span class="font17"> what we want here, because algebra tells us that </span><span class="font17" style="font-style:italic;">(a.</span><span class="font8" style="font-style:italic;">0</span><span class="font3"> + </span><span class="font17" style="font-style:italic;">a</span><span class="font8" style="font-style:italic;">\</span><span class="font17" style="font-style:italic;">x</span><span class="font3"> + • • •</span><span class="font17">) </span><span class="font3">x </span><span class="font17">(</span><span class="font17" style="font-style:italic;">b</span><span class="font15">0 </span><span class="font3">+ </span><span class="font18" style="font-style:italic;font-variant:small-caps;">^</span><span class="font17" style="font-variant:small-caps;">i</span><span class="font18" style="font-style:italic;font-variant:small-caps;">x</span><span class="font3"> + • • •</span><span class="font17">) </span><span class="font3">= </span><span class="font17" style="font-style:italic;">a.</span><span class="font8" style="font-style:italic;">0</span><span class="font17" style="font-style:italic;">b</span><span class="font8" style="font-style:italic;">0</span><span class="font3"> + </span><span class="font17">(</span><span class="font17" style="font-style:italic;">a</span><span class="font15">0</span><span class="font17" style="font-style:italic;">b</span><span class="font15">1 </span><span class="font3">+ </span><span class="font17" style="font-style:italic;">a.</span><span class="font8" style="font-style:italic;">1 </span><span class="font17" style="font-style:italic;">b</span><span class="font8" style="font-style:italic;">()</span><span class="font17" style="font-style:italic;">)x</span><span class="font3"> + • • •</span><span class="font17">, and </span><span class="font2">mul2() </span><span class="font17">would give us </span><span class="font17" style="font-style:italic;">^</span><span class="font15">0</span><span class="font17" style="font-style:italic;">^</span><span class="font15">0 </span><span class="font3">+ </span><span class="font18" style="font-style:italic;font-variant:small-caps;">^</span><span class="font17" style="font-variant:small-caps;">i</span><span class="font18" style="font-style:italic;font-variant:small-caps;">^</span><span class="font17" style="font-variant:small-caps;">i</span><span class="font18" style="font-style:italic;font-variant:small-caps;">x</span><span class="font3"> + • • • </span><span class="font17">instead.</span></p>
<p><span class="font17">Our regex-string generator comes to the rescue: Power series multiplication is formally almost identical to regex concatenation. First note that if </span><span class="font2">$S </span><span class="font17">represents some power series, say </span><span class="font17" style="font-style:italic;">a.</span><span class="font8" style="font-style:italic;">0</span><span class="font3"> + </span><span class="font18" style="font-style:italic;font-variant:small-caps;">A</span><span class="font16" style="font-style:italic;font-variant:small-caps;">i</span><span class="font18" style="font-style:italic;font-variant:small-caps;">x</span><span class="font3"> + </span><span class="font17" style="font-style:italic;">a.</span><span class="font8" style="font-style:italic;">2</span><span class="font17" style="font-style:italic;">x</span><span class="font17"><sup>2</sup> </span><span class="font3">+ • • • </span><span class="font17">then </span><span class="font2">tail($S) </span><span class="font17">represents</span></p>
<p><span class="font2" style="font-style:italic;">6.7</span><span class="font15"> P OWE R SERIES </span><span class="font20">321</span></p>
<p><span class="font17" style="font-style:italic;">a</span><span class="font8" style="font-style:italic;">i</span><span class="font3"> + </span><span class="font17" style="font-style:italic;">a</span><span class="font8" style="font-style:italic;">2</span><span class="font17" style="font-style:italic;">x</span><span class="font3"> + </span><span class="font17" style="font-style:italic;">a</span><span class="font8" style="font-style:italic;">3</span><span class="font17" style="font-style:italic;">x</span><span class="font17"><sup>2</sup> </span><span class="font3">+ • • •</span><span class="font17">. Then:</span></p>
<p><span class="font17" style="font-style:italic;">S</span><span class="font3"> = </span><span class="font17" style="font-style:italic;">a</span><span class="font15">o &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="font3">+ </span><span class="font17" style="font-style:italic;">a</span><span class="font8" style="font-style:italic;">i</span><span class="font17" style="font-style:italic;">x</span><span class="font3"> + </span><span class="font17" style="font-style:italic;">a</span><span class="font8" style="font-style:italic;">2</span><span class="font17" style="font-style:italic;">x</span><span class="font3"> + </span><span class="font17" style="font-style:italic;">a</span><span class="font8" style="font-style:italic;">3</span><span class="font17" style="font-style:italic;">x^</span><span class="font3"> + • • •</span></p>
<p><span class="font3">= </span><span class="font17" style="font-style:italic;">a</span><span class="font15">o &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="font3">+ </span><span class="font17" style="font-style:italic;">x •</span><span class="font17"> (</span><span class="font17" style="font-style:italic;">a</span><span class="font15">i </span><span class="font3">+ </span><span class="font17" style="font-style:italic;">a</span><span class="font8" style="font-style:italic;">2</span><span class="font17" style="font-style:italic;">x</span><span class="font3"> + </span><span class="font17" style="font-style:italic;">a</span><span class="font15">3</span><span class="font17" style="font-style:italic;">x</span><span class="font3"> + • • •</span><span class="font17">)</span></p>
<p><span class="font3">= </span><span class="font17">head(</span><span class="font17" style="font-style:italic;">S</span><span class="font17">) </span><span class="font3">+ </span><span class="font17" style="font-style:italic;">x •</span><span class="font17"> tail(</span><span class="font17" style="font-style:italic;">S</span><span class="font17">)</span></p>
<p><span class="font17">Now we want to multiply two series, </span><span class="font2">$S </span><span class="font17">and </span><span class="font2">$T</span><span class="font17">:</span></p>
<p><span class="font17" style="font-style:italic;">S</span><span class="font3"> = </span><span class="font17">head(</span><span class="font17" style="font-style:italic;">S</span><span class="font17">) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="font3">+ </span><span class="font17" style="font-style:italic;">x</span><span class="font17"> tail(</span><span class="font17" style="font-style:italic;">S</span><span class="font17">)</span></p>
<p><span class="font17" style="font-style:italic;">T =</span><span class="font17"> head(</span><span class="font17" style="font-style:italic;">T</span><span class="font17">) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="font3">+ </span><span class="font17" style="font-style:italic;">x</span><span class="font17"> tail(</span><span class="font17" style="font-style:italic;">T</span><span class="font17">)</span></p>
<div>
<p><span class="font20">322</span></p>
</div><br clear="all">
<p><span class="font15" style="font-variant:small-caps;">chapter </span><span class="font2" style="font-style:italic;">6</span><span class="font15"> Infinite Streams</span></p>
<p><span class="font17">For power series, we can get a more efficient implementation by optimizing </span><span class="font2">scale() </span><span class="font17">slightly:</span></p>
<p><span class="font2">sub scale {</span></p>
<p><span class="font2">my ($s, $c) = @_;</span></p>
<p><span class="font2" style="font-weight:bold;">return &nbsp;&nbsp;&nbsp;if $c == 0;</span></p>
<p><span class="font2" style="font-weight:bold;">return $s if $c == 1;</span></p>
<p><span class="font2">transform { $_[0]*$c } $s;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">To test this, we can try out the identity sin<sup>2</sup>(</span><span class="font17" style="font-style:italic;">x</span><span class="font17">) </span><span class="font3">+ </span><span class="font17">cos<sup>2</sup>(</span><span class="font17" style="font-style:italic;">x</span><span class="font17">) </span><span class="font3">= </span><span class="font17">1:</span></p>
<p><span class="font2">my $one = add2(multiply($cos, $cos), multiply($sin, $sin));</span></p>
<p><span class="font2">show($one, 20);</span></p>
<p><span class="font2">10000000 4.33680868994202e-19 000000000 6.46234853557053e-27 0</span></p>
<p><span class="font17">Exactly 1, as predicted, except for two insignificant round-off errors.</span></p>
<p><span class="font17">We might like to make </span><span class="font2">multiply() </span><span class="font17">a little cleaner and faster by replacing the two calls to </span><span class="font2">add2() </span><span class="font17">with a single call to a function that can add together any number of series:</span></p>
<p><span class="font2">sub sum {</span></p>
<p><span class="font2">my @s = grep $_, @_;</span></p>
<p><span class="font2">my $total = 0;</span></p>
<p><span class="font2">$total += head($_) for @s;</span></p>
<p><span class="font2">node($total,</span></p>
<p><span class="font2">promise { sum(map tail($_), @s) }</span></p>
<p><span class="font2">);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">sum() </span><span class="font17">first discards any empty streams from its arguments, since they won’t contribute to the sum anyway. It then adds up the heads to get the head of the result and returns a new stream with the sum at its head; the tail promises to add up the tails similarly. With this new function, </span><span class="font2">multiply() </span><span class="font17">becomes:</span></p>
<p><span class="font2">sub multiply {</span></p>
<p><span class="font2">my ($S, $T) = @_;</span></p>
<p><span class="font2">my ($s, $t) = (head($S), head($T));</span></p>
<p><span class="font2">node($s*$t,</span></p>
<p><span class="font17" style="font-style:italic;">G.~J</span><span class="font15"> POWER SERIES </span><span class="font20">323</span></p>
<p><span class="font2" style="font-weight:bold;">promise { sum(scale(tail($T), $s),</span></p>
<p><span class="font2" style="font-weight:bold;">scale(tail($S), $t),</span></p>
<p><span class="font2">node(0,</span></p>
<p><span class="font2">promise {multiply(tail($S), tail($T))}),</span></p>
<p><span class="font2" style="font-weight:bold;">)</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">The next step is to calculate the reciprocal of a power series. If </span><span class="font2">$s </span><span class="font17">is the power series for a function </span><span class="font17" style="font-style:italic;">f (x</span><span class="font17">), then the reciprocal series </span><span class="font2">$r </span><span class="font17">is the series for the function </span><span class="font17" style="font-style:italic;">1/f</span><span class="font17">(</span><span class="font17" style="font-style:italic;">x</span><span class="font17">). To get this requires a little bit of algebraic ingenuity. Let’s suppose that the first term of </span><span class="font2">$s </span><span class="font17">is 1. (If it’s not, we can scale </span><span class="font2">$s </span><span class="font17">appropriately, and then scale the result back when we’re done.)</span></p>
<p><span class="font17" style="font-style:italic;">r &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= 1/f (x</span><span class="font17">)</span></p>
<p><a href="#bookmark345"><span class="font17" style="font-style:italic;">r &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=</span></a></p>
<p><span class="font17" style="font-style:italic;">r &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=</span><span class="font17"> 1/(1 </span><span class="font3">+ </span><span class="font17">tail(</span><span class="font17" style="font-style:italic;">s</span><span class="font17">))</span></p>
<p><a href="#bookmark346"><span class="font17" style="font-style:italic;">r •</span><span class="font17"> (1 </span><span class="font3">+ </span><span class="font17">tail(</span><span class="font17" style="font-style:italic;">s</span><span class="font17">)) &nbsp;</span><span class="font3">=</span></a></p>
<p><a href="#bookmark347"><span class="font17" style="font-style:italic;">r</span><span class="font3"> + </span><span class="font17" style="font-style:italic;">r •</span><span class="font17"> tail(</span><span class="font17" style="font-style:italic;">s</span><span class="font17">) &nbsp;&nbsp;&nbsp;</span><span class="font3">=</span></a></p>
<p><span class="font17" style="font-style:italic;">r &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=</span><span class="font17"> 1 </span><span class="font3">— </span><span class="font17" style="font-style:italic;">r •</span><span class="font17"> tail(</span><span class="font17" style="font-style:italic;">s</span><span class="font17">)</span></p>
<p><span class="font17">And now, amazingly, we’re done. We now know that the first term of </span><span class="font2">$r </span><span class="font17">must be 1, and we can compute the rest of the terms recursively by using our trick of defining the </span><span class="font2">$r </span><span class="font17">stream in terms of itself:</span></p>
<ul style="list-style:none;"><li>
<p><span class="font2"># Works only if head($s) = 1</span></p></li></ul>
<p><span class="font2">sub recip {</span></p>
<p><span class="font2">my ($s) = shift;</span></p>
<p><span class="font2">my $r;</span></p>
<p><span class="font2">$r = node(1,</span></p>
<p><span class="font2">promise { scale(multiply($r, tail($s)), -1) });</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">The heavy lifting is done; dividing power series is now a one-liner:</span></p>
<ul style="list-style:none;"><li>
<p><span class="font2"># Works only if head($t) = 1</span></p></li></ul>
<p><span class="font2">sub divide {</span></p>
<p><span class="font2">my ($s, $t) = @_;</span></p>
<p><span class="font20">324 </span><span class="font15">CHAPTER 6 Infinite Streams</span></p>
<p><span class="font2">multiply($s, recip($t));</span></p>
<p><span class="font2">} $tan = divide($sin, $cos);</span></p>
<p><span class="font2">show($tan, 10);</span></p>
<p><span class="font17" style="font-weight:bold;">0 1</span></p>
<p><span class="font17" style="font-weight:bold;">0 0.333333333333333</span></p>
<p><span class="font17" style="font-weight:bold;">0 0.133333333333333</span></p>
<p><span class="font17" style="font-weight:bold;">0 0.053968253968254</span></p>
<p><span class="font17" style="font-weight:bold;">0 0.0218694885361552</span></p>
<p><span class="font17">My </span><span class="font17" style="font-style:italic;">Engineering Mathematics Handbook<sup>1</sup></span><span class="font17"> says that the coefficients are 0, 1,0, 1/3, 0, 2/15, 0, 17/315, 0, 62/2835,</span><span class="font17" style="font-style:italic;">...</span><span class="font17">, so it looks as though the program is working properly. If we would like the program to generate the fractions instead of decimal approximations, we should download the </span><span class="font2">Math::BigRat </span><span class="font17">module from CPAN and use it to initialize the </span><span class="font2">factorial() </span><span class="font17">function that is the basis of </span><span class="font2">$sin </span><span class="font17">and </span><span class="font2">$cos</span><span class="font17">.</span></p>
<p><span class="font2">Math::BigRat </span><span class="font17">values are infectious: if you combine one with an ordinary number, the result is another </span><span class="font2">Math::BigRat </span><span class="font17">object. Since the </span><span class="font2">©fact </span><span class="font17">table is initialized with a </span><span class="font2">Math::BigRat</span><span class="font17">, its other elements will be constructed as </span><span class="font2">Math::BigRat</span><span class="font17">s also; since the return values of </span><span class="font2">fact() </span><span class="font17">are </span><span class="font2">Math::BigRat</span><span class="font17">s, the elements of </span><span class="font2">$sin </span><span class="font17">and </span><span class="font2">$cos </span><span class="font17">will be too; and since these are used in the computation of </span><span class="font2">$tan</span><span class="font17">, the end result will be </span><span class="font2">Math::BigRat </span><span class="font17">objects. Changing one line in the source code causes a ripple effect that propagates all the way to the final result:</span></p>
<p><span class="font2" style="font-weight:bold;">my @fact = (Math::BigRat-&gt;new(1));</span></p>
<p><span class="font2">sub factorial { my $n = shift; return $fact[$n] if defined $fact[$n]; $fact[$n] = $n * factorial($n-1);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">The output is now:</span></p>
<p><span class="font2">0101/30 2/15 0 17/315 0 62/2835</span></p>
<p><span class="font15">12 Jan J. Tuma, McGraw-Hill, 1970.</span></p>
<p><span class="font14">CHAPTER</span></p>
<h3><a name="bookmark138"></a><span class="font25">HIGH ER-ORD ER FUNCTIONS AND CURRYING</span></h3>
<p><span class="font17">Our </span><span class="font2">memoize() </span><span class="font17">function of Chapter 3 was a “function factory,” building stub functions that served as replacements for other functions. The technique of using functions to build other functions is extremely powerful. In this chapter, we’ll look at a technique called </span><span class="font17" style="font-style:italic;">currying,</span><span class="font17"> which transforms an ordinary function into a function factory for manufacturing more functions, and at other techniques for transforming one function into another.</span></p>
<p><span class="font17">A higher-order function is a function that operates on other functions instead of on data values. Some of these take data arguments and manufacture functions to order; others, like the </span><span class="font2">imap() </span><span class="font17">function of Chapter 4, transform one function into another one.</span></p>
<ul style="list-style:none;"><li>
<h5><a name="bookmark139"></a><span class="font18">7.1 CURRYING</span></h5></li></ul>
<p><span class="font17">We have seen several times how to use callbacks to parametrize the behavior of a function so that it can serve many purposes. For example, in Section 1.5 we saw how a generic directory-walking function could be used to print a list of dangling symbolic links, to return a list of interesting files, or to copy an entire directory.</span></p>
<h5><a name="bookmark348"></a><span class="font18">325</span></h5>
<div>
<p><span class="font20">326</span></p>
</div><br clear="all">
<p><span class="font15">CHAPTER 7 Higher-Order Functions and Currying</span></p>
<p><span class="font17">Callbacks are a way to make functions more general by supplying other functions to them as arguments. We saw how to write functions that used closures to generate other functions as return values. The </span><span class="font17" style="font-style:italic;">currying</span><span class="font17"> technique we’ll see combines closures and callbacks, turning an ordinary function into a factory that manufactures functions on demand.</span></p>
<p><span class="font17">Recall our </span><span class="font2">walk_html() </span><span class="font17">function from Chapter 1. Its arguments were an HTML tree and a pair of callbacks, one to handle plain text and one to handle tagged text. We found a way to use this to extract all the text that was enclosed in </span><span class="font2">&lt;h1&gt; </span><span class="font17">tags:</span></p>
<p><span class="font2">©tagged_texts = walk_html(Stree, sub { ['MAYBE', S_[0]] }, \&amp;promote_if_h1tag);</span></p>
<p><span class="font2">sub promote_if_h1tag {</span></p>
<p><span class="font2">my Selement = shift;</span></p>
<p><span class="font2">if (Selement-&gt;{_tag} eq 'hl') {</span></p>
<p><span class="font2">return ['KEEPER', join '', map {S_-&gt;[1]} ©_];</span></p>
<p><span class="font2">} else {</span></p>
<p><span class="font2">return @_;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">sub extract_headers {</span></p>
<p><span class="font2">my Stree = shift;</span></p>
<p><span class="font2">my @tagged_texts = walk_html(Stree, sub { ['MAYBE', S_[0]]}, \&amp;promote_if_h1tag);</span></p>
<p><span class="font2">my ©keepers = grep { S_-&gt;[0] eq 'KEEPER' } @tagged_texts;</span></p>
<p><span class="font2">my ©keeper_text = map { S_-&gt;[1] } ©keepers;</span></p>
<p><span class="font2">my Sheader_text = join '', ©keeper_text;</span></p>
<p><span class="font2">return Sheader_text;</span></p>
<p><span class="font2">}</span></p>
<h6><a name="bookmark349"></a><span class="font17">We then observed that it would make sense to abstract the </span><span class="font2">&lt;h1&gt; </span><span class="font17">out of promote</span><span class="font2">_if_h1tag()</span><span class="font17">, to make it more general:</span></h6>
<p><span class="font2">sub promote_if {</span></p>
<p><span class="font2">my Sis_interesting = shift;</span></p>
<p><span class="font2">my Selement = shift;</span></p>
<p><span class="font2">if (Sis_interesting-&gt;(Selement-&gt;{_tag}) {</span></p>
<p><span class="font2">return ['keeper', join '', map {S_-&gt;[1]} ©_];</span></p>
<p><span class="font2">} else {</span></p>
<p><span class="font15">7.1 CURRYING </span><span class="font20">327</span></p>
<p><span class="font2">return @_; } }</span></p>
<p><span class="font2">my @tagged_texts = walk_html(Stree, sub { ['maybe', $_[0]] }, sub { promote_if(</span></p>
<p><span class="font2">sub { S_[0] eq 'h1' }, S_[0]) });</span></p>
<p class="font17">The second callback in <span class="font2">walk_html() </span><span class="font17">is rather peculiar. It’s an anonymous function that we manufactured solely to call </span><span class="font2">promote_if() </span><span class="font17">with the right arguments. The previous version of the code was tidier. What we need is away to get </span><span class="font2">promote_if() </span><span class="font17">to </span><span class="font17" style="font-style:italic;">manufacture</span><span class="font17"> the </span><span class="font2">promote_if_h1tag() </span><span class="font17">function we need. This seems like it should be possible, because </span><span class="font2">promote_if() </span><span class="font17">already knows how to perform the task that we want </span><span class="font2">promote_if_h1tag() </span><span class="font17">to perform. All that we need to do is to have </span><span class="font2">promote_if() </span><span class="font17">wrap up that behavior into a new function: </span><span class="font2">sub promote_if {</span></p>
<div>
<p><span class="font9" style="font-weight:bold;">CODE LIBRARY</span></p>
</div><br clear="all">
<p><span class="font2">my Sis_interesting = shift; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="font0"><sup>pr</sup>oirio<sup>te</sup>_-i<sup>f</sup>_<sup>curr</sup></span></p>
<p><span class="font2" style="font-weight:bold;">return sub { </span><span class="font2">my Selement = shift; if (Sis_interesting-&gt;(Selement-&gt;{_tag}) { return ['keeper', join '', map {S_-&gt;[1]} @_]; } else { return @_; } </span><span class="font2" style="font-weight:bold;">} </span><span class="font2">}</span></p>
<p><span class="font17">Instead of accepting both arguments right away, </span><span class="font2">promote_if() </span><span class="font17">now gets the </span><span class="font2">Sis_interesting </span><span class="font17">callback only, and manufactures a new function that, given an HTML element, promotes it if it’s considered interesting. Making this change to </span><span class="font2">promote_if()</span><span class="font17">, to turn it from a function of two arguments into a function of one argument that returns a function of one argument, is called </span><span class="font17" style="font-style:italic;">currying</span><span class="font17"> it, and the version of </span><span class="font2">promote_if() </span><span class="font17">immediately above is the </span><span class="font17" style="font-style:italic;">curried</span><span class="font17"> version of </span><span class="font2">promote_if()</span><span class="font17">.<a name="footnote32"></a><sup><a href="#bookmark350">32</a></sup><sup></sup></span></p>
<p><span class="font20">328 </span><span class="font15">CHAPTER 7 Higher-Order Functions and Currying</span></p>
<h6><a name="bookmark351"></a><span class="font17">The happy outcome is that the call to </span><span class="font2">walk_html() </span><span class="font17">is now much simpler:</span></h6>
<p><span class="font2">my @tagged_texts = walk_html($tree,</span></p>
<p><span class="font2">sub { ['maybe', $_[0]] }, promote_if(sub { $_[0] eq 'h1' }), );</span></p>
<p><span class="font17">Once you get used to the idea of currying, you start to see opportunities to do it all over. Recall our functions from Chapter 6 for adding and multiplying two streams together element-by-element: </span><span class="font2">add2() </span><span class="font17">and </span><span class="font2">mul2()</span><span class="font17">:</span></p>
<p><span class="font2">sub add2 {</span></p>
<p><span class="font2">my ($s, $t) = @_;</span></p>
<p><span class="font2">return unless $s &amp;&amp;&nbsp;$t;</span></p>
<p><span class="font2">node(head($s) + head($t),</span></p>
<p><span class="font2">promise { add2(tail($s), tail($t)) });</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">sub mul2 {</span></p>
<p><span class="font2">my ($s, $t) = @_;</span></p>
<p><span class="font2">return unless $s &amp;&amp;&nbsp;$t;</span></p>
<p><span class="font2">node(head($s) * head($t),</span></p>
<p><span class="font2">promise { mul2(tail($s), tail($t)) });</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">These functions are almost identical. We saw in Chapter 1 that two functions with similar code can often be combined into a single function that accepts a callback parameter. In this case, the callback, </span><span class="font2">$op</span><span class="font17">, specifies the operation to use to combine </span><span class="font2">head($s) </span><span class="font17">and </span><span class="font2">head($t)</span><span class="font17">:</span></p>
<p><span class="font2">sub combine2 {</span></p>
<p><span class="font2">my ($s, $t, $op) = @_;</span></p>
<p><span class="font2">return unless $s &amp;&amp;&nbsp;$t;</span></p>
<p><span class="font2">node($op-&gt;(head($s), head($t)),</span></p>
<p><span class="font2">promise { combine2(tail($s), tail($t), $op) });</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">Now we can build </span><span class="font2">add2() </span><span class="font17">and </span><span class="font2">mul2() </span><span class="font17">from </span><span class="font2">combine2()</span><span class="font17">:</span></p>
<p><span class="font2">sub add2 { combine2(@_, sub { $_[0] + $_[1] }) }</span></p>
<p><span class="font2">sub mul2 { combine2(@_, sub { $_[0] * $_[1] }) }</span></p>
<p><span class="font17">Since a major use of </span><span class="font2">combine2() </span><span class="font17">is to manufacture such functions, it would be more convenient for </span><span class="font2">combine2() </span><span class="font17">to do what we wanted in the first place. We can turn </span><span class="font2">combine2() </span><span class="font17">into a factory that manufactures stream-combining functions by currying it:</span></p>
<p><span class="font2">sub combine2 {</span></p>
<div>
<p><span class="font9" style="font-weight:bold;">CODE LIBRARY</span></p>
</div><br clear="all">
<div>
<p><span class="font0">combine2</span></p>
</div><br clear="all">
<p><span class="font2" style="font-weight:bold;">my $op = shift;</span></p>
<p><span class="font2" style="font-weight:bold;">return sub {</span></p>
<p><span class="font2" style="font-weight:bold;">my ($s, $t) = @_;</span></p>
<p><span class="font2">return unless $s &amp;&amp;&nbsp;$t;</span></p>
<p><span class="font2">node($op-&gt;(head($s), head($t)),</span></p>
<p><span class="font2" style="font-weight:bold;">promise { combine2($op)-&gt;(tail($s), tail($t))}); };</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">Now we have simply:</span></p>
<p><span class="font2">$add2 = combine2(sub { $_[0] + $_[1] });</span></p>
<p><span class="font2">$mul2 = combine2(sub { $_[0] * $_[1] });</span></p>
<p><span class="font17">This may also be fractionally more efficient, since we won’t have to do an extra function call every time we call </span><span class="font2">add2() </span><span class="font17">or </span><span class="font2">mul2()</span><span class="font17">. </span><span class="font2">add2() </span><span class="font17">is the function to add the two streams, rather than a function that re-invokes </span><span class="font2">combine2() </span><span class="font17">in a way that adds two streams.</span></p>
<p><span class="font17">If we want these functions to stick around, we can give them names, as we just did; alternatively, we can use them anonymously:</span></p>
<p><span class="font2">my $catstrs = combine2(sub { &quot;$_[0]$_[1]&quot; })-&gt;($s, $t);</span></p>
<p><span class="font17">Instead of the </span><span class="font2">scale() </span><span class="font17">function we saw earlier, we might prefer this curried version:</span></p>
<p><span class="font2">sub scale {</span></p>
<p><span class="font2">my $s = shift;</span></p>
<p><span class="font2">return sub {</span></p>
<p><span class="font2">my $c = shift;</span></p>
<p><span class="font2">return if $c == 0;</span></p>
<p><span class="font2">transform { $_[0] * $c } $s;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">scale() </span><span class="font17">is now a function factory. Instead of taking a stream and a number and returning a new stream, it takes a stream and manufactures a function that produces new streams. </span><span class="font2">$scale_s = scale($s) </span><span class="font17">returns a function for scaling </span><span class="font2">$s</span><span class="font17">; given a numeric argument, say </span><span class="font2">$n</span><span class="font17">, </span><span class="font2">$scale_s </span><span class="font17">produces a stream that has the elements of </span><span class="font2">$s </span><span class="font17">scaled by </span><span class="font2">$n</span><span class="font17">. For example, </span><span class="font2">$scale_s-&gt;(2) </span><span class="font17">returns a stream whose every element is twice </span><span class="font2">$s</span><span class="font17">’s, and </span><span class="font2">$scale_s-&gt;(3) </span><span class="font17">returns a stream whose every element is three times </span><span class="font2">$s</span><span class="font17">’s. If we’re planning to scale the same stream by several different factors, it might make sense to have a single scale function to generate all the outputs.</span></p>
<p><span class="font17">Depending on how we’re using it, we might have preferred to curry the function arguments in the other order:</span></p>
<div>
<p><span class="font9" style="font-weight:bold;">CODE LIBRARY</span></p>
</div><br clear="all">
<div>
<p><span class="font0">scale</span></p>
</div><br clear="all">
<p><span class="font2">sub scale {</span></p>
<p><span class="font2" style="font-weight:bold;">my $c = shift;</span></p>
<p><span class="font2">return sub {</span></p>
<p><span class="font2" style="font-weight:bold;">my $s = shift;</span></p>
<p><span class="font2">transform { $_[0] * $c } $s;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">Now </span><span class="font2">scale() </span><span class="font17">is a factory for manufacturing scaling functions. </span><span class="font2">scale(2) </span><span class="font17">returns a function that takes any stream and doubles it; </span><span class="font2">scale(3) </span><span class="font17">returns a function that takes any stream and triples it. We could write </span><span class="font2">$double = scale(2) </span><span class="font17">and then use </span><span class="font2">$double-&gt;($s) </span><span class="font17">to double </span><span class="font2">$s</span><span class="font17">, or </span><span class="font2">scale(2)-&gt;($s) </span><span class="font17">to double </span><span class="font2">$s</span><span class="font17">.</span></p>
<p><span class="font17">If you don’t like the extra arrows in </span><span class="font2">$double-&gt;($s) </span><span class="font17">you can get rid of them by using Perl’s glob feature, as we did in Chapter 3:</span></p>
<p><span class="font2">*double = scale(2);</span></p>
<p><span class="font2">$s2 = double($s);</span></p>
<p><span class="font17">Similarly, in Chapter 6, we defined a </span><span class="font2">slope() </span><span class="font17">function that returned the slope of some other function at a particular point:</span></p>
<p><span class="font2">sub slope {</span></p>
<p><span class="font2">my ($f, $x) = @_;</span></p>
<p><span class="font2">my $e = 0.00000095367431640625;</span></p>
<p><span class="font2">($f-&gt;($x+$e) - $f-&gt;($x-$e)) / (2*$e);</span></p>
<p><span class="font2">}</span></p>
<div>
<p><span class="font17">We could make this more flexible by currying the </span><span class="font2">$x </span><span class="font17">argument:</span></p>
</div><br clear="all">
<div>
<p><span class="font2">sub slope {</span></p>
<p><span class="font2" style="font-weight:bold;">my $f = shift;</span></p>
<p><span class="font2">my $e = 0.00000095367431640625;</span></p>
<p><span class="font2" style="font-weight:bold;">return sub {</span></p>
<p><span class="font2" style="font-weight:bold;">my $x = shift;</span></p>
<p><span class="font2">($f-&gt;($x+$e) - $f-&gt;($x-$e)) / (2*$e);</span></p>
<p><span class="font2" style="font-weight:bold;">};</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">slope() </span><span class="font17">now takes a function and returns its derivative function! By evaluating the derivative function at a particular point, we compute the slope at that point.</span></p>
<p><span class="font17">If we like, we can use Perl’s polymorphism to put both behaviors into the same function:</span></p>
</div><br clear="all">
<div>
<p><span class="font9" style="font-weight:bold;">CODE LIBRARY</span></p>
</div><br clear="all">
<div>
<p><span class="font0">slope0</span></p>
</div><br clear="all">
<div>
<p><span class="font2">sub slope {</span></p>
<p><span class="font2">my $f = shift;</span></p>
<p><span class="font2">my $e = 0.00000095367431640625;</span></p>
<p><span class="font2" style="font-weight:bold;">my $d = sub {</span></p>
<p><span class="font2">my ($x) = shift;</span></p>
<p><span class="font2">($f-&gt;($x+$e) - $f-&gt;($x-$e)) / (2*$e);</span></p>
<p><span class="font2">};</span></p>
<p><span class="font2" style="font-weight:bold;">return @_ ? $d-&gt;(shift) : $d;</span></p>
<p><span class="font2">}</span></p>
</div><br clear="all">
<div>
<p><span class="font9" style="font-weight:bold;">CODE LIBRARY</span></p>
</div><br clear="all">
<div>
<p><span class="font0">slope</span></p>
</div><br clear="all">
<div>
<p><span class="font17">Now we can call </span><span class="font2">slope($f, $x) </span><span class="font17">as before, to compute the slope of </span><span class="font2">$f </span><span class="font17">at the point </span><span class="font2">$x</span><span class="font17">, or we can call </span><span class="font2">slope($f) </span><span class="font17">and get back the derivative function of </span><span class="font2">$f</span><span class="font17">.</span></p>
<p><span class="font17">Currying can be a good habit to get into. Earlier, we wrote:</span></p>
<p><span class="font2">sub iterate_function {</span></p>
<p><span class="font2">my ($f, $x) = @_;</span></p>
<p><span class="font2">my $s;</span></p>
<p><span class="font2">$s = node($x, promise { &amp;transform($f, $s) });</span></p>
<p><span class="font2">}</span></p>
</div><br clear="all">
<div>
<p><span class="font17">But it’s almost as easy to write it this way instead:</span></p>
</div><br clear="all">
<div>
<p><span class="font2">sub iterate_function { </span><span class="font2" style="font-weight:bold;">my $f = shift;</span></p>
</div><br clear="all">
<div>
<p><span class="font9" style="font-weight:bold;">CODE LIBRARY</span></p>
</div><br clear="all">
<div>
<p><span class="font0">iterate_function</span></p>
</div><br clear="all">
<p><span class="font2" style="font-weight:bold;">return sub { my $x = shift; </span><span class="font2">my $s;</span></p>
<p><span class="font2">$s = node($x, promise { &amp;transform($f, $s) });</span></p>
<p><span class="font2" style="font-weight:bold;">};</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">It requires hardly any extra thought to do it this way, and the payoff is substantially increased functionality. We now have a function that manufactures stream-building functions to order. We could construct </span><span class="font2">upfrom() </span><span class="font17">as a special case of </span><span class="font2">iterate_function()</span><span class="font17">; for example:</span></p>
<p><span class="font2">*upfrom = iterate_function(sub { $_[0] + 1 });</span></p>
<p><span class="font17">Or similarly, our earlier example of </span><span class="font2">pow2_from()</span><span class="font17">:</span></p>
<p><span class="font2">*pow2_from = iterate_function(sub { $_[0] * 2 });</span></p>
<p><span class="font17">One final lexical point about currying: When currying a recursive function, it’s often possible to get a small time and memory performance improvement by tightening up the recursion. For example, consider </span><span class="font2">combine2() </span><span class="font17">again:</span></p>
<p><span class="font2">sub combine2 { my $op = shift; return sub { my ($s, $t) = @_; return unless $s &amp;&amp;&nbsp;$t; node($op-&gt;(head($s), head($t)), promise { combine2($op)-&gt;(tail($s), tail($t)) });</span></p>
<p><span class="font2">};</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">combine2($op) </span><span class="font17">will return the same result function every time. So we should be able to get a speed-up by caching its value and using the cached value in the promise instead of repeatedly calling </span><span class="font2">combine2($op)</span><span class="font17">. Moreover, </span><span class="font2">combine2($op) </span><span class="font17">is precisely the value that </span><span class="font2">combine2() </span><span class="font17">is about to return anyway. So we can change this to:</span></p>
<div>
<p><span class="font9" style="font-weight:bold;">CODE LIBRARY</span></p>
</div><br clear="all">
<p class="font2">sub combine2 {</p>
<p><span class="font0"><sup>c</sup>o<sup>mbine2-</sup>s<sup>h</sup>o<sup>r</sup>t<sup>er</sup> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="font2">my $op = shift;</span></p>
<div>
<p><span class="font15">7.2 COMMON HIGHER-ORDER FUNCTIONS</span></p>
</div><br clear="all">
<div>
<h4><a name="bookmark352"></a><span class="font20">333</span></h4>
</div><br clear="all">
<div>
<p><span class="font2" style="font-weight:bold;">my $r;</span></p>
<p><span class="font2" style="font-weight:bold;">$r = sub {</span></p>
<p><span class="font2">my ($s, $t) = @_;</span></p>
<p><span class="font2">return unless $s &amp;&amp;&nbsp;$t;</span></p>
<p><span class="font2">node($op-&gt;(head($s), head($t)),</span></p>
<p><span class="font2" style="font-weight:bold;">promise { $r-&gt;(tail($s), tail($t)) });</span></p>
<p><span class="font2">};</span></p>
<p><span class="font2">}</span></p>
</div><br clear="all">
<div>
<p><span class="font17">Now the promise no longer needs to call </span><span class="font2">combine2()</span><span class="font17">; we’ve cached the value that </span><span class="font2">combine2() </span><span class="font17">is about to return by storing it in </span><span class="font2">$r</span><span class="font17">, and the promise can call </span><span class="font2">$r </span><span class="font17">directly. The code is also easier to understand this way: Now the promise says explicitly that the function will be calling itself on the tails of the two streams.</span></p>
<p><span class="font17">These curried functions are examples of </span><span class="font17" style="font-style:italic;">higher-order functions.</span><span class="font17"> Ordinary functions operate on values: You put some values in, and you get some other values out. Higher-order functions are functions that operate on other functions: You put some functions in, and you get some other functions out. For example, in </span><span class="font2">combine2() </span><span class="font17">we put in a function to operate on two scalars and we got out an analogous function to operate on two streams.</span></p>
</div><br clear="all">
<div>
<h5><a name="bookmark140"></a><span class="font18">7.2 COMMON HIGHER-ORDER FUNCTIONS</span></h5>
</div><br clear="all">
<div>
<p><span class="font17">Probably the two most fundamental higher-order functions for any list or other kind of sequence are analogs of </span><span class="font2">map() </span><span class="font17">and </span><span class="font2">grep()</span><span class="font17">. </span><span class="font2">map() </span><span class="font17">and </span><span class="font2">grep() </span><span class="font17">are higher-order functions because each of them takes an argument that is itself another function. We’ve already seen versions of </span><span class="font2">map() </span><span class="font17">and </span><span class="font2">grep() </span><span class="font17">for iterators and streams. Perl’s standard </span><span class="font2">map() </span><span class="font17">and </span><span class="font2">grep() </span><span class="font17">each take a function and a list and return a new list; for example:</span></p>
</div><br clear="all">
<div>
<p><span class="font2">map { $_ * 2 } (1..5); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# returns 2, 4, 6, 8, 10</span></p>
<p><span class="font2">grep { $_ % 2 == 0 } (1..10); &nbsp;&nbsp;&nbsp;&nbsp;# returns 2, 4, 6, 8, 10</span></p>
<p><span class="font17">Often it’s more convenient to have curried versions of these functions:</span></p>
</div><br clear="all">
<div>
<p><span class="font2">sub cmap (&amp;) { my $f = shift; my $r = sub {</span></p>
</div><br clear="all">
<div>
<p><span class="font9" style="font-weight:bold;">CODE LIBRARY</span></p>
</div><br clear="all">
<div>
<p><span class="font0">cmap</span></p>
</div><br clear="all">
<p><span class="font2">my ©result;</span></p>
<p><span class="font2">for (©_) {</span></p>
<p><span class="font2">push @result, $f-&gt;($_);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">@result;</span></p>
<p><span class="font2">};</span></p>
<p><span class="font2">return $r;</span></p>
<p><span class="font2">}</span></p>
<div>
<p><span class="font9" style="font-weight:bold;">CODE LIBRARY</span></p>
</div><br clear="all">
<div>
<p><span class="font0">cgrep</span></p>
</div><br clear="all">
<p><span class="font2">sub cgrep (&amp;) {</span></p>
<p><span class="font2">my $f = shift;</span></p>
<p><span class="font2">my $r = sub {</span></p>
<p><span class="font2">my @result;</span></p>
<p><span class="font2">for (©_) {</span></p>
<p><span class="font2">push @result, $_ if $f-&gt;($_);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">@result;</span></p>
<p><span class="font2">};</span></p>
<p><span class="font2">return $r;</span></p>
<p><span class="font2">}</span></p>
<h6><a name="bookmark353"></a><span class="font17">These functions should be called like this:</span></h6>
<p><span class="font2">Sdouble = cmap { $_ * 2 };</span></p>
<p><span class="font2">$find_slashdot = cgrep { $_-&gt;{referer} =- /slashdot/i };</span></p>
<p><span class="font17">After which </span><span class="font2">$double-&gt;(1..5) </span><span class="font17">returns (2, 4, 6, 8, 10) and </span><span class="font2">$find_slashdot -&gt;(weblog()) </span><span class="font17">returns the web log records that represent referrals from Slashdot.</span></p>
<p><span class="font17">It may be tempting to try to make </span><span class="font2">cmap() </span><span class="font17">and </span><span class="font2">cgrep() </span><span class="font17">polymorphic, as we did with </span><span class="font2">slope() </span><span class="font17">(I was tempted, anyway.):</span></p>
<p><span class="font2" style="font-weight:bold;">sub cmap (&amp;;@) {</span></p>
<p><span class="font2">my $f = shift;</span></p>
<p><span class="font2">my $r = sub {</span></p>
<p><span class="font2">my ©result;</span></p>
<p><span class="font2">for (©_) {</span></p>
<p><span class="font2">push ©result, $f-&gt;($_);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">©result;</span></p>
<p><span class="font2">};</span></p>
<div>
<p><span class="font15">7.2 COMMON HIGHER-ORDER FUNCTIONS</span></p>
</div><br clear="all">
<div>
<h4><a name="bookmark354"></a><span class="font20">335</span></h4>
</div><br clear="all">
<div>
<p><span class="font17">Then we would also be able to use </span><span class="font2">cmap() </span><span class="font17">and </span><span class="font2">cgrep() </span><span class="font17">like regular </span><span class="font2">map() </span><span class="font17">and </span><span class="font2">grep()</span><span class="font17">:</span></p>
<p><span class="font2">©doubles = cmap { $_ * 2 } (1..5);</span></p>
<p><span class="font2">@evens = cgrep { $_ % 2 == 0 } (1..10);</span></p>
<p><span class="font17">Unfortunately, this apparently happy notation hides an evil surprise:</span></p>
<p><span class="font2">©doubles = cmap { $_ * 2 } ©some_array;</span></p>
<p><span class="font17">If</span><span class="font2">©some_array </span><span class="font17">is empty, </span><span class="font2">©doubles </span><span class="font17">is assigned a reference to a doubling function.</span></p>
</div><br clear="all">
<div>
<h5><a name="bookmark141"></a><span class="font19">7.2.1 Automatic Currying</span></h5>
<p><span class="font17">We’ve written the same code several times to implement curried functions:</span></p>
<p><span class="font2">sub some_curried_function { my $first_arg = shift;</span></p>
<p><span class="font2">my $r = sub {</span></p>
</div><br clear="all">
<div>
<p><span class="font2">};</span></p>
<p><span class="font2">return ©_ ? $r-&gt;(©_) : $r;</span></p>
<p><span class="font2">}</span></p>
</div><br clear="all">
<div>
<p><span class="font17">(Possibly with the polymorphism trick omitted from the final line.)</span></p>
<p><span class="font17">As usual, once we recognize this pattern, we should see if it makes sense to abstract it into a function:</span></p>
</div><br clear="all">
<div>
<p><span class="font2">package Curry;</span></p>
<p><span class="font2">use base 'Exporter';</span></p>
<p><span class="font2">©EXPORT = ('curry');</span></p>
<p><span class="font2">©EXPORT_OK = qw(curry_listfunc curry_n);</span></p>
</div><br clear="all">
<div>
<p><span class="font9" style="font-weight:bold;">CODE LIBRARY</span></p>
</div><br clear="all">
<div>
<p><span class="font0">Curry.pm</span></p>
</div><br clear="all">
<div>
<p><span class="font2">sub curry {</span></p>
<p><span class="font2">my $f = shift;</span></p>
<p><span class="font2">return sub {</span></p>
<p><span class="font2">my $first_arg = shift;</span></p>
<p><span class="font2">my $r = sub { $f-&gt;($first_arg, ©_) };</span></p>
</div><br clear="all">
<p><span class="font2">return @_ ? $r-&gt;(@_) : Sr;</span></p>
<p><span class="font2">};</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">sub curry_listfunc {</span></p>
<p><span class="font2">my Sf = shift;</span></p>
<p><span class="font2">return sub {</span></p>
<p><span class="font2">my Sfirst_arg = shift;</span></p>
<p><span class="font2">return sub { Sf-&gt;(Sfirst_arg, @_) };</span></p>
<p><span class="font2">};</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">1;</span></p>
<h6><a name="bookmark355"></a><span class="font2">curry() </span><span class="font17">takes any function and returns a curried version of that function. For example, consider the </span><span class="font2">imap() </span><span class="font17">function from Chapter 4:</span></h6>
<p><span class="font2">sub imap (&amp;$) {</span></p>
<p><span class="font2">my (Stransform, Sit) = @_;</span></p>
<p><span class="font2">return sub {</span></p>
<p><span class="font2">my Snext = NEXTVAL(Sit);</span></p>
<p><span class="font2">return unless defined Snext;</span></p>
<p><span class="font2">return Stransform-&gt;(Snext);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
<h6><a name="bookmark356"></a><span class="font2">imap() </span><span class="font17">is analogous to </span><span class="font2">map()</span><span class="font17">, but operates on iterators rather than on lists. We might use it like this:</span></h6>
<p><span class="font2">my Sdoubles_iterator = imap { S_[0] * 2 } Sit;</span></p>
<h6><a name="bookmark357"></a><span class="font17">If we end up doubling a lot of iterators, we have to repeat the </span><span class="font2">{S_[0] * 2} </span><span class="font17">part:</span></h6>
<p><span class="font2">my Sdoubles_a = imap { S_[0] * 2 } Sit_a;</span></p>
<p><span class="font2">my Sdoubles_b = imap { S_[0] * 2 } Sit_b;</span></p>
<p><span class="font2">my Sdoubles_c = imap { S_[0] * 2 } Sit_c;</span></p>
<h6><a name="bookmark358"></a><span class="font17">We might wish we had a single, special-purpose function for doubling every element of an iterator, so that we could write instead:</span></h6>
<p><span class="font2">my Sdoubles_a = double Sit_a;</span></p>
<p><span class="font2">my Sdoubles_b = double Sit_b;</span></p>
<p><span class="font2">my Sdoubles_c = double Sit_c;</span></p>
<ul style="list-style:none;"><li>
<p class="font15">7.2 COMMON HIGHER-ORDER FUNCTIONS</p>
<div>
<p><span class="font20">337</span></p>
</div><br clear="all"></li></ul>
<p><span class="font17">or even:</span></p>
<p><span class="font2">my ($doubles_a, $doubles_b, $doubles_c) = map double($_), $it_a, $it_b, $it_c;</span></p>
<p><span class="font17">If we had written </span><span class="font2">imap() </span><span class="font17">in a curried style, we could have done:</span></p>
<p><span class="font2">*double = imap { $_[0] * 2 };</span></p>
<p><span class="font17">but we didn’t, so we can’t. But that’s no problem, because </span><span class="font2">curry() </span><span class="font17">will manufacture a curried version of </span><span class="font2">imap() </span><span class="font17">on the fly:</span></p>
<p><span class="font2">*double = curry(\&amp;imap)-&gt;(sub { $_[0] * 2 });</span></p>
<p><span class="font17">Since the curried </span><span class="font2">imap() </span><span class="font17">function came in handy once, perhaps we should keep it around in case we need it again:</span></p>
<p><span class="font2">*c_imap = curry(\&amp;imap);</span></p>
<p><span class="font17">Then to manufacture </span><span class="font2">double() </span><span class="font17">we do:</span></p>
<p><span class="font2">*double = c_imap(sub { $_[0] * 2 });</span></p>
<ul style="list-style:none;"><li>
<h5><a name="bookmark142"></a><span class="font19">7.2.2 Prototypes</span></h5></li></ul>
<p><span class="font17">The only drawback of this approach is that we lose </span><span class="font2">imap()</span><span class="font17">’s pretty calling syntax, which is enabled by the </span><span class="font2">(&amp;@) </span><span class="font17">prototype at compile time. We can get it back, although the results are somewhat peculiar. First, we modify </span><span class="font2">curry() </span><span class="font17">so that the function it manufactures has the appropriate prototype:</span></p>
<p><span class="font2">sub curry {</span></p>
<p><span class="font2">my $f = shift;</span></p>
<p><span class="font2" style="font-weight:bold;">return sub (&amp;;@) {</span></p>
<p><span class="font2">my $first_arg = shift;</span></p>
<p><span class="font2">my $r = sub { $f-&gt;($first_arg, @_) };</span></p>
<p><span class="font2">return @_ ? $r-&gt;(@_) : $r;</span></p>
<p><span class="font2">};</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">Then we </span><span class="font2">call curry() </span><span class="font17">at compile time instead of at run time:</span></p>
<p><span class="font2">BEGIN { *c_imap = curry (\&amp;imap); }</span></p>
<p><span class="font17">Now we can say:</span></p>
<p><span class="font2">*double = c_imap { $_[0] * 2 };</span></p>
<p><span class="font17">and we can still use </span><span class="font2">c_imap() </span><span class="font17">in place of regular </span><span class="font2">imap()</span><span class="font17">:</span></p>
<p><span class="font2">$doubles_a = c_imap { $_[0] * 2 } $it_a;</span></p>
<p><span class="font17">PROTOTYPE PROBLEMS</span></p>
<p><span class="font17">The problem with this technique is that the prototype must be hardwired into </span><span class="font2">curry()</span><span class="font17">, so now it will generate </span><span class="font17" style="font-style:italic;">only</span><span class="font17"> curried functions with the prototype </span><span class="font2">(&amp;;@)</span><span class="font17">. This isn’t a problem for functions like </span><span class="font2">c_imap() </span><span class="font17">or </span><span class="font2">c_grep()</span><span class="font17">, which would have had that prototype anyway. But that prototype is inappropriate for the curried version of the </span><span class="font2">scale() </span><span class="font17">function from Chapter 6. The uncurried version was:</span></p>
<p><span class="font2">sub scale {</span></p>
<p><span class="font2">my ($s, $c) = @_;</span></p>
<p><span class="font2">$s-&gt;transform(sub { $_[0]*$c });</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">curry(\&amp;scale) </span><span class="font17">returns a function that behaves like this:</span></p>
<p><span class="font2">sub {</span></p>
<p><span class="font2">my $s = shift;</span></p>
<p><span class="font2">my $r = sub { scale($s, @_) };</span></p>
<p><span class="font2">return @_ ? $r-&gt;(@_) : $r;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">The internals of this function are correct, and it will work just fine, as long as it </span><span class="font17" style="font-style:italic;">doesn’t have</span><span class="font17"> a </span><span class="font2">(&amp;;@) </span><span class="font17">prototype. Such a prototype would be inappropriate, since the function is expecting to get one or two scalar arguments. The correct prototype would be </span><span class="font2">($;$)</span><span class="font17">. But if we did:</span></p>
<p><span class="font2">BEGIN { *c_scale = curry(\&amp;scale) }</span></p>
<p><span class="font17">then the resulting </span><span class="font2">c_scale() </span><span class="font17">function wouldn’t work, because it would have a </span><span class="font2">(&amp;;@) </span><span class="font17">prototype when we expected to call it as though it had a </span><span class="font2">($;$) </span><span class="font17">prototype.</span></p>
<ul style="list-style:none;"><li>
<p class="font15">7.2 COMMON HIGHER-ORDER FUNCTIO</p>
<div>
<p><span class="font15" style="font-variant:small-caps;">ns</span><span class="font20"> 339</span></p>
</div><br clear="all"></li></ul>
<p><span class="font17">We want to call it in one of these two ways:</span></p>
<p><span class="font2">my Sdouble = c_scale(2);</span></p>
<p><span class="font2">my Sdoubled_it = c_scale(2, Sit);</span></p>
<p><span class="font17">but because </span><span class="font2">c_scale() </span><span class="font17">would have a prototype of </span><span class="font2">(&amp;;@)</span><span class="font17">, these both would be syntax errors, yielding:</span></p>
<p><span class="font2">Type of arg 1 to main::c_scale must be block or sub {} (not constant item)...</span></p>
<p><span class="font17">This isn’t a show-stopper. This works:</span></p>
<p><span class="font2">*c_scale = curry(\&amp;scale);</span></p>
<p><span class="font2">my Sdouble = c_scale(2);</span></p>
<p><span class="font2">my Sdoubled_it = c_scale(2, Sit);</span></p>
<p><span class="font17">Here the call to </span><span class="font2">c_scale() </span><span class="font17">is compiled, with no prototype, before </span><span class="font2">*c_scale </span><span class="font17">is assigned to; the call to </span><span class="font2">curry() </span><span class="font17">that sets up the bad prototype occurs too late to foul up our attempt to (correctly) call </span><span class="font2">c_scale()</span><span class="font17">.</span></p>
<p><span class="font17">But now we have a somewhat confusing situation. Our </span><span class="font2">curry() </span><span class="font17">function creates curried functions with </span><span class="font2">(&amp;;@) </span><span class="font17">prototypes, and these prototypes may be inappropriate. But the prototypes are inoperative unless </span><span class="font2">curry() </span><span class="font17">is called in a </span><span class="font2">BEGIN </span><span class="font17">block. To add to the confusion, this doesn’t work:</span></p>
<p><span class="font2">*c_scale = curry(\&amp;scale);</span></p>
<p><span class="font2">my Sdouble = eval 'c_scale(2)';</span></p>
<p><span class="font17">because, once again, the call to </span><span class="font2">c_scale() </span><span class="font17">has been compiled after the prototype was set up by </span><span class="font2">curry()</span><span class="font17">.</span></p>
<p><span class="font17">There isn’t really any easy way to fix this. The obvious thing to do is to tell </span><span class="font2">curry() </span><span class="font17">what prototype we desire by supplying it with an optional parameter:</span></p>
<p><span class="font2"># Doesn’t really work sub curry {</span></p>
<p><span class="font2">my Sf = shift;</span></p>
<p><span class="font2" style="font-weight:bold;">my SPROTOTYPE = shift;</span></p>
<p><span class="font2" style="font-weight:bold;">return sub (SPROTOTYPE) {</span></p>
<p><span class="font2">my Sfirst_arg = shift;</span></p>
<p><span class="font2">my Sr = sub { Sf-&gt;(Sfirst_arg, @_) };</span></p>
<p><span class="font2">return @_ ? Sr-&gt;(@_) : Sr;</span></p>
<p><span class="font2">};</span></p>
<p><span class="font2">}</span></p>
<div>
<h4><a name="bookmark359"></a><span class="font20">340</span></h4>
</div><br clear="all">
<div>
<p><span class="font15">CHAPTER 7 Higher-Order Functions and Currying</span></p>
</div><br clear="all">
<div>
<p><span class="font17">Unfortunately, this is illegal; </span><span class="font2">(SPROTOTYPE) </span><span class="font17" style="font-style:italic;">does not</span><span class="font17"> indicate that the desired prototype is stored in </span><span class="font2">SPROTOTYPE</span><span class="font17">. Perl 5.8.1 provides a </span><span class="font2">Scalar::Util::set_prototype </span><span class="font17">function to set the prototype of a particular function:</span></p>
</div><br clear="all">
<div>
<p><span class="font9" style="font-weight:bold;">CODE LIBRARY</span></p>
</div><br clear="all">
<div>
<p><span class="font0">curry-set_proto</span></p>
</div><br clear="all">
<div>
<p><span class="font2"># Doesn’t work before 5.8.1</span></p>
<p><span class="font2" style="font-weight:bold;">use Scalar::Util 'set_prototype';</span></p>
<p><span class="font2">sub curry {</span></p>
<p><span class="font2">my Sf = shift;</span></p>
<p><span class="font2">my SPROTOTYPE = shift;</span></p>
<p><span class="font2" style="font-weight:bold;">set_prototype(sub {</span></p>
<p><span class="font2">my Sfirst_arg = shift;</span></p>
<p><span class="font2">my Sr = sub { Sf-&gt;(Sfirst_arg, @_) }; return @_ ? Sr-&gt;(@_) : Sr;</span></p>
<p><span class="font2" style="font-weight:bold;">}, SPROTOTYPE);</span></p>
<p><span class="font2">}</span></p>
</div><br clear="all">
<div>
<p><span class="font17">If you don’t have 5.8.1 yet, the only way to dynamically specify the prototype of a function is to use string </span><span class="font2">eval</span><span class="font17">:</span></p>
</div><br clear="all">
<div>
<p><span class="font9" style="font-weight:bold;">CODE LIBRARY</span></p>
</div><br clear="all">
<div>
<p><span class="font0">curry_eval</span></p>
</div><br clear="all">
<div>
<p><span class="font2">sub curry {</span></p>
<p><span class="font2">my Sf = shift;</span></p>
<p><span class="font2">my SPROTOTYPE = shift;</span></p>
<p><span class="font2" style="font-weight:bold;">SPROTOTYPE = &quot;(SPROTOTYPE)&quot; if defined SPROTOTYPE; my SCODE = q{sub PROTOTYPE {</span></p>
<p><span class="font2">my Sfirst_arg = shift;</span></p>
<p><span class="font2">my Sr = sub { Sf-&gt;(Sfirst_arg, @_) }; return @_ ? Sr-&gt;((@_) : Sr;</span></p>
<p><span class="font2" style="font-weight:bold;">}};</span></p>
<p><span class="font2" style="font-weight:bold;">SCODE =</span><span class="font2">- </span><span class="font2" style="font-weight:bold;">s/PROTOTYPE/SPROTOTYPE/;</span></p>
<p><span class="font2" style="font-weight:bold;">eval SCODE;</span></p>
</div><br clear="all">
<div>
<h5><a name="bookmark144"></a><span class="font19">7.2.3 More Currying</span></h5>
<p><span class="font17">We can extend the idea of </span><span class="font2">curry() </span><span class="font17">and build a function that generates a generic curried version of another function:</span></p>
</div><br clear="all">
<div>
<p><span class="font2">sub curry_n {</span></p>
<p><span class="font2">my SN = shift;</span></p>
<p><span class="font2">my Sf = shift;</span></p>
</div><br clear="all">
<ul style="list-style:none;"><li>
<p class="font15">7.2 COMMON HIGHER-ORDER FUNCTIONS</p></li></ul>
<p><span class="font2">my Sc;</span></p>
<p><span class="font2">Sc = sub {</span></p>
<p><span class="font2">if (@_ &gt;= SN) { $f-&gt;(@_) }</span></p>
<p><span class="font2">else {</span></p>
<p><span class="font2">my @a = @_;</span></p>
<p><span class="font2">curry_n($N-@a, sub { $f-&gt;(@a, @_) });</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">};</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">curry_n() </span><span class="font17">takes two arguments: a number </span><span class="font17" style="font-style:italic;">N,</span><span class="font17"> and a function </span><span class="font17" style="font-style:italic;">f,</span><span class="font17"> which expects at least </span><span class="font17" style="font-style:italic;">N</span><span class="font17"> arguments. The result is a new function, </span><span class="font17" style="font-style:italic;">c,</span><span class="font17"> which does the same thing </span><span class="font17" style="font-style:italic;">f</span><span class="font17"> does, but which accepts curried arguments. If </span><span class="font17" style="font-style:italic;">c</span><span class="font17"> is called with </span><span class="font17" style="font-style:italic;">N</span><span class="font17">or more arguments, it just passes them on to </span><span class="font17" style="font-style:italic;">f</span><span class="font17"> and returns the result. If there are fewer than </span><span class="font17" style="font-style:italic;">N</span><span class="font17"> arguments, </span><span class="font17" style="font-style:italic;">c</span><span class="font17"> generates a new function that remembers the arguments that were passed; if this new function is called with the remaining arguments, both old and new arguments are given to </span><span class="font17" style="font-style:italic;">f</span><span class="font17">. For example:</span></p>
<p><span class="font2">*add = curry_n(2, sub { S_[0] + S_[1] });</span></p>
<p><span class="font17">And now we can call:</span></p>
<p><span class="font2">add(2, 3); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Returns 5</span></p>
<p><span class="font17">or:</span></p>
<p><span class="font2">*increment = add(1);</span></p>
<p><span class="font2">increment(8); # return 9</span></p>
<p><span class="font17">or perhaps more realistically:</span></p>
<p><span class="font2">*csubstr = curry_n(3, sub { defined S_[3] ?</span></p>
<p><span class="font2">substr($_[0], $_[1], $_[2], $_[3]) : substr($_[0], $_[1], $_[2]) });</span></p>
<p><span class="font17">Then we can use any of:</span></p>
<p><span class="font2">Starget = &quot;I like pie&quot;;</span></p>
<p><span class="font15" style="font-style:italic;"># Just like regular substr</span></p>
<p><span class="font2">Sss = csubstr(Starget, Sstart, Slength);</span></p>
<p><span class="font2">csubstr(Starget, Sstart, Slength, Sreplacement);</span></p>
<div>
<p><span class="font20">341</span></p>
</div><br clear="all">
<table border="1">
<tr><td>
<p><span class="font20">342</span></p></td><td style="vertical-align:bottom;">
<p><span class="font15">CHAPTER 7 Higher-Order Functions and Currying</span></p>
<ul style="list-style:none;"><li>
<p><span class="font15" style="font-style:italic;"># Not just like regular substr</span></p></li>
<li>
<p><span class="font15" style="font-style:italic;"># This '$part' function gets two arguments: a start position</span></p></li>
<li>
<p><span class="font15" style="font-style:italic;"># and a length; it returns the appropriate part of$target.</span></p></li></ul>
<p><span class="font2">Spart = csubstr(Starget);</span></p>
<p><span class="font2">my Sss = Spart-&gt;(Sstart, Slength);</span></p>
<ul style="list-style:none;"><li>
<p><span class="font15" style="font-style:italic;"># This function gets an argument N and returns that many characters</span></p></li>
<li>
<p><span class="font15" style="font-style:italic;"># from the beginning of$target.</span></p></li></ul>
<p><span class="font2">Sfirst_N_chars = csubstr(Starget, 0);</span></p>
<p><span class="font2">my Sprefix_3 = Sfirst_N_chars-&gt;(3); &nbsp;&nbsp;&nbsp;&nbsp;# &quot;I l&quot;</span></p>
<p><span class="font2">my Sprefix_7 = Sfirst_N_chars-&gt;(7); &nbsp;&nbsp;&nbsp;&nbsp;# &quot;I like &quot;</span></p></td></tr>
</table>
<ul style="list-style:none;"><li>
<h5><a name="bookmark145"></a><span class="font19">7.2.4 Yet More Currying</span></h5></li></ul>
<h6><a name="bookmark360"></a><span class="font17">Many of the functions we saw earlier in the book would benefit from currying. For example, </span><span class="font2">dir_walk() </span><span class="font17">from Chapter 1:</span></h6>
<p><span class="font2">sub dir_walk {</span></p>
<p><span class="font2">my (Stop, Sfilefunc, Sdirfunc) = @_;</span></p>
<p><span class="font2">my SDIR;</span></p>
<p><span class="font2">if (-d Stop) { my Sfile;</span></p>
<p><span class="font2">unless (opendir SDIR, Stop) {</span></p>
<p><span class="font2">warn &quot;Couldn’t open directory Scode: S!; skipping.\n&quot;;</span></p>
<p><span class="font2">return;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">my ©results;</span></p>
<p><span class="font2">while (Sfile = readdir SDIR) {</span></p>
<p><span class="font2">next if Sfile eq '.' || Sfile eq '..';</span></p>
<p><span class="font2">push ©results, dir_walk(&quot;Stop/Sfile&quot;, Sfilefunc, Sdirfunc);</span></p>
<p><span class="font2">} return Sdirfunc-&gt;(Stop, ©results);</span></p>
<p><span class="font2">} else { return Sfilefunc-&gt;(Stop);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">Here we specify a top directory and two callback functions. But the callback functions are constant through any call to </span><span class="font2">dir_walk()</span><span class="font17">, and we might like to specify them in advance, because we might know them well before we know which directories we want to search. The conversion is easy:</span></p>
<p><span class="font2">sub dir_walk {</span></p>
<div>
<p><span class="font9" style="font-weight:bold;">CODE LIBRARY</span></p>
</div><br clear="all">
<p><span class="font2" style="font-weight:bold;">unshift ©_, undef if ©_ &lt;&nbsp;3; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="font0">dir-raU-curried</span></p>
<p><span class="font2">my (Stop, Sfilefunc, Sdirfunc) = @_;</span></p>
<p><span class="font2" style="font-weight:bold;">my Sr;</span></p>
<p><span class="font2" style="font-weight:bold;">Sr = sub {</span></p>
<p><span class="font2">my SDIR;</span></p>
<p><span class="font2" style="font-weight:bold;">my Stop = shift;</span></p>
<p><span class="font2">if (-d Stop) {</span></p>
<p><span class="font2">my Sfile;</span></p>
<p><span class="font2">unless (opendir SDIR, Stop) {</span></p>
<p><span class="font2">warn &quot;Couldn’t open directory Scode: $!; skipping.\n&quot;;</span></p>
<p><span class="font2">return;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">my ©results;</span></p>
<p><span class="font2">while (Sfile = readdir SDIR) {</span></p>
<p><span class="font2">next if Sfile eq '.' || Sfile eq '..';</span></p>
<p><span class="font2" style="font-weight:bold;">push ©results, Sr-&gt;(&quot;Stop/Sfile&quot;);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">return Sdirfunc-&gt;(Stop, ©results);</span></p>
<p><span class="font2">} else {</span></p>
<p><span class="font2">return Sfilefunc-&gt;(Stop);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">};</span></p>
<p><span class="font2" style="font-weight:bold;">defined(Stop) ? Sr-&gt;(Stop) : Sr;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">We can still call </span><span class="font2">dir_walk</span><span class="font17">(</span><span class="font2">Stop, Sfilefunc, Sdirfunc</span><span class="font17">) and get the same result, or we can omit the </span><span class="font2">Stop </span><span class="font17">argument (or pass </span><span class="font2">undef</span><span class="font17">) and get back a specialized filewalking function. As a minor added bonus, the recursive call will be fractionally more efficient because the callback arguments don’t need to be explicitly passed.</span></p>
<p><span class="font18">7.3 </span><span class="font3">reduce() </span><span class="font18">AND </span><span class="font3">combine()</span></p>
<p><span class="font17">The standard Perl </span><span class="font2">List::Util </span><span class="font17">module provides several commonly requested functions that are not built-in to Perl. These include </span><span class="font2">max() </span><span class="font17">and </span><span class="font2">min() </span><span class="font17">functions,</span></p>
<div>
<p><span class="font20">344</span></p>
</div><br clear="all">
<p><span class="font15">CHAPTER 7 Higher-Order Functions and Currying</span></p>
<p><span class="font17">which respectively return the largest and smallest numbers in their argument lists, </span><span class="font2">maxstr() </span><span class="font17">and </span><span class="font2">minstr()</span><span class="font17">, which are the analogous functions for strings; and </span><span class="font2">sum()</span><span class="font17">, which returns the sum of the numbers in a list.</span></p>
<p><span class="font17">If we write sample code for these five functions, we’ll see the similarity immediately:</span></p>
<p><span class="font2">sub max { my Smax = shift;</span></p>
<p><span class="font2">for (@_) { Smax = $_ &gt;&nbsp;Smax ? $_ : Smax }</span></p>
<p><span class="font2">return Smax;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">sub min { my Smin = shift;</span></p>
<p><span class="font2">for (@_) { Smin = $_ &lt;&nbsp;Smin ? $_ : Smin }</span></p>
<p><span class="font2">return Smin;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">sub maxstr { my Smax = shift;</span></p>
<p><span class="font2">for (@_) { Smax = $_ gt Smax ? $_ : Smax } return Smax;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">sub minstr { my Smin = shift;</span></p>
<p><span class="font2">for (@_) { Smin = $_ It Smin ? $_ : Smin } return Smin;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">sub sum { my Ssum = shift;</span></p>
<p><span class="font2">for (@_) { Ssum = Ssum + $_ }</span></p>
<p><span class="font2">return Ssum;</span></p>
<p><span class="font2">}</span></p>
<h6><a name="bookmark361"></a><span class="font17">Generalizing this gives us the </span><span class="font2">reduce() </span><span class="font17">function that is also provided by </span><span class="font2">List::Util</span><span class="font17">:</span></h6>
<p><span class="font2">sub reduce { my Scode = shift;</span></p>
<p><span class="font2">my Sval = shift;</span></p>
<p><span class="font2">for (@_) { Sval = Scode-&gt;(Sval, $_) } return Sval;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">(</span><span class="font2">List::Util::reduce </span><span class="font17">is actually written in C for speed, but what it does is equivalent to this Perl code.) The idea is that the function will scan the list one element</span></p>
<ul style="list-style:none;"><li>
<p class="font15">7.3 <span class="font2">reduce() </span><span class="font15" style="font-variant:small-caps;">and</span><span class="font2"> combine() </span><span class="font20">345</span></p></li></ul>
<p><span class="font17">at a time, accumulating a “total” of some sort. We provide a function (</span><span class="font2">$code</span><span class="font17">) that says how to compute the new total, given the old total (first argument) and the current element (second argument). If our goal is just to add up all the list elements, then we compute the total at each stage by adding the previous total to the current element:</span></p>
<p><span class="font2">reduce(sub { $_[0] + $_[1] }, @VALUES) == sum(@VALUES)</span></p>
<p><span class="font17">If our goal is to find the maximum element, then the “total” is actually the maximum so far. Then we compute the total at each stage by taking whichever of the current maximum and the current element is larger:</span></p>
<p><span class="font2">reduce(sub { $_[0] &gt;&nbsp;$_[1] ? $_[0] : $_[1] }, @VALUES) == max(@VALUES)</span></p>
<p><span class="font17">The </span><span class="font2">reduce() </span><span class="font17">function provided by </span><span class="font2">List::Util </span><span class="font17">is easier to call than the preceding one. It places the total-so-far in </span><span class="font2">$a </span><span class="font17">and the current list element into </span><span class="font2">$b </span><span class="font17">before invoking the callback, so that we can write:</span></p>
<p><span class="font2">reduce(sub { $a + $b }, @VALUES)</span></p>
<p><span class="font2">reduce(sub { $a &gt;&nbsp;$b ? $a : $b }, @VALUES)</span></p>
<p><span class="font17">We saw how to make this change back in Section 4.4, when we arranged to have </span><span class="font2">imap()</span><span class="font17">’s callback invoked with the current iterator value in </span><span class="font2">$_ </span><span class="font17">in addition to </span><span class="font2">$_[0]</span><span class="font17">; this allowed it to have a more </span><span class="font2">map()</span><span class="font17">-like calling syntax. We can arrange </span><span class="font2">reduce() </span><span class="font17">similarly:</span></p>
<p><span class="font2">sub reduce (&amp;@) {</span></p>
<p><span class="font2">my $code = shift;</span></p>
<p><span class="font2">my $val = shift;</span></p>
<p><span class="font2">for (@_) {</span></p>
<p><span class="font2" style="font-weight:bold;">local ($a, $b) = ($val, $_);</span></p>
<p><span class="font2">$val = $code-&gt;($val, $_)</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">return $val;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">Here we’re using the global variables </span><span class="font2">$a </span><span class="font17">and </span><span class="font2">$b </span><span class="font17">to pass the total and the current list element. Use of global variables normally causes a compile-time failure under </span><span class="font2">strict 'vars'</span><span class="font17">, but there is a special exemption for the variables </span><span class="font2">$a </span><span class="font17">and </span><span class="font2">$b</span><span class="font17">. The exemption is there to allow usages just like this one, and in particular to support the analogous feature of Perl’s built-in </span><span class="font2">sort() </span><span class="font17">function. The </span><span class="font2">List::Util </span><span class="font17">version of </span><span class="font2">reduce() </span><span class="font17">already has this feature built in.</span></p>
<div>
<p><span class="font20">346</span></p>
</div><br clear="all">
<p><span class="font15">CHAPTER 7 Higher-Order Functions and Currying</span></p>
<p><span class="font17">If we curry the </span><span class="font2">reduce() </span><span class="font17">function, we can use it to </span><span class="font17" style="font-style:italic;">manufacture</span><span class="font17"> functions like </span><span class="font2">sum() </span><span class="font17">and </span><span class="font2">max()</span><span class="font17">:</span></p>
<p><span class="font2">BEGIN {</span></p>
<p><span class="font2">*reduce = curry(\&amp;List::Util::reduce);</span></p>
<p><span class="font2">*sum = reduce { $a + $b };</span></p>
<p><span class="font2">*max = reduce { $a &gt;&nbsp;$b ? $a : $b };</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">This version of </span><span class="font2">reduce() </span><span class="font17">isn’t quite as general as it could be. All the functions manufactured by </span><span class="font2">reduce() </span><span class="font17">have one thing in common: Given an empty list of arguments, they always return </span><span class="font2">undef</span><span class="font17">. For </span><span class="font2">max() </span><span class="font17">and </span><span class="font2">min() </span><span class="font17">this may be appropriate, but for </span><span class="font2">sum() </span><span class="font17">it’s wrong; the sum of an empty list should be taken to be 0. (The </span><span class="font2">sum() </span><span class="font17">function provided by </span><span class="font2">List::Util </span><span class="font17">also has this defect.) This small defect masks a larger one: When the argument list is nonempty, our version of </span><span class="font2">reduce() </span><span class="font17">assumes that the total should be initialized to the first data item. This happens to work for </span><span class="font2">sum() </span><span class="font17">and </span><span class="font2">max()</span><span class="font17">, but it isn’t appropriate for all functions. </span><span class="font2">reduce </span><span class="font17">can be made much more general if we drop this assumption. As a trivial example, suppose we want a function to produce the length of a list. This is </span><span class="font17" style="font-style:italic;">almost</span><span class="font17"> what we want:</span></p>
<p><span class="font2">reduce { $a + 1 };</span></p>
<p><span class="font17">But it only produces the correct length when given a list whose first element is 1, since otherwise </span><span class="font2">$val </span><span class="font17">is incorrectly initialized. A more general version of </span><span class="font2">reduce() </span><span class="font17">accepts an explicit parameter to say what value should be returned for an empty list:</span></p>
<p><span class="font2" style="font-weight:bold;">sub reduce (&amp;$@) {</span></p>
<p><span class="font2">my $code = shift;</span></p>
<p><span class="font2">my $val = shift;</span></p>
<p><span class="font2">for (@_) {</span></p>
<p><span class="font2">local ($a, $b) = ($val, $_);</span></p>
<p><span class="font2">$val = $code-&gt;($val, $_)</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">return $val;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">A version with optional currying is:</span></p>
<div>
<p><span class="font9" style="font-weight:bold;">CODE LIBRARY</span></p>
</div><br clear="all">
<div>
<p><span class="font0">reduce</span></p>
</div><br clear="all">
<p><span class="font2">sub reduce (&amp;;$@) { my $code = shift;</span></p>
<p><span class="font2">my $f = sub {</span></p>
<p><span class="font2">my $base_val = shift;</span></p>
<p><span class="font2">my $g = sub {</span></p>
<p><span class="font2">my $val = $base_val;</span></p>
<p><span class="font2">for (@_) {</span></p>
<p><span class="font2">local ($a, $b) = ($val, $_);</span></p>
<p><span class="font2">$val = $code-&gt;($val, $_);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">return $val;</span></p>
<p><span class="font2">};</span></p>
<p><span class="font2">@_ ? $g-&gt;(@_) : $g;</span></p>
<p><span class="font2">};</span></p>
<p><span class="font2">@_ ? $f-&gt;(@_) : $f;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">The list-length function is now:</span></p>
<p><span class="font2">*listlength = reduce { $a + 1 } 0;</span></p>
<p><span class="font17">where the </span><span class="font2">0 </span><span class="font17">here is the correct result for an empty list. Similarly,</span></p>
<p><span class="font2">*product = reduce { $a * $b } 1;</span></p>
<p><span class="font17">is a function that multiplies all the elements in a list of numbers. We can even use </span><span class="font2">reduce() </span><span class="font17">to compute both at the same time:</span></p>
<p><span class="font2">*length_and_product = reduce { [$a-&gt;[0]+1, $a-&gt;[1]*$b] } [0, 1];</span></p>
<p><span class="font17">This makes only one pass over the list to compute both the length and the product. For an empty list, the result is </span><span class="font2">[0, 1]</span><span class="font17">, and for a list with one element </span><span class="font17" style="font-style:italic;">x,</span><span class="font17"> the result is </span><span class="font2">[1, x]</span><span class="font17">. </span><span class="font2">List::Util::reduce() </span><span class="font17">can manufacture only functions that return </span><span class="font2">undef </span><span class="font17">for the empty list, and that return the first list element for a single-element list. The </span><span class="font2">length_and_product() </span><span class="font17">function can’t be generated by </span><span class="font2">List::Util::reduce() </span><span class="font17">because it doesn’t have these properties.</span></p>
<p><span class="font17">A properly general version of </span><span class="font2">reduce() </span><span class="font17">gets an additional argument that says that the function should return when given an empty list as its argument. In the programming literature, the properly general version of </span><span class="font2">reduce() </span><span class="font17">is more typically called </span><span class="font2">fold()</span><span class="font17">:</span></p>
<p><span class="font2">sub fold {</span></p>
<p><span class="font2">my $f = shift;</span></p>
<div>
<p><span class="font9" style="font-weight:bold;">CODE LIBRARY</span></p>
</div><br clear="all">
<div>
<p><span class="font0">fold</span></p>
</div><br clear="all">
<div>
<p><span class="font9" style="font-weight:bold;">CODE LIBRARY</span></p>
</div><br clear="all">
<div>
<p><span class="font0">interleave</span></p>
</div><br clear="all">
<div>
<p><span class="font2">my Sfold;</span></p>
<p><span class="font2">Sfold = sub {</span></p>
<p><span class="font2">my Sx = shift;</span></p>
<p><span class="font2">sub {</span></p>
<p><span class="font2">return Sx unless @_;</span></p>
<p><span class="font2">my Sfirst = shift;</span></p>
<p><span class="font2">$fold-&gt;($f-&gt;($x, Sfirst), @_) }</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">Eliminating the recursion yields:</span></p>
</div><br clear="all">
<div>
<p><span class="font2">sub fold {</span></p>
<p><span class="font2">my Sf = shift;</span></p>
<p><span class="font2">sub {</span></p>
<p><span class="font2">my Sx = shift;</span></p>
<p><span class="font2">sub {</span></p>
<p><span class="font2" style="font-weight:bold;">my $r = $x;</span></p>
<p><span class="font2" style="font-weight:bold;">while (@_) {</span></p>
<p><span class="font2" style="font-weight:bold;">$r = $f-&gt;($r, shiftO);</span></p>
<p><span class="font2" style="font-weight:bold;">}</span></p>
<p><span class="font2" style="font-weight:bold;">return $r;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
</div><br clear="all">
<div>
<h5><a name="bookmark147"></a><span class="font19">7.3.1 Boolean Operators</span></h5>
<p><span class="font17">In Section 4.3 we saw a system that would search backwards through a log file looking for records that matched a simple query. To extend this into a useful database system, we need to be able to combine simple queries into more complex ones.</span></p>
<p><span class="font17">Let’s suppose that </span><span class="font2">Sa </span><span class="font17">and </span><span class="font2">Sb </span><span class="font17">are iterators that will produce data items that match queries </span><span class="font17" style="font-style:italic;">A</span><span class="font17"> and </span><span class="font17" style="font-style:italic;">B,</span><span class="font17"> respectively. How can we manufacture an iterator that matches the query </span><span class="font17" style="font-style:italic;">A</span><span class="font2"> || </span><span class="font17" style="font-style:italic;">B</span><span class="font17">?</span></p>
<p><span class="font17">One way we could do this is to interleave the elements of </span><span class="font2">Sa </span><span class="font17">and </span><span class="font2">Sb</span><span class="font17">:</span></p>
<p><span class="font2">sub interleave {</span></p>
<p><span class="font2">my (Sa, Sb) = @_;</span></p>
</div><br clear="all">
<ul style="list-style:none;"><li>
<p class="font15">7.3 <span class="font2">reduce() </span><span class="font15" style="font-variant:small-caps;">and</span><span class="font2"> combine() </span><span class="font20">349</span></p></li></ul>
<p><span class="font2">return sub {</span></p>
<p><span class="font2">my $next = $a-&gt;();</span></p>
<p><span class="font2">unless (defined $next) { $a = $b;</span></p>
<p><span class="font2">$next = $a-&gt;();</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">($a, $b) = ($b, $a);</span></p>
<p><span class="font2">$next;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">But this has the drawback that if the record sets produced by </span><span class="font2">$a </span><span class="font17">and </span><span class="font2">$b </span><span class="font17">happen to overlap, the interleaved outputs will include some records more than once.</span></p>
<p><span class="font17">We can do better if we suppose that the records will be produced in some sort of canonical order. This assumption isn’t unreasonable. Typically, a database will have a natural order dictated by the physical layout of the information on the disk and will always produce records in this natural order, at least until the data is modified. For example, our program for searching the web log file always produces matching records in the order they appear in the file. Even DBM files, which don’t appear to keep records in any particular order, have a natural order; this is the order in which the records will be generated by the </span><span class="font2">each() </span><span class="font17">function.</span></p>
<p><span class="font17">Supposing that </span><span class="font2">$a </span><span class="font17">and </span><span class="font2">$b </span><span class="font17">will produce records in the same order, we can perform an “or” operation as follows:</span></p>
<p><span class="font2">package Iterator_Logic;</span></p>
<div>
<p><span class="font9" style="font-weight:bold;">CODE LIBRARY</span></p>
</div><br clear="all">
<div>
<p><span class="font0">Iterator_Logic.pm</span></p>
</div><br clear="all">
<p><span class="font2">use base 'Exporter';</span></p>
<p><span class="font2">@EXPORT = qw(i_or_ i_or i_and_ i_and i_without_ i_without);</span></p>
<p><span class="font2">sub i_or_ {</span></p>
<p><span class="font2">my ($cmp, $a, $b) = @_;</span></p>
<p><span class="font2">my ($av, $bv) = ($a-&gt;(), $b-&gt;());</span></p>
<p><span class="font2">return sub {</span></p>
<p><span class="font2">my $rv;</span></p>
<p><span class="font2">if (! defined $av &amp;&amp;&nbsp;! defined $bv) { return } elsif (! defined $av) { $rv = $bv; $bv = $b-&gt;() } elsif (! defined $bv) { $rv = $av; $av = $a-&gt;() } else {</span></p>
<p><span class="font2">my $d = $cmp-&gt;($av, $bv);</span></p>
<p><span class="font2">if ($d &lt;&nbsp;0) { $rv = $av; $av = $a-&gt;() }</span></p>
<p><span class="font2">elsif ($d &gt;&nbsp;0) { $rv = $bv; $bv = $b-&gt;() }</span></p>
<p><span class="font2">else &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ $rv = $av; $av = $a-&gt;(); $bv = $b-&gt;() }</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">return $rv;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">} use Curry;</span></p>
<p><span class="font2">BEGIN { *i_or = curry(\&amp;i_or_) }</span></p>
<p><span class="font2">i_or_() </span><span class="font17">gets a comparator function, </span><span class="font2">$cmp</span><span class="font17">, which defines the canonical order, and two iterators, </span><span class="font2">$a </span><span class="font17">and </span><span class="font2">$b</span><span class="font17">. It returns a new iterator that returns the next record from either </span><span class="font2">$a </span><span class="font17">or </span><span class="font2">$b </span><span class="font17">in the canonical order. If </span><span class="font2">$a </span><span class="font17">and </span><span class="font2">$b </span><span class="font17">both produce the same record, the duplicate is discarded. It begins by kicking </span><span class="font2">$a </span><span class="font17">and </span><span class="font2">$b </span><span class="font17">to obtain the next record from each. If either is exhausted, it returns the record from the other; if both are exhausted, it returns </span><span class="font2">undef </span><span class="font17">to indicate that there are no more records. </span><span class="font2">$rv </span><span class="font17">holds the record that is to be the return value.</span></p>
<p><span class="font17">If both input iterators produce records, the new iterator compares the records to see which should come out first. If the comparator returns zero, it means the two records are the same, and only one of them should be emitted. </span><span class="font2">$rv </span><span class="font17">is assigned one of the two records, as appropriate, and then one or both of the iterators is kicked to produce new records for the next call.</span></p>
<p><span class="font17">The logic is very similar to the </span><span class="font2">merge() </span><span class="font17">function of Section 6.4. In fact, </span><span class="font2">merge() </span><span class="font17">is the stream analog of the “or” operator.</span></p>
<p><span class="font2">i_or() </span><span class="font17">is a curried version of </span><span class="font2">i_or_()</span><span class="font17">, called like this:</span></p>
<p><span class="font2">BEGIN { *numeric_or = i_or { $_[0] &lt;=&gt; $_[1] };</span></p>
<p><span class="font2">*alphabetic_or = i_or { $_[0] cmp $_[1] };</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">$event_times = numeric_or($access_request_times, numeric_or($report_request_times, $server_start_times));</span></p>
<p><span class="font17">“And” is similar:</span></p>
<p><span class="font2">sub i_and_ {</span></p>
<p><span class="font2">my ($cmp, $a, $b) = @_;</span></p>
<p><span class="font2">my ($av, $bv) = ($a-&gt;(), $b-&gt;());</span></p>
<p><span class="font2">return sub {</span></p>
<p><span class="font2">my $d;</span></p>
<p><span class="font2">until (! defined $av || ! defined $bv ||</span></p>
<p><span class="font2">($d = $cmp-&gt;($av, $bv)) == 0) {</span></p>
<p><span class="font2">if ($d &lt;&nbsp;0) { $av = $a-&gt;() }</span></p>
<p><span class="font2">else &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ $bv = $b-&gt;() }</span></p>
<p><span class="font2">}</span></p>
<ul style="list-style:none;"><li>
<p class="font15">7.4 DATABASES <span class="font20">351</span></p></li></ul>
<p><span class="font2">return unless defined $av &amp;&amp;&nbsp;defined $bv;</span></p>
<p><span class="font2">my $rv = $av;</span></p>
<p><span class="font2">($av, $bv) = ($a-&gt;(), $b-&gt;());</span></p>
<p><span class="font2">return $rv;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">BEGIN { *i_and = curry \&amp;i_and_ }</span></p>
<ul style="list-style:none;"><li>
<h5><a name="bookmark148"></a><span class="font18">7.4 DATABASES</span></h5></li></ul>
<p><span class="font17">In Section 4.3 we saw the beginnings of a database system that would manufacture an iterator containing the results of a simple query. To open the database we did:</span></p>
<p><span class="font2">my $dbh = FlatDB-&gt;new($datafile);</span></p>
<p><span class="font17">and then to perform a query,</span></p>
<p><span class="font2">$dbh-&gt;query($fieldname, $value);</span></p>
<p><span class="font17">or:</span></p>
<p><span class="font2">$dbh-&gt;callbackquery(sub { ... });</span></p>
<p><span class="font17">which selects the records for which the subroutine returns true.</span></p>
<p><span class="font17">Let’s extend this system to handle compound queries. Eventually, we’ll want the system to support calls like this:</span></p>
<p><span class="font2">$dbh-&gt;select(&quot;STATE = 'NY' |</span></p>
<p><span class="font2">OWES &gt;&nbsp;100 &amp;&nbsp;STATE = 'MA'&quot;);</span></p>
<p><span class="font17">This will require parsing of the query string, which we’ll see in detail in Chapter 8. In the meantime, we’ll build the internals that are required to support such queries.</span></p>
<p><span class="font17">The internals for simple queries like </span><span class="font2">&quot;STATE = 'NY'&quot; </span><span class="font17">are already done, since that’s exactly what the </span><span class="font2">$dbh-&gt;query('STATE', 'NY') </span><span class="font17">does. We can assume that other simple queries are covered by similar simple functions, or perhaps by calls to </span><span class="font2">callbackquery()</span><span class="font17">. What we need noware ways to combine simple queries into compound queries.</span></p>
<p><span class="font17">The </span><span class="font2">i_and() </span><span class="font17">and </span><span class="font2">i_or() </span><span class="font17">functions we saw earlier will do what we want, if we modify them suitably. The main thing we need to arrange is to define a canonical order for records produced by one of the simple query iterators. In particular, we need some way for the </span><span class="font2">i_and() </span><span class="font17">and </span><span class="font2">i_or() </span><span class="font17">operators to recognize that their two argument iterators have generated the same output record.</span></p>
<p><span class="font17">The natural way to do this is to tag each record with a unique ID number as it comes out of the query. Two different records will have different ID numbers. For flat-file databases, there’s a natural record ID number already to hand: the record number of the record in the file. We’ll need to adjust the </span><span class="font2">query() </span><span class="font17">function so that the iterators it returns will generate record numbers. When we last saw the </span><span class="font2">query() </span><span class="font17">function, it returned each record as a single string; this is a good opportunity to have it return a more structured piece of data:</span></p>
<div>
<p><span class="font9" style="font-weight:bold;">CODE LIBRARY</span></p>
</div><br clear="all">
<div>
<p><span class="font0">FlatDB_Compose.pm</span></p>
</div><br clear="all">
<p><span class="font2">package FlatDB_Compose;</span></p>
<p><span class="font2">use base 'FlatDB';</span></p>
<p><span class="font2">use base 'Exporter';</span></p>
<p><span class="font2">@EXPORT_OK = qw(query_or query_and query_not query_without); use Iterator_Logic;</span></p>
<ul style="list-style:none;"><li>
<p><span class="font2"># usage: $dbh-&gt;query(fieldname, value)</span></p></li>
<li>
<p><span class="font2"># returns all records for which (fieldname) matches (value) sub query {</span></p></li></ul>
<p><span class="font2">my $self = shift;</span></p>
<p><span class="font2">my ($field, $value) = @_;</span></p>
<p><span class="font2">my $fieldnum = $self-&gt;{FIELDNUM}{uc $field};</span></p>
<p><span class="font2">return unless defined $fieldnum;</span></p>
<p><span class="font2">my $fh = $self-&gt;{FH};</span></p>
<p><span class="font2">seek $fh, 0, 0;</span></p>
<p><span class="font2">&lt;$fh&gt;; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# discard header line</span></p>
<p><span class="font2">my $position = tell $fh;</span></p>
<p><span class="font2" style="font-weight:bold;">my $recno = 0;</span></p>
<p><span class="font2">return sub {</span></p>
<p><span class="font2">local $_;</span></p>
<p><span class="font2">seek $fh, $position, 0;</span></p>
<p><span class="font2">while (&lt;$fh&gt;) {</span></p>
<p><span class="font2">chomp;</span></p>
<p><span class="font2" style="font-weight:bold;">$recno++;</span></p>
<p><span class="font2">$position = tell $fh;</span></p>
<p><span class="font2">my @fields = split $self-&gt;{FIELDSEP};</span></p>
<p><span class="font2">my $fieldval = $fields[$fieldnum];</span></p>
<p><span class="font2" style="font-weight:bold;">return [$recno, ©fields] if $fieldval eq $value;</span></p>
<ul style="list-style:none;"><li>
<p class="font15">7.4 DATABASES <span class="font20">353</span></p></li></ul>
<p><span class="font2">}</span></p>
<p><span class="font2">return;</span></p>
<p><span class="font2">};</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">It might be tempting to try to use Perl’s built-in </span><span class="font2">S</span><span class="font17">. variable here instead of having each iterator carry its own synthetic </span><span class="font2">Srecno</span><span class="font17">, but that’s a bad idea. We took some pains to make sure that a single database filehandle could be shared among more than one query. However, the information for </span><span class="font2">S</span><span class="font17">. is stored inside the filehandle; since we don’t want the current record number to be shared among queries, we need to store it in the query object (which is private) rather than in the filehandle (which isn’t). An alternative to maintaining a special </span><span class="font2">Srecno </span><span class="font17">variable would be to use </span><span class="font2">Sposition </span><span class="font17">as a record identifier, since it’s already lying around, and since it has the necessary properties of being different for different records and of increasing as the query proceeds through the file.</span></p>
<p><span class="font17">Now we need to manufacture versions of </span><span class="font2">i_and() </span><span class="font17">and </span><span class="font2">i_or() </span><span class="font17">that use the record ID numbers when deciding what to pass along. Because these functions are curried, we don’t need to rewrite any code to do this:</span></p>
<p><span class="font2">BEGIN { *query_or = i_or(sub { S_[0][0] &lt;=&gt; S_[1][0] });</span></p>
<p><span class="font2">*query_and = i_and(sub { S_[0][0] &lt;=&gt; S_[1][0] });</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">BEGIN { *query_without = i_without(sub { $_[0][0] &lt;=&gt; $_[1][0] }); }</span></p>
<p><span class="font17">The comparator function says that arguments </span><span class="font2">$_[0] </span><span class="font17">and </span><span class="font2">$_[1] </span><span class="font17">will be arrays of record data, and that we should compare the first element of each, which is the record number, to decide which data should come out first and to decide record identity.</span></p>
<p><span class="font17">Here’s a similarly modified version of </span><span class="font2">callbackquery()</span><span class="font17">:</span></p>
<p><span class="font2">sub callbackquery {</span></p>
<p><span class="font2">my Sself = shift;</span></p>
<p><span class="font2">my Sis_interesting = shift;</span></p>
<p><span class="font2">my Sfh = Sself-&gt;{FH};</span></p>
<p><span class="font2">seek Sfh, 0, SEEK_SET;</span></p>
<p><span class="font2">&lt;Sfh&gt;; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# discard header line</span></p>
<p><span class="font2">my Sposition = tell Sfh;</span></p>
<p><span class="font2" style="font-weight:bold;">my Srecno = 0;</span></p>
<p><span class="font2">return sub {</span></p>
<p><span class="font2">local S_;</span></p>
<table border="1">
<tr><td>
<p><span class="font20">354</span></p></td><td style="vertical-align:bottom;">
<p><span class="font15">CHAPTER 7 Higher-Order Functions and Currying</span></p>
<p><span class="font2">seek Sfh, Sposition, SEEK_SET;</span></p>
<p><span class="font2">while (&lt;Sfh&gt;) {</span></p>
<p><span class="font2">Sposition = tell Sfh;</span></p>
<p><span class="font2">chomp;</span></p>
<p><span class="font2" style="font-weight:bold;">$recno++;</span></p>
<p><span class="font2">my %F;</span></p>
<p><span class="font2">my @fieldnames = @{Sself-&gt;{FIELDS}};</span></p>
<p><span class="font2">my @fields = split Sself-&gt;{FIELDSEP};</span></p>
<p><span class="font2">for (0 .. S#fieldnames) {</span></p>
<p><span class="font2">SF{Sfieldnames[S_]} = Sfields[S_];</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2" style="font-weight:bold;">return [$recno, ©fields] if $is_interesting-&gt;(%F);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">return;</span></p>
<p><span class="font2">};</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">1;</span></p></td></tr>
</table>
<p><span class="font17">In Chapter 8, we’ll build a parser that, given this query:</span></p>
<p><span class="font2">&quot;STATE = 'NY' | OWES &gt;&nbsp;100 &amp;&nbsp;STATE = 'MA'&quot; </span><span class="font17">makes this call:</span></p>
<p><span class="font2">query_or($dbh-&gt;query('STATE', 'NY'),</span></p>
<p><span class="font2">query_and(Sdbh-&gt;callbackquery(sub { my %F = @_; SF{OWES} &gt;&nbsp;100 }), $dbh-&gt;query('STATE', 'MA')</span></p>
<p><span class="font2">))</span></p>
<p><span class="font17">and returns the resulting iterator. In the meantime, we can manufacture the iterator manually.</span></p>
<p><span class="font17">The one important logical connective that’s still missing is “not,” which is a little bit peculiar, logically, because its meaning is tied to the original database. If </span><span class="font2">$q </span><span class="font17">is a query for all the people in a database who are male, then </span><span class="font2">query_not(Sq) </span><span class="font17">should produce all the people from the database who are female. But the </span><span class="font2">query_not </span><span class="font17">function can’t do that without visiting the original database to find the female persons. Unlike the outputs of </span><span class="font2">query_and() </span><span class="font17">and </span><span class="font2">query_or()</span><span class="font17">, the output of </span><span class="font2">query_not() </span><span class="font17">is not a selection of the inputs.</span></p>
<p><span class="font17">One way around this is for each query to capture a reference back to the original database that it’s a query on. An alternative is to specify the database explicitly, as </span><span class="font2">Sdbh-&gt;query_not(Sq)</span><span class="font17">. Then we can implement a more</span></p>
<h6><a name="bookmark362"></a><span class="font17">general operator on queries, the so-called </span><span class="font17" style="font-style:italic;">set difference operator,</span><span class="font17"> also known as </span><span class="font17" style="font-style:italic;">without</span><span class="font17">:</span></h6>
<p><span class="font2"># $a but not $b</span></p>
<p><span class="font2">sub i_without_ {</span></p>
<p><span class="font2">my ($cmp, $a, $b) = @_;</span></p>
<p><span class="font2">my ($av, $bv) = ($a-&gt;(), $b-&gt;());</span></p>
<p><span class="font2">return sub {</span></p>
<p><span class="font2">while (defined $av) {</span></p>
<p><span class="font2">my $d;</span></p>
<p><span class="font2">while (defined $bv &amp;&amp;&nbsp;($d = $cmp-&gt;($av, $bv)) &gt;&nbsp;0) {</span></p>
<p><span class="font2">$bv = $b-&gt;();</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">if ( ! defined $bv || $d &lt;&nbsp;0 ) {</span></p>
<p><span class="font2">my $rv = $av; $av = $a-&gt;(); return $rv;</span></p>
<p><span class="font2">} else {</span></p>
<p><span class="font2">$bv = $b-&gt;();</span></p>
<p><span class="font2">$av = $a-&gt;();</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">return;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">BEGIN {</span></p>
<p><span class="font2">*i_without = curry \&amp;i_without_;</span></p>
<p><span class="font2">*query_without =</span></p>
<p><span class="font2">i_without(sub { my ($a,$b) = @_; $a-&gt;[0] &lt;=&gt; $b-&gt;[0] });</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">1;</span></p>
<p><span class="font17">If </span><span class="font2">$a </span><span class="font17">and </span><span class="font2">$b </span><span class="font17">are iterators on the same database, </span><span class="font2">query_without($a, $b) </span><span class="font17">is an iterator that produces every record that appears in </span><span class="font2">$a </span><span class="font17">but </span><span class="font17" style="font-style:italic;">not</span><span class="font17"> in </span><span class="font2">$b</span><span class="font17">. This is useful on its own, and it also gives us a base for “not”, which becomes something like this:</span></p>
<p><span class="font2">sub query_not {</span></p>
<p><span class="font2">my $self = shift;</span></p>
<p><span class="font2">my $q = shift;</span></p>
<p><span class="font2">query_without($self-&gt;all, $q);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">$self-&gt;all </span><span class="font17">is a database method that performs a trivial query that disgorges all the records in the database. We could implement it specially, or, less efficiently, we could simply use:</span></p>
<p><span class="font2">sub all {</span></p>
<p><span class="font2">$_[0]-&gt;callbackquery(sub { 1 });</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">1;</span></p>
<p><span class="font17">A possibly amusing note is that once we have </span><span class="font2">query_without()</span><span class="font17">, we no longer need </span><span class="font2">query_and()</span><span class="font17">, since </span><span class="font17" style="font-style:italic;">(a</span><span class="font17"> and </span><span class="font17" style="font-style:italic;">b)</span><span class="font17"> is the same as </span><span class="font17" style="font-style:italic;">(a</span><span class="font17"> without </span><span class="font17" style="font-style:italic;">(a</span><span class="font17"> without </span><span class="font17" style="font-style:italic;">b</span><span class="font17">)).</span></p>
<ul style="list-style:none;"><li>
<h5><a name="bookmark149"></a><span class="font19">7.4.1 Operator Overloading</span></h5></li></ul>
<p><span class="font17">Perl provides a feature called </span><span class="font17" style="font-style:italic;">operator overloading</span><span class="font17"> that lets us write complicated query expressions more conveniently. Operator overloading allows us to redefine Perl’s built-in operator symbols to have whatever meaning we like when they are applied to our objects. Enabling the feature is simple. First we make a small change to methods such as </span><span class="font2">query() </span><span class="font17">so that they return iterators that are blessed into package </span><span class="font2">FlatDB</span><span class="font17">:</span></p>
<div>
<p><span class="font9" style="font-weight:bold;">CODE LIBRARY</span></p>
</div><br clear="all">
<div>
<p><span class="font0">FlatDB_Ovl.pm</span></p>
</div><br clear="all">
<p><span class="font2">package FlatDB_Ovl;</span></p>
<p><span class="font2">BEGIN {</span></p>
<p><span class="font2">for my $f (qw(and or without)) {</span></p>
<p><span class="font2">*{&quot;query_$f&quot;} = \&amp;{&quot;FlatDB_Compose::query_$f&quot;};</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">use base 'FlatDB_Compose';</span></p>
<p><span class="font2">sub query {</span></p>
<p><span class="font2">$self = shift;</span></p>
<p><span class="font2">my $q = $self-&gt;SUPER::query(@_);</span></p>
<p><span class="font2">bless $q =&gt; __PACKAGE__;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">sub callbackquery {</span></p>
<p><span class="font2">$self = shift;</span></p>
<p><span class="font2">my $q = $self-&gt;SUPER::callbackquery(@_);</span></p>
<p><span class="font2">bless $q =&gt; __PACKAGE__;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">1;</span></p>
<p><span class="font17">Then we add:</span></p>
<p><span class="font2">use overload '|' =&gt; \&amp;query_or,</span></p>
<p><span class="font2">'&amp;' =&gt; \&amp;query_and, '-' =&gt; \&amp;query_without, 'fallback' =&gt; 1;</span></p>
<p><span class="font17">at the top of </span><span class="font2">FlatDB.pm</span><span class="font17">. From then on, any time a </span><span class="font2">FlatDB </span><span class="font17">object participates in an </span><span class="font2">| </span><span class="font17">or </span><span class="font2">&amp;&nbsp;</span><span class="font17">operation, the specified function will be invoked instead.</span></p>
<p><span class="font17">Now, given the following simple queries:</span></p>
<p><span class="font2">my ($ny, $debtor, $ma) = ($dbh-&gt;query('STATE', 'NY'), $dbh-&gt;callbackquery(sub { my %F = @_; $F{OWES} &gt;&nbsp;100 }), $dbh-&gt;query('STATE', 'MA') );</span></p>
<p><span class="font17">we’ll be able to replace this:</span></p>
<p><span class="font2">my $interesting = query_or($ny, query_and($debtor, $ma))</span></p>
<p><span class="font17">with this:</span></p>
<p><span class="font2">my $interesting = $ny | $debtor &amp;&nbsp;$ma;</span></p>
<p><span class="font17">The operators are still Perl’s built-in operators, and so they obey the usual precedence and associativity rules. In particular, </span><span class="font2">&amp;&nbsp;</span><span class="font17">has higher precedence than </span><span class="font2">|</span><span class="font17">.</span></p>
<p><span class="font14">CHAPTER</span></p>
<h3><a name="bookmark363"></a><span class="font25">PARSING</span></h3>
<p><span class="font17" style="font-style:italic;">Parsing</span><span class="font17"> is the process of converting an unstructured input, such as a text file, into a data structure. Almost every program that reads input must perform parsing of some type. Long ago when I started writing this book, I was amazed to discover how underappreciated parsing processes are. One editor even worried that parsing might not be a useful application of Perl. But parsing is nearly universal, because almost every program must read an unstructured input, such as a text file, and turn it into a data structure, so that it can do some processing on it.</span></p>
<p><span class="font17">Programmers have become adept at designing data formats so that parsing is as simple as possible, and they may be unaware that they are doing it. But even Perl’s </span><span class="font2">&lt;HANDLE&gt; </span><span class="font17">operator is a rudimentary parser, transforming a character stream into a record stream. For more complicated sorts of inputs, many programmers fall back on a lot of weird hackery. But writing parsers can be straightforward and elegant, even for complex inputs, once you have the right set of tools available.</span></p>
<ul style="list-style:none;"><li>
<h5><a name="bookmark151"></a><span class="font18">8.1 LEXERS</span></h5></li></ul>
<p><span class="font17">Although it isn’t absolutely required, parsing is almost always split into two smaller tasks. Consider the process of parsing an English sentence, such as “The bear devoured Joe’s tent.” Before we can consider the way the words go together, we have to </span><span class="font17" style="font-style:italic;">recognize</span><span class="font17"> the words. At the beginning, all we have is a sequence of characters. We analyze the characters, observing that there are five words, and also a punctuation character, the period. We should probably consider the apostrophe to be part of the word </span><span class="font2">Joe’s</span><span class="font17">, although an alternative is to consider </span><span class="font2">Joe’s </span><span class="font17">to be a combination of the “words” </span><span class="font2">Joe </span><span class="font17">and </span><span class="font2">’s</span><span class="font17">. We’ll probably throw away the whitespace, since that doesn’t contribute to the meaning of the sentence except that it allows us to distinguish word boundaries.</span></p>
<p><span class="font17">A </span><span class="font17" style="font-style:italic;">token</span><span class="font17"> is the smallest part of an input that has a definite meaning. In our English example, the characters </span><span class="font2">devoured </span><span class="font17">have a meaning, but </span><span class="font2">dev </span><span class="font17">and </span><span class="font2">oured</span></p>
<h5><a name="bookmark364"></a><span class="font18">359</span></h5>
<div>
<h4><a name="bookmark365"></a><span class="font20">360</span></h4>
</div><br clear="all">
<div>
<p><span class="font15">CHAPTER 8 Parsing</span></p>
</div><br clear="all">
<p><span class="font17">don’t. </span><span class="font2">devoured </span><span class="font17">is therefore a token; </span><span class="font2">dev </span><span class="font17">and </span><span class="font2">oured </span><span class="font17">aren’t. (We could also argue that </span><span class="font2">devoured </span><span class="font17">can be further split, into </span><span class="font2">devour </span><span class="font17">and </span><span class="font2">ed. </span><span class="font17">But there’s clearly a limit to how far the meaning can be divided; </span><span class="font2">d </span><span class="font17">and </span><span class="font2">e </span><span class="font17">have no meaning by themselves.)</span></p>
<p><span class="font17">Computer parsing processes are similar. Given an utterance such as </span><span class="font2">my $terminator = @_ ? shift:$/;</span><span class="font17">, the first thing we usually do is assemble up the unstructured characters of the input into meaningful tokens. Here, the tokens are </span><span class="font2">my</span><span class="font17">, </span><span class="font2">$terminator</span><span class="font17">, </span><span class="font2">=</span><span class="font17">, </span><span class="font2">@_</span><span class="font17">, </span><span class="font2">?</span><span class="font17">, </span><span class="font2">shift</span><span class="font17">, </span><span class="font2">:</span><span class="font17">, </span><span class="font2">$/</span><span class="font17">, and </span><span class="font2">;</span><span class="font17">. Alternatively, we could divide some of the tokens a little further; Perl’s parser divides </span><span class="font2">$terminator </span><span class="font17">into </span><span class="font2">$ </span><span class="font17">and </span><span class="font2">terminator</span><span class="font17">, and </span><span class="font2">@_ </span><span class="font17">into </span><span class="font2">@ </span><span class="font17">and </span><span class="font2">_</span><span class="font17">, for example. But again, there’s a limit to how far we can divide things up without destroying the meaning. When analyzing the meaning of this statement, one simply doesn’t consider the meaning of </span><span class="font2">min</span><span class="font17">.</span></p>
<p><span class="font17">This process of dividing the characters into tokens goes by several names: </span><span class="font17" style="font-style:italic;">tokenization, lexical analysis</span><span class="font17"> or </span><span class="font17" style="font-style:italic;">lexing,</span><span class="font17"> and </span><span class="font17" style="font-style:italic;">scanning.</span><span class="font17"> All these words mean the same thing. The programs that do it are called </span><span class="font17" style="font-style:italic;">tokenizers, lexical analyzers, lexers, </span><span class="font17">or </span><span class="font17" style="font-style:italic;">scanners.</span></p>
<p><span class="font17">One natural way to represent the lexing process is as an iterator of some type. The lexer can generate a sequence of tokens, potentially infinite, to be consumed by some later part of the parsing process.</span></p>
<ul style="list-style:none;"><li>
<h5><a name="bookmark152"></a><span class="font19">8.1.1 Emulating the </span><span class="font3">&lt;&gt;&nbsp;</span><span class="font19">Operator</span></h5></li></ul>
<p><span class="font17">As a very simple example of a lexer, we’ll build an iterator that takes a sequence of characters and turns it into a sequence of records. Here’s a function that builds iterators that generate sequences of characters:</span></p>
<div>
<p><span class="font9" style="font-weight:bold;">CODE LIBRARY</span></p>
</div><br clear="all">
<div>
<p><span class="font0">Lexer.pm</span></p>
</div><br clear="all">
<p><span class="font2">package Lexer;</span></p>
<p><span class="font2">use base &quot;Exporter&quot;;</span></p>
<p><span class="font2">@EXPORT_OK = qw(make_charstream blocks records tokens iterator_to_stream make_lexer allinput);</span></p>
<p><span class="font2">%EXPORT_TAGS = ('all' =&gt; \@EXPORT_OK);</span></p>
<p><span class="font2">sub make_charstream {</span></p>
<p><span class="font2">my $fh = shift;</span></p>
<p><span class="font2">return sub { return getc($fh) };</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2"># For example:</span></p>
<p><span class="font2">my $stdin = make_charstream(\*STDIN);</span></p>
<p><span class="font15">8.1</span></p>
<p><span class="font17">If </span><span class="font2">Schars </span><span class="font17">is an iterator that generates a sequence of characters, then </span><span class="font2">records(Schars) </span><span class="font17">turns it into an iterator that generates a sequence of records:</span></p>
<p><span class="font2">sub records {</span></p>
<p><span class="font2">my Schars = shift;</span></p>
<p><span class="font2">my Sterminator = @_ ? shift : $/;</span></p>
<p><span class="font2">my Sbuffer = &quot;&quot;;</span></p>
<p><span class="font2">sub {</span></p>
<p><span class="font2">my Schar;</span></p>
<p><span class="font2">while (substr(Sbuffer, -(length Sterminator)) ne Sterminator</span></p>
<p><span class="font2">&amp;&amp; defined(Schar = Schars-&gt;())</span></p>
<p><span class="font2">) {</span></p>
<p><span class="font2">Sbuffer .= Schar;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">if (Sbuffer ne &quot;&quot;) {</span></p>
<p><span class="font2">my Sline = Sbuffer;</span></p>
<p><span class="font2">Sbuffer = &quot;&quot;;</span></p>
<p><span class="font2">return Sline;</span></p>
<p><span class="font2">} else {</span></p>
<p><span class="font2">return;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">In addition to the character generator, </span><span class="font2">records() </span><span class="font17">also gets an optional argument, a line-terminator string; if not supplied, it defaults to the current value of </span><span class="font2">S/</span><span class="font17">, which is the variable that controls the analogous behavior of the </span><span class="font2">&lt;...&gt; </span><span class="font17">operator. The iterator keeps a buffer with the characters seen so far but not returned, and appends each new character to the buffer as it appears. When the buffer is seen to end with the terminator string, it’s emptied and the contents are returned to the caller.</span></p>
<p><span class="font17">With this formulation, we’re in a position to do things that Perl doesn’t have built-in already. For example, people often ask for the ability to set </span><span class="font2">S/ </span><span class="font17">to a regex instead of to a plain string. This doesn’t work; the “regex” is interpreted as a plain string anyway. The reason that Perl doesn’t have this feature is that it’s surprisingly tricky to implement. It looks easy. For example, we might try implementing it by changing </span><span class="font2">records() </span><span class="font17">as follows:</span></p>
<p><span class="font2">sub records {</span></p>
<p><span class="font2">my Schars = shift;</span></p>
<p><span class="font2" style="font-weight:bold;">my Sterminator = @_ ? shift : quotemeta($/);</span></p>
<div>
<p><span class="font15">LEXERS </span><span class="font20">361</span></p>
</div><br clear="all">
<div>
<p><span class="font9" style="font-weight:bold;">CODE LIBRARY</span></p>
</div><br clear="all">
<div>
<p><span class="font0">records</span></p>
</div><br clear="all">
<div>
<h4><a name="bookmark366"></a><span class="font20">362</span></h4>
</div><br clear="all">
<div>
<p><span class="font15">CHAPTER 8 Parsing</span></p>
</div><br clear="all">
<p><span class="font2" style="font-weight:bold;">my Spattern = qr&lt;(?:$terminator)$&gt;;</span></p>
<p><span class="font2">my Sbuffer = &quot;&quot;;</span></p>
<p><span class="font2">sub {</span></p>
<p><span class="font2">my Schar;</span></p>
<p><span class="font2" style="font-weight:bold;">while (Sbuffer !- /Spattern/</span></p>
<p><span class="font2">&amp;&amp; defined(Schar = Schars-&gt;()) ) {</span></p>
<p><span class="font2">Sbuffer .= $char;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">if (Sbuffer ne &quot;&quot;) {</span></p>
<p><span class="font2">my Sline = Sbuffer;</span></p>
<p><span class="font2">Sbuffer = &quot;&quot;;</span></p>
<p><span class="font2">return Sline;</span></p>
<p><span class="font2">} else {</span></p>
<p><span class="font2">return;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">If we’re expecting inputs with sections that might be terminated either with </span><span class="font2">&quot;&nbsp;—\n&quot; </span><span class="font17">or with </span><span class="font2">&quot;+++\n&quot;</span><span class="font17">, but we don’t know which, we can say:</span></p>
<p><span class="font2">my Srecords = records(Schars, qr/-{3}\n|\+{3}\n/);</span></p>
<p><span class="font17">Inside of </span><span class="font2">records()</span><span class="font17">, the terminator pattern is wrapped up into </span><span class="font2">qr/-{3}\n| \+{3}\n/</span><span class="font17">, which looks for the terminator pattern only at the end of the buffer.</span></p>
<p><span class="font17">There are two problems with this implementation. One problem is that it’s not very efficient. Reading an input one character at a time into a buffer may be a good way to perform lexical analysis in C, but in Perl, it’s slow. The more serious problem is that this implementation mishandles a number of regexes that come up in practice. The simplest example is the regex </span><span class="font2">/\n\n+/</span><span class="font17">, which says that each record is terminated by one or more following blank lines. Given this input:</span></p>
<p><span class="font2">b</span></p>
<p><span class="font17">(that is, </span><span class="font2">“a\n\n\nb\n”</span><span class="font17">) there should be two records: </span><span class="font2">“a\n\n\n” </span><span class="font17">and </span><span class="font2">“b\n”</span><span class="font17">. But this iterator gets a different answer; it produces </span><span class="font2">“a\n\n” </span><span class="font17">and </span><span class="font2">“\nb\n”</span><span class="font17">. The problem here is that the terminator regex could be considered ambiguous. It says that a record is terminated by two or more newline characters. The iterator has decided that the first record is terminated by exactly two newline characters, and that the third newline character is part of the </span><span class="font17" style="font-style:italic;">second</span><span class="font17"> record. While this is arguably “correct”, it probably isn’t what was wanted. The problem occurs because the input is being read character-by-character; when the buffer contains </span><span class="font2">“a\n\n”</span><span class="font17">, the terminator pattern succeeds, and the record is split, even though more reading would have generated a longer match.</span></p>
<p><span class="font17">The same bug causes a more serious problem in a different example. Suppose we’re reading an email header and we’d like the iterator to generate logical fields instead of physical lines. Suppose the email header is as follows:</span></p>
<p><span class="font2">Delivered-To: </span><a href="mailto:mjd-filter-deliver2@plover.com"><span class="font2">mjd-filter-deliver2@plover.com</span></a></p>
<p><span class="font2">Received: from localhost [127.0.0.1] by plover.com</span></p>
<p><span class="font2">with SpamAssassin (2.55 1.174.2.19-2003-05-19-exp);</span></p>
<p><span class="font2">Mon, 11 Aug 2003 16:22:12 -0400</span></p>
<p><span class="font2">From: &quot;Doris Bower&quot; &lt;</span><a href="mailto:yij447mrx@yahoo.com.hk"><span class="font2">yij447mrx@yahoo.com.hk</span></a><span class="font2">&gt;</span></p>
<p><span class="font2">To: </span><a href="mailto:webmaster@plover.com"><span class="font2">webmaster@plover.com</span></a></p>
<p><span class="font2">Subject: LoseWeight Now with Pphentermine,Aadipex,Bontriil,PrescribedOnline,shipped to Your Door fltynzlfoybv kie</span></p>
<p><span class="font17">There are five fields here; the second one, with the </span><span class="font2">Received </span><span class="font17">tag, consists of three physical lines. Lines that begin with whitespace are continuations of the previous line. So if the records we want are email header fields, the terminator pattern is </span><span class="font2">/\n(?!\s)/</span><span class="font17">. That is, it’s a newline that is not followed by a whitespace.</span></p>
<p><span class="font17">Note that </span><span class="font2">/\n[&quot;\s]/ </span><span class="font17">is not correct here, as this says that the following nonwhitespace is actually part of the terminator, which it isn’t. This would treat the </span><span class="font2">F </span><span class="font17">of </span><span class="font2">From </span><span class="font17">as the final character of the terminator of the </span><span class="font2">Received </span><span class="font17">field; the next field would then begin </span><span class="font2">rom: &quot;Doris</span><span class="font17">. In contrast, theassertion </span><span class="font2">(?!\s) </span><span class="font17">behaves like part of the preceding </span><span class="font2">\n </span><span class="font17">symbol, constraining it to match only certain newline characters instead of all newline characters.</span></p>
<p><span class="font17">Plugging </span><span class="font2">/\n(?!\s)/ </span><span class="font17">into </span><span class="font2">records() </span><span class="font17">doesn’t work, however. The </span><span class="font2">Received </span><span class="font17">field is broken into three separate records anyway. What went wrong? Suppose the first </span><span class="font2">Received </span><span class="font17">line has been read in completely, including the newline character at the end. The iterator checks to see if the buffer matches </span><span class="font2">/(?:\n(?!\s))$/ — </span><span class="font17">and it </span><span class="font17" style="font-style:italic;">does</span><span class="font17"> match, because the buffer </span><span class="font17" style="font-style:italic;">does</span><span class="font17"> end with a newline character, and the newline character is </span><span class="font17" style="font-style:italic;">not</span><span class="font17"> followed by whitespace. So the iterator cuts off the line prematurely, without waiting to discover that this wasn’t actually an appropriate newline.</span></p>
<p><span class="font17">We might try to fix this by changing the pattern to </span><span class="font2">/\n(?=\S)/</span><span class="font17">, which says that the fields are terminated by newline characters that </span><span class="font17" style="font-style:italic;">are</span><span class="font17"> followed by </span><span class="font17" style="font-style:italic;">non</span><span class="font17">-whitespace. This does indeed prevent the </span><span class="font2">Received </span><span class="font17">field from being split prematurely, because when the first newline comes along, the pattern says that it must be followed by non-whitespace, and it isn’t followed by anything. But the pattern also prevents the field from being split in the correct place, and in fact the entire input comes out as one big field. This is because by the time the non-whitespace comes along, the pattern can no longer match at the end of the string, because it requires that the string end with a newline! So we need another approach.</span></p>
<p><span class="font17">Unfortunately, there doesn’t seem to be any good way to solve this problem with the features currently in Perl.</span></p>
<p><span class="font17">The essential problem is that a pattern match can fail and backtrack for two essentially different reasons. Consider a pattern like </span><span class="font2">/(abcd)+/</span><span class="font17">, and the two target strings </span><span class="font2">&quot;abcde&quot; </span><span class="font17">and </span><span class="font2">&quot;abcda&quot;</span><span class="font17">. The regex matches the </span><span class="font2">&quot;abcd&quot; </span><span class="font17">part of both strings, but in different ways. When it matches the string </span><span class="font2">&quot;abcde&quot;</span><span class="font17">, it stops at the </span><span class="font2">e </span><span class="font17">because it sees the </span><span class="font2">e </span><span class="font17">and knows the match can’t possibly continue. But when it matches the string </span><span class="font2">&quot;abcda&quot; </span><span class="font17">the match stops because the engine runs out of characters after the second </span><span class="font2">&quot;a&quot;</span><span class="font17">, and backtracks to the </span><span class="font2">&quot;d&quot;</span><span class="font17">.</span></p>
<p><span class="font17">For most applications, this distinction doesn’t matter. But in </span><span class="font17" style="font-style:italic;">this</span><span class="font17"> application, the second situation is quite different, because when the engine runs off the end of the string, we want it to try to read some more data, append it to the end of the target string, and continue. If the engine would tell us whether it reached the end of the string during the matching process, we could write code that would extend the target string and try the match again, but at present that feature is not available, and Perl doesn’t give us any good way to distinguish the two situations.</span></p>
<p><span class="font17">The best we can do at present is to read the entire input into memory at once:</span></p>
<p><span class="font2">sub records {</span></p>
<p><span class="font2">my Sinput = shift;</span></p>
<p><span class="font2">my Sterminator = @_ ? shift : quotemeta(S/);</span></p>
<p><span class="font2">my @records;</span></p>
<p><span class="font2">my @newrecs = split /(Sterminator)/, Sinput;</span></p>
<p><span class="font2">while (@newrecs &gt;&nbsp;2) {</span></p>
<p><span class="font2">push @records, shift(@newrecs).shift(@newrecs);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">push @records, @newrecs;</span></p>
<p><span class="font2">return sub {</span></p>
<p><span class="font2">return shift @records;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">There are a few complications here. We enclose the terminator in parentheses, to prevent </span><span class="font2">split </span><span class="font17">from discarding it. The </span><span class="font2">shift(@newrecs).shift(@newrecs) </span><span class="font17">expression reassembles a record with its terminator. The function does this only</span></p>
<p><span class="font17">when it is sure it has seen the beginning of the </span><span class="font17" style="font-style:italic;">next</span><span class="font17"> record on the input, because it doesn’t want to jump the gun and return an incomplete record or a record with an incomplete terminator; hence </span><span class="font2">©newrecs &gt;&nbsp;2 </span><span class="font17">instead of </span><span class="font2">©newrecs &gt;= 2</span><span class="font17">. When the input is exhausted, the input buffer contains the (possibly incomplete) final record, which is put onto the agenda.</span></p>
<ul style="list-style:none;"><li>
<h5><a name="bookmark153"></a><span class="font19">8.1.2 Lexers More Generally</span></h5></li></ul>
<p><span class="font17">To write a lexer in a language like C, one typically writes a loop that reads the input, one character at a time, and which runs a state machine, returning a complete token to the caller when the state machine definition says to. Alternatively, we could use a program like </span><span class="font2">lex</span><span class="font17">, whose input is a definition of the tokens we want to recognize, and whose output is a state machine program in C.</span></p>
<p><span class="font17">In Perl, explicit character-by-character analysis of input is slow. But Perl has a special feature whose sole purpose is to analyze a string character-by-character and to run a specified state machine on it; the character loop is done internally in compiled C, so it’s fast. This feature is regex matching. To match a string against a regex, Perl examines the string one character at a time and runs a state machine as it goes. The structure of the state machine is determined by the regex.</span></p>
<p><span class="font17">This suggests that regexes can act like lexers, and in fact Perl’s regexes have been extended with a few features put in expressly to make them more effective for lexing.</span></p>
<p><span class="font17">As an example, let’s consider a calculator program. The program will accept an input in the following form:</span></p>
<p><span class="font2">a = 12345679 * 6</span></p>
<p><span class="font2">b=a*9; c=0</span></p>
<p><span class="font2">print b</span></p>
<p><span class="font17">This will perform the indicated computations and print the result, 666666666. The first stage of processing this input is to tokenize it. Tokens are integer numerals; variable names, which have the form </span><span class="font2">/&quot;[a-zA-Z_]\w*$/</span><span class="font17">; parentheses; the operators </span><span class="font2">+</span><span class="font17">, </span><span class="font2">-</span><span class="font17">, </span><span class="font2">*</span><span class="font17">, </span><span class="font2">/</span><span class="font17">, </span><span class="font2">**</span><span class="font17">, and </span><span class="font2">=</span><span class="font17">; and the special directive </span><span class="font2">print</span><span class="font17">. Also, newlines are significant, since they terminate expressions, while other whitespace is unimportant except insofar as it separates tokens that might otherwise be considered a single token. (For example, </span><span class="font2">printb </span><span class="font17">is a variable name, as opposed to </span><span class="font2">print b</span><span class="font17">, which isn’t.)</span></p>
<p><span class="font17">The classic style for Perl lexers looks like this:</span></p>
<p><span class="font2">sub tokens {</span></p>
<div>
<p><span class="font9" style="font-weight:bold;">CODE LIBRARY</span></p>
</div><br clear="all">
<div>
<p><span class="font0">tokens-calc</span></p>
</div><br clear="all">
<p><span class="font2">my Starget = shift;</span></p>
<p><span class="font2">return sub {</span></p>
<p><span class="font2">TOKEN: {</span></p>
<table border="1">
<tr><td>
<p><span class="font2">return</span></p></td><td>
<p><span class="font2">['INTEGER', $1]</span></p></td><td>
<p><span class="font2">if</span></p></td><td>
<p><span class="font2">$target =<sub>-</sub></span></p></td><td>
<p><span class="font2">/\G</span></p></td><td>
<p><span class="font2">(\d+)</span></p></td><td>
<p><span class="font2">/gcx;</span></p></td></tr>
<tr><td style="vertical-align:bottom;">
<p><span class="font2">return</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">['PRINT']</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">if</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">$target =<sub>-</sub></span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">/\G</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">print \b</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">/gcx;</span></p></td></tr>
<tr><td style="vertical-align:bottom;">
<p><span class="font2">return</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">['IDENTIFIER', $1]</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">if</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">$target =<sub>-</sub></span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">/\G</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">([A-Za-z_]\w*)</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">/gcx;</span></p></td></tr>
<tr><td>
<p><span class="font2">return</span></p></td><td>
<p><span class="font2">['OPERATOR', $1]</span></p></td><td>
<p><span class="font2">if</span></p></td><td>
<p><span class="font2">$target =<sub>-</sub></span></p></td><td>
<p><span class="font2">/\G</span></p></td><td>
<p><span class="font2">(\*\*)</span></p></td><td>
<p><span class="font2">/gcx;</span></p></td></tr>
<tr><td style="vertical-align:bottom;">
<p><span class="font2">return</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">['OPERATOR', $1]</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">if</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">$target =<sub>-</sub></span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">/\G</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">([-+*\/=()])</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">/gcx;</span></p></td></tr>
<tr><td>
<p><span class="font2">return</span></p></td><td>
<p><span class="font2">['TERMINATOR', $1]</span></p></td><td>
<p><span class="font2">if</span></p></td><td>
<p><span class="font2">$target =<sub>-</sub></span></p></td><td>
<p><span class="font2">/\G</span></p></td><td>
<p><span class="font2">(; \n* | \n+)</span></p></td><td>
<p><span class="font2">/gcx;</span></p></td></tr>
<tr><td colspan="2">
<p><span class="font2">redo TOKEN</span></p></td><td>
<p><span class="font2">if</span></p></td><td>
<p><span class="font2">$target =<sub>-</sub></span></p></td><td>
<p><span class="font2">/\G</span></p></td><td>
<p><span class="font2">\s+</span></p></td><td>
<p><span class="font2">/gcx;</span></p></td></tr>
<tr><td>
<p><span class="font2">return</span></p></td><td>
<p><span class="font2">['UNKNOWN', $1]</span></p></td><td>
<p><span class="font2">if</span></p></td><td>
<p><span class="font2">$target =<sub>-</sub></span></p></td><td>
<p><span class="font2">/\G</span></p></td><td>
<p><span class="font2">(.)</span></p></td><td>
<p><span class="font2">/gcx;</span></p></td></tr>
<tr><td style="vertical-align:bottom;">
<p><span class="font2">return;</span></p></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
</table>
<p><span class="font17">There are a few obscure features here. Every Perl scalar may have associated with it a “current matching position,” initially the leftmost end of the string. Whenever a scalar is matched against an expression with the </span><span class="font2">/g </span><span class="font17">flag, its current matching position is set to the position at which the regex left off matching. Moreover, if a scalar has a current matching position, then when it’s matched against a pattern with </span><span class="font2">/g</span><span class="font17">, the search starts at the current matching position instead of at the leftmost end of the string, effectively ignoring everything to the left of the current matching position.</span></p>
<p><span class="font17">The current matching position of a scalar can be examined or set with the </span><span class="font2">pos() </span><span class="font17">built-in function. For example:</span></p>
<div>
<p><span class="font9" style="font-weight:bold;">CODE LIBRARY</span></p>
</div><br clear="all">
<div>
<p><span class="font0">regex-g-demo</span></p>
</div><br clear="all">
<p><span class="font2">my $target = &quot;123..45.6789...0&quot;;</span></p>
<p><span class="font2">while ($target =- /(\d+)/g) {</span></p>
<p><span class="font2">print &quot;Saw '$1' ending at position &quot;, pos($target), &quot;\n&quot;;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">The output is:</span></p>
<p><span class="font2">Saw '123' ending at position 3</span></p>
<p><span class="font2">Saw '45' ending at position 7</span></p>
<p><span class="font2">Saw '6789' ending at position 12</span></p>
<p><span class="font2">Saw '0' ending at position 16</span></p>
<p><span class="font17">In this example, the matching was able to skip past the dots in the string, just as </span><span class="font2">&quot;carrot&quot; =- /r\w+/ </span><span class="font17">is able to skip past the </span><span class="font2">c </span><span class="font17">and the </span><span class="font2">a</span><span class="font17">. The </span><span class="font2">\G </span><span class="font17">metacharacter anchors each match to occur </span><span class="font17" style="font-style:italic;">only</span><span class="font17"> at the position that the previous match left off;</span></p>
<p><span class="font15">8.1 LEXERS </span><span class="font20">367</span></p>
<p><span class="font17">it’s no longer allowed to skip characters at that position. This is what we want for our lexer, because we don’t want the lexer to skip forward in the string looking for a numeral when there might be some other token that appears earlier; we want to process the string in strict left-to-right order, skipping nothing.</span></p>
<p><span class="font17">Our basic strategy is something like this:</span></p>
<p><span class="font2">if (Starget =- /\Gtoken1/g) {</span></p>
<ul style="list-style:none;"><li>
<p><span class="font2"># do something with tokenl</span></p></li></ul>
<p><span class="font2">} elsif (Starget =- /\Gtoken2/g) {</span></p>
<ul style="list-style:none;"><li>
<p><span class="font2"># do something with token2</span></p></li></ul>
<p><span class="font2">} elsif ...</span></p>
<p><span class="font17">The idea is that we’ll search at the current position for something that looks like </span><span class="font2">tokenl</span><span class="font17">; if we don’t find it, we’ll look at that position for </span><span class="font2">token2</span><span class="font17">, and so on. Unfortunately, </span><span class="font2">/g </span><span class="font17">has a misfeature that prevents this from working: if the pattern match </span><span class="font17" style="font-style:italic;">fails</span><span class="font17"> in a </span><span class="font2">/g </span><span class="font17">match, the current matching position is destroyed! By the time control reaches the </span><span class="font2">elsif </span><span class="font17">branch, the scalar has forgotten where the search is intended to occur.</span></p>
<p><span class="font17">We could work around this by using </span><span class="font2">pos </span><span class="font17">to save and restore the current matching position before and after every match, but Perl has another special feature that was introduced just so that we wouldn’t have to do that: If the match operator has the </span><span class="font2">/c </span><span class="font17">flag as well as the </span><span class="font2">/g </span><span class="font17">flag, the misfeature is disabled. An unsuccessful match against a </span><span class="font2">/gc </span><span class="font17">pattern leaves the current matching position unchanged, instead of resetting it.</span></p>
<p><span class="font17">The iterator returned by </span><span class="font2">tokens() </span><span class="font17">uses this strategy. It captures the target string, and then, each time it’s called, looks for some sort of token at the current matching position. If it finds one, it returns a value that represents the token; if not, it tries looking for a different kind of token.</span></p>
<p><span class="font17">The only exceptions to this rule are in the last three lines of the function. If the text at the current position is whitespace (but not newlines, which would have been taken care of by the </span><span class="font2">TERMINATOR </span><span class="font17">line) the function skips the whitespace and tries again. The following line (</span><span class="font2">UNKNOWN</span><span class="font17">) is a catchall for handling unrecognized characters. Alternatively, we might have written the function to throw an exception. Finally, the last line handles the case where the current position is at the very end of the string; as usual, it returns a false value to the caller to indicate that it has no more output.</span></p>
<p><span class="font17">On our sample input:</span></p>
<p><span class="font2">a = 12345679 * 6</span></p>
<p><span class="font2">b=a*9; c=0</span></p>
<p><span class="font2">print b</span></p>
<p><span class="font17">The output is:</span></p>
<p><span class="font2">[IDENTIFIER, &quot;a&quot;]</span></p>
<p><span class="font2">[OPERATOR, &quot;=&quot;]</span></p>
<p><span class="font2">[INTEGER, &quot;12345679&quot;]</span></p>
<p><span class="font2">[OPERATOR, &quot;*&quot;]</span></p>
<p><span class="font2">[INTEGER, &quot;6&quot;]</span></p>
<p><span class="font2">[TERMINATOR, &quot;\n&quot;]</span></p>
<p><span class="font2">[IDENTIFIER, &quot;b&quot;]</span></p>
<p><span class="font2">[OPERATOR, &quot;=&quot;]</span></p>
<p><span class="font2">[IDENTIFIER, &quot;a&quot;]</span></p>
<p><span class="font2">[OPERATOR, &quot;*&quot;]</span></p>
<p><span class="font2">[INTEGER, &quot;9&quot;]</span></p>
<p><span class="font2">[TERMINATOR, &quot;;&quot;]</span></p>
<p><span class="font2">[IDENTIFIER, &quot;c&quot;]</span></p>
<p><span class="font2">[OPERATOR, &quot;=&quot;]</span></p>
<p><span class="font2">[INTEGER, &quot;0&quot;]</span></p>
<p><span class="font2">[TERMINATOR, &quot;\n&quot;]</span></p>
<p><span class="font2">[PRINT]</span></p>
<p><span class="font2">[IDENTIFIER, &quot;b&quot;]</span></p>
<p><span class="font2">[TERMINATOR, &quot;\n&quot;]</span></p>
<ul style="list-style:none;"><li>
<h5><a name="bookmark154"></a><span class="font19">8.1.3 Chained Lexers</span></h5></li></ul>
<p><span class="font17">The lexer of the previous section is easy to read and to write, and it’s efficient. It has one major drawback, however: the target string must be stored entirely in memory. As we saw, it’s quite tricky to use regexes to tokenize an input that hasn’t been completely read yet; we might have read some string that ends with </span><span class="font2">print</span><span class="font17">, and tokenized the </span><span class="font2">print </span><span class="font17">as a </span><span class="font2">print </span><span class="font17">operator, only to read another block and discover that it was actually the first five letters of an identifier </span><span class="font2">printmaking</span><span class="font17">. The lexer might similarly misparse </span><span class="font2">** </span><span class="font17">as </span><span class="font2">* *</span><span class="font17">.</span></p>
<p><span class="font17">A modified version ofthe iterator of Section 8.1.1 solves this problem. It gets three arguments. The first is an input iterator, as before. The input iterator will generate strings of input, perhaps a block at a time, or perhaps less or more. The second argument is a label, such as </span><span class="font2">IDENTIFIER </span><span class="font17">or </span><span class="font2">OPERATOR</span><span class="font17">, to include in the output tokens. The third argument is a regex that matches the tokens we want to find. The iterator’s output will be a sequence of tokens and strings. When it sees something it recognizes, it converts it into a token, which is a value of the form:</span></p>
<p><span class="font2">[$label, $string]</span></p>
<p><span class="font17">and when it sees something it doesn’t recognize, it returns it unchanged, as a plain string. So, for example, the lexer produced by </span><span class="font2">tokens($input, &quot;NUMERAL&quot;, qr/\d+/)</span><span class="font17">, if given the same preceding sample input, will generate the following items:</span></p>
<p><span class="font2">&quot;a = &quot;</span></p>
<p><span class="font2">[&quot;NUMERAL&quot;, 12345679]</span></p>
<p><span class="font2">&quot; * &quot;</span></p>
<p><span class="font2">[&quot;NUMERAL&quot;, 6]</span></p>
<p><span class="font2">&quot;\nb=a*&quot;</span></p>
<p><span class="font2">[&quot;NUMERAL&quot;, 9]</span></p>
<p><span class="font2">&quot;; c=&quot;</span></p>
<p><span class="font2">[&quot;NUMERAL&quot;, 0]</span></p>
<p><span class="font2">&quot;\nprint b\n&quot;</span></p>
<p><span class="font17">Once we have this, what do we do with it? We feed it as input to another lexer iterator, one which passes the </span><span class="font2">NUMERAL </span><span class="font17">tokens through unmodified, but examines the string portions for tokens that match its own regex. If we filter the input with a series of these iterators, we’ll get an output stream that will contain the tokens we want, and also some plain strings that represent unrecognized portions of the input.</span></p>
<p><span class="font17">The code is complicated by the need to hold onto input while looking ahead to make sure that something coming up doesn’t change the interpretation of the input we’ve seen already:</span></p>
<p><span class="font2">sub tokens {</span></p>
<div>
<p><span class="font9" style="font-weight:bold;">CODE LIBRARY</span></p>
</div><br clear="all">
<div>
<p><span class="font0">tokens</span></p>
</div><br clear="all">
<p><span class="font2">my (Sinput, Slabel, Spattern) = @_;</span></p>
<p><span class="font2">my @tokens;</span></p>
<p><span class="font2">my (Sbuf, Sfinished) = (&quot;&quot;);</span></p>
<p><span class="font2">my Ssplit = sub { split /(Spattern)/, S_[0] };</span></p>
<p><span class="font2">my Smaketoken = sub { [Slabel, S_[0] ]};</span></p>
<p><span class="font2">sub {</span></p>
<p><span class="font2">while (@tokens == 0 &amp;&amp;&nbsp;! Sfinished) {</span></p>
<p><span class="font2">my Si = Sinput-&gt;();</span></p>
<p><span class="font2">if (ref Si) { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Input is a token</span></p>
<p><span class="font2">my (Ssep, Stok) = Ssplit-&gt;(Sbuf);</span></p>
<p><span class="font2">Stok = Smaketoken-&gt;(Stok) if defined Stok;</span></p>
<p><span class="font2">push @tokens, grep defined &amp;&amp;&nbsp;S_ ne &quot;&quot;, Ssep, Stok, Si; Sbuf = &quot;&quot;;</span></p>
<p><span class="font2">} else { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Input is an untokenized string</span></p>
<p><span class="font2">Sbuf .= Si if defined Si; # Append new input to buffer</span></p>
<p><span class="font2">my ©newtoks = $split-&gt;($buf);</span></p>
<p><span class="font2">while (©newtoks &gt;&nbsp;2</span></p>
<p><span class="font2">|| ©newtoks &amp;&amp;&nbsp;! defined $i) {</span></p>
<ul style="list-style:none;"><li>
<p><span class="font2"># Buffer contains complete separator plus complete token</span></p></li>
<li>
<p><span class="font2"># OR we’ve reached the end of the input</span></p></li></ul>
<p><span class="font2">push @tokens, shift(@newtoks);</span></p>
<p><span class="font2">push @tokens, $maketoken-&gt;(shift ©newtoks) if @newtoks;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2"># Reassemble remaining contents of buffer $buf = join &quot;&quot;, @newtoks;</span></p>
<p><span class="font2">$finished = 1 if ! defined $i;</span></p>
<p><span class="font2">@tokens = grep $_ ne &quot;&quot;, @tokens;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">return shift(@tokens);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">The output agenda is </span><span class="font2">©tokens</span><span class="font17">. Tokens are put onto it under three circumstances:</span></p>
<ul style="list-style:none;"><li>
<p><span class="font17">1. &nbsp;When the current input contains so much text that it’s clear the function has seen an entire token, plus at least one character of what follows it, then the token and any preceding non-token text are placed into </span><span class="font2">©tokens</span><span class="font17">. This occurs when </span><span class="font2">©newtoks &gt;&nbsp;2</span><span class="font17">.</span></p></li>
<li>
<p><span class="font17">2. &nbsp;When the current input is exhausted, a token is extracted from it, if possible, and then whatever was found is put into </span><span class="font2">©tokens</span><span class="font17">. This occurs when </span><span class="font2">$i</span><span class="font17">, the most recent input, is undefined.</span></p></li>
<li>
<p><span class="font17">3. &nbsp;When the most recent input is itself a token, passed up from some lower-level lexer, we know that the following characters aren’t part of </span><span class="font17" style="font-style:italic;">this</span><span class="font17"> token, so we can examine the current text in the same way as if it were at the end of the input. This occurs when </span><span class="font2">$i</span><span class="font17">, the most recent input, is a token; the test is </span><span class="font2">if (ref $i)</span><span class="font17">.</span></p></li></ul>
<p><span class="font17">The input to </span><span class="font2">tokens() </span><span class="font17">is usually another iterator that was built by </span><span class="font2">tokens()</span><span class="font17">. To get the process started, we could supply an iterator that emits a string containing the data that is to be tokenized:</span></p>
<p><span class="font2">sub allinput {</span></p>
<p><span class="font2">my $fh = shift;</span></p>
<p><span class="font2">my ©data;</span></p>
<p><span class="font2">{ local $/;</span></p>
<p><span class="font2">Sdata[0] = &lt;Sfh&gt;;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">sub { return shift @data }</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">We can avoid the need to read the entire input into memory all at once, and use a base iterator that returns one block of data at a time from a filehandle:</span></p>
<p><span class="font2">sub blocks {</span></p>
<p><span class="font2">my Sfh = shift;</span></p>
<p><span class="font2">my Sblocksize = shift || 8192;</span></p>
<p><span class="font2">sub {</span></p>
<p><span class="font2">return unless read Sfh, my(Sblock), Sblocksize;</span></p>
<p><span class="font2">return Sblock;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">But if we use this, then we must be extremely careful that we don’t exercise the problem we saw back in Section 8.1.1, in which a lexer might return a short token when it could have returned a longer one.</span></p>
<p><span class="font17">We can generalize </span><span class="font2">tokens() </span><span class="font17">a little bit. The code that manufactures the token value, </span><span class="font2">Smaketoken</span><span class="font17">, is an anonymous function. We might as well let the user specify the function that performs this task, making it into a callback. Then </span><span class="font2">Slabel</span><span class="font17">, which isn’t used anywhere else, merely becomes a user argument to this callback:</span></p>
<p><span class="font2">sub tokens {</span></p>
<p><span class="font2">my (Sinput, Slabel, Spattern, Smaketoken) = @_;</span></p>
<p><span class="font2" style="font-weight:bold;">Smaketoken || = sub { [ $_[1], $_[0] ] };</span></p>
<p><span class="font2">my ©tokens;</span></p>
<p><span class="font2">my Sbuf = &quot;&quot;; &nbsp;&nbsp;# set to undef to when input is exhausted</span></p>
<p><span class="font2">my Ssplit = sub { split /(Spattern)/, S_[0] };</span></p>
<p><span class="font2">sub {</span></p>
<p><span class="font2">while (©tokens == 0 &amp;&amp;&nbsp;defined Sbuf) {</span></p>
<p><span class="font2">my Si = Sinput-&gt;();</span></p>
<p><span class="font2">if (ref Si) {</span></p>
<p><span class="font2">my (Ssep, Stok) = Ssplit-&gt;(Sbuf);</span></p>
<p><span class="font2" style="font-weight:bold;">$tok = Smaketoken-&gt;(Stok, Slabel) if defined Stok;</span></p>
<p><span class="font2">push ©tokens, grep defined &amp;&amp;&nbsp;S_ ne &quot;&quot;, Ssep, Stok, Si;</span></p>
<p><span class="font2">Sbuf = &quot;&quot;;</span></p>
<p><span class="font2">last;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">$buf .= $i if defined $i;</span></p>
<p><span class="font2">my @newtoks = $split-&gt;($buf);</span></p>
<p><span class="font2">while (@newtoks &gt;&nbsp;2</span></p>
<p><span class="font2">|| @newtoks &amp;&amp;&nbsp;! defined $i) { push @tokens, shift(@newtoks);</span></p>
<p><span class="font2" style="font-weight:bold;">push @tokens, $maketoken-&gt;(shift(@newtoks), $label) </span><span class="font2">if @newtoks;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">$buf = join &quot;&quot;, @newtoks;</span></p>
<p><span class="font2">undef $buf if ! defined $i;</span></p>
<p><span class="font2">@tokens = grep $_ ne &quot;&quot;, @tokens;</span></p>
<p><span class="font2">} return shift(@tokens);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">We can call this version of </span><span class="font2">tokens </span><span class="font17">just as before, but now it’s more flexible. Formerly, we could have written a whitespace recognizer that generated whitespace tokens:</span></p>
<p><span class="font2">tokens($input, &quot;WHITESPACE&quot;, qr/\s+/)</span></p>
<p><span class="font17">but we would have had to discard these tokens later on, perhaps with </span><span class="font2">igrep</span><span class="font17">, since we weren’t really interested in them. With the new formulation, we can write:</span></p>
<p><span class="font2">tokens($input, &quot;WHITESPACE&quot;, qr/\s+/, sub { &quot;&quot;&nbsp;});</span></p>
<p><span class="font17">which represents a whitespace token as an empty string; the empty strings are removed from the output by the iterator itself, so the whitespace just disappears. (If this seems like too much of a trick, it’s simple to change the code so that the </span><span class="font2">$maketoken </span><span class="font17">argument is expected to return a </span><span class="font17" style="font-style:italic;">list</span><span class="font17"> of tokens to be inserted into the output, and then have the </span><span class="font2">WHITESPACE maketoken() </span><span class="font17">function return an empty list.)</span></p>
<p><span class="font17">Similarly, instead of a generic </span><span class="font2">OPERATOR </span><span class="font17">token, it might be convenient to include the operator type and its precedence in the token:</span></p>
<p><span class="font2">%optype = ('+' =&gt; ['ARITHMETIC', 3],</span></p>
<p><span class="font2">'-' =&gt; ['ARITHMETIC', 3],</span></p>
<p><span class="font15">8.1 LEXERS </span><span class="font20">373</span></p>
<p><span class="font2">'*' </span><span class="font2" style="font-style:italic;">=&gt;</span><span class="font2"> ['ARITHMETIC', 4],</span></p>
<p><span class="font2">'/' =&gt; ['ARITHMETIC', 4],</span></p>
<p><span class="font2">'**' =&gt; ['ARITHMETIC', 5],</span></p>
<p><span class="font2">'x' =&gt; ['STRING' &nbsp;&nbsp;&nbsp;&nbsp;, 4],</span></p>
<p><span class="font2">'.' =&gt; ['STRING' &nbsp;&nbsp;&nbsp;&nbsp;, 3],</span></p>
<p><span class="font2">...</span></p>
<p><span class="font2">);</span></p>
<p><span class="font2">tokens(Sinput, \%optype, qr/\*\*|[-+*\/x.]|.../, sub { my Soptype = S_[1];</span></p>
<p><span class="font2">[ &quot;OPERATOR&quot;, @{Soptype-&gt;{S_[0]}}, $_[0] ] });</span></p>
<p><span class="font17">The tokens that come out of this iterator look like </span><span class="font2">[&quot;OPERATOR&quot;, &quot;ARITHMETIC&quot;, 5, &quot;**&quot;]</span><span class="font17">.</span></p>
<p><span class="font17">Lexers are easy to write with the chained-lexer technique, but the resulting code is ugly:</span></p>
<p><span class="font2">my Slexer = tokens(</span></p>
<p><span class="font2">tokens(</span></p>
<p><span class="font2">tokens(</span></p>
<p><span class="font2">tokens(</span></p>
<p><span class="font2">tokens(</span></p>
<p><span class="font2">tokens(Sinput,</span></p>
<p><span class="font2">'TERMINATOR',</span></p>
<p><span class="font2">qr/;\n*|\n+/,</span></p>
<p><span class="font2">),</span></p>
<p><span class="font2">'INTEGER',</span></p>
<p><span class="font2">qr/\b\d+\b/,</span></p>
<p><span class="font2">),</span></p>
<p><span class="font2">'PRINT',</span></p>
<p><span class="font2">qr/\bprint\b/,</span></p>
<p><span class="font2">),</span></p>
<p><span class="font2">'IDENTIFIER',</span></p>
<p><span class="font2">qr|[A-Za-z_]\w*|,</span></p>
<p><span class="font2">),</span></p>
<p><span class="font2">'OPERATOR',</span></p>
<p><span class="font2">qr#\*\*|[-=+*/()]#,</span></p>
<p><span class="font2">),</span></p>
<p><span class="font2">'WHITESPACE',</span></p>
<p><span class="font2">qr/\s+/, sub { &quot;&quot;&nbsp;}, # discard</span></p>
<p><span class="font2">);</span></p>
<div>
<h4><a name="bookmark367"></a><span class="font20">374</span></h4>
</div><br clear="all">
<div>
<p><span class="font15">CHAPTER 8 Parsing</span></p>
</div><br clear="all">
<p><span class="font17">But a spoonful of syntactic sugar makes the medicine go down:</span></p>
<p><span class="font2">sub make_lexer {</span></p>
<p><span class="font2">my $lexer = shift;</span></p>
<p><span class="font2">while (@_) {</span></p>
<p><span class="font2">my $args = shift;</span></p>
<p><span class="font2">$lexer = tokens($lexer, @$args);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">$lexer;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">Now we can build the lexer with a tidy, tabular piece of code:</span></p>
<p><span class="font2">my $lexer = make_lexer($input, ['TERMINATOR', ['INTEGER', ['PRINT', ['IDENTIFIER', ['OPERATOR', ['WHITESPACE', );</span></p>
<div>
<p><span class="font2">qr/;\n*|\n+/ ], qr/\b\d+\b/ ], qr/\bprint\b/ ],</span></p>
<p><span class="font2">qr|[A-Za-z_]\w*| ], qr#\*\*|[-=+*/()]# ], qr/\s+/, sub { &quot;&quot;&nbsp;} ],</span></p>
</div><br clear="all">
<p><span class="font17">Calls to </span><span class="font2">make_lexer() </span><span class="font17">can be chained the same way that calls to </span><span class="font2">tokens() </span><span class="font17">were.</span></p>
<p><span class="font17">We’ll use this lexer later, so let’s observe one feature that you might otherwise miss: A semicolon (possibly followed by newlines, but possibly alone) is lexed as a </span><span class="font2">TERMINATOR </span><span class="font17">token, the same as actual newline characters would be.</span></p>
<ul style="list-style:none;"><li>
<h5><a name="bookmark155"></a><span class="font19">8.1.4 Peeking</span></h5></li></ul>
<p><span class="font17">Our lexers need one more feature to be complete. Consider a parser for some kind of expression that has two distinct forms; say a parser for numerals that might look either like </span><span class="font2">&quot;123&quot; </span><span class="font17">or like </span><span class="font2">&quot;-123&quot;</span><span class="font17">. These will be tokenized as </span><span class="font2">[INTEGER, &quot;123&quot;] </span><span class="font17">and as </span><span class="font2">[OPERATOR, &quot;-&quot;]</span><span class="font17">, </span><span class="font2">[INTEGER, &quot;123&quot;]</span><span class="font17">, respectively.</span></p>
<p><span class="font17">We would like to build the parser to understand both forms, and for reasons of maintenance and modularity we might like to build it from two separate parts, one that handles unsigned integers and one that handles negated integers. A master control will examine the next token in the input. If it’s an </span><span class="font2">INTEGER</span><span class="font17">, the master control will invoke the sub-parser for unsigned integers; if it’s an </span><span class="font2">OPERATOR </span><span class="font17">the master control will invoke the sub-parser for negated integers. If the next token is anything else, the master parser will signal an error.</span></p>
<p><span class="font17">The problem is that once the master control has eaten the token at the front of the input stream, the token is gone; the sub-parsers no longer have access to it, and the unsigned integer parser certainly needs it, because the token contains the value of the integer. We could fix this by passing the eaten token to the subparsers explicitly. However, this will entail complications in the parsers, which will now have to get their inputs from two separate sources.</span></p>
<p><span class="font17">A simpler approach is to allow the master parser to put the eaten token back into the input stream, or, alternatively, to allow it to examine the next token in an input </span><span class="font17" style="font-style:italic;">without</span><span class="font17"> removing it from the stream. We’ll use the second approach:</span></p>
<p><span class="font2">sub tokens {</span></p>
<p><span class="font2">■ ■■</span></p>
<p><span class="font2">sub {</span></p>
<p><span class="font2">while (©tokens == 0 &amp;&amp;&nbsp;! Sfinished) {</span></p>
<p><span class="font2">■■■</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2" style="font-weight:bold;">return $_[0] eq 'peek' ? $tokens[0] : shift(@tokens);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">Normally, we invoke a lexer as </span><span class="font2">Slexer-&gt;()</span><span class="font17">, which consumes and returns the next token in the input. With this change, we have the option of saying </span><span class="font2">Slexer-&gt;('peek')</span><span class="font17">, which returns the next token in the input </span><span class="font17" style="font-style:italic;">without</span><span class="font17"> consuming it; the next call to </span><span class="font2">Slexer-&gt;() </span><span class="font17">will return the same token we just peeked at.</span></p>
<p><span class="font17">An alternative approach is to represent lexers as streams, in the sense of Chapter 6. Turning our generic function-style iterators into lazy streams is easy:</span></p>
<p><span class="font2">use Stream 'node';</span></p>
<div>
<p><span class="font9" style="font-weight:bold;">CODE LIBRARY</span></p>
</div><br clear="all">
<p><span class="font0">it2stream.pl</span></p>
<p><span class="font2">sub iterator_to_stream {</span></p>
<p><span class="font2">my Sit = shift;</span></p>
<p><span class="font2">my Sv = Sit-&gt;();</span></p>
<p><span class="font2">return unless defined Sv;</span></p>
<p><span class="font2">node(Sv, sub { iterator_to_stream(Sit) });</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">1;</span></p>
<p><span class="font17">If we do this, the “peek” function is just </span><span class="font2">head()</span><span class="font17">, and the “read and discard” function is </span><span class="font2">drop()</span><span class="font17">.</span></p>
<div>
<h4><a name="bookmark368"></a><span class="font20">376</span></h4>
</div><br clear="all">
<div>
<p><span class="font15">CHAPTER 8 Parsing</span></p>
</div><br clear="all">
<ul style="list-style:none;"><li>
<h5><a name="bookmark156"></a><span class="font18">8.2 PARSING IN GENERAL</span></h5></li></ul>
<p><span class="font17">We’ve finished with lexers, which transform unstructured character sequences into token sequences. Now we’ll deal with parsers, which read sequences of tokens and integrate them into complex structures. The result of parsing is the </span><span class="font17" style="font-style:italic;">meaning</span><span class="font17"> of the input, or the </span><span class="font17" style="font-style:italic;">value</span><span class="font17"> of the input. For example, the result of parsing the input </span><span class="font2">3 + 4 * 5 </span><span class="font17">might be the number 23, which is the meaning or the value of the expression. If the parser is part of a compiler, the value might be a sequence of machine language instructions for calculating 3 </span><span class="font3">+ </span><span class="font17">4 </span><span class="font3">• </span><span class="font17">5.</span></p>
<ul style="list-style:none;"><li>
<h5><a name="bookmark157"></a><span class="font19">8.2.1 Grammars</span></h5></li></ul>
<p><span class="font17">The key to parsing is the </span><span class="font17" style="font-style:italic;">grammar,</span><span class="font17"> which describes the structure of a legal input. As a simple example, we’ll consider a parser for a very limited set of arithmetic expressions, including only addition, multiplication, and parentheses. Here is the grammar:</span></p>
<p><span class="font2">expression ^ atom '+' expression expression ^ atom '*' expression expression ^ '(' expression ')' expression ^ atom atom ^ 'INT'</span></p>
<p><span class="font2">atom ^ 'VAR'</span></p>
<p><span class="font17">Items in quotes represent literal tokens; items not in quotes represent other parts of the grammar. Both kinds of items are called </span><span class="font17" style="font-style:italic;">symbols.</span><span class="font17"> The first section is the definition of the </span><span class="font17" style="font-style:italic;">expression symbol.</span><span class="font17"> It says that there are four alternative forms for an </span><span class="font17" style="font-style:italic;">expression.</span><span class="font17"> An </span><span class="font17" style="font-style:italic;">expression</span><span class="font17"> might be an atom followed by a </span><span class="font2">+ </span><span class="font17">token followed by a complete expression, or it might be an atom followed by a </span><span class="font2">* </span><span class="font17">token followed by a complete expression, or it might be a complete expression enclosed in parentheses, or it might simply be an atom by itself. What’s an atom? The second section defines the </span><span class="font17" style="font-style:italic;">atom symbol:</span><span class="font17"> It’s either an </span><span class="font2">INT </span><span class="font17">token or a </span><span class="font2">VAR </span><span class="font17">token. The four alternatives in the </span><span class="font17" style="font-style:italic;">expression</span><span class="font17"> definition and the two alternatives in the </span><span class="font17" style="font-style:italic;">atom</span><span class="font17"> definition are sometimes called </span><span class="font17" style="font-style:italic;">clauses</span><span class="font17"> or </span><span class="font17" style="font-style:italic;">productions.</span><span class="font17"> One of the symbols is usually considered more important than the others, and represents the entire structure that we’re trying to parse; the other symbols usually represent various sub-structures or special cases. In this case the important symbol is </span><span class="font17" style="font-style:italic;">expression</span><span class="font17">. This more-important symbol is called the </span><span class="font17" style="font-style:italic;">start symbol</span><span class="font17">.</span></p>
<p><span class="font15">8.2 PARSING IN GENERAL </span><span class="font20">377</span></p>
<p><span class="font17">The grammar defines all the legal expressions, as follows. Start with the start symbol, </span><span class="font17" style="font-style:italic;">expression.</span><span class="font17"> Apply a production by replacing the symbol on the left side of the production with the symbols on the right; for example, replace </span><span class="font17" style="font-style:italic;">expression</span><span class="font17"> with </span><span class="font2" style="font-style:italic;">(</span><span class="font17" style="font-style:italic;">expression</span><span class="font2" style="font-style:italic;">)</span><span class="font17">. Repeat until there is nothing left but literal tokens. For example,</span></p>
<p><span class="font2" style="font-style:italic;">expression</span></p>
<table border="1">
<tr><td>
<p><span class="font2" style="font-style:italic;">atom</span></p></td><td>
<p><span class="font2">* </span><span class="font2" style="font-style:italic;">expression</span></p></td><td>
<p><span class="font2">#</span></p></td><td>
<p><span class="font2">expression</span></p></td><td>
<p><span class="font2">clause</span></p></td><td>
<p><span class="font2">2</span></p></td></tr>
<tr><td>
<p><span class="font2">INT</span></p></td><td>
<p><span class="font2">* </span><span class="font2" style="font-style:italic;">expression</span></p></td><td>
<p><span class="font2">#</span></p></td><td>
<p><span class="font2">atom clause</span></p></td><td>
<p><span class="font2">1</span></p></td><td></td></tr>
<tr><td>
<p><span class="font2">INT</span></p></td><td>
<p><span class="font2">* ( </span><span class="font2" style="font-style:italic;">expression</span></p></td><td>
<p><span class="font2">) #</span></p></td><td>
<p><span class="font2">expression</span></p></td><td>
<p><span class="font2">clause</span></p></td><td>
<p><span class="font2">3</span></p></td></tr>
<tr><td>
<p><span class="font2">INT</span></p></td><td colspan="2">
<p><span class="font2">* ( </span><span class="font2" style="font-style:italic;">atom</span><span class="font2"> + </span><span class="font2" style="font-style:italic;">expression</span><span class="font2"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;) #</span></p></td><td>
<p><span class="font2">expression</span></p></td><td>
<p><span class="font2">clause</span></p></td><td>
<p><span class="font2">1</span></p></td></tr>
<tr><td>
<p><span class="font2">INT</span></p></td><td>
<p><span class="font2">* ( </span><span class="font2" style="font-style:italic;">atom</span><span class="font2"> + </span><span class="font2" style="font-style:italic;">atom</span></p></td><td>
<p><span class="font2">* </span><span class="font2" style="font-style:italic;">expression</span><span class="font2"> ) #</span></p></td><td>
<p><span class="font2">expression</span></p></td><td>
<p><span class="font2">clause</span></p></td><td>
<p><span class="font2">2</span></p></td></tr>
<tr><td>
<p><span class="font2">INT</span></p></td><td>
<p><span class="font2">* ( </span><span class="font2" style="font-style:italic;">atom</span><span class="font2"> + VAR</span></p></td><td>
<p><span class="font2">* </span><span class="font2" style="font-style:italic;">expression</span><span class="font2"> ) #</span></p></td><td>
<p><span class="font2">atom clause</span></p></td><td>
<p><span class="font2">2</span></p></td><td></td></tr>
<tr><td style="vertical-align:bottom;">
<p><span class="font2">INT</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">* ( </span><span class="font2" style="font-style:italic;">atom</span><span class="font2"> + VAR</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">* </span><span class="font2" style="font-style:italic;">atom</span><span class="font2"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;) #</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">expression</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">clause</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">4</span></p></td></tr>
<tr><td>
<p><span class="font2">INT</span></p></td><td>
<p><span class="font2">* ( VAR + VAR</span></p></td><td>
<p><span class="font2">* </span><span class="font2" style="font-style:italic;">atom</span><span class="font2"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;) #</span></p></td><td>
<p><span class="font2">atom clause</span></p></td><td>
<p><span class="font2">2</span></p></td><td></td></tr>
<tr><td style="vertical-align:bottom;">
<p><span class="font2">INT</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">* ( VAR + VAR</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">* INT &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;) #</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">atom clause</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">1</span></p></td><td></td></tr>
</table>
<p><span class="font17">This </span><span class="font17" style="font-style:italic;">derivation</span><span class="font17"> shows that the sequence of tokens </span><span class="font2">INT * ( VAR + VAR * INT ) </span><span class="font17">is a valid expression. The valid expressions are exactly those for which derivations exist. </span><span class="font2">INT INT INT </span><span class="font17">and </span><span class="font2">INT + + VAR </span><span class="font17">are not valid expressions, according to our grammar, because there are no derivations for them.</span></p>
<p><span class="font17">Now some jargon: The symbols that appear on the left side of productions, such as </span><span class="font17" style="font-style:italic;">expression</span><span class="font17"> and </span><span class="font17" style="font-style:italic;">atom,</span><span class="font17"> are called </span><span class="font17" style="font-style:italic;">nonterminal symbols</span><span class="font17"> or just </span><span class="font17" style="font-style:italic;">nonterminals, </span><span class="font17">because a derivation is not complete as long as one of them appears in the result. Conversely, the literal tokens are called </span><span class="font17" style="font-style:italic;">terminal symbols</span><span class="font17"> or just </span><span class="font17" style="font-style:italic;">terminals</span><span class="font17"> because once they appear, they can’t be replaced. A sequence of symbols is sometimes called a </span><span class="font17" style="font-style:italic;">sentential form;</span><span class="font17"> if all the symbols are terminals, the sentential form is a </span><span class="font17" style="font-style:italic;">sentence.</span><span class="font17"> So a derivation of a particular sentence consists of a sequence of sentential forms, each of which is obtained from the previous one by the application of one of the productions to one of the nonterminal symbols.</span></p>
<p><span class="font17">One of the primary jobs of parsing is to determine if a particular sequence of tokens is a sentence according to a given grammar, and, if so, which productions to apply in which order to produce it. In principle, this is simple. The space of all possible sentential forms has a tree structure, and we need only do a tree search on this tree, looking for the sentential form that corresponds to the input tokens. Figure 8.1 shows the top portion of the tree for the </span><span class="font17" style="font-style:italic;">expression</span><span class="font17"> symbol in the example grammar.</span></p>
<p><span class="font17">The root node is the sentential form that consists only of the start symbol, </span><span class="font17" style="font-style:italic;">expression</span><span class="font17">. At each node, we obtain the child nodes by replacing the leftmost nonterminal symbol with the right-hand side of one if its productions. When there are no nonterminal symbols, the node is a leaf. A path from the root to</span></p>
<div>
<p><span class="font0">|</span><span class="font0" style="text-decoration:underline;"> </span><span class="font0">expressio^j-|</span><span class="font0" style="text-decoration:underline;"> </span><span class="font0">atom</span><span class="font0" style="text-decoration:underline;"> </span><span class="font0">+</span><span class="font0" style="text-decoration:underline;"> </span><span class="font0">expression</span><span class="font0" style="text-decoration:underline;"> </span><span class="font0">^-|</span><span class="font0" style="text-decoration:underline;"> </span><span class="font0">INT</span><span class="font0" style="text-decoration:underline;"> </span><span class="font0">+</span><span class="font0" style="text-decoration:underline;"> </span><span class="font0">expression</span><span class="font0" style="text-decoration:underline;"> </span><span class="font0">|-</span></p>
</div><br clear="all">
<div><img src="HigherOrderPerl_files/HigherOrderPerl-52.jpg" alt="" style="width:74pt;height:48pt;">
</div><br clear="all">
<div>
<p><span class="font0">—</span><span class="font0" style="text-decoration:underline;">| INT + atom ]</span><span class="font0">~[~</span><span class="font0" style="text-decoration:underline;">| INT + INT | </span><span class="font0">b-</span><span class="font0" style="text-decoration:underline;">|&quot;|NT + VAR | VAR + expression^</span><span class="font0">------—</span><span class="font0" style="text-decoration:underline;">| VAR + atom + expression |</span></p>
</div><br clear="all">
<div>
<p><span class="font0">—</span><span class="font0" style="text-decoration:underline;">| VAR + atom*expression |</span></p>
<p><span class="font0">—</span><span class="font0" style="text-decoration:underline;">| VAR + (expressionTj</span></p>
<p><span class="font0">■—</span><span class="font0" style="text-decoration:underline;">I VAR + atom~</span></p>
</div><br clear="all">
<div>
<p><span class="font0">-| atom*expressionHINT*expression j-</span></p>
</div><br clear="all">
<div>
<p><span class="font0">VAR + INT |</span><span class="font0" style="text-decoration:underline;"> </span><span class="font1" style="font-variant:small-caps;text-decoration:underline;">~VAr</span><span class="font0" style="text-decoration:underline;"> + VAR | </span><span class="font0">--</span><span class="font0" style="text-decoration:underline;">1 INT*atom + expression | </span><span class="font0">—</span><span class="font0" style="text-decoration:underline;">I INT*atom*expression | </span><span class="font0">—</span><span class="font0" style="text-decoration:underline;">I INT*( expression) j </span><span class="font0">•—</span><span class="font0" style="text-decoration:underline;">j INT*atom&quot;</span></p>
</div><br clear="all">
<div>
<p><span class="font0">(expression)</span></p>
</div><br clear="all">
<div>
<p><span class="font0">-j</span><span class="font0" style="text-decoration:underline;"> </span><span class="font0">VAR*expression</span><span class="font0" style="text-decoration:underline;"> </span><span class="font0">j-</span></p>
</div><br clear="all">
<div>
<p><span class="font1" style="font-variant:small-caps;">]---[-</span><span class="font1" style="font-variant:small-caps;text-decoration:underline;">| int*int|</span></p>
<p><span class="font0">l-</span><span class="font0" style="text-decoration:underline;">|~INT*VAR | </span><span class="font0">--</span><span class="font0" style="text-decoration:underline;">1 VAR*atom+expression | </span><span class="font0">—</span><span class="font0" style="text-decoration:underline;">I VAR*atom*expression | </span><span class="font0">—</span><span class="font0" style="text-decoration:underline;">|VAR*( expression) | </span><span class="font0">—</span><span class="font0" style="text-decoration:underline;">| VAR* atom ^</span><span class="font0">[-</span><span class="font0" style="text-decoration:underline;">| VAR* INT |</span></p>
<p><span class="font0" style="text-decoration:underline;">VAR*VAR |</span></p>
</div><br clear="all">
<div>
<p><span class="font0">j</span><span class="font0" style="text-decoration:underline;"> </span><span class="font0">(atom+expression?j-</span></p>
</div><br clear="all">
<div>
<p><span class="font0">—</span><span class="font0" style="text-decoration:underline;">I (atom*expression)|</span><span class="font0">~</span></p>
</div><br clear="all">
<div>
<p><span class="font0">—</span><span class="font0" style="text-decoration:underline;">I ((expression)) [</span><span class="font0">~</span></p>
</div><br clear="all">
<div>
<p><span class="font0" style="text-decoration:underline;">(INT+expression) |</span></p>
<p><span class="font0">|</span><span class="font0" style="text-decoration:underline;"> </span><span class="font0">(VAR+expression)</span><span class="font0" style="text-decoration:underline;"> </span><span class="font0">| q!</span><span class="font0" style="text-decoration:underline;"> </span><span class="font0">(INT*expression)</span><span class="font0" style="text-decoration:underline;"> </span><span class="font0">|</span></p>
<p><span class="font0">|</span><span class="font0" style="text-decoration:underline;"> </span><span class="font0">(VAR*expression)</span><span class="font0" style="text-decoration:underline;"> </span><span class="font0">| --</span><span class="font0" style="text-decoration:underline;">1 ((atom+expression)) | </span><span class="font0">—</span><span class="font0" style="text-decoration:underline;">I ((atom*expression)) | </span><span class="font0">—</span><span class="font0" style="text-decoration:underline;">I (((expression)))&quot;! </span><span class="font0">l-|((atom))^-|((INT))|</span></p>
</div><br clear="all">
<div><img src="HigherOrderPerl_files/HigherOrderPerl-53.jpg" alt="" style="width:132pt;height:62pt;">
<p><span class="font14">FIGURE 8.1 </span><span class="font16">Part of the search space of all possible expressions.</span></p>
</div><br clear="all">
<div>
<p><span class="font0" style="text-decoration:underline;">((VAR)) |</span></p>
</div><br clear="all">
<p><span class="font17">a particular leaf gives a derivation of the sentence at that leaf. For example, by tracing backwards from the </span><span class="font2">INT+INT </span><span class="font17">leaf to the root, we find a derivation of the sentence </span><span class="font2">INT+INT</span><span class="font17">:</span></p>
<table border="1">
<tr><td colspan="5">
<p><span class="font2">expression</span></p></td></tr>
<tr><td>
<p><span class="font2">atom</span></p></td><td>
<p><span class="font2">' + '</span></p></td><td>
<p><span class="font2">expression</span></p></td><td>
<p><span class="font2">#</span></p></td><td>
<p><span class="font2">expression clause 1</span></p></td></tr>
<tr><td>
<p><span class="font2">'INT'</span></p></td><td>
<p><span class="font2">' + '</span></p></td><td>
<p><span class="font2">expression</span></p></td><td>
<p><span class="font2">#</span></p></td><td>
<p><span class="font2">atom clause 1</span></p></td></tr>
<tr><td>
<p><span class="font2">'INT'</span></p></td><td>
<p><span class="font2">' + '</span></p></td><td>
<p><span class="font2">atom</span></p></td><td>
<p><span class="font2">#</span></p></td><td>
<p><span class="font2">expression clause 4</span></p></td></tr>
<tr><td style="vertical-align:bottom;">
<p><span class="font2">'INT'</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">' + '</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">'INT'</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">#</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">atom clause 1</span></p></td></tr>
</table>
<p><span class="font17">Finding a derivation for a particular sentence, therefore, is equivalent to locating the sentence in the tree, and therefore to a tree search.</span></p>
<p><span class="font17">Breadth-first search will eventually find the derivation, if it exists, but, as is usual with breadth-first search, consumes a lot of memory, and so isn’t used very often. Depth-first search is cheaper, but since the tree is typically infinite, depth-first search can go charging down one of the infinite branches, never to return. To illustrate the potential problem and its solution, here’s a particularly simple example grammar:</span></p>
<p><span class="font2">expr ^ 'A' expr expr ^ 'X'</span></p>
<p><span class="font17">An </span><span class="font17" style="font-style:italic;">expr</span><span class="font17"> is either an </span><span class="font2">X </span><span class="font17">token or else an </span><span class="font2">A </span><span class="font17">token followed by a complete </span><span class="font17" style="font-style:italic;">expr.</span><span class="font17"> Expressions </span><span class="font17" style="font-style:italic;">(expr)</span><span class="font17"> in this grammar therefore consist of some number of </span><span class="font2">A</span><span class="font17">’s followed by an </span><span class="font2">X</span><span class="font17">. The derivation tree looks like this:</span></p><img src="HigherOrderPerl_files/HigherOrderPerl-54.jpg" alt="" style="width:287pt;height:150pt;">
<p><span class="font17">A naive depth-first search will go charging down the topmost branch, looking for a complete sentence, and never find one. It will never investigate any of the</span></p>
<p><span class="font17">other branches. But there’s an obvious way to prune the search. Suppose the search is looking for </span><span class="font2">AX</span><span class="font17">. The search first examines the </span><span class="font2">Aexpr </span><span class="font17">node. Each node below this one will begin with </span><span class="font2">A</span><span class="font17">. The target sentence, </span><span class="font2">AX</span><span class="font17">, also begins with </span><span class="font2">A</span><span class="font17">, so the search continues. The next node is </span><span class="font2">AAexpr</span><span class="font17">. Every node below </span><span class="font17" style="font-style:italic;">this</span><span class="font17"> one will begin with </span><span class="font2">AA</span><span class="font17">. The target sentence does not begin with </span><span class="font2">AA</span><span class="font17">, so the search can ignore this entire branch, moving over to the sibling branch, </span><span class="font2">AX</span><span class="font17">. The search then succeeds. The tree is infinite, but the search process can trim out large infinite portions of it.</span></p>
<p><span class="font17">For an analogous example with a more typical grammar, consider our original grammar example. Suppose the target sentence is simply </span><span class="font2">VAR</span><span class="font17">. The search proceeds down the first branch, </span><span class="font17" style="font-style:italic;">atom+expression,</span><span class="font17"> to the first of its two sub-nodes, which is </span><span class="font2" style="font-style:italic;">INT+</span><span class="font17" style="font-style:italic;">expression.</span><span class="font17"> Each node below this one must begin with </span><span class="font2">INT +</span><span class="font17">, and the target sentence does not, so the search can skip all the lower nodes, moving instead to the </span><span class="font2">VAR+</span><span class="font17" style="font-style:italic;">expression</span><span class="font17"> branch. Each node below this one begins with </span><span class="font2">VAR +</span><span class="font17">, and the target sentence does not, so the search again skips all the lower nodes, moving instead to the </span><span class="font17" style="font-style:italic;">atom</span><span class="font2" style="font-style:italic;">*</span><span class="font17" style="font-style:italic;">expression</span><span class="font17"> branch, which fails similarly. The third branch, </span><span class="font2" style="font-style:italic;">(</span><span class="font17" style="font-style:italic;">expression</span><span class="font2" style="font-style:italic;">)</span><span class="font17" style="font-style:italic;">,</span><span class="font17"> fails even more quickly, since the search knows that all the lower nodes on that branch will begin with </span><span class="font2">(</span><span class="font17">, and the target sentence does not. Finally, the search moves to the fourth branch, </span><span class="font17" style="font-style:italic;">atom</span><span class="font17">, tries the first sub-node, </span><span class="font2">INT</span><span class="font17">, which fails, and then the second sub-node, </span><span class="font2">VAR</span><span class="font17">, which is the sentence that was being sought.</span></p>
<ul style="list-style:none;"><li>
<h5><a name="bookmark158"></a><span class="font19">8.2.2 Parsing Grammars</span></h5></li></ul>
<p><span class="font17">One way to implement a parser is the same way we’ve done tree search in previous chapters. The search maintains an agenda of sentential forms that need to be investigated. Initially, the agenda contains only the sentential form consisting of just the start symbol. At each stage, the search pops a sentential form off the agenda list. If the sentential form is a sentence, the search succeeds if it is the correct sentence, and continues otherwise. If the sentential form is not a sentence, but begins with some terminal symbols, the search checks to make sure that the target sentence begins with the same terminals. If not, the sentential form is discarded, pruning the search. When there are no sentential forms remaining in the agenda, the search fails.</span></p>
<p><span class="font17">If the sentential form popped from the agenda is not discarded, the search locates the leftmost nonterminal symbol in the sentential form — let’s say the sentential form is </span><span class="font2">VAR + </span><span class="font17" style="font-style:italic;">expression,</span><span class="font17"> so the leftmost nonterminal symbol is </span><span class="font17" style="font-style:italic;">expression. </span><span class="font17">The search looks up all the productions whose left side is this nonterminal symbol, </span><span class="font17" style="font-style:italic;">expression.</span><span class="font17"> In our example, there are four of these. It adds a new item to the agenda for each one, obtaining the new item by replacing the nonterminal symbol in the</span></p>
<div>
<p><span class="font15">8.2 PARSING IN GENERAL</span></p>
</div><br clear="all">
<div>
<h4><a name="bookmark369"></a><span class="font20">381</span></h4>
</div><br clear="all">
<p><span class="font17">left side of the production with the sentential form on the right. In our example, the search adds the four items </span><span class="font2">VAR + </span><span class="font17" style="font-style:italic;">atom</span><span class="font17"> + </span><span class="font17" style="font-style:italic;">expression,</span><span class="font2"> VAR + </span><span class="font17" style="font-style:italic;">atom</span><span class="font2"> * </span><span class="font17" style="font-style:italic;">expression, </span><span class="font2">VAR + ( </span><span class="font17" style="font-style:italic;">expression</span><span class="font2"> )</span><span class="font17">, and </span><span class="font2">VAR + </span><span class="font17" style="font-style:italic;">atom</span><span class="font17"> to the agenda. The process then repeats.</span></p>
<p><span class="font17">Here’s sample code, using the </span><span class="font2">make_dfs_search() </span><span class="font17">function of Section 5.3. We will represent a grammar as a hash:</span></p>
<p><span class="font2">expression =&gt; [['INT', '+', 'expression'], ['INT', '*', 'expression'], ['(', 'expression', ')'], ['INT'], ]</span></p>
<p><span class="font17">Keys are nonterminal symbols; values are arrays of productions. To distinguish a terminal from a nonterminal symbol, we just look it up in the hash:</span></p>
<p><span class="font2">require &quot;make-dfs-search&quot;;</span></p>
<div>
<p><span class="font9" style="font-weight:bold;">CODE LIBRARY</span></p>
</div><br clear="all">
<p><span class="font0">DFSParser.pm</span></p>
<p><span class="font2">sub make_parser_for_grammar {</span></p>
<p><span class="font2">my ($start, $grammar, $target) = @_;</span></p>
<p><span class="font2">my $is_nonterminal = sub {</span></p>
<p><span class="font2">my $symbol = shift;</span></p>
<p><span class="font2">exists $grammar-&gt;{$symbol};</span></p>
<p><span class="font2">};</span></p>
<p><span class="font17">When the search finds a sentential form, it scans the form to see if it matches the target sentence, stopping at the first nonterminal symbol. If the sentential form is too long or too short, or if one of its leading tokens doesn’t match the corresponding token in the target sentence, then the search won’t mention it:</span></p>
<p><span class="font2">my $is_interesting = sub {</span></p>
<p><span class="font2">my $sentential_form = shift;</span></p>
<p><span class="font2">for my $i (0 .. $#$sentential_form) {</span></p>
<p><span class="font2">return 1 if $is_nonterminal-&gt;($sentential_form-&gt;[$i]);</span></p>
<p><span class="font2">return if $i &gt;&nbsp;$#$target;</span></p>
<p><span class="font2">return if $sentential_form-&gt;[$i] ne $target-&gt;[$i];</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">return @$sentential_form == @$target ;</span></p>
<p><span class="font2">};</span></p>
<p><span class="font17">Given a sentential form, we find the children in the tree by locating the leftmost nonterminal symbol and replacing it with each of its productions from the grammar.</span></p>
<p><span class="font17">First we locate the leftmost nonterminal symbol:</span></p>
<p><span class="font2">my Schildren = sub {</span></p>
<p><span class="font2">my Ssentential_form = shift;</span></p>
<p><span class="font2">my Sleftmost_nonterminal;</span></p>
<p><span class="font2">my ©children;</span></p>
<p><span class="font2">for my Si (0 .. S#Ssentential_form) {</span></p>
<p><span class="font2">if (Sis_nonterminal-&gt;(Ssentential_form-&gt;[Si])) { Sleftmost_nonterminal = Si;</span></p>
<p><span class="font2">last;</span></p>
<p><span class="font17">If the sentential form is too long to match the target, we prune the tree at that point by reporting that it has no children:</span></p>
<p><span class="font2">} else {</span></p>
<p><span class="font2">return if Si &gt;&nbsp;S#Starget;</span></p>
<p><span class="font17">Similarly, if the initial tokens of the sentential form don’t match the initial tokens of the target sentence, we prune:</span></p>
<p><span class="font2">return if Starget-&gt;[Si] ne Ssentential_form-&gt;[Si];</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">If a node has no nonterminal symbols, it is a leaf and has no children:</span></p>
<p><span class="font2">return unless defined Sleftmost_nonterminal; # no nonterminal symbols</span></p>
<p><span class="font17">Having located the leftmost nonterminal symbol, we generate the child nodes by replacing the nonterminal with each of the possible productions for it:</span></p>
<p><span class="font2">for my Sproduction (©{Sgrammar-&gt;{Ssentential_form-&gt;[Sleftmost_nonterminal]}}) { my ©child = ©Ssentential_form;</span></p>
<p><span class="font2">splice ©child, Sleftmost_nonterminal, 1, ©Sproduction;</span></p>
<p><span class="font2">push ©children, \©child;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">©children;</span></p>
<p><span class="font2">};</span></p>
<ul style="list-style:none;"><li>
<p class="font15">8.2 PARSING IN GENERAL <span class="font20">383</span></p></li></ul>
<p><span class="font17">The parser itself uses </span><span class="font2">make_dfs_search() </span><span class="font17">(See Section 5-3) to do a DFS search of the space of sentential forms. The root node is the sentential form containing only the start symbol:</span></p>
<p><span class="font2">return sub {</span></p>
<p><span class="font2">make_dfs_search([Sstart], Schildren, Sis_interesting);</span></p>
<p><span class="font2">};</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">1;</span></p>
<h6><a name="bookmark370"></a><span class="font17">To use this, we say something like:</span></h6>
<p><span class="font2">my Sparser = make_parser_for_grammar 'expression',</span></p>
<p><span class="font2">{</span></p>
<p><span class="font2">expression =&gt; [['INT', '+', 'expression'],</span></p>
<p><span class="font2">['INT', '*', 'expression'],</span></p>
<p><span class="font2">['(', 'expression', ')'],</span></p>
<p><span class="font2">['INT'],</span></p>
<p><span class="font2">],</span></p>
<p><span class="font2">},</span></p>
<p><span class="font2">['(', 'INT', '*', '(', 'INT', '+', 'INT', ')', ')']</span></p>
<p><span class="font3"><sup>;</sup></span></p>
<p><span class="font17">The target sentence here is </span><span class="font2">( INT * ( INT + INT ) )</span><span class="font17">.</span></p>
<p><span class="font2">my Sparses = Sparser-&gt;();</span></p>
<p><span class="font2">while (my Sparse = Sparses-&gt;()) {</span></p>
<p><span class="font2">print &quot;@Sparse\n&quot;;</span></p>
<p><span class="font2">}</span></p>
<h6><a name="bookmark371"></a><span class="font17">The output is:</span></h6>
<p><span class="font2">expression</span></p>
<p><span class="font2">( expression )</span></p>
<p><span class="font2">( INT * expression )</span></p>
<p><span class="font2">( INT * ( expression ) )</span></p>
<p><span class="font2">( INT * ( INT + expression ) )</span></p>
<p><span class="font2">( INT * ( INT + INT ) )</span></p>
<p><span class="font17">which is indeed a derivation of the target sentence.</span></p>
<p><span class="font17">If we try parsing a non-sentence, say </span><span class="font2">INT * + INT</span><span class="font17">, we get:</span></p>
<p><span class="font2">expression</span></p>
<p><span class="font2">INT * expression</span></p>
<p><span class="font17">The target sentence never comes out, because the parser got stuck. It wanted to find a way to make </span><span class="font2">+ INT </span><span class="font17">into an expression, but it couldn’t.</span></p>
<ul style="list-style:none;"><li>
<h5><a name="bookmark159"></a><span class="font18">8.3 RECURSIVE-DESCENT PARSERS</span></h5></li></ul>
<p><span class="font17">A commonly used technique for parsing by DFS is to move the responsibility for the search back into the Perl function-call mechanism. A parser becomes a function that takes an input stream and examines its front for a certain pattern of tokens and values. If it likes what it sees, it returns two things: the value or meaning it assigns to the tokens, and the unused portion of the input. If the function doesn’t like what it sees, it returns false. If a parser represents a compound expression, it may call sub-parsers to help it decide if the input is in the proper form; this is where the DFS arises. Parsers that call each other recursively to parse an input in this way are called </span><span class="font17" style="font-style:italic;">recursive-descent parsers.</span></p>
<p><span class="font17">We’ll develop a module, </span><span class="font2">Parser.pm</span><span class="font17">, with tools for manufacturing recursivedescent parsers. The module starts off with the usual declarations:</span></p>
<div>
<p><span class="font9" style="font-weight:bold;">CODE LIBRARY</span></p>
</div><br clear="all">
<div>
<p><span class="font0">Parser.pm</span></p>
</div><br clear="all">
<p><span class="font2">package Parser;</span></p>
<p><span class="font2">use Stream ':all';</span></p>
<p><span class="font2">use base Exporter;</span></p>
<p><span class="font2">@EXPORT_OK = qw(parser nothing End_of_Input lookfor alternate concatenate star list_of operator T error action test);</span></p>
<p><span class="font2">%EXPORT_TAGS = ('all' =&gt; \@EXPORT_OK);</span></p>
<p><span class="font2">sub parser (&amp;); &nbsp;&nbsp;# Advance declaration - see below</span></p>
<ul style="list-style:none;"><li>
<h5><a name="bookmark160"></a><span class="font19">8.3.1 Very Simple Parsers</span></h5></li></ul>
<p><span class="font17">The simplest parser of all consumes no input and always succeeds, yielding the value </span><span class="font2">undef</span><span class="font17">:</span></p>
<p><span class="font2">sub nothing {</span></p>
<p><span class="font2">my $input = shift;</span></p>
<ul style="list-style:none;"><li>
<p class="font15">8.3 R E C U R S IVE - D E S C E NT PARSERS <span class="font20">385</span></p></li></ul>
<p><span class="font2">return (undef, Sinput);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">The next simplest just checks for the end of the input:</span></p>
<p><span class="font2">sub End_of_Input {</span></p>
<p><span class="font2">my Sinput = shift;</span></p>
<p><span class="font2">defined(Sinput) ? () : (undef, undef);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">If the input is undefined (that is, empty), then the function returns success: the value </span><span class="font2">undef</span><span class="font17">, and the remaining unread input, also </span><span class="font2">undef </span><span class="font17">(still empty). Otherwise, the function returns an empty list to indicate failure.</span></p>
<p><span class="font17">The next-simplest parsers look for single specific tokens. For example, a parser that succeeds if the next token is an </span><span class="font2">INT</span><span class="font17">:</span></p>
<p><span class="font2">sub INT {</span></p>
<p><span class="font2">my Sinput = shift;</span></p>
<p><span class="font2">return unless defined Sinput;</span></p>
<p><span class="font2">my Snext = head(Sinput);</span></p>
<p><span class="font2">return unless Snext-&gt;[0] eq 'INT';</span></p>
<p><span class="font2">my Stoken_value = Snext-&gt;[1];</span></p>
<p><span class="font2">return (Stoken_value, tail(Sinput));</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">If the input is empty, it fails immediately. Otherwise, it examines the token at the head of the input to see if it is an </span><span class="font2">INT </span><span class="font17">token; if not, it fails. But if the next token is an </span><span class="font2">INT </span><span class="font17">token, the function returns the token’s numeric value (stored in </span><span class="font2">Stoken-&gt;[1]</span><span class="font17">) and the remaining input. The value returned by this parser is a number, namely the value one would expect the integer token to represent.</span></p>
<p><span class="font17">Since we’ll need many of these token-recognizing functions, we’ll build them with a function factory:</span></p>
<p><span class="font2">sub lookfor {</span></p>
<p><span class="font2">my Swanted = shift;</span></p>
<p><span class="font2">my Svalue = shift || sub { S_[0][1] };</span></p>
<p><span class="font2">my Su = shift;</span></p>
<p><span class="font2">Swanted = [Swanted] unless ref Swanted;</span></p>
<p><span class="font2">my Sparser = parser {</span></p>
<p><span class="font2">my Sinput = shift;</span></p>
<p><span class="font2">return unless defined Sinput;</span></p>
<p><span class="font2">my Snext = head(Sinput);</span></p>
<p><span class="font2">for my Si (0 .. S#Swanted) {</span></p>
<p><span class="font2">next unless defined Swanted-&gt;[Si];</span></p>
<p><span class="font2">return unless Swanted-&gt;[Si] eq Snext-&gt;[Si]; }</span></p>
<p><span class="font2">my Swanted_value = Svalue-&gt;(Snext, Su);</span></p>
<p><span class="font2">return (Swanted_value, tail(Sinput));</span></p>
<p><span class="font2">};</span></p>
<p><span class="font2">return Sparser;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">To generate a function that looks for an </span><span class="font2">[OP +] </span><span class="font17">token, we can call </span><span class="font2">lookfor(['OP', ' + '])</span><span class="font17">. The generated parser will examine all the elements of </span><span class="font2">Swanted</span><span class="font17">, the argument, and will succeed if all the specified components in </span><span class="font2">Swanted </span><span class="font17">match the actual components of the next input token in </span><span class="font2">Snext</span><span class="font17">. To generate the preceding </span><span class="font2">INT </span><span class="font17">function, we could call </span><span class="font2">lookfor(['INT'])</span><span class="font17">. </span><span class="font2">lookfor('INT') </span><span class="font17">is a shorthand for </span><span class="font2">lookfor(['INT'])</span><span class="font17">.</span></p>
<p><span class="font2">lookfor() </span><span class="font17">gets an optional second argument, which is a callback function that turns the token into a value, and an optional third argument, which is a user parameter to the callback. The default callback extracts the second element from the token; with the lexers we’ve been using, this is always the literal text of the token.</span></p>
<p><span class="font17">The </span><span class="font2">parser() </span><span class="font17">function takes a block of code and builds a parser from it. Right now, it does nothing:</span></p>
<p><span class="font2">sub parser (&amp;) { S_[0] }</span></p>
<p><span class="font17">Later on, it will have some additional behavior.</span></p>
<ul style="list-style:none;"><li>
<h5><a name="bookmark161"></a><span class="font19">8.3.2 Parser Operators</span></h5></li></ul>
<p><span class="font17">Now that we have some simple parsers, how can we put parsers together? The most obvious thing to do with two parsers is to call them in sequence on the input. Suppose we have the following grammar:</span></p>
<p><span class="font2">doorbell ^ DING DONG</span></p>
<p><span class="font17">We need a parser that looks for </span><span class="font2">DING</span><span class="font17">, and then if it finds </span><span class="font2">DING </span><span class="font17">it looks for </span><span class="font2">DONG</span><span class="font17">, and if it finds </span><span class="font2">DONG</span><span class="font17">, it succeeds. This is called the </span><span class="font17" style="font-style:italic;">concatenation</span><span class="font17"> of the two components.</span></p>
<ul style="list-style:none;"><li>
<p class="font15">8.3 RECURSIVE-DESCENT PARSERS <span class="font20">387</span></p></li></ul>
<p><span class="font17">If we have a parser function that looks for </span><span class="font2">DING </span><span class="font17">and one that looks for </span><span class="font2">DONG</span><span class="font17">, here’s a function to concatenate them into a function that looks for </span><span class="font2">doorbell</span><span class="font17">:</span></p>
<p><span class="font2">sub concatenate {</span></p>
<p><span class="font2">my ($p1, $p2) = @_;</span></p>
<p><span class="font2">my Sparser = parser {</span></p>
<p><span class="font2">my SinputO = shift;</span></p>
<p><span class="font2">my (Sv1, Sinputl) = Sp1-&gt;(SinputO) or return;</span></p>
<p><span class="font2">my (Sv2, Sinput2) = Sp2-&gt;(Sinput1) or return;</span></p>
<p><span class="font2">return ([Sv1, Sv2], Sinput2);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">The value returned by the concatenation of the two parsers is an array containing the values returned by the parsers individually. The parser for the </span><span class="font2">doorbell </span><span class="font17">symbol can be built by saying:</span></p>
<p><span class="font2">Sdoorbell = concatenate(lookfor('DING'), lookfor('DONG'));</span></p>
<p><span class="font17">If given an input that begins with tokens </span><span class="font2">DING DONG ... </span><span class="font17">, this parser returns the value </span><span class="font2">['DING', 'DONG'] </span><span class="font17">and the remaining tokens.</span></p>
<p><span class="font17">It’s easy to generalize concatenation to more than two parsers:</span></p>
<p><span class="font2">sub concatenate { my @p = @_;</span></p>
<p><span class="font2">return \&amp;nothing if @p == 0;</span></p>
<p><span class="font2">my Sparser = parser {</span></p>
<p><span class="font2">my Sinput = shift;</span></p>
<p><span class="font2">my Sv;</span></p>
<p><span class="font2">my ©values;</span></p>
<p><span class="font2">for (©p) {</span></p>
<p><span class="font2">(Sv, Sinput) = S_-&gt;(Sinput) or return;</span></p>
<p><span class="font2">push ©values, Sv;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">return (\©values, Sinput);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">The other important operation on parsers is </span><span class="font17" style="font-style:italic;">alternation,</span><span class="font17"> which looks for an input in one of several alternative forms. For example, </span><span class="font2">alternate(lookfor('DING'),</span></p>
<p><span class="font20">388 </span><span class="font15">CHAPTER 8 Parsing</span></p>
<p><span class="font2">lookfor('DONG')) </span><span class="font17">succeeds if the next token in the input is </span><span class="font2">DING </span><span class="font17" style="font-style:italic;">or</span><span class="font2"> DONG </span><span class="font17">and fails otherwise. Here’s a two-parser version of </span><span class="font2">alternate()</span><span class="font17">:</span></p>
<p><span class="font2">sub alternate { my ($p1, $p2) = @_; my $parser = parser { my $input = shift; my ($v, $newinput); if (($v, $newinput) = $p1-&gt;($input)} { return ($v, $newinput) } if (($v, $newinput) = $p2-&gt;($input)} { return ($v, $newinput) } return;</span></p>
<p><span class="font2">};</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">The new parser tries running </span><span class="font2">$p1 </span><span class="font17">on the input; if </span><span class="font2">$p1 </span><span class="font17">succeeds, the new parser just returns whatever </span><span class="font2">$p1 </span><span class="font17">returned, effectively behaving like </span><span class="font2">$p1</span><span class="font17">. If </span><span class="font2">$p1 </span><span class="font17">fails, the new parser tries </span><span class="font2">$p2 </span><span class="font17">in the same way, behaving like </span><span class="font2">$p2 </span><span class="font17">instead. If they both fail, then the new parser indicates failure also.</span></p>
<p><span class="font17">It’s even easier to generalize </span><span class="font2">alternate()</span><span class="font17">:</span></p>
<p><span class="font2">sub alternate { my @p = @_; return parser { return () } if @p == 0; return $p[0] &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if @p == 1;</span></p>
<p><span class="font2">my $parser = parser { my $input = shift; my ($v, $newinput); for (@p) {</span></p>
<p><span class="font2">if (($v, $newinput) = $_-&gt;($input)) { return ($v, $newinput);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">return;</span></p>
<p><span class="font2">};</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">The only fine point here is that if there are no alternatives at all </span><span class="font2">(@p == 0)</span><span class="font17">, then </span><span class="font2">alternate() </span><span class="font17">returns a parser that never succeeds (</span><span class="font2">parser { return () }</span><span class="font17">).</span></p>
<ul style="list-style:none;"><li>
<h5><a name="bookmark162"></a><span class="font19">8.3.3 Compound Operators</span></h5></li></ul>
<p><span class="font17">Having written functions to build parsers to handle alternatives and concatenations of other parsers, it’s now easy to build more powerful operators for parsers.</span></p>
<ul style="list-style:none;"><li>
<p class="font15">8.3 R E C U R S IVE - D E S C E NT PARSERS <span class="font20">389</span></p></li></ul>
<p><span class="font17">For example, we can build an operator that’s analogous to the regex </span><span class="font2">* </span><span class="font17">operator. If the parser </span><span class="font2">$P </span><span class="font17">matches a certain kind of input, say </span><span class="font2">DING DONG</span><span class="font17">, then </span><span class="font2">star($P) </span><span class="font17">will be a parser that matches an empty input, </span><span class="font2">DING DONG</span><span class="font17">, </span><span class="font2">DING DONG DING DONG</span><span class="font17">, </span><span class="font2">DING DONG DING DONG DING DONG</span><span class="font17">, and so on. The first cut is:</span></p>
<p><span class="font2">sub star {</span></p>
<p><span class="font2">my $p = shift;</span></p>
<p><span class="font2">my $p_star;</span></p>
<p><span class="font2">$p_star = alternate(concatenate($p, $p_star),</span></p>
<p><span class="font2">\&amp;nothing);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">The idea here is to match an input of the form matched by </span><span class="font2">$p</span><span class="font17">, followed by something else (possibly empty) of the form </span><span class="font2">star($p)</span><span class="font17">, or, ifwe can’t find anything acceptable to </span><span class="font2">$p</span><span class="font17">, match nothing.</span></p>
<p><span class="font17">This function doesn’t quite work, because at the time </span><span class="font2">concatenate() </span><span class="font17">is called, its argument </span><span class="font2">$p_star </span><span class="font17">is still undefined. There are several tricks we can use to work around this. The simplest is:</span></p>
<p><span class="font2">sub star {</span></p>
<p><span class="font2">my $p = shift;</span></p>
<p><span class="font2">my $p_star;</span></p>
<p><span class="font2" style="font-weight:bold;">$p_star = alternate(concatenate($p, parser { $p_star-&gt;(@_) }),</span></p>
<p><span class="font2">\&amp;nothing);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">We’ve replaced </span><span class="font2">$p_star </span><span class="font17">on the right-hand side with a new parser that just calls </span><span class="font2">$p_star </span><span class="font17">on its arguments and returns the result. Behaviorally, the new parser is interchangeable with </span><span class="font2">$p_star </span><span class="font17">itself. But the </span><span class="font2">$p_star </span><span class="font17">on the right isn’t evaluated until the new parser is called, by which time </span><span class="font2">$p_star </span><span class="font17">has the right value. This trick goes by the peculiar name of </span><span class="font17" style="font-style:italic;">eta-conversion.</span></p>
<p><span class="font17">An alternative formulation would be:</span></p>
<p><span class="font2">sub star {</span></p>
<p><span class="font2">my $p = shift;</span></p>
<p><span class="font2">my $p_star;</span></p>
<p><span class="font2">$p_star = parser { alternate(concatenate($p, $p_star),</span></p>
<p><span class="font2">\&amp;nothing)-&gt;(@_) };</span></p>
<p><span class="font2">}</span></p>
<p><span class="font20">390 </span><span class="font15">CHAPTER 8 Parsing</span></p>
<p><span class="font17">which works for essentially the same reason. But it will be less efficient than the previous version, because it will call </span><span class="font2">alternate() </span><span class="font17">and </span><span class="font2">concatenate() </span><span class="font17">each time it is called.</span></p>
<p><span class="font17">Using our parser operators, we can build larger operators whenever it’s convenient. A common feature of programming languages is lists of various sorts. For example, Perl has list expressions:</span></p>
<p><span class="font2">@items = (Sexpressionl, Sexpression2, Sexpression3);</span></p>
<p><span class="font17">and blocks:</span></p>
<p><span class="font2">Sblock = sub { Sstatementl; Sstatement2; Sstatement3 };</span></p>
<p><span class="font17">Here’s a parser operator for parsing lists of elements separated by some kind of separator sequence:</span></p>
<p><span class="font2">sub list_of {</span></p>
<p><span class="font2">my (Selement, Sseparator) = @_;</span></p>
<p><span class="font2">Sseparator = lookfor('COMMA') unless defined Sseparator;</span></p>
<p><span class="font2">return concatenate(Selement,</span></p>
<p><span class="font2">star(concat(Sseparator, Selement));</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">l;</span></p>
<p><span class="font17">Now we can make a parser for lists of expressions:</span></p>
<p><span class="font2">Sexpression_list = list_of(Sexpression);</span></p>
<p><span class="font17">or for lists of statements:</span></p>
<p><span class="font2">Sstatement_list = list_of(Sstatement, lookfor('SEMICOLON'));</span></p>
<ul style="list-style:none;"><li>
<h5><a name="bookmark163"></a><span class="font18">8.4 ARITHMETIC EXPRESSIONS</span></h5></li></ul>
<p><span class="font17">In Section 8.2, we saw a grammar for a simple subset of arithmetic expressions:</span></p>
<p><span class="font2">expression ^ atom '+' expression</span></p>
<p><span class="font2">expression ^ atom '*' expression</span></p>
<ul style="list-style:none;"><li>
<p class="font15">8.4 ARITHMETIC EXPRESSIONS <span class="font20">391</span></p></li></ul>
<p><span class="font2">expression ^ '(' expression ')' expression ^ atom atom ^ 'INT' atom ^ 'VAR'</span></p>
<p><span class="font17">Let’s use an even simpler example, which has only numbers, and no variables:</span></p>
<p><span class="font2">expression ^ 'INT' '+' expression expression ^ 'INT' '*' expression expression ^ '(' expression ')' expression ^ 'INT'</span></p>
<p><span class="font17">There’s also an additional rule that represents an entire input:</span></p>
<p><span class="font2">entire_input ^ expression 'End_of_Input'</span></p>
<p><span class="font17">We will build a parser for this example, and later add the other required features, like subtraction. Transforming the grammar into a parser is simple. We build one parser function for each nonterminal symbol. We use </span><span class="font2">alternate() </span><span class="font17">when a symbol has several alternative definitions, and </span><span class="font2">concatenate^ </span><span class="font17">when a definition is the concatenation of more than one token or symbol. When the grammar mentions that a symbol might contain a token, we call </span><span class="font2">lookfor() </span><span class="font17">to build a parser that looks for that token; when the grammar mentions that a symbol might contain an instance of some other nonterminal symbol, we invoke the parser for that symbol.</span></p>
<p><span class="font17">To transform the preceding grammar, we first transform the definition of </span><span class="font2">expression </span><span class="font17">into a parser for expressions:</span></p>
<p><span class="font2">my $expression;</span></p>
<p><span class="font2">$expression = alternate(concatenate(lookfor('INT'),</span></p>
<p><span class="font2">lookfor(['OP', ' + ']),</span></p>
<p><span class="font2">$expression),</span></p>
<p><span class="font2">concatenate(lookfor('INT'),</span></p>
<p><span class="font2">lookfor(['OP', '*']),</span></p>
<p><span class="font2">$expression),</span></p>
<p><span class="font2">concatenate(lookfor(['OP', '(']),</span></p>
<p><span class="font2">$expression,</span></p>
<p><span class="font2">lookfor(['OP', ')'])),</span></p>
<p><span class="font2">lookfor('INT'));</span></p>
<p><span class="font17">Again, this doesn’t quite work. We can’t use </span><span class="font2">$expression </span><span class="font17">in its own definition, because until we’ve defined it, it’s </span><span class="font2">undef</span><span class="font17">. The eta-conversion trick works</span></p>
<h6><a name="bookmark372"></a><span class="font17">just fine here:</span></h6>
<div>
<p><span class="font9" style="font-weight:bold;">CODE LIBRARY</span></p>
</div><br clear="all">
<p><span class="font2">use Parser ':all';</span></p>
<p><span class="font0">expr-parser.pl </span><span class="font2">use Lexer ':all';</span></p>
<p><span class="font2">my Sexpression;</span></p>
<p><span class="font2" style="font-weight:bold;">my SExpression = parser { Sexpression-&gt;(@_) };</span></p>
<p><span class="font2">Sexpression = alternate(concatenate(lookfor('INT'), lookfor(['OP', ' + ']), </span><span class="font2" style="font-weight:bold;">SExpression), </span><span class="font2">concatenate(lookfor('INT'),</span></p>
<p><span class="font2">lookfor(['OP', '*']), </span><span class="font2" style="font-weight:bold;">SExpression),</span></p>
<p><span class="font2">concatenate(lookfor(['OP', '(']), </span><span class="font2" style="font-weight:bold;">SExpression, </span><span class="font2">lookfor(['OP', ')'])),</span></p>
<p><span class="font2">lookfor('INT'));</span></p>
<h6><a name="bookmark373"></a><span class="font17">Defining a parser for </span><span class="font2">entire_input </span><span class="font17">is simple:</span></h6>
<p><span class="font2">my Sentire_input = concatenate(SExpression, \&amp;End_of_Input);</span></p>
<h6><a name="bookmark374"></a><span class="font17">Suppose the input is the string </span><span class="font2">&quot;2 * 3 + (4 * 5)&quot;</span><span class="font17">, and we use the lexer of Section 8.1.3:</span></h6>
<p><span class="font2">my @input = q[2 * 3 + (4 * 5)]; my Sinput = sub { return shift @input };</span></p>
<p><a href="#bookmark375"><span class="font2">my Slexer = iterator_to_stream( make_lexer(Sinput, ['TERMINATOR', qr/;\n*|\n+/</span></a></p>
<p><a href="#bookmark376"><span class="font2">['INT', &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;qr/\b\d+\b/</span></a></p>
<p><a href="#bookmark377"><span class="font2">['PRINT', &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;qr/\bprint\b/</span></a></p>
<p><a href="#bookmark378"><span class="font2">['IDENTIFIER', qr|[A-Za-z_]\w*|</span></a></p>
<p><a href="#bookmark379"><span class="font2">['OP', &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;qr#\*\*|[-=+*/()]#</span></a></p>
<p><a href="#bookmark380"><span class="font2">['WHITESPACE', qr/\s+/, sub { &quot;&quot;&nbsp;}</span></a></p>
<p><span class="font2">) );</span></p>
<p><span class="font2">if (my (Sresult, Sremaining_input) = Sentire_input-&gt;(Slexer)) { use Data::Dumper;</span></p>
<ul style="list-style:none;"><li>
<p class="font15">8.4 ARITHMETIC EXPRESSIONS <span class="font20">393</span></p></li></ul>
<p><span class="font2">print Dumper($result), &quot;\n&quot;;</span></p>
<p><span class="font2">} else {</span></p>
<p><span class="font2">warn &quot;Parse error.\n&quot;;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">The parser does succeed, returning the following </span><span class="font2">$result</span><span class="font17">:</span></p>
<p><span class="font2">[</span></p>
<p><span class="font2">[</span></p>
<p><span class="font2">'2',</span></p>
<p><span class="font2">[</span></p>
<p><span class="font2">'3',</span></p>
<p><span class="font2">' + ',</span></p>
<p><span class="font2">[</span></p>
<p><span class="font2">'(',</span></p>
<p><span class="font2">[</span></p>
<p><span class="font2">'4',</span></p>
<p><span class="font2">'5'</span></p>
<p><span class="font2">],</span></p>
<p><span class="font2">')'</span></p>
<p><span class="font2">]</span></p>
<p><span class="font2">]</span></p>
<p><span class="font2">],</span></p>
<p><span class="font2">undef</span></p>
<p><span class="font2">]</span></p>
<p><span class="font17">Each of the three-element arrays was returned by </span><span class="font2">concatenated</span><span class="font17">, which returned an array of the three values that it concatenated. The trailing </span><span class="font2">undef </span><span class="font17">was returned by the </span><span class="font2">End_of_Input() </span><span class="font17">parser and concatenated into the final result by the </span><span class="font2">concatenated </span><span class="font17">in:</span></p>
<p><span class="font2">my $entire_input = concatenate($Expression, \&amp;End_of_Input);</span></p>
<p><span class="font17">There are a couple of problems with this result. What we’d most like is to have the parser generate an abstract syntax tree (AST), as in Section 2.2, where each node is labeled with an operator, and has child nodes representing the operands of that operator. We’d like the parser to understand that operators have different precedences — that </span><span class="font2">2*3 + 4 </span><span class="font17">should be parsed the same as </span><span class="font2">(2 * 3) + 4 </span><span class="font17">but differently from </span><span class="font2">2 * (3 + 4)</span><span class="font17">. The parentheses shouldn’t appear literally in the</span></p>
<p><span class="font20">394 </span><span class="font15">CHAPTER 8 Parsing</span></p>
<p><span class="font17">output; they should affect only the results of the parse. The value we’d like to get out of the parser for the input </span><span class="font2">&quot;2 * 3 + (4 * 5)&quot; </span><span class="font17">is:</span></p>
<p><span class="font2">[ ' + ',</span></p>
<p><span class="font2">[ </span><span class="font2" style="font-style:italic;">'*', 2,</span><span class="font2"> 3 ],</span></p>
<p><span class="font2">[ '*', 4, 5 ]</span></p>
<p><span class="font2">]</span></p>
<p><span class="font17">which says that the expression is adding two quantities: the product of 2 and 3, and the product of 4 and 5. Similarly, </span><span class="font2">2*3 + 4 </span><span class="font17">and </span><span class="font2">(2 * 3) + 4 </span><span class="font17">should produce:</span></p>
<p><span class="font2">[ ' + ', ['*', 2, 3], 4 ]</span></p>
<p><span class="font17">but </span><span class="font2">2 * (3 + 4) </span><span class="font17">should produce:</span></p>
<p><span class="font2">[ '*', 2, ['+', 3, 4] ]</span></p>
<p><span class="font17">We’ll tackle the precedence issue first. There are a few ways to take care of this, but the quickest one is to make a small change to the grammar. We can think of an expression like </span><span class="font2">&quot;2 * 3 + (4 * 5)&quot; </span><span class="font17">as a sum of one or more </span><span class="font17" style="font-style:italic;">terms, </span><span class="font17">where each term is a product of one or more </span><span class="font17" style="font-style:italic;">factors.</span><span class="font17"> If we rewrite the grammar to express this, the precedence will take care of itself:</span></p>
<p><span class="font2">entire_input ^ expression 'End_of_Input'</span></p>
<p><span class="font2">expression ^ term '+' expression | term</span></p>
<p><span class="font2">term ^ factor '*' term | factor</span></p>
<p><span class="font2">factor ^ 'INT' | '(' expression ')'</span></p>
<p><span class="font17">The notation:</span></p>
<p><span class="font2">a ^ b | c</span></p>
<p><span class="font17">is shorthand for the two rules:</span></p>
<p><span class="font2">a ^ b</span></p>
<p><span class="font2">a ^ c</span></p>
<ul style="list-style:none;"><li>
<p class="font15">8.4 ARITHMETIC EXPRESSIONS <span class="font20">395</span></p></li></ul>
<p><span class="font17">so the grammar says that an expression is either a plain term, or a term plus a complete expression. A term is either a plain factor, or a factor times a complete term. Finally, a factor is either an integer token or else a complete expression enclosed in parentheses.</span></p>
<p><span class="font17">Translating this grammar into code gives us:</span></p>
<p><span class="font2">use Parser ':all';</span></p>
<div>
<p><span class="font9" style="font-weight:bold;">CODE LIBRARY</span></p>
</div><br clear="all">
<p><span class="font2">use Lexer ':all'; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="font0">expr-p^er^.pl</span></p>
<p><span class="font2">my (Sexpression, $term, Sfactor);</span></p>
<p><a href="#bookmark381"><span class="font2">my SExpression = parser { Sexpression-&gt;(@_)</span></a></p>
<p><a href="#bookmark382"><span class="font2">my STerm &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= parser { Sterm &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&gt;(@_)</span></a></p>
<p><a href="#bookmark383"><span class="font2">my SFactor &nbsp;&nbsp;&nbsp;&nbsp;= parser { Sfactor &nbsp;&nbsp;&nbsp;-&gt;(@_)</span></a></p>
<p><span class="font2">Sexpression = alternate(concatenate(STerm, lookfor(['OP', ' + ']), SExpression), STerm);</span></p>
<p><span class="font2">Sterm = alternate(concatenate(SFactor, lookfor(['OP', '*']), STerm), SFactor);</span></p>
<p><span class="font2">Sfactor = alternate(lookfor('INT'), concatenate(lookfor(['OP', '(']), SExpression, lookfor(['OP', ')'])) );</span></p>
<p><span class="font2">Sentire_input = concatenate(SExpression, \&amp;End_of_Input);</span></p>
<p><span class="font17">The output of the parser on </span><span class="font2">&quot;2 * 3 + (4 * 5)&quot; </span><span class="font17">is now:</span></p>
<p><span class="font2">[</span></p>
<p><span class="font2">[ [ '2',</span></p>
<p><span class="font2">'3' ], ' + ',</span></p>
<p><span class="font20">396 </span><span class="font15">CHAPTER 8 Parsing</span></p>
<p><span class="font2">[</span></p>
<p><span class="font2">'(',</span></p>
<p><span class="font2">[</span></p>
<p><span class="font2">'4',</span></p>
<p><span class="font2">'5'</span></p>
<p><span class="font2">],</span></p>
<p><span class="font2">')'</span></p>
<p><span class="font2">]</span></p>
<p><span class="font2">],</span></p>
<p><span class="font2">undef</span></p>
<p><span class="font2">]</span></p>
<p><span class="font17">Not all the problems have been fixed, but the multiplication arguments have been clustered together, as we wanted; 2 is now associated with 3, and 4 with 5. Similarly, </span><span class="font2">&quot;2*3 + 4&quot; </span><span class="font17">produces:</span></p>
<p><span class="font2">[</span></p>
<p><span class="font2">[</span></p>
<p><span class="font2">[</span></p>
<p><span class="font2">'2',</span></p>
<p><span class="font2">'3'</span></p>
<p><span class="font2">],</span></p>
<p><span class="font2">' + ',</span></p>
<p><span class="font2">'4'</span></p>
<p><span class="font2">],</span></p>
<p><span class="font2">undef</span></p>
<p><span class="font2">]</span></p>
<p><span class="font17">with the 2 and 3 correctly grouped; the previous grammar produced this incorrect parse instead:</span></p>
<p><span class="font2">[</span></p>
<p><span class="font2">[</span></p>
<p><span class="font2">'2',</span></p>
<p><span class="font2">[</span></p>
<p><span class="font2">'3',</span></p>
<p><span class="font2">' + ',</span></p>
<p><span class="font2">'4'</span></p>
<ul style="list-style:none;"><li>
<p class="font15">8.4 ARITHMETIC EXPRESSIONS <span class="font20">397</span></p></li></ul>
<p><span class="font2">]</span></p>
<p><span class="font2">],</span></p>
<p><span class="font2">undef</span></p>
<p><span class="font2">]</span></p>
<p><span class="font17">Now we’ll fix the parsers so that they generate proper abstract syntax trees. This isn’t hard. All the necessary information is available; we just need to arrange it correctly. In a parser definition like this one:</span></p>
<p><span class="font2">Sterm = alternate(concatenate(SFactor,</span></p>
<p><span class="font2">lookfor(['OP', '*']),</span></p>
<p><span class="font2">STerm),</span></p>
<p><span class="font2">SFactor);</span></p>
<p><span class="font17">the </span><span class="font2">concatenate^ </span><span class="font17">operator assembles the values returned by its three arguments in the order they’re listed. But for an abstract syntax tree, we want the operator first, not second. Similarly, in:</span></p>
<p><span class="font2">Sfactor = alternate(lookfor('INT'),</span></p>
<p><span class="font2">concatenate(lookfor(['OP', '(']),</span></p>
<p><span class="font2">SExpression,</span></p>
<p><span class="font2">lookfor(['OP', ')']))</span></p>
<p><span class="font2">);</span></p>
<p><span class="font17">the </span><span class="font2">concatenate() </span><span class="font17">operator assembles all three values, but we’re interested only in the middle one, not the parentheses themselves. The value of a factor of the form </span><span class="font2">'(' expression ')' </span><span class="font17">should be the same as the value of the inner expression.</span></p>
<p><span class="font17">The following function is a little bit like </span><span class="font2">map </span><span class="font17">for parsers generated by </span><span class="font2">concatenate()</span><span class="font17">. It takes a parser and a transformation function, and returns a new parser, which recognizes the same inputs, but whose return value is filtered through the transformation function. It is named </span><span class="font2">T</span><span class="font17">, which is short for “transform”:</span></p>
<p><span class="font2">sub T {</span></p>
<p><span class="font2">my (Sparser, Stransform) = @_;</span></p>
<p><span class="font2">return parser {</span></p>
<p><span class="font2">my Sinput = shift;</span></p>
<p><span class="font2">if (my (Svalue, Snewinput) = Sparser-&gt;(Sinput)) {</span></p>
<p><span class="font2">Svalue = Stransform-&gt;(@Svalue);</span></p>
<p><span class="font2">return (Svalue, Snewinput);</span></p>
<p><span class="font2">} else { return;</span></p>
<p><span class="font2">} };</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">For example, to get </span><span class="font2">Sfactor </span><span class="font17">to throw away the parentheses and return only the inner expression, we replace this:</span></p>
<p><span class="font2">Sfactor = alternate(lookfor('INT'), concatenate(lookfor(['OP', '(']), SExpression, lookfor(['OP', ')'])) );</span></p>
<p><span class="font17">with this:</span></p>
<p><span class="font2">Sfactor = alternate(lookfor('INT'), </span><span class="font2" style="font-weight:bold;">T( </span><span class="font2">concatenate(lookfor(['OP', '(']), SExpression, lookfor(['OP', ')'])), </span><span class="font2" style="font-weight:bold;">sub { $_[1] }) </span><span class="font2">);</span></p>
<p><span class="font17">The three values accumulated by </span><span class="font2">concatenate() </span><span class="font17">are passed to the anonymous subroutine, which returns only the second one.</span></p>
<p><span class="font17">Similarly, to get </span><span class="font2">Sterm </span><span class="font17">to assemble the operator and operands in that order, we use:</span></p>
<p><span class="font2">Sterm = alternate( </span><span class="font2" style="font-weight:bold;">T( </span><span class="font2">concatenate(SFactor, lookfor(['OP', '*']), STerm),</span></p>
<p><span class="font2" style="font-weight:bold;">sub { [ $_[1], $_[0], $_[2] ]}), </span><span class="font2">SFactor);</span></p>
<p><span class="font17">For the term </span><span class="font2">3*4 </span><span class="font17">the three arguments to the anonymous subroutine will be </span><span class="font2">(3, '*', 4) </span><span class="font17">and the return value will be </span><span class="font2">['*', 3, 4]</span><span class="font17">. We should make a similar change to the definition of </span><span class="font2">Sexpression</span><span class="font17">, and we can eliminate the spurious</span></p>
<ul style="list-style:none;"><li>
<p class="font15">8.4 ARITHMETIC EXPRESSIONS <span class="font20">399</span></p></li></ul>
<p><span class="font17">trailing </span><span class="font2">undef </span><span class="font17">by changing </span><span class="font2">$entire_input </span><span class="font17">to:</span></p>
<p><span class="font2">my $entire_input = T(concatenate($Expression, \&amp;End_of_Input), sub { $_[0] }</span></p>
<p><span class="font2">);</span></p>
<h6><a name="bookmark384"></a><span class="font17">With these changes, the output of the parser, given the input </span><span class="font2">&quot;2 * 3 + (4 * 5)&quot;</span><span class="font17">,</span></h6>
<h6><span class="font17">is perfect:</span></h6>
<p><span class="font2">[</span></p>
<p><span class="font2">' + ',</span></p>
<p><span class="font2">[</span></p>
<p><span class="font2">'2',</span></p>
<p><span class="font2">'3'</span></p>
<p><span class="font2">],</span></p>
<p><span class="font2">[</span></p>
<p><span class="font2">'4',</span></p>
<p><span class="font2">'5'</span></p>
<p><span class="font2">]</span></p>
<p><span class="font2">]</span></p>
<p><span class="font2">&quot;2*3 + 4&quot; </span><span class="font17">and </span><span class="font2">&quot;(2 * 3) + 4&quot; </span><span class="font17">both come back as:</span></p>
<p><span class="font2">[</span></p>
<p><span class="font2">' + ',</span></p>
<p><span class="font2">[</span></p>
<p><span class="font2">'2',</span></p>
<p><span class="font2">'3'</span></p>
<p><span class="font2">],</span></p>
<p><span class="font2">'4'</span></p>
<p><span class="font2">]</span></p>
<h6><a name="bookmark385"></a><span class="font17">but </span><span class="font2">&quot;2 * (3 + 4)&quot;</span><span class="font17">, which is different, comes back as:</span></h6>
<p><span class="font2">[</span></p>
<p><span class="font2">'2',</span></p>
<p><span class="font2">[</span></p>
<p><span class="font2">' + ',</span></p>
<p><span class="font2">'3',</span></p>
<p><span class="font2">'4'</span></p>
<ul style="list-style:none;"><li>
<h5><a name="bookmark164"></a><span class="font19">8.4.1 A Calculator</span></h5></li></ul>
<p><span class="font17">By adjusting the transformation functions, we can turn our parser into a calculator instead of an abstract-syntax-tree-maker. The value returned by each parser is an abstract syntax tree for some part of the expression. We need to change the parsers to return numeric values instead of AST values. Only two changes are necessary:</span></p>
<p><span class="font2">Sexpression = alternate(T(concatenate(STerm, lookfor(['OP', ' + ']), SExpression),</span></p>
<p><span class="font2" style="font-weight:bold;">sub { $_[0] + $_[2] }), </span><span class="font2">STerm);</span></p>
<div>
<p><span class="font2">Sterm</span></p>
</div><br clear="all">
<p><span class="font2">= alternate(T(concatenate(SFactor, lookfor(['OP', '*']), STerm),</span></p>
<p><span class="font2" style="font-weight:bold;">sub { $_[0] * $_[2] }), </span><span class="font2">SFactor);</span></p>
<p><span class="font17">The values returned by the parsers are no longer arrays; now they’re numbers. When the parser sees an expression like </span><span class="font2">term + expression</span><span class="font17">, instead of building an abstract-syntax-tree node out of the values of the term and the expression, it simply adds the values numerically and returns the sum. Similarly, when computing the value of a term, it just does numeric multiplication on the constituents of the term.</span></p>
<p><span class="font17">The output for </span><span class="font2">&quot;2 * (3 + 4)&quot; </span><span class="font17">is now just the number 14, and the output for </span><span class="font2">&quot;2 * 3 + 4&quot; </span><span class="font17">and </span><span class="font2">&quot;(2 * 3) + 4&quot; </span><span class="font17">is 10. The parser returns failure when given an input with mismatched or unbalanced parentheses, or any other syntactically incorrect input, such as an input with two consecutive operators or numbers.</span></p>
<ul style="list-style:none;"><li>
<h5><a name="bookmark165"></a><span class="font19">8.4.2 Left Recursion</span></h5></li></ul>
<p><span class="font17">Let’s add subtraction and division to the calculator. This requires only small changes to the grammar:</span></p>
<p><span class="font2">entire_input ^ expression 'End_of_Input' expression ^ term '+' expression</span></p>
<p><span class="font2" style="font-weight:bold;">expression </span><span class="font2">^ </span><span class="font2" style="font-weight:bold;">term '-' expression </span><span class="font2">expression ^ term term ^ factor '*' term </span><span class="font2" style="font-weight:bold;">term </span><span class="font2">^ </span><span class="font2" style="font-weight:bold;">factor '/' term </span><span class="font2">term ^ factor factor ^ 'INT' | '(' expression ')'</span></p>
<h6><a name="bookmark386"></a><span class="font17">In the code, the definition of </span><span class="font2">Sexpression </span><span class="font17">changes from this:</span></h6>
<p><span class="font2">Sexpression = alternate(concatenate($Term, lookfor(['OP', ' + ']), SExpression), STerm);</span></p>
<h6><a name="bookmark387"></a><span class="font17">to this:</span></h6>
<p><span class="font2">Sexpression = alternate(concatenate(STerm, lookfor(['OP', '+']), SExpression), </span><span class="font2" style="font-weight:bold;">concatenate(STerm, lookfor(['OP', '-']), SExpression), </span><span class="font2">STerm);</span></p>
<h6><a name="bookmark388"></a><span class="font17">and </span><span class="font2">Sterm </span><span class="font17">changes similarly. We can get the calculator to calculate numeric values by supplying transformation functions like these:</span></h6>
<p><span class="font2">Sexpression = alternate(T(concatenate(STerm, lookfor(['OP', '+']), SExpression), sub { S_[0] + S_[2] }), T(concatenate(STerm, lookfor(['OP', '-']), SExpression), sub { S_[0] - S_[2] }), STerm);</span></p>
<p><span class="font17">But now there’s a problem: If we ask for the value of </span><span class="font2">&quot;8 - 4&quot;</span><span class="font17">, we get the right answer. But if we ask for the value of </span><span class="font2">&quot;8 - 4 - 3&quot;</span><span class="font17">, we get 7; the correct answer is 1. What’s gone wrong?</span></p>
<p><span class="font17">If we return to the AST version of the program, we can see the problem. </span><span class="font2">&quot;8 - 4 - 3&quot; </span><span class="font17">is parsed as:</span></p>
<p><span class="font2">[ '-', 8, [ '-', 4, 3 ]]</span></p>
<p><span class="font20">402 </span><span class="font15">CHAPTER 8 Parsing</span></p>
<p><span class="font17">which is the same as the parse of </span><span class="font2">&quot;8 - (4 - 3)&quot;</span><span class="font17">. But </span><span class="font2">&quot;8 - 4 - 3&quot; </span><span class="font17">is conventionally understood to mean </span><span class="font2">&quot;(8 - 4) - 3&quot;</span><span class="font17">, which parses as:</span></p>
<p><span class="font2">[ '-', [ '-', 8, 4], 3 ]</span></p>
<p><span class="font17">We say that subtraction </span><span class="font17" style="font-style:italic;">associates from left to right</span><span class="font17"> because, in the absence of parentheses, multiple subtractions are performed from left to right.</span></p>
<p><span class="font17">The essential problem is that there are two different ways to understand an expression like </span><span class="font2">&quot;8 - 4 - 3&quot;</span><span class="font17">. We can parse it as an expression (&quot;</span><span class="font2">8 - 4</span><span class="font17">&quot;) minus a term (&quot;</span><span class="font2">3</span><span class="font17">&quot;) or as a term (&quot;</span><span class="font2">8</span><span class="font17">&quot;) minus an expression (&quot;</span><span class="font2">4 - 3</span><span class="font17">&quot;). The convention says that it should be the former, but our grammar rule:</span></p>
<p><span class="font2">expression ^ term '-' expression</span></p>
<p><span class="font17">says it’s the latter. The problem didn’t arise for addition; the values of the two parses were numerically the same because addition is associative, which means that we get the same answers whether we consider it to associate from left to right or from right to left.</span></p>
<p><span class="font17">It might seem that we could fix this by reversing the order of the expression and term symbols in the grammar, as follows:</span></p>
<p><span class="font2" style="font-weight:bold;">expression </span><span class="font2">^ </span><span class="font2" style="font-weight:bold;">expression '+' term expression </span><span class="font2">^ </span><span class="font2" style="font-weight:bold;">expression '-' term </span><span class="font2">expression ^ term</span></p>
<p><span class="font17">Then the corresponding parser definition in the code becomes:</span></p>
<p><span class="font2" style="font-weight:bold;">$expression = alternate(T(concatenate($Expression, </span><span class="font2">lookfor(['OP', '+']), </span><span class="font2" style="font-weight:bold;">$Term),</span></p>
<p><span class="font2">sub { $_[0] + $_[2] }), </span><span class="font2" style="font-weight:bold;">T(concatenate($Expression, </span><span class="font2">lookfor(['OP', '-']), </span><span class="font2" style="font-weight:bold;">$Term),</span></p>
<p><span class="font2">sub { $_[0] - $_[2] }), $Term);</span></p>
<p><span class="font17">Unfortunately, if we do this, the parser no longer works. The first thing that the </span><span class="font2">$expression </span><span class="font17">parser does is to look for another expression, so it recurses forever. Returning to the sentential form trees of Section 8.2.1, we see that this is because there’s a branch that looks like this:</span></p><img src="HigherOrderPerl_files/HigherOrderPerl-55.jpg" alt="" style="width:287pt;height:114pt;">
<p><span class="font17">The topmost branch is infinite, so we run the risk that a depth-first search on it will never terminate. We’d been dealing with this risk by pruning the search at each node whose initial terminal symbols failed to match the target sentence. But here, none of the nodes in the topmost branch have any initial terminal symbols, so the pruning doesn’t work, and the search </span><span class="font17" style="font-style:italic;">is</span><span class="font17"> infinite.</span></p>
<p><span class="font17">A grammar rule of the form:</span></p>
<p><span class="font2">symbol ^ symbol stuff...</span></p>
<p><span class="font17">is called </span><span class="font17" style="font-style:italic;">left-recursive;</span><span class="font17"> recursive-descent parsers hang forever whenever they meet left-recursive grammar rules. In general, left-recursion can be quite complicated; consider:</span></p>
<p><span class="font2">A ^ B stuff</span></p>
<p><span class="font2">B ^ C stuff</span></p>
<p><span class="font2">C ^ A stuff</span></p>
<p><span class="font17">Our example is much simpler; the recursion loop involves only one symbol instead of three. Fortunately, there’s a technique for eliminating simple loops from a grammar. If we have a set of rules like this:</span></p>
<p><span class="font2">symbol ^ symbol A | symbol B | X | Y</span></p>
<p><span class="font17">We can transform them into equivalent rules that aren’t left-recursive. Let’s consider what a </span><span class="font17" style="font-style:italic;">symbol</span><span class="font17"> must begin with. Clearly, it must be an </span><span class="font2">X </span><span class="font17">or a </span><span class="font2">Y</span><span class="font17">. </span><span class="font17" style="font-style:italic;">symbol</span><span class="font17"> might</span></p>
<p><span class="font17">expand to something more complicated that also begins with a </span><span class="font17" style="font-style:italic;">symbol,</span><span class="font17"> but in that case we just have to ask the same question again. So a </span><span class="font17" style="font-style:italic;">symbol</span><span class="font17"> must be an </span><span class="font2">X </span><span class="font17">or a </span><span class="font2">Y </span><span class="font17">followed by a tail of </span><span class="font2">A</span><span class="font17">’s and </span><span class="font2">B</span><span class="font17">’s. The equivalent grammar is:</span></p>
<p><span class="font2">symbol ^ X symbol_tail | Y symbol_tail symbol_tail ^ A symbol_tail | B symbol_tail | (nothing)</span></p>
<p><span class="font17">For example, our left-recursive subtraction and addition rule:</span></p>
<p><span class="font2">expression ^ expression '+' term expression ^ expression '-' term expression ^ term</span></p>
<p><span class="font17">becomes:</span></p>
<p><span class="font2">expression ^ term expression_tail</span></p>
<p><span class="font2">expression_tail ^ '+' term expression_tail</span></p>
<p><span class="font2">expression_tail ^ '-' term expression_tail</span></p>
<p><span class="font2">expression_tail ^ (nothing)</span></p>
<p><span class="font17" style="font-style:italic;">expression_tail</span><span class="font17"> here represents the “rest of an expression.” A full expression is a single term followed by the rest of an expression; the rest of the expression is either empty, or else a </span><span class="font2">+ </span><span class="font17">or </span><span class="font2">- </span><span class="font17">followed by another term followed by the rest of the rest of the expression. If we apply a similar transformation to the </span><span class="font17" style="font-style:italic;">term</span><span class="font17"> rule of the grammar, we get:</span></p>
<p><span class="font2">entire_input ^ expression 'End_of_Input'</span></p>
<p><span class="font2">expression ^ term expression_tail</span></p>
<p><span class="font2">expression_tail ^ '+' term expression_tail</span></p>
<p><span class="font2">expression_tail ^ '-' term expression_tail</span></p>
<p><span class="font2">expression_tail ^ (nothing)</span></p>
<p><span class="font2" style="font-weight:bold;">term </span><span class="font2">^ </span><span class="font2" style="font-weight:bold;">factor term_tail</span></p>
<p><span class="font2" style="font-weight:bold;">term_tail </span><span class="font2">^ </span><span class="font2" style="font-weight:bold;">'*' factor term_tail</span></p>
<p><span class="font2" style="font-weight:bold;">term_tail </span><span class="font2">^ </span><span class="font2" style="font-weight:bold;">'/' factor term_tail</span></p>
<p><span class="font2" style="font-weight:bold;">term_tail </span><span class="font2">^ </span><span class="font2" style="font-weight:bold;">(nothing)</span></p>
<p><span class="font2">factor ^ 'INT'</span></p>
<p><span class="font2">factor ^ '(' expression ')'</span></p>
<ul style="list-style:none;"><li>
<p class="font15">8.4 ARITHMETIC EXPRESSIONS <span class="font20">405</span></p></li></ul>
<p><span class="font17">Now, however, we have another problem. Before, we had rules like:</span></p>
<p><span class="font2">expression ^ term '+' expression</span></p>
<p><span class="font17">and it was obvious how to compute the value of an expression, given the values of the subterm and the subexpression: Just add them. But what value should we assign to an </span><span class="font17" style="font-style:italic;">expression_tail?</span><span class="font17"> It represents an incomplete expression, such as </span><span class="font2">&quot;+ 3 - 4&quot;</span><span class="font17">. When we’re parsing an expression like </span><span class="font2">&quot;1 + 3 - 4&quot;</span><span class="font17">, the </span><span class="font2">&quot;1&quot; </span><span class="font17">will become the </span><span class="font17" style="font-style:italic;">term</span><span class="font17"> part at the beginning of the </span><span class="font17" style="font-style:italic;">expression</span><span class="font17"> rule, and the </span><span class="font2">&quot;+ 3 - 4&quot; </span><span class="font17">will become the </span><span class="font17" style="font-style:italic;">expression_tail</span><span class="font17"> part at the end of the </span><span class="font17" style="font-style:italic;">expression</span><span class="font17"> rule. The value of the </span><span class="font17" style="font-style:italic;">expression</span><span class="font17"> can’t be calculated until we finish parsing the </span><span class="font17" style="font-style:italic;">expression_tail</span><span class="font17"> and assign a value to it, because the value of the </span><span class="font17" style="font-style:italic;">expression_tail</span><span class="font17"> will be passed to the </span><span class="font17" style="font-style:italic;">expression</span><span class="font17"> rule for the computation of </span><span class="font17" style="font-style:italic;">its</span><span class="font17"> value. But the value of an </span><span class="font17" style="font-style:italic;">expression_tail </span><span class="font17">can’t be a number, because it’s an incomplete expression; the parser won’t know what number it is until it finished parsing the complete expression.</span></p>
<p><span class="font17">The natural way to represent the result of an incomplete computation such as an </span><span class="font17" style="font-style:italic;">expression_tail</span><span class="font17"> is as a function. An expression tail is like an expression with a blank space at the beginning:</span></p>
<p><span class="font2"> +3-4</span></p>
<p><span class="font17">which can be represented as the function:</span></p>
<p><span class="font2">sub { $_[0] + 3 - 4 }</span></p>
<p><span class="font17">When the missing parts of the expression become known, they can be passed as arguments to the function, which will compute the final result. The value of an </span><span class="font17" style="font-style:italic;">expression_tail</span><span class="font17"> will be a function, which, given the missing part of the expression, computes the final result. The action rule for the complete expression will get a </span><span class="font17" style="font-style:italic;">term</span><span class="font17"> value and an </span><span class="font17" style="font-style:italic;">expression_tail</span><span class="font17"> function, and will pass the value to the function to compute the final result.</span></p>
<p><span class="font17">As an example, let’s consider </span><span class="font2">&quot;5 + 7&quot;</span><span class="font17">. Let’s also disregard multiplication and division for a little while; our grammar will be:</span></p>
<p><span class="font2">expression ^ term expression_tail</span></p>
<p><span class="font2">expression_tail ^ '+' term expression_tail</span></p>
<p><span class="font2">| '-' term expression_tail</span></p>
<p><span class="font2">| (nothing)</span></p>
<p><span class="font2">term ^ 'INT' | '(' expression ')'</span></p>
<p><span class="font17">If </span><span class="font2">&quot;5 + 7&quot; </span><span class="font17">is to be an </span><span class="font17" style="font-style:italic;">expression,</span><span class="font17"> it must be a </span><span class="font17" style="font-style:italic;">term</span><span class="font17"> followed by an </span><span class="font17" style="font-style:italic;">expression_tail. </span><span class="font17">The </span><span class="font17" style="font-style:italic;">term</span><span class="font17"> is clearly </span><span class="font2">&quot;5&quot;</span><span class="font17">, and has a value of 5.</span></p>
<p><span class="font17">The </span><span class="font17" style="font-style:italic;">expression_tail</span><span class="font17"> matches the first alternative, and is a “+” followed by a </span><span class="font17" style="font-style:italic;">term</span><span class="font17"> followed by another </span><span class="font17" style="font-style:italic;">expression_tail.</span><span class="font17"> The </span><span class="font17" style="font-style:italic;">term</span><span class="font17"> here is clearly </span><span class="font2">&quot;7&quot;</span><span class="font17">, and the following </span><span class="font2">expression_tail </span><span class="font17">is empty. The main </span><span class="font17" style="font-style:italic;">expression_tail</span><span class="font17">represents the partial input </span><span class="font2">&quot;+ 7&quot;</span><span class="font17">, and so its value should be a function that adds 7 to its argument: </span><span class="font2">sub { $_[0] + 7 }</span><span class="font17">.</span></p>
<p><span class="font17">Themain </span><span class="font17" style="font-style:italic;">expression</span><span class="font17"> now gets two values, which are 5 and </span><span class="font2">sub { $_[0]+ 7 }</span><span class="font17">. It passes the number to the function; the result is the value of the expression, 12.</span></p>
<p><span class="font17">To program </span><span class="font17" style="font-style:italic;">expression</span><span class="font17">, we write:</span></p>
<p><span class="font2">Sexpression = T(concatenate(STerm, $Expression_Tail), sub { S_[1]-&gt;(S_[0]) } );</span></p>
<p><span class="font17">It gets the value of the term (</span><span class="font2">S_[0]</span><span class="font17">), which is a number, and the value of the partial expression </span><span class="font17" style="font-style:italic;">expression_tail</span><span class="font17"> (</span><span class="font2">S_[1]</span><span class="font17">), which is a function. It passes the term value to the expression tail function, and returns the result.</span></p>
<p><span class="font17">The code for </span><span class="font17" style="font-style:italic;">expression_tail</span><span class="font17"> is a little more complicated. Let’s consider just the case for the rule:</span></p>
<p><span class="font2">expression_tail ^ '+' term expression_tail</span></p>
<p><span class="font17">The parser code looks like this:</span></p>
<p><span class="font2">Sexpression_tail = alternate(T(concatenate(lookfor(['OP', '+']),</span></p>
<p><span class="font2">STerm,</span></p>
<p><span class="font2">SExpression_Tail),</span></p>
<p><span class="font2">sub { ... }),</span></p>
<p><span class="font17">Suppose the input has this form:</span></p>
<p><span class="font2">LEFT + term RIGHT</span></p>
<p><span class="font17">Say that </span><span class="font2">Sterm_value </span><span class="font17">is the number value returned by the </span><span class="font2">STerm </span><span class="font17">parser for the </span><span class="font17" style="font-style:italic;">term</span><span class="font17"> part of the input, and </span><span class="font2">Srest </span><span class="font17">is the function value returned by the </span><span class="font2">Sexpression_tail </span><span class="font17">parser for the </span><span class="font17" style="font-style:italic;">RIGHT</span><span class="font17"> part of the input. The argument to </span><span class="font2">T() </span><span class="font17">is a function factory that wants to build a new function that represents the + </span><span class="font17" style="font-style:italic;">term RIGHT</span><span class="font17"> part of the input.</span></p>
<p><span class="font17">The arguments to the function factory are the </span><span class="font2">Sterm_value </span><span class="font17">and the </span><span class="font2">SRIGHT </span><span class="font17">function (and also the </span><span class="font2">&quot;+&quot; </span><span class="font17">token):</span></p>
<p><span class="font2">sub {</span></p>
<p><span class="font2">my (Splus_token, Sterm_value, SRIGHT) = @_;</span></p>
<ul style="list-style:none;"><li>
<p class="font15">8.4 ARITHMETIC EXPRESSIONS</p>
<div>
<p><span class="font20">407</span></p>
</div><br clear="all"></li></ul>
<p><span class="font17">The job of this function factory is to build another function that given the value of </span><span class="font17" style="font-style:italic;">LEFT,</span><span class="font17"> will return the value of the entire expression. The function we want to build is:</span></p>
<p><span class="font2">return sub { SRIGHT-&gt;(S_[0] + Sterm_value) }</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">The code for the minus rule is almost the same:</span></p>
<p><span class="font2">T(concatenate(lookfor(['OP', '-']),</span></p>
<p><span class="font2">STerm,</span></p>
<p><span class="font2">SExpression_Tail),</span></p>
<p><span class="font2">sub {</span></p>
<p><span class="font2">my (Splus_token, Sterm_value, RIGHT) = @_;</span></p>
<p><span class="font2">return sub { SRIGHT-&gt;(S_[0] - Sterm_value) }</span></p>
<p><span class="font2">}),</span></p>
<p><span class="font17">The code for the “nothing” rule is simple. The “rest” of the expression contains nothing at all. We want a function, which, given the value of the left part of the expression, returns the value of the entire expression. But if the “rest” of the expression is empty, then the value of the left part of the expression </span><span class="font17" style="font-style:italic;">is</span><span class="font17"> the value of the entire expression. So the function we want is just the function that returns its argument unchanged:</span></p>
<p><span class="font2">T(\&amp;nothing, sub { sub { S_[0] } })</span></p>
<p><span class="font17">The code for the entire expression parser is:</span></p>
<p><span class="font2">Sexpression = T(concatenate($Term, $Expression_Tail),</span></p>
<p><span class="font2">sub { $_[1]-&gt;($_[0]) }</span></p>
<p><span class="font2">);</span></p>
<p><span class="font2">Sexpression_tail = alternate(T(concatenate(lookfor(['OP', '+']),</span></p>
<p><span class="font2">STerm,</span></p>
<p><span class="font2">SExpression_Tail),</span></p>
<p><span class="font2">sub { my (Sop, Stv, Srest) = @_;</span></p>
<p><span class="font2">sub { Srest-&gt;(S_[0] + Stv) }</span></p>
<p><span class="font2">}),</span></p>
<p><span class="font2">T(concatenate(lookfor(['OP', '-']),</span></p>
<p><span class="font2">STerm,</span></p>
<p><span class="font2">SExpression_Tail),</span></p>
<p><span class="font2">sub { my (Sop, Stv, Srest) = @_;</span></p>
<div>
<p><span class="font20">408</span></p>
</div><br clear="all">
<p><span class="font15">CHAPTER 8 Parsing</span></p>
<p><span class="font2">sub { Srest-&gt;(S_[0] - Stv) }</span></p>
<p><span class="font2">}),</span></p>
<p><span class="font2">T(\&amp;nothing, sub { sub { S_[0] } })</span></p>
<p><span class="font2">);</span></p>
<p><span class="font17">With this structure, the parser works perfectly for all arithmetic expressions. To make it generate ASTs instead of numbers, we use:</span></p>
<p><span class="font2">Sexpression = T(concatenate($Term, SExpression_Tail),</span></p>
<p><span class="font2">sub { S_[1]-&gt;(S_[0]) }</span></p>
<p><span class="font2">);</span></p>
<p><span class="font2">Sexpression_tail = alternate(T(concatenate(lookfor(['OP', '+']),</span></p>
<p><span class="font2">STerm,</span></p>
<p><span class="font2">SExpression_Tail),</span></p>
<p><span class="font2">sub { my (Sop, Stv, Srest) = @_;</span></p>
<p><span class="font2" style="font-weight:bold;">sub { [ '+', $tv, Srest-&gt;(S_[0]) ] }</span></p>
<p><span class="font2">}),</span></p>
<p><span class="font2">T(concatenate(lookfor(['OP', '-']),</span></p>
<p><span class="font2">STerm,</span></p>
<p><span class="font2">SExpression_Tail),</span></p>
<p><span class="font2">sub { my (Sop, Stv, Srest) = @_;</span></p>
<p><span class="font2" style="font-weight:bold;">sub {['-', Stv, Srest-&gt;(S_[0]) ] }</span></p>
<p><span class="font2">}),</span></p>
<p><span class="font2">T(\&amp;nothing, sub { sub { S_[0] } })</span></p>
<p><span class="font2">);</span></p>
<ul style="list-style:none;"><li>
<h5><a name="bookmark166"></a><span class="font19">8.4.3 A Variation on </span><span class="font3">star()</span></h5></li></ul>
<p><span class="font17">We can use the </span><span class="font2">T() </span><span class="font17">function to improve our definition for </span><span class="font2">star()</span><span class="font17">. Formerly, the parser </span><span class="font2">star(lookfor('INT')) </span><span class="font17">would have returned a value like </span><span class="font2">[1, [2, [3, [4, undef]]]]</span><span class="font17">, because at each stage it’s using </span><span class="font2">concatenate() </span><span class="font17">to join the values returned by </span><span class="font2">Sp</span><span class="font17">, its argument, and </span><span class="font2">Sp_star</span><span class="font17">, the recursive call to itself. We can use </span><span class="font2">T() </span><span class="font17">to adjust the value that comes out of </span><span class="font2">concatenate() </span><span class="font17">so that the result is </span><span class="font2">[1, 2, 3, 4] </span><span class="font17">instead:</span></p>
<p><span class="font2">sub star {</span></p>
<p><span class="font2">my Sp = shift;</span></p>
<p><span class="font2">my Sp_star;</span></p>
<p><span class="font2" style="font-weight:bold;">Sp_star = alternate(T(concatenate(Sp, parser { Sp_star-&gt;(@_) }),</span></p>
<p><span class="font2" style="font-weight:bold;">sub { my (Sfirst, $rest) = @_;</span></p>
<ul style="list-style:none;"><li>
<p class="font15">8.4 ARITHMETIC EXPRESSIONS</p></li></ul>
<p><span class="font2" style="font-weight:bold;">defined $rest ? [$first, @$rest] : [$first]</span></p>
<p><span class="font2" style="font-weight:bold;">}),</span></p>
<p><span class="font2">\&amp;nothing);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">The function we give to </span><span class="font2">T() </span><span class="font17">is responsible for appending the single value returned by </span><span class="font2">$p </span><span class="font17">to the (possibly empty) list of values returned by </span><span class="font2">$p_star </span><span class="font17">to generate a new list.</span></p>
<p><span class="font17">Given an input that’s unacceptable to </span><span class="font2">$p</span><span class="font17">, </span><span class="font2">star($p) </span><span class="font17">succeeds, consuming none of the tokens, and returns an undefined value, behaving essentially like </span><span class="font2">nothing()</span><span class="font17">. We might prefer for it to return an empty array. In that case, we should use this version:</span></p>
<p><span class="font2" style="font-weight:bold;">sub null_list {</span></p>
<p><span class="font2" style="font-weight:bold;">my Sinput = shift;</span></p>
<p><span class="font2" style="font-weight:bold;">return ([], Sinput);</span></p>
<p><span class="font2" style="font-weight:bold;">}</span></p>
<p><span class="font2">sub star {</span></p>
<p><span class="font2">my $p = shift;</span></p>
<p><span class="font2">my $p_star;</span></p>
<p><span class="font2">$p_star = alternate(T(concatenate($p, parser { $p_star-&gt;(@_) }), sub { my ($first, $rest) = @_;</span></p>
<p><span class="font2" style="font-weight:bold;">[$first, @Srest];</span></p>
<p><span class="font2">}),</span></p>
<p><span class="font2">\</span><span class="font2" style="font-weight:bold;">&amp;null_list);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">null_list() </span><span class="font17">is like </span><span class="font2">nothing()</span><span class="font17">: It never consumes any input, and it always succeeds. But unlike </span><span class="font2">nothing()</span><span class="font17">, it returns an empty array instead of an undefined value. With this change, we no longer need the special-casery in the transformation function.</span></p>
<p><span class="font17">Having done this, we can simplify our elimination of left recursion. Instead of converting this:</span></p>
<p><span class="font2">A ^ A b | c</span></p>
<p><span class="font17">to this:</span></p>
<p><span class="font2">A ^ c A_tail</span></p>
<p><span class="font2">A_tail ^ b A_tail | (nothing)</span></p>
<div>
<p><span class="font20">409</span></p>
</div><br clear="all">
<h6><a name="bookmark389"></a><span class="font17">we can convert it to this:</span></h6>
<p><span class="font2">A ^ c star(b)</span></p>
<h6><a name="bookmark390"></a><span class="font17">Similarly, this:</span></h6>
<p><span class="font2">symbol ^ symbol A | symbol B symbol ^ X | Y</span></p>
<h6><a name="bookmark391"></a><span class="font17">becomes this:</span></h6>
<p><span class="font2">symbol ^ (X | Y) star(A | B)</span></p>
<h6><a name="bookmark392"></a><span class="font17">With this transformation, our original grammar for expressions:</span></h6>
<p><span class="font2">expression ^ expression '+' term | expression '-' term | term term ^ term '*' factor | term '/' factor | factor factor ^ 'INT' | '(' expression ')'</span></p>
<h6><a name="bookmark393"></a><span class="font17">is transformed to:</span></h6>
<p><span class="font2">expression ^ term star('+' term | '-' term) term ^ factor star('*' factor | '/' factor) factor ^ 'INT' | '(' expression ')'</span></p>
<p><span class="font17">which is much easier to understand than the version that we saw before, with the artificial </span><span class="font17" style="font-style:italic;">expression_tail</span><span class="font17"> and </span><span class="font17" style="font-style:italic;">term_tail</span><span class="font17"> symbols.</span></p>
<p><span class="font17">The basic code for the </span><span class="font17" style="font-style:italic;">expression</span><span class="font17"> parser now looks like this:</span></p>
<p><span class="font2">$expression = concatenate($Term, star(alternate(concatenate(lookfor(['OP', '+']), $Term), concatenate(lookfor(['OP', '-']), $Term))));</span></p>
<p><span class="font17">To get this to compute the right values, we’ll have the </span><span class="font17" style="font-style:italic;">+ term</span><span class="font17"> and </span><span class="font17" style="font-style:italic;">- term</span><span class="font17"> parts return functions that, given the value of the left part of an expression, compute and return the value of the entire expression:</span></p>
<p><span class="font2">concatenate(lookfor(['OP', '+']), $Term)</span></p>
<ul style="list-style:none;"><li>
<p class="font15">8.4 ARITHMETIC EXPRESSIONS <span class="font20">411 </span><span class="font17">becomes:</span></p></li></ul>
<p><span class="font2">T(concatenate(lookfor(['OP', ' + ']), STerm),</span></p>
<p><span class="font2" style="font-weight:bold;">sub { my $term_value = $_[1];</span></p>
<p><span class="font2" style="font-weight:bold;">return sub { $_[0] + $term_value }</span></p>
<p><span class="font2" style="font-weight:bold;">});</span></p>
<p><span class="font17">The code for the </span><span class="font17" style="font-style:italic;">- term</span><span class="font17"> part looks the same, with subtraction substituted for addition.</span></p>
<p><span class="font17">The parser generated by the </span><span class="font2">star() </span><span class="font17">call will return a list of these addition or subtraction functions. The outermost </span><span class="font2">concatenate^ </span><span class="font17">call will produce a parser that expects the value of the leftmost </span><span class="font17" style="font-style:italic;">term</span><span class="font17"> and the list of expression-computing functions returned by the </span><span class="font2">star() </span><span class="font17">parser. If the </span><span class="font17" style="font-style:italic;">expression</span><span class="font17"> is </span><span class="font2">4+3-5</span><span class="font17">, the arguments to the parser will be the number 4 and the function list (</span><span class="font2">sub { $_[0] + 3 }</span><span class="font17">, </span><span class="font2">sub { $_[0] - 5 }</span><span class="font17">):</span></p>
<p><span class="font2">4 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+3 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- 5</span></p>
<p><span class="font2">| &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|</span></p>
<p><span class="font2">4 sub { S_[0] + 3 } sub { S_[0] - 5 }</span></p>
<p><span class="font17">The outermost parser must compute the complete value of the expression. It does this by passing the leftmost </span><span class="font17" style="font-style:italic;">term</span><span class="font17"> value to the first addition or subtraction function, passing the result to the second addition or subtraction function, and so on, like this:</span></p>
<p><span class="font2">sub { my (Stotal, Sfuncs) = @_;</span></p>
<p><span class="font2">for my Sf (@$funcs) {</span></p>
<p><span class="font2">Stotal = $f-&gt;($total);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">Stotal;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">The complete parser for expressions is :</span></p>
<p><span class="font2">Sexpression =</span></p>
<p><span class="font2">T(concatenate($Term, star(alternate(T(concatenate(lookfor(['OP', '+']),</span></p>
<p><span class="font2">STerm),</span></p>
<p><span class="font2">sub {</span></p>
<p><span class="font2">my Sterm_value = S_[1];</span></p>
<p><span class="font2">sub { S_[0] + Sterm_value };</span></p>
<p><span class="font2">}), T(concatenate(lookfor(['OP', '-']),</span></p>
<p><span class="font2">STerm),</span></p>
<p><span class="font2">sub {</span></p>
<p><span class="font2">my Sterm_value = S_[1];</span></p>
<p><span class="font2">sub { S_[0] - Sterm_value };</span></p>
<p><span class="font2">}),</span></p>
<p><span class="font2">))),</span></p>
<p><span class="font2">sub { my (Stotal, Sfuncs) = @_;</span></p>
<p><span class="font2">for my Sf (@Sfuncs) {</span></p>
<p><span class="font2">Stotal = Sf-&gt;(Stotal);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">Stotal;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">);</span></p>
<p><span class="font17">The corresponding change to the </span><span class="font17" style="font-style:italic;">term</span><span class="font17"> parser is identical, with multiplication and division substituted for addition and subtraction.</span></p>
<ul style="list-style:none;"><li>
<h5><a name="bookmark167"></a><span class="font19">8.4.4 Generic-Operator Parsers</span></h5></li></ul>
<p><span class="font17">We’ve already used this operator parser pattern twice, once in </span><span class="font17" style="font-style:italic;">expression</span><span class="font17"> and once in </span><span class="font17" style="font-style:italic;">term</span><span class="font17">. Since operators are common, we might expect to use the same pattern in the future. We should try to abstract it into a generic function.</span></p>
<p><span class="font17">In general, we have a grammar where </span><span class="font17" style="font-style:italic;">symbol</span><span class="font17"> can be expanded as </span><span class="font17" style="font-style:italic;">subpart </span><span class="font2">OP </span><span class="font17" style="font-style:italic;">subpart</span><span class="font2"> OP </span><span class="font17" style="font-style:italic;">... subpart,</span><span class="font17"> where </span><span class="font2">OP </span><span class="font17">is left-associative. The parser we just saw is an example, with </span><span class="font17" style="font-style:italic;">symbol, subpart,</span><span class="font17"> and </span><span class="font2">OP </span><span class="font17">being replaced by </span><span class="font17" style="font-style:italic;">expression, term, </span><span class="font17">and +, respectively. We’ll write a function, </span><span class="font2">operator()</span><span class="font17">, which, given a parser for the subpart, a parser that recognizes the operator, and a callback function that implements the operator (</span><span class="font2">sub { S_[0] + S_[1] } </span><span class="font17">in the case of addition), generates a parser for sequences of </span><span class="font17" style="font-style:italic;">subpart</span><span class="font17"> combined with </span><span class="font2">OP</span><span class="font17">. In general we’ll want multiple operators of the same precedence, but to begin with let’s assume there’s only one operator at a time. Here’s an example of what we want to produce: the parser for </span><span class="font17" style="font-style:italic;">expression</span><span class="font17">, with only addition, and not subtraction:</span></p>
<p><span class="font2">Sexpression =</span></p>
<p><span class="font2">T(concatenate(STerm, star(T(concatenate(lookfor(['OP', '+']),</span></p>
<p><span class="font2">STerm), sub {</span></p>
<ul style="list-style:none;"><li>
<p class="font15">8.4 ARITHMETIC EXPRESSIONS</p>
<div>
<p><span class="font20">413</span></p>
</div><br clear="all"></li></ul>
<p><span class="font2">my Sterm_value = S_[1];</span></p>
<p><span class="font2">sub { S_[0] + Sterm_value };</span></p>
<p><span class="font2">}),</span></p>
<p><span class="font2">)), sub { my (Stotal, Sfuncs) = @_;</span></p>
<p><span class="font2">for my Sf (@$funcs) { Stotal = Sf-&gt;(Stotal);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">Stotal;</span></p>
<p><span class="font2">} );</span></p>
<h6><a name="bookmark394"></a><span class="font17">The outline of our </span><span class="font2">operator() </span><span class="font17">function is:</span></h6>
<p><span class="font2">sub operator { my (Ssubpart, Sop, Sopfunc) = @_; # Build and return parser like the preceding one }</span></p>
<p class="font17">To construct the <span class="font2">operator() </span><span class="font17">function, we start by copying the </span><span class="font17" style="font-style:italic;">expression</span><span class="font17"> parser into the body of </span><span class="font2">sub operator</span><span class="font17">. Then we systematically remove all the </span><span class="font17" style="font-style:italic;">expressionspecific</span><span class="font17"> code and replace each removed bit with the corresponding argument: </span><span class="font2">sub operator {</span></p>
<div>
<p><span class="font9" style="font-weight:bold;">CODE LIBRARY</span></p>
</div><br clear="all">
<p><span class="font2">my (Ssubpart, Sop, Sopfunc) = @_; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="font0">operwor-^ngleop</span></p>
<p><span class="font2"># Build and return parser like the earlier one </span><span class="font2" style="font-weight:bold;">T(concatenate($subpart, star(T(concatenate($op, Ssubpart), </span><span class="font2">sub { my Ssubpart_value = S_[1]; </span><span class="font2" style="font-weight:bold;">sub { $opfunc-&gt;($_[0], $subpart_value)}; </span><span class="font2">}), )), sub { my (Stotal, Sfuncs) = @_; for my Sf (@Sfuncs) { Stotal = Sf-&gt;(Stotal); } Stotal; } );</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">This does work; </span><span class="font2">operator(STerm, lookfor(['op', ' + ']), sub { $_[0] + S_[1] }) </span><span class="font17">does generate a parser for sums of terms. We now need to extend </span><span class="font2">operator() </span><span class="font17">to handle multiple operators of the same precedence. The argument to </span><span class="font2">star() </span><span class="font17">will be an alternation of several sections, rather than a single section. The argument to </span><span class="font2">operator() </span><span class="font17">itself may contain several </span><span class="font2">Sops</span><span class="font17">es and </span><span class="font2">Sopfunc</span><span class="font17">s. We’ll call it like this:</span></p>
<p><span class="font2">operator(STerm, [lookfor(['OP', ' + ']), sub { S_[0] + S_[1] }], [lookfor(['OP', '-']), sub { S_[0] - $_[1] }]);</span></p>
<p><span class="font2">sub operator {</span></p>
<p><span class="font2" style="font-weight:bold;">my (Ssubpart, ©ops) = ©_;</span></p>
<p><span class="font2" style="font-weight:bold;">my (©alternatives);</span></p>
<p><span class="font17">First we generate the alternatives that we’ll give to </span><span class="font2">star()</span><span class="font17">:</span></p>
<p><span class="font2" style="font-weight:bold;">for my Soperator (©ops) { my ($op, Sopfunc) = ©Soperator; push ©alternatives,</span></p>
<p><span class="font2">T(concatenate($op,</span></p>
<p><span class="font2">Ssubpart), sub {</span></p>
<p><span class="font2">my Ssubpart_value = S_[1];</span></p>
<p><span class="font2">sub { $opfunc-&gt;($_[0], Ssubpart_value) } });</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">Then we build the parser from the alternatives:</span></p>
<p><span class="font2">my Sresult =</span></p>
<p><span class="font2">T(concatenate($subpart,</span></p>
<p><span class="font2" style="font-weight:bold;">star(alternate(©alternatives))), </span><span class="font2">sub { my (Stotal, Sfuncs) = @_;</span></p>
<p><span class="font2">for my Sf (@Sfuncs) { Stotal = Sf-&gt;(Stotal);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">Stotal;</span></p>
<p><span class="font2">});</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">This is a lot of hairy code, but the payoff is excellent. We can stick the hairy </span><span class="font2">operator() </span><span class="font17">function into our parser-generating library and forget about it.</span></p>
<p><span class="font17">The code to generate the parsers for </span><span class="font17" style="font-style:italic;">term</span><span class="font17"> and </span><span class="font17" style="font-style:italic;">expression</span><span class="font17"> becomes short and transparent:</span></p>
<p><span class="font2">Sexpression = operator(STerm, [lookfor(['OP', [lookfor(['OP',</span></p>
<div>
<p><span class="font2">' + ']), sub { $_[0] + $_[1] }], '-']), sub { $_[0] - $_[1] }]);</span></p>
</div><br clear="all">
<div>
<p><span class="font2">'*']), sub { $_[0] * $_[1] }], '/']), sub { $_[0] / $_[1] }]);</span></p>
</div><br clear="all">
<p><span class="font2">Sterm = operator(SFactor, [lookfor(['OP', [lookfor(['OP',</span></p>
<p><span class="font17">Now that we have </span><span class="font2">operator()</span><span class="font17">, it’s easy to imagine the next step: a parser generator function whose argument is an entire operator precedence table, and that, given a table like this:</span></p>
<p><span class="font2">[</span></p>
<p><span class="font2">[['OP', '*'], ['OP', '/']], # highest precedence</span></p>
<p><span class="font2">[['OP', '+'], ['OP', '-']], # lower precedence</span></p>
<p><span class="font2">]</span></p>
<p><span class="font17">does the work of the two calls to </span><span class="font2">operator()</span><span class="font17">, or more if we ask it to.</span></p>
<ul style="list-style:none;"><li>
<h5><a name="bookmark168"></a><span class="font19">8.4.5 Debugging</span></h5></li></ul>
<p><span class="font17">Debugging programs containing complex nested functions can be difficult. The Perl interactive debugger isn’t very helpful. If </span><span class="font2">Sz </span><span class="font17">contains a reference to an anonymous function, the debugger won’t give us much useful information about it:</span></p>
<p><span class="font2">DB&lt;119&gt; x Sz</span></p>
<p><span class="font2">0 CODE(0x849aca0)</span></p>
<p><span class="font2">-&gt; &amp;main::__ANON__[arith15.pl:169] in arith15.pl:159-169</span></p>
<p><span class="font17">Just the file and the line numbers in the file. It could easily display the code, but it doesn’t; with some extensions it could display the values of the subroutine’s lexical variables, but again it doesn’t. Internally, the debugger is a tremendous mess, and these improvements probably aren’t forthcoming.<a name="footnote33"></a><sup><a href="#bookmark395">33</a></sup><sup></sup> So we have to fall back on other techniques.</span></p>
<p><span class="font17">The first problem with the debugger’s display of anonymous functions is that it’s hard to tell them apart. </span><span class="font2">CODE(0x849aca0) </span><span class="font17">doesn’t communicate anything intelligible. The easy way to fix this is to have a hash that maps anonymous functions to names or descriptions:</span></p>
<p><span class="font2">SN{Sz} = &quot;main parser&quot;;</span></p>
<p><span class="font17">Now if we’re in the middle of the program and we see a mysterious anonymous function, we can ask for:</span></p>
<p><span class="font2">print SN{Smystery};</span></p>
<p><span class="font17">and get something like:</span></p>
<p><span class="font2">Third alternative of 'expression' symbol</span></p>
<p><span class="font17">A variation on this technique makes the functions into blessed objects with an overloaded stringification operator. The stringification operator simply returns the appropriate element of </span><span class="font2">%N</span><span class="font17">.</span></p>
<p><span class="font17">Another variation that may not be for everyone, but that I’ve sometimes used when the functions had little natural significance, is to tie the </span><span class="font2">%N </span><span class="font17">hash and have it </span><span class="font17" style="font-style:italic;">invent</span><span class="font17"> a name when asked for the name of a function that hasn’t already had a name assigned:</span></p>
<p><span class="font2">open NAMES, &quot;&lt;&quot;, Snamefile or die ...;</span></p>
<p><span class="font2">sub STORE {</span></p>
<p><span class="font2">my (Sself, Skey, Sname) = @_;</span></p>
<p><span class="font2">Sself-&gt;{Skey} = Sname;</span></p>
<p><span class="font2">} sub FETCH {</span></p>
<p><span class="font2">my (Sself, Skey) = @_:</span></p>
<p><span class="font2">if (exists Sself-&gt;{Skey}) { return Sself-&gt;{Skey} } chomp(my Sname = &lt;NAMES&gt;);</span></p>
<p><span class="font2">Sself-&gt;{Skey} = Sname;</span></p>
<p><span class="font2">warn &quot;Function had no name; I’ll call it 'Sname'.\n&quot;; return Sname;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">Then you fill up </span><span class="font2">Snamefile </span><span class="font17">with twenty or thirty random but evocative nouns, such as:</span></p>
<p><span class="font17">Maximo Perez</span></p>
<p><span class="font17">The Train</span></p>
<p><span class="font17">Luis Melian Lafineur</span></p>
<p><span class="font17">Olimar</span></p>
<p><span class="font17">Brimstone</span></p>
<p><span class="font17">Clubs</span></p>
<p><span class="font17">The Whale</span></p>
<p><span class="font17">Gas</span></p>
<p><span class="font17">The Cauldron</span></p>
<p><span class="font17">Napoleon</span></p>
<p><span class="font17">Agustin de Vedia</span></p>
<p><span class="font17">Nine</span></p>
<p><span class="font17">The Negro Timoteo</span></p>
<p><span class="font17">The Flesh Blanket</span></p>
<p><span class="font17">Even meaningless names can be helpful. They don’t tell you what the function does, but they give your memory a peg to hang an association on, and you’re likely to recognize a function you’ve seen before when it comes up again. If you don’t like the name that was automatically assigned, you can easily replace it by assigning a different value to </span><span class="font2">%N</span><span class="font17">.</span></p>
<p><span class="font17">From here it’s a small step to having the functions receive their names at their time of manufacture; for example:</span></p>
<p><span class="font2" style="font-weight:bold;">my $CON = 'A';</span></p>
<p><span class="font2">sub concatenate {</span></p>
<p><span class="font2" style="font-weight:bold;">my $id;</span></p>
<p><span class="font2" style="font-weight:bold;">if (ref $_[0]) { $id = &quot;Unnamed concatenation $CON&quot;; $CON++ } else { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$id = shift }</span></p>
<p><span class="font2">my @p = @_;</span></p>
<p><span class="font2">return \&amp;nothing if @p == 0;</span></p>
<p><span class="font2">return $p[0] if @p == 1;</span></p>
<p><span class="font2">my Sparser = parser {</span></p>
<p><span class="font2">my Sinput = shift;</span></p>
<p><span class="font2">my Sv;</span></p>
<p><span class="font2">my ©values;</span></p>
<p><span class="font2">for (©p) {</span></p>
<p><span class="font2">(Sv, Sinput) = S_-&gt;(Sinput) or return;</span></p>
<div>
<p><span class="font9" style="font-weight:bold;">CODE LIBRARY</span></p>
</div><br clear="all">
<div>
<p><span class="font0">Parser::Debug.pm</span></p>
</div><br clear="all">
<div>
<p><span class="font2">push ©values, Sv; }</span></p>
<p><span class="font2">return values;</span></p>
<p><span class="font2">};</span></p>
<p><span class="font2" style="font-weight:bold;">SN{Sparser} = Sid;</span></p>
<p><span class="font2" style="font-weight:bold;">return Sparser;</span></p>
<p><span class="font2">}</span></p>
</div><br clear="all">
<div>
<h6><a name="bookmark396"></a><span class="font17">Now </span><span class="font2">concatenate() </span><span class="font17">gets an optional initial argument, which is a string that will be used as the name of the parser it generates; for example:</span></h6>
</div><br clear="all">
<div>
<p><span class="font2">Sfactor</span></p>
</div><br clear="all">
<div>
<p><span class="font2">= alternate(lookfor('INT'), </span><span class="font2" style="font-weight:bold;">T(concatenate(&quot;factor : '(' expr ')'&quot;, </span><span class="font2">lookfor(['OP', '(']), SExpression, lookfor(['OP', ')'])), sub { S_[1] })</span></p>
<p><span class="font2">);</span></p>
</div><br clear="all">
<div>
<p><span class="font17">We can of course do the same thing to </span><span class="font2">alternate()</span><span class="font17">:</span></p>
</div><br clear="all">
<div>
<p><span class="font2" style="font-weight:bold;">Sfactor</span></p>
</div><br clear="all">
<div>
<p><span class="font2" style="font-weight:bold;">= alternate(&quot;factor symbol parser&quot;, </span><span class="font2">lookfor('INT'), T(concatenate(&quot;factor : '(' expr ')'&quot;, lookfor(['OP', '(']), SExpression, lookfor(['OP', ')'])), sub { S_[1] })</span></p>
<p><span class="font2">);</span></p>
</div><br clear="all">
<div>
<h6><a name="bookmark397"></a><span class="font17">Since </span><span class="font2">Sid </span><span class="font17">is a lexical variable, it can be captured and used inside the parser itself:</span></h6>
</div><br clear="all">
<div>
<p><span class="font2">package Parser::Debug;</span></p>
<p><span class="font2">use base 'Exporter';</span></p>
<p><span class="font2">use Parser ':all';</span></p>
<p><span class="font2">@EXPORT_OK = ©Parser::EXPORT_OK;</span></p>
<p><span class="font2">%EXPORT_TAGS = %Parser::EXPORT_TAGS;</span></p>
</div><br clear="all">
<div>
<p><span class="font2">my SCON = 'A';</span></p>
<p><span class="font2">sub concatenate { my Sid;</span></p>
</div><br clear="all">
<p><span class="font15">8.4 ARITHMETIC EXPRESSIONS</span></p>
<p><span class="font2">if (ref S_[0]) { Sid = &quot;Unnamed concatenation SCON&quot;; SCON++ } else { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sid = shift }</span></p>
<p><span class="font2">my @p = @_</span></p>
<p><span class="font2">return \&amp;n ll if @p == 0;</span></p>
<p><span class="font2">return Sp[ ] if @p == 1;</span></p>
<p><span class="font2">my Sparser = parser { my Sinput = shift; </span><span class="font2" style="font-weight:bold;">debug &quot;Looking for Sid</span><span class="font2">\</span><span class="font2" style="font-weight:bold;">n&quot;; </span><span class="font2">my Sv; my @values; </span><span class="font2" style="font-weight:bold;">my ($q, Snp) = (0, scalar @p); </span><span class="font2">for (@p) {</span></p>
<p><span class="font2" style="font-weight:bold;">Sq++;</span></p>
<p><span class="font2" style="font-weight:bold;">unless ((Sv, Sinput) = $_-&gt;($input)) {</span></p>
<p><span class="font2" style="font-weight:bold;">debug &quot;Failed concatenated component &nbsp;&nbsp;Sq/Snp</span><span class="font2">\</span><span class="font2" style="font-weight:bold;">n&quot;;</span></p>
<p><span class="font2">return;</span></p>
<p><span class="font2" style="font-weight:bold;">}</span></p>
<p><span class="font2" style="font-weight:bold;">debug &quot;Matched concatenated component &nbsp;&nbsp;Sq/Snp</span><span class="font2">\</span><span class="font2" style="font-weight:bold;">n&quot;;</span></p>
<p><span class="font2">push @values, Sv;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2" style="font-weight:bold;">debug &quot;Finished matching Sid</span><span class="font2">\</span><span class="font2" style="font-weight:bold;">n&quot;;</span></p>
<p><span class="font2">return \@values;</span></p>
<p><span class="font2">};</span></p>
<p><span class="font2">SN{Sparser} = Sid;</span></p>
<p><span class="font2">return Sparser;</span></p>
<p><span class="font2">}</span></p>
<h6><a name="bookmark398"></a><span class="font17">With a suitable definition of </span><span class="font2">debug()</span><span class="font17">, this will generate output like:</span></h6>
<p><span class="font2">Looking for factor : '(' expr ')'</span></p>
<p><span class="font2">Matched concatenated component 1/3</span></p>
<p><span class="font2">Matched concatenated component 2/3</span></p>
<p><span class="font2">Matched concatenated component 3/3</span></p>
<p><span class="font2">Finished matching factor : '(' expr ')'</span></p>
<h6><a name="bookmark399"></a><span class="font17">or:</span></h6>
<p><span class="font2">Looking for factor : '(' expr ')'</span></p>
<p><span class="font2">Failed concatenated component 1/3</span></p>
<div>
<p><span class="font20">419</span></p>
</div><br clear="all">
<p><span class="font17">The easiest thing to do in </span><span class="font2">debug() </span><span class="font17">is just to print out the message. But we can do a little better:</span></p>
<p><span class="font2">sub debug ($) {</span></p>
<p><span class="font2">return unless $DEBUG || $ENV{DEBUG};</span></p>
<p><span class="font2">my $msg = shift;</span></p>
<p><span class="font2">my $i =0;</span></p>
<p><span class="font2">$i++ while caller($i);</span></p>
<p><span class="font2">$I = &quot;| &quot;&nbsp;x ($i-2);</span></p>
<p><span class="font2">print $I, $msg;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">The </span><span class="font2">while caller </span><span class="font17">loop computes the depth to which function calls have been nested. </span><span class="font2">$I </span><span class="font17">is an indentation string that is used to indent the debugging message accordingly. Now the output while parsing an expression like </span><span class="font2">&quot;8 - 3&quot; </span><span class="font17">begins like this:</span></p>
<p><span class="font2">| Looking for Input: expression EOI</span></p>
<p><span class="font2">| (Next token is INT 8)</span></p>
<p><span class="font2">| | | | Looking for expression : term star('+'term | '-' term)</span></p>
<p><span class="font2">| &nbsp;| &nbsp;| &nbsp;| &nbsp;(Next token is INT 8)</span></p>
<p><span class="font2">| &nbsp;| &nbsp;| &nbsp;| &nbsp;| &nbsp;| &nbsp;| Looking for term: factor star('*'factor | '/' factor)</span></p>
<p><span class="font2">| &nbsp;| &nbsp;| &nbsp;| &nbsp;| &nbsp;| &nbsp;| &nbsp;(Next token is INT 8)</span></p>
<p><span class="font2">| &nbsp;| &nbsp;| &nbsp;| &nbsp;| &nbsp;| &nbsp;| &nbsp;| &nbsp;| &nbsp;Looking for factor: INT | '(' expression ')'</span></p>
<p><span class="font2">| &nbsp;| &nbsp;| &nbsp;| &nbsp;| &nbsp;| &nbsp;| &nbsp;| &nbsp;| &nbsp;(Next token is INT 8)</span></p>
<p><span class="font2">| &nbsp;| &nbsp;| &nbsp;| &nbsp;| &nbsp;| &nbsp;| &nbsp;| &nbsp;| &nbsp;Trying alternative 1/2</span></p>
<p><span class="font2">| &nbsp;| &nbsp;| &nbsp;| &nbsp;| &nbsp;| &nbsp;| &nbsp;| &nbsp;| &nbsp;| Looking for token [INT]</span></p>
<p><span class="font2">| &nbsp;&nbsp;| &nbsp;&nbsp;| &nbsp;&nbsp;| &nbsp;&nbsp;| &nbsp;&nbsp;| &nbsp;&nbsp;| &nbsp;&nbsp;| &nbsp;&nbsp;| &nbsp;&nbsp;| Next token is [INT 8]</span></p>
<p><span class="font2">| &nbsp;&nbsp;| &nbsp;&nbsp;| &nbsp;&nbsp;| &nbsp;&nbsp;| &nbsp;&nbsp;| &nbsp;&nbsp;| &nbsp;&nbsp;| &nbsp;&nbsp;| &nbsp;&nbsp;| Token matched</span></p>
<p><span class="font2">| &nbsp;| &nbsp;| &nbsp;| &nbsp;| &nbsp;| &nbsp;| &nbsp;| &nbsp;| &nbsp;Matched alternative 1/2</span></p>
<p><span class="font2">| &nbsp;| &nbsp;| &nbsp;| &nbsp;| &nbsp;| &nbsp;| Matched concatenated component 1/2</span></p>
<p><span class="font17">Capturing </span><span class="font2">$id </span><span class="font17">inside the generated parser, as we’ve done, causes a problem. If we want to change the name of a parser after we’ve constructed it, we can’t, because the name is captured in an inaccessible lexical variable inside the parser. We can change the name in the </span><span class="font2">%N </span><span class="font17">hash, but when the parser prints debug messages, it will still use the old name. One way to fix this is to have the debug messages refer to </span><span class="font2">%N</span><span class="font17">; another way is to provide each parser with a method for changing its name. The </span><span class="font2">%N </span><span class="font17">tactic is easier by far. Using a global variable like this should make you uncomfortable, and when you do it, the first question</span></p>
<p><span class="font17">you should ask is “What if there are several different parsers in one program? Will their overlapping uses of </span><span class="font2">%N </span><span class="font17">collide?” In this case, though, there’s no problem. Each anonymous function in the program resides at a different address, which means that the </span><span class="font2">CODE(0x436c1d) </span><span class="font17">strings will all be unique. As long as the parsers don’t tamper with hash elements they don’t understand, all will be well.</span></p>
<p><span class="font17">Why would we want to change the name of a parser? We’ll see in a minute. Before that, let’s note that the names we’ve been using are formulaic, which means that the next step is to get the parser construction functions to generate the names automatically. We begin by naming the basic parsers:</span></p>
<p><span class="font2">$N{\&amp;End_of_Input} = 'EOI';</span></p>
<p><span class="font2">$N{\&amp;nothing} = '(nothing)';</span></p>
<p><span class="font2">$N{$Expression} = 'expression';</span></p>
<p><span class="font2">$N{$Term} = 'term';</span></p>
<p><span class="font2">$N{$Factor} = 'factor';</span></p>
<p><span class="font17">Then we fix up </span><span class="font2">concatenate() </span><span class="font17">and </span><span class="font2">alternate() </span><span class="font17">to generate names from the names of their arguments:</span></p>
<p><span class="font2">sub concatenate {</span></p>
<p><span class="font2">my @p = @_;</span></p>
<p><span class="font2">return \&amp;nothing if @p == 0;</span></p>
<p><span class="font2">return $p[0] if @p == 1;</span></p>
<p><span class="font2" style="font-weight:bold;">my $id = &quot;@N{@p}&quot;;</span></p>
<p><span class="font2">my $p = parser {</span></p>
<p><span class="font2">...</span></p>
<p><span class="font2">};</span></p>
<p><span class="font2" style="font-weight:bold;">$N{$p} = $id;</span></p>
<p><span class="font2">return $p;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">sub alternate {</span></p>
<p><span class="font2">my @p = @_;</span></p>
<p><span class="font2">return parser { return () } if @p == 0;</span></p>
<p><span class="font2">return $p[0] &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if @p == 1;</span></p>
<p><span class="font2" style="font-weight:bold;">my $id = join &quot;&nbsp;| &quot;, @N{@p};</span></p>
<div>
<p><span class="font20">422</span></p>
</div><br clear="all">
<p><span class="font15">CHAPTER 8 Parsing</span></p>
<p><span class="font2">my Sp = parser {</span></p>
<p><span class="font2">■ ■■</span></p>
<p><span class="font2">};</span></p>
<p><span class="font2" style="font-weight:bold;">$N{$p} = &quot;($id)&quot;;</span></p>
<p><span class="font2">return Sp;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">Similarly, the description of the parser produced by </span><span class="font2">T() </span><span class="font17">is the same as the description of its argument:</span></p>
<p><span class="font2">sub T {</span></p>
<p><span class="font2">my (Sparser, Stransform) = @_;</span></p>
<p><span class="font2">my Sp = parser {</span></p>
<p><span class="font2">■■■</span></p>
<p><span class="font2">};</span></p>
<p><span class="font2" style="font-weight:bold;">$N{$p} = $N{$parser};</span></p>
<p><span class="font2">return Sp;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">Now we change </span><span class="font2">lookfor() </span><span class="font17">to name its parsers after the token they’re looking for:</span></p>
<p><span class="font2">sub lookfor {</span></p>
<p><span class="font2">my Swanted = shift;</span></p>
<p><span class="font2">■■■</span></p>
<p><span class="font2" style="font-weight:bold;">$N{$parser} = &quot;[@$wanted]&quot;;</span></p>
<p><span class="font2">return Sparser;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">Finally, we change </span><span class="font2">star()</span><span class="font17">:</span></p>
<p><span class="font2">sub star {</span></p>
<p><span class="font2">my Sp = shift;</span></p>
<p><span class="font2" style="font-weight:bold;">my ($p_star, $conc);</span></p>
<p><span class="font2" style="font-weight:bold;">$p_star = alternate(T($conc = concatenate($p, parser { $p_star-&gt;(@_) }),</span></p>
<p><span class="font2">sub { my (Sfirst, Srest) = @_;</span></p>
<p><span class="font2">[Sfirst, @Srest];</span></p>
<p><span class="font2">}),</span></p>
<p><span class="font2">\&amp;null_list);</span></p>
<p><span class="font2" style="font-weight:bold;">$N{$p_star} = &quot;star($N{$p})&quot;;</span></p>
<p><span class="font2" style="font-weight:bold;">$N{$conc} = &quot;$N{$p} $N{$p_star}&quot;;</span></p>
<p><span class="font2">return Sp_star;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">This is why we needed to be able to change the names of parsers. The arguments to </span><span class="font2">concatenate() </span><span class="font17">are the argument </span><span class="font2">$p</span><span class="font17">, whose description, let’s say, is </span><span class="font2">P</span><span class="font17">, and the eta-converted version of </span><span class="font2">$p_star</span><span class="font17">, which didn’t have a description. The parser that would come out of </span><span class="font2">concatenate() </span><span class="font17">therefore would have a name something like </span><span class="font2">&quot;P &quot;</span><span class="font17">, and the parser that would come out of </span><span class="font2">alternate() </span><span class="font17">would be named something like </span><span class="font2">P | (nothing)</span><span class="font17">, neither of which is very helpful. After the parsers are generated, we change the name of the alternation, </span><span class="font2">$p_star </span><span class="font17">itself, to </span><span class="font2">star(P)</span><span class="font17">, and the name of the concatenation, temporarily stored in </span><span class="font2">$conc</span><span class="font17">, to </span><span class="font2">P star(P)</span><span class="font17">.</span></p>
<p><span class="font17">The output, including automatically generated names, now looks like this (the input was </span><span class="font2">&quot;8 - 3&quot;</span><span class="font17">):</span></p>
<div>
<p><span class="font2">|</span></p>
<p><span class="font2">|</span></p>
<p><span class="font2">|</span></p>
<p><span class="font2">|</span></p>
<p><span class="font2">|</span></p>
<p><span class="font2">|</span></p>
<p><span class="font2">|</span></p>
<p><span class="font2">|</span></p>
<p><span class="font2">|</span></p>
<p><span class="font2">|</span></p>
<p><span class="font2">|</span></p>
<p><span class="font2">|</span></p>
<p><span class="font2">|</span></p>
<p><span class="font2">|</span></p>
<p><span class="font2">|</span></p>
<p><span class="font2">|</span></p>
<p><span class="font2">|</span></p>
</div><br clear="all">
<p><span class="font2">Looking for expression EOI</span></p>
<p><span class="font2">(Next token is INT 8)</span></p>
<p><span class="font2">| &nbsp;| &nbsp;| Looking for term star(([OP +] term | [OP -] term))</span></p>
<p><span class="font2">| &nbsp;| &nbsp;| &nbsp;(Next token is INT 8)</span></p>
<p><span class="font2">| &nbsp;| &nbsp;| &nbsp;| | | Looking for factor star(([OP *] factor | &nbsp;[OP /] factor))</span></p>
<p><span class="font2">| &nbsp;| &nbsp;| &nbsp;| | | &nbsp;(Next token is INT 8)</span></p>
<p><span class="font2">| &nbsp;| &nbsp;| &nbsp;| &nbsp;| &nbsp;| &nbsp;| &nbsp;| &nbsp;Looking for ([INT] | [OP (] expression [OP )])</span></p>
<p><span class="font2">| &nbsp;| &nbsp;| &nbsp;| &nbsp;| &nbsp;| &nbsp;| &nbsp;| &nbsp;(Next token is INT 8)</span></p>
<p><span class="font2">| &nbsp;| &nbsp;| &nbsp;| &nbsp;| &nbsp;| &nbsp;| &nbsp;| &nbsp;Trying alternative 1/2</span></p>
<p><span class="font2">| &nbsp;| &nbsp;| &nbsp;| &nbsp;| &nbsp;| &nbsp;| &nbsp;| &nbsp;| Looking for token [INT]</span></p>
<p><span class="font2">| &nbsp;| &nbsp;| &nbsp;| &nbsp;| &nbsp;| &nbsp;| &nbsp;| &nbsp;| Next token is [INT 8]</span></p>
<p><span class="font2">| &nbsp;&nbsp;| &nbsp;&nbsp;| &nbsp;&nbsp;| &nbsp;&nbsp;| &nbsp;&nbsp;| &nbsp;&nbsp;| &nbsp;&nbsp;| &nbsp;&nbsp;| Token matched</span></p>
<p><span class="font2">| &nbsp;| &nbsp;| &nbsp;| &nbsp;| &nbsp;| &nbsp;| &nbsp;| Matched alternative 1/2</span></p>
<p><span class="font2">| &nbsp;| &nbsp;| &nbsp;| &nbsp;| &nbsp;| Matched concatenated component 1/2</span></p>
<p><span class="font2">| &nbsp;| &nbsp;| &nbsp;| &nbsp;| &nbsp;| &nbsp;| Looking for star(([OP *] factor | [OP /] factor))</span></p>
<p><span class="font2">| &nbsp;| &nbsp;| &nbsp;| &nbsp;| &nbsp;| &nbsp;| &nbsp;(Next token is OP -)</span></p>
<p><span class="font2">| &nbsp;| &nbsp;| &nbsp;| &nbsp;| &nbsp;| &nbsp;| Trying alternative 1/2</span></p>
<p><span class="font17">... looking for multiplicative factors ...</span></p>
<p><a href="#bookmark400"><span class="font2">| &nbsp;| &nbsp;| &nbsp;| &nbsp;| &nbsp;| &nbsp;| &nbsp;| &nbsp;Failed alternative</span></a></p>
<p><a href="#bookmark401"><span class="font2">| &nbsp;| &nbsp;| &nbsp;| &nbsp;| &nbsp;| &nbsp;| &nbsp;| &nbsp;Trying alternative</span></a></p>
<p><span class="font2">| &nbsp;| &nbsp;| &nbsp;| &nbsp;| &nbsp;| &nbsp;| &nbsp;| &nbsp;| | Looking for nothing</span></p>
<p><a href="#bookmark402"><span class="font2">| &nbsp;&nbsp;| &nbsp;&nbsp;| &nbsp;&nbsp;| &nbsp;&nbsp;| &nbsp;&nbsp;| &nbsp;&nbsp;| &nbsp;&nbsp;| &nbsp;&nbsp;| | (Next token is</span></a></p>
<p><span class="font2">| &nbsp;| &nbsp;| &nbsp;| &nbsp;| &nbsp;| | | Matched alternative 2/2</span></p>
<p><span class="font2">| &nbsp;| &nbsp;| &nbsp;| &nbsp;| &nbsp;| | Matched concatenated component 2/2</span></p>
<p><span class="font2">| &nbsp;| &nbsp;| &nbsp;| &nbsp;| &nbsp;| | Finished matching factor star(([OP *] factor | [OP /] factor))</span></p>
<p><span class="font2">| | | | Matched concatenated component 1/2</span></p>
<p><span class="font2">| &nbsp;| &nbsp;| &nbsp;| &nbsp;| Looking for star(([OP +] term | [OP -] term))</span></p>
<p><span class="font2">| &nbsp;| &nbsp;| &nbsp;| &nbsp;| &nbsp;(Next token is OP -)</span></p>
<p><span class="font2">| &nbsp;| &nbsp;| &nbsp;| &nbsp;| Trying alternative 1/2</span></p>
<div>
<h4><a name="bookmark403"></a><span class="font20">424</span></h4>
</div><br clear="all">
<div>
<p><span class="font15">CHAPTER 8 Parsing</span></p>
</div><br clear="all">
<p><span class="font17">When parsing goes wrong, examination of this debugging output is usually enough to figure out where the problem lies.</span></p>
<ul style="list-style:none;"><li>
<h5><a name="bookmark169"></a><span class="font19">8.4.6 The Finished Calculator</span></h5></li></ul>
<h6><a name="bookmark404"></a><span class="font17">Let’s finish the calculator now. It starts with the lexer that we saw before:</span></h6>
<div>
<p><span class="font9" style="font-weight:bold;">CODE LIBRARY</span></p>
</div><br clear="all">
<p><span class="font2">use Parser ':all';</span></p>
<p><span class="font0">calculator &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="font2">use Lexer ':all';</span></p>
<p><span class="font2">my $input = allinput(\*STDIN);</span></p>
<p><span class="font2">my $lexer = iterator_to_stream( make_lexer($input,</span></p>
<p><a href="#bookmark405"><span class="font2">['TERMINATOR', qr/;\n*|\n+/</span></a></p>
<p><a href="#bookmark406"><span class="font2">['INT', &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;qr/\b\d+\b/</span></a></p>
<p><a href="#bookmark407"><span class="font2">['PRINT', &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;qr/\bprint\b/</span></a></p>
<p><a href="#bookmark408"><span class="font2">['IDENTIFIER', qr|[A-Za-z_]\w*|</span></a></p>
<p><a href="#bookmark409"><span class="font2">['OP', &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;qr#\*\*|[-=+*/()]#</span></a></p>
<p><a href="#bookmark410"><span class="font2">['WHITESPACE', qr/\s+/, sub { &quot;&quot;&nbsp;}</span></a></p>
<p><span class="font2">)</span></p>
<p><span class="font2">);</span></p>
<h6><a name="bookmark411"></a><span class="font17">The complete grammar for the calculator is:</span></h6>
<p><span class="font2">program ^ star(statement) 'End_of_Input';</span></p>
<p><span class="font2">statement ^ 'PRINT' expression 'TERMINATOR'</span></p>
<p><span class="font2">| 'IDENTIFIER' '=' expression 'TERMINATOR'</span></p>
<p><span class="font2">expression ^ term star('+' term | '-' term)</span></p>
<p><span class="font2">term ^ factor star('*' factor | '/' factor)</span></p>
<p><span class="font2">factor ^ base ('**' factor | (nothing))</span></p>
<p><span class="font2">base ^ 'INT' | 'IDENTIFIER' | '(' expression ')'</span></p>
<p><span class="font17">There are two new grammar rules at the top: </span><span class="font17" style="font-style:italic;">program,</span><span class="font17"> which represents the entire input, and </span><span class="font17" style="font-style:italic;">statement,</span><span class="font17"> which represents a single statement, either a variable assignment or a request to print a result.<a name="footnote34"></a><sup><a href="#bookmark412">34</a></sup><sup></sup></span></p>
<p><span class="font15">8.4 ARITHMETIC EXPRESSIONS</span></p>
<div>
<p><span class="font20">425</span></p>
</div><br clear="all">
<p><span class="font17">The grammar for expressions is a little more complicated also. The </span><span class="font17" style="font-style:italic;">factor </span><span class="font17">symbol no longer represents an atomic expression. Instead, it contains an optional exponentiation operation. Filling the atomic role formerly played by </span><span class="font17" style="font-style:italic;">factor</span><span class="font17"> is a new symbol, </span><span class="font17" style="font-style:italic;">base,</span><span class="font17"> which as before can be a number or a parenthesized expression, and now can also be a variable name.</span></p>
<p><span class="font2">my %VAR;</span></p>
<p><span class="font2">my (Sbase, Sexpression, Sfactor, Sprogram, Sstatement, Sterm);</span></p>
<p><span class="font2">SBase = parser { Sbase-&gt;(@_) };</span></p>
<p><span class="font2">SExpression = parser { Sexpression-&gt;(@_) };</span></p>
<p><span class="font2">SFactor &nbsp;&nbsp;&nbsp;&nbsp;= parser { Sfactor-&gt;(@_) };</span></p>
<p><span class="font2">SProgram &nbsp;&nbsp;&nbsp;= parser { Sprogram-&gt;(@_) };</span></p>
<p><span class="font2">SStatement = parser { Sstatement-&gt;(@_) };</span></p>
<p><span class="font2">STerm = parser { Sterm-&gt;(@_) };</span></p>
<p><span class="font2">Sprogram = concatenate(star(SStatement), \&amp;End_of_Input);</span></p>
<p><span class="font2">Sstatement = alternate(T(concatenate(lookfor('PRINT'), SExpression, lookfor('TERMINATOR')), sub { print &quot;&gt;&gt;&nbsp;S_[1]\n&quot; }), T(concatenate(lookfor('IDENTIFIER'), lookfor(['OP', ' = ']), SExpression, lookfor('TERMINATOR') ),</span></p>
<p><span class="font2">sub { SVAR{S_[0]} = S_[2] }), );</span></p>
<p><span class="font17">When the parser recognizes a complete </span><span class="font2">print </span><span class="font17">statement, it prints out the value of the expression. When it recognizes a complete assignment statement, it stores the value of the expression in a hash, </span><span class="font2">%VAR</span><span class="font17">, with the variable’s name as a key. (We can prepopulate </span><span class="font2">%VAR </span><span class="font17">with the values of useful constants, such as </span><span class="font17" style="font-style:italic;">n</span><span class="font17">.)</span></p>
<p><span class="font17">The parsers for </span><span class="font17" style="font-style:italic;">expression</span><span class="font17"> and </span><span class="font17" style="font-style:italic;">term</span><span class="font17"> are exactly as before:</span></p>
<p><span class="font2">Sexpression = operator(STerm, [lookfor(['OP', ' + ']), sub { S_[0] + S_[1] }], [lookfor(['OP', '-']), sub { S_[0] - S_[1] }]);</span></p>
<p><span class="font15">expressions, the former returning true or false to indicate success or failure of printing, and the latter returning the value of </span><span class="font1">Sy</span><span class="font15">. If we do this, we get the opportunity to do things like </span><span class="font1">Sresult = print Sx </span><span class="font15">and </span><span class="font1">Sx = Sy = Sz</span><span class="font15">, which the calculator won’t allow. It would have been both simpler and more useful to write the calculator this way, and I introduced the special </span><span class="font15" style="font-style:italic;">statement</span><span class="font15"> forms solely for variety.</span></p>
<div>
<h4><a name="bookmark413"></a><span class="font20">426</span></h4>
</div><br clear="all">
<div>
<p><span class="font15">CHAPTER 8 Parsing</span></p>
</div><br clear="all">
<p><span class="font2">Sterm = operator($Factor, [lookfor(['OP', '*']), sub { S_[0] * S_[1] }], [lookfor(['OP', '/']), sub { $_[0] / $_[1] }]);</span></p>
<p><span class="font17">Factors are a little different than in earlier examples, because they may now contain </span><span class="font2">** </span><span class="font17">operators:</span></p>
<p><span class="font2">Sfactor = T(concatenate(SBase, alternate(T(concatenate(lookfor(['OP', '**']),</span></p>
<p><span class="font2">SFactor),</span></p>
<p><span class="font2">sub { S_[1] }), T(\&amp;nothing, sub { 1 }))), sub { S_[0] ** S_[1] });</span></p>
<p><span class="font17">For an expression like </span><span class="font2">3 ** 4</span><span class="font17">, we assign a value of 4 to the </span><span class="font2">** 4 </span><span class="font17">part; the final value computation assigns a value of 81 totheentire </span><span class="font2">3 ** 4 </span><span class="font17">expression. A missing exponent has a value of 1, so that </span><span class="font2">3 </span><span class="font17">gets the same value as </span><span class="font2">3 ** 1</span><span class="font17">. We haven’t used </span><span class="font2">operator() </span><span class="font17">here because </span><span class="font2">operator() </span><span class="font17">generates parsers for left-associative operators, and </span><span class="font2">** </span><span class="font17">is right associative. </span><span class="font2">2**2**3 </span><span class="font17">means </span><span class="font2">2**(2**3) </span><span class="font3">= </span><span class="font17">256, not </span><span class="font2">(2**2)**3 </span><span class="font3">= </span><span class="font17">64.</span></p>
<p><span class="font2">Sbase = alternate(lookfor('INT'), lookfor('IDENTIFIER', sub { SVAR{S_[0][1]} || 0 }), T(concatenate(lookfor(['OP', '(']), SExpression, lookfor(['OP', ')'])), sub { S_[1] }) );</span></p>
<p><span class="font17">The parser for </span><span class="font17" style="font-style:italic;">base</span><span class="font17"> is just like the old parser for </span><span class="font17" style="font-style:italic;">term,</span><span class="font17"> except with an extra clause for handling identifiers. To recover the value of an identifier, we look up the name of the identifier in the </span><span class="font2">%VAR </span><span class="font17">hash. Undefined variables behave like the number 0. Alternatively, we could have the calculator issue a warning message for undefined variables.</span></p>
<p><span class="font17">The calculator is complete; all we need is to invoke the parser:</span></p>
<p><span class="font2">Sprogram-&gt;(Slexer);</span></p>
<p><span class="font17">Given the following input:</span></p>
<p><span class="font2">a = 12345679 * 6 b=a*9; c=0 print b</span></p>
<p><span class="font17">it produces the correct output:</span></p>
<p><span class="font2">&gt;&gt; 666666666</span></p>
<ul style="list-style:none;"><li>
<h5><a name="bookmark170"></a><span class="font19">8.4.7 Error Diagnosis and Recovery</span></h5></li></ul>
<p><span class="font17">Although the calculator works fine on correct inputs, it fails unpleasantly on erroneous input. If we delete the semicolon from the previous example, yielding:</span></p>
<p><span class="font2">a = 12345679 * 6</span></p>
<p><span class="font2" style="font-weight:bold;">b=a*9 c=0</span></p>
<p><span class="font2">print b</span></p>
<p><span class="font17">then the parser simply fails after the assignment to </span><span class="font2">a</span><span class="font17">, returning an undefined value. No error message is generated.</span></p>
<p><span class="font17">ERROR-RECOVERY PARSERS</span></p>
<p><span class="font17">One easy way to put some error handling into the parser is to build a specialpurpose sub-parser whose job is to recover from errors. If a statement goes awry, control will pass to the error-recovery parser. The error-recovery parser will try to resynchronize the parser with the input by discarding tokens until it gets to the end of the bad statement, and then restarting the parser from the new position:</span></p>
<p><span class="font2">Sstatement = alternate(T(concatenate(lookfor('PRINT'), SExpression, lookfor('TERMINATOR')), sub { print &quot;&gt;&gt;&nbsp;S_[1]\n&quot; }), T(concatenate(lookfor('IDENTIFIER'), lookfor(['OP', ' = ']), SExpression, lookfor('TERMINATOR') ), sub { SVAR{S_[0]} = $_[2] }), </span><span class="font2" style="font-weight:bold;">error(lookfor('TERMINATOR'), SStatement), </span><span class="font2">);</span></p>
<p><span class="font17">The </span><span class="font2">error() </span><span class="font17">call here generates a new parser, which is a third alternative form for </span><span class="font17" style="font-style:italic;">statement.</span><span class="font17"> If, when trying to parse a statement, the upcoming input fails to</span></p>
<p><span class="font17">match either of the first two forms, the error-recovery parser returned by </span><span class="font2">error() </span><span class="font17">will be invoked.</span></p>
<p><span class="font2">error()</span><span class="font17">’s first argument is another parser whose job is to identify a good place in the input to restart the parsing process. The error-recovery parser generated by </span><span class="font2">error() </span><span class="font17">will discard one token at a time until it reaches a point in the input that is acceptable to </span><span class="font2">error()</span><span class="font17">’s first argument. In this case, a good place to restart is immediately following a </span><span class="font2">TERMINATOR </span><span class="font17">token, because that is where a new statement is likely to begin. When the error-recovery parser is ready to continue, it invokes another parser to continue the job on the remaining input stream; this other parser is </span><span class="font2">error()</span><span class="font17">’s second argument. In this case, once the error-recovery parser reaches a newline, it invokes </span><span class="font2">SStatement </span><span class="font17">to start looking for another statement.</span></p>
<p><span class="font17">The code for </span><span class="font2">error() </span><span class="font17">is fairly straightforward. First we’ll see it without debugging clutter:</span></p>
<p><span class="font2">sub error {</span></p>
<p><span class="font2">my (Schecker, Scontinuation) = @_;</span></p>
<p><span class="font2">my Sp;</span></p>
<p><span class="font2">Sp = parser {</span></p>
<p><span class="font2">my Sinput = shift;</span></p>
<p><span class="font2">while (defined(Sinput)) {</span></p>
<p><span class="font2">if (my (undef, Sresult) = Schecker-&gt;(Sinput)) {</span></p>
<p><span class="font2">Sinput = Sresult;</span></p>
<p><span class="font2">last;</span></p>
<p><span class="font2">} else {</span></p>
<p><span class="font2">drop(Sinput);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">return unless defined Sinput;</span></p>
<p><span class="font2">return Scontinuation-&gt;(Sinput);</span></p>
<p><span class="font2">};</span></p>
<p><span class="font2">SN{Sp} = &quot;errhandler(SN{Scontinuation} -&gt; SN{Schecker})&quot;;</span></p>
<p><span class="font2">return Sp;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">The essential line is </span><span class="font2">drop(Sinput)</span><span class="font17">, which discards a token from the input. This is done until either the </span><span class="font2">Schecker </span><span class="font17">parser (</span><span class="font2">lookfor('TERMINATOR') </span><span class="font17">in the example) succeeds, or the input is exhausted. Afterward, the error-handler parser continues by invoking the continuation (</span><span class="font2">SStatement </span><span class="font17">in the example) on the remaining input.</span></p>
<p><span class="font15">8.4 ARITHMETIC EXPRESSIONS</span></p>
<div>
<p><span class="font20">429</span></p>
</div><br clear="all">
<p><span class="font17">Here’s the version with debugging messages:</span></p>
<p><span class="font2">sub error { my (Schecker, Scontinuation) = @_; my Sp;</span></p>
<p><span class="font2">Sp = parser { my Sinput = shift; </span><span class="font2" style="font-weight:bold;">debug &quot;Error in $N{$continuation}</span><span class="font2">\</span><span class="font2" style="font-weight:bold;">n&quot;; debug &quot;Discarding up to $N{$checker}</span><span class="font2">\</span><span class="font2" style="font-weight:bold;">n&quot;; my @discarded; </span><span class="font2">while (defined(Sinput)) { </span><span class="font2" style="font-weight:bold;">my $h = head($input); </span><span class="font2">if (my (undef, Sresult) = Schecker-&gt;(Sinput)) { </span><span class="font2" style="font-weight:bold;">debug &quot;Discarding $N{$checker}</span><span class="font2">\</span><span class="font2" style="font-weight:bold;">n&quot;; push @discarded, $N{$checker}; </span><span class="font2">Sinput = Sresult; last; } else {</span></p>
<p><span class="font2" style="font-weight:bold;">debug &quot;Discarding token [@$h]</span><span class="font2">\</span><span class="font2" style="font-weight:bold;">n&quot;; push @discarded, $h-&gt;[1];</span></p>
<p><span class="font2">drop(Sinput);</span></p>
<p><span class="font2">} } </span><span class="font2" style="font-weight:bold;">warn &quot;Erroneous input: ignoring '@discarded'</span><span class="font2">\</span><span class="font2" style="font-weight:bold;">n&quot; if @discarded; </span><span class="font2">return unless defined Sinput;</span></p>
<p><span class="font2" style="font-weight:bold;">debug &quot;Continuing with $N{$continuation} after error recovery</span><span class="font2">\</span><span class="font2" style="font-weight:bold;">n&quot;; </span><span class="font2">Scontinuation-&gt;(Sinput);</span></p>
<p><span class="font2">};</span></p>
<p><span class="font2">SN{Sp} = &quot;errhandler(SN{Scontinuation} -&gt; SN{Schecker})&quot;; return Sp;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">On our erroneous input, the calculator program performs the assignment to </span><span class="font2">a </span><span class="font17">as instructed on the first line, and then says:</span></p>
<p><span class="font2">Erroneous input: ignoring ’b = a * 9 c = 0 ’ &gt;&gt;&nbsp;0</span></p>
<p><span class="font17">The </span><span class="font2">&gt;&gt;&nbsp;0 </span><span class="font17">is the result of printing out the value of </span><span class="font2">b </span><span class="font17">in the final line; </span><span class="font2">b </span><span class="font17">was unset and defaulted to 0 because of the syntax error in the previous line.</span></p>
<div>
<h4><a name="bookmark414"></a><span class="font20">430</span></h4>
</div><br clear="all">
<div>
<p><span class="font15">CHAPTER 8 Parsing</span></p>
</div><br clear="all">
<p><span class="font17">EXCEPTIONS</span></p>
<p><span class="font17">Another convenient way to deal with errors is to change the structure of the parsers. Instead of returning </span><span class="font2">undef </span><span class="font17">to indicate a failed parse, they will throw an exception. The exception will include information about what the parser would have accepted and what it saw instead. Error-handler parsers will catch the exceptions, issue error messages, resynchronize, and restart.</span></p>
<p><span class="font17">First, a brief review of the semantics of exceptions in Perl. Perl’s exceptionhandling mechanism is unfortunately named </span><span class="font2">eval</span><span class="font17">:</span></p>
<p><span class="font2">my Sresult = eval { ... };</span></p>
<p><span class="font17">Code in the </span><span class="font2">eval </span><span class="font17">is run in exactly the same way as any other code, returning the same result into </span><span class="font2">Sresult</span><span class="font17">, except that if it throws an exception, the exception will be caught by the </span><span class="font2">eval </span><span class="font17">instead of terminating the program. If the code inside the </span><span class="font2">eval </span><span class="font17">throws an exception, </span><span class="font2">Sresult </span><span class="font17">becomes undefined.</span></p>
<p><span class="font17">Exceptions are thrown with the </span><span class="font2">die </span><span class="font17">function. They may be arbitrary data objects. After an exception is caught, the value thrown is placed into the special variable </span><span class="font2">S@</span><span class="font17">.</span></p>
<p><span class="font17">To rewrite the </span><span class="font2">End_of_Input() </span><span class="font17">parser in this style, we say:</span></p>
<div>
<p><span class="font9" style="font-weight:bold;">CODE LIBRARY</span></p>
</div><br clear="all">
<div>
<p><span class="font0">Parser::Except.pm</span></p>
</div><br clear="all">
<p><span class="font2">sub End_of_Input {</span></p>
<p><span class="font2">my Sinput = shift;</span></p>
<p><span class="font2">return (undef, undef) unless defined(Sinput);</span></p>
<p><span class="font2">die [&quot;End of input&quot;, Sinput];</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">If there is no more input, the parser returns a value as before. If there is more input, the parser fails by calling </span><span class="font2">die</span><span class="font17">. The </span><span class="font2">die </span><span class="font17">value includes a string describing what was being sought (</span><span class="font2">&quot;End of Input&quot;</span><span class="font17">) and what was found instead (</span><span class="font2">Sinput</span><span class="font17">).</span></p>
<p><span class="font17">Here’s </span><span class="font2">lookfor()</span><span class="font17">:</span></p>
<p><span class="font2">sub lookfor {</span></p>
<p><span class="font2">my Swanted = shift;</span></p>
<p><span class="font2">my Svalue = shift || sub { S_[0][1] };</span></p>
<p><span class="font2">my Su = shift;</span></p>
<p><span class="font2">Swanted = [Swanted] unless ref Swanted;</span></p>
<p><span class="font2">my Sparser = parser { my Sinput = shift;</span></p>
<p><span class="font2">unless (defined Sinput) {</span></p>
<p><span class="font2" style="font-weight:bold;">die ['TOKEN', $input, Swanted];</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">my Snext = head(Sinput);</span></p>
<p><span class="font2">for my Si (0 .. S#wanted) {</span></p>
<p><span class="font2">next unless defined Swanted-&gt;[Si];</span></p>
<p><span class="font2">unless (Swanted-&gt;[Si] eq Snext-&gt;[Si]) { </span><span class="font2" style="font-weight:bold;">die ['TOKEN', $input, Swanted];</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">my Swanted_value = Svalue-&gt;(Snext, Su);</span></p>
<p><span class="font2">return (Swanted_value, tail(Sinput));</span></p>
<p><span class="font2">};</span></p>
<p><span class="font2">SN{Sparser} = &quot;[©Swanted]&quot;;</span></p>
<p><span class="font2">return Sparser;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">If the </span><span class="font2">lookfor()</span><span class="font17">-generated parser sees the token it wants, it returns the same value as the old version. If it sees end-of-input or the wrong token, it throws an exception. As before, the exception value includes a tag indicating what kind of thing was being sought (a </span><span class="font2">TOKEN</span><span class="font17">), and what was found instead (</span><span class="font2">Sinput</span><span class="font17">). Here it also includes auxiliary information indicating what token was sought.</span></p>
<p><span class="font2">nothing() </span><span class="font17">requires no changes because it never fails. </span><span class="font2">concatenate() </span><span class="font17">requires no changes, although we have an opportunity to make it simpler. It no longer needs to check to see if its sub-parsers have succeeded and terminate prematurely if one hasn’t. It can assume that they all will succeed, because if one doesn’t, it will throw an exception that will terminate </span><span class="font2">concatenate() </span><span class="font17">prematurely anyway.</span></p>
<p><span class="font2">alternate() </span><span class="font17">is the interesting one. When a sub-parser succeeds, it stops and returns the value, as before. When a sub-parser fails, the </span><span class="font2">alternate() </span><span class="font17">parser needs to catch the exception so that it can try the next sub-parser. It installs the exception in an array </span><span class="font2">©failures</span><span class="font17">; if all the sub-parsers fail, </span><span class="font2">©failures </span><span class="font17">will contain the list of reasons why, and </span><span class="font2">alternate() </span><span class="font17">can throw an exception that includes this information:</span></p>
<p><span class="font2">sub alternate {</span></p>
<p><span class="font2">my ©p = ©_;</span></p>
<p><span class="font2">return parser { return () } if ©p == 0;</span></p>
<p><span class="font2">return Sp[0] &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ©p == 1;</span></p>
<p><span class="font2">my Sp;</span></p>
<p><span class="font2">Sp = parser {</span></p>
<div>
<p><span class="font20">432</span></p>
</div><br clear="all">
<p><span class="font15">CHAPTER 8 Parsing</span></p>
<p><span class="font2">my Sinput = shift;</span></p>
<p><span class="font2">my (Sv, Snewinput);</span></p>
<p><span class="font2" style="font-weight:bold;">my ©failures;</span></p>
<p><span class="font2">for (@p) {</span></p>
<p><span class="font2" style="font-weight:bold;">eval { (Sv, Snewinput) = $_-&gt;($input) };</span></p>
<p><span class="font2" style="font-weight:bold;">if (S©) {</span></p>
<p><span class="font2" style="font-weight:bold;">die unless ref S©;</span></p>
<p><span class="font2" style="font-weight:bold;">push ©failures, S©;</span></p>
<p><span class="font2" style="font-weight:bold;">} else {</span></p>
<p><span class="font2">return (Sv, Snewinput);</span></p>
<p><span class="font2" style="font-weight:bold;">}</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2" style="font-weight:bold;">die ['ALT', Sinput, </span><span class="font2">\</span><span class="font2" style="font-weight:bold;">©failures];</span></p>
<p><span class="font2">};</span></p>
<p><span class="font2">SN{Sp} = &quot;(&quot; . join(&quot; | &quot;, map SN{S_}, @p) . &quot;)&quot;;</span></p>
<p><span class="font2">return Sp;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">The </span><span class="font2">die unless ref S@ </span><span class="font17">line is there to propagate any exception that has to do with a programming error, such as division by zero. If we didn’t propagate these, then they would get absorbed into the </span><span class="font2">©failures </span><span class="font17">array, and might be thrown away.</span></p>
<p><span class="font17">Finally, we need a function to actually catch exceptions and issue a report. Here’s a simple one:</span></p>
<p><span class="font2">sub error {</span></p>
<p><span class="font2">my (Stry) = ©_;</span></p>
<p><span class="font2">my Sp;</span></p>
<p><span class="font2">Sp = parser {</span></p>
<p><span class="font2">my Sinput = shift;</span></p>
<p><span class="font2">my ©result = eval { Stry-&gt;(Sinput) };</span></p>
<p><span class="font2">if ($©) {</span></p>
<p><span class="font2">display_failures(S©) if ref S©;</span></p>
<p><span class="font2">die;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">return ©result;</span></p>
<p><span class="font2">};</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">Its argument </span><span class="font2">Stry </span><span class="font17">isaparser; </span><span class="font2">error() </span><span class="font17">returns a new parser that tries </span><span class="font2">Stry</span><span class="font17">. If </span><span class="font2">Stry </span><span class="font17">succeeds, </span><span class="font2">error() </span><span class="font17">returns its value. If </span><span class="font2">Stry </span><span class="font17">fails, </span><span class="font2">error() </span><span class="font17">issues an error report</span></p>
<p><span class="font17">with </span><span class="font2">display_failures() </span><span class="font17">and then calls </span><span class="font2">die </span><span class="font17">to propagate the same exception up to </span><span class="font17" style="font-style:italic;">its</span><span class="font17"> caller.</span></p>
<p><span class="font17">Here’s a rather elaborate implementation of </span><span class="font2">display_failures()</span><span class="font17">:</span></p>
<p><span class="font2">sub display_failures {</span></p>
<p><span class="font2">my ($fail, $depth) = @_;</span></p>
<p><span class="font2">$depth ||= 0;</span></p>
<p><span class="font2">my $I = &quot;&nbsp;&quot;&nbsp;x $depth;</span></p>
<p><span class="font2">my (Stype, Sposition, $data) = @$fail;</span></p>
<p><span class="font2">my $pos_desc = &quot;&quot;;</span></p>
<p><span class="font2">while (length($pos_desc) &lt;&nbsp;40) {</span></p>
<p><span class="font2">if ($position) {</span></p>
<p><span class="font2">my $h = head($position);</span></p>
<p><span class="font2">$pos_desc .= &quot;[@$h] &quot;;</span></p>
<p><span class="font2">} else {</span></p>
<p><span class="font2">$pos_desc .= &quot;End of input &quot;;</span></p>
<p><span class="font2">last;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">$position = tail($position);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">chop $pos_desc;</span></p>
<p><span class="font2">$pos_desc .= &quot;...&quot; if defined $position;</span></p>
<p><span class="font2">if ($type eq 'TOKEN') {</span></p>
<p><span class="font2">print $I, &quot;Wanted [@$data] instead of '$pos_desc'\n&quot;;</span></p>
<p><span class="font2">} elsif ($type eq 'End of input') {</span></p>
<p><span class="font2">print $I, &quot;Wanted EOI instead of '$pos_desc'\n&quot;;</span></p>
<p><span class="font2">} elsif ($type eq 'ALT') {</span></p>
<p><span class="font2">print $I, ($depth ? &quot;Or any&quot; : &quot;Any&quot;), &quot;&nbsp;of the following:\n&quot;;</span></p>
<p><span class="font2">for (@$data) {</span></p>
<p><span class="font2">display_failures($_, $depth+1);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">display_failures() </span><span class="font17">is expecting to get at least one argument, which is the exception object, and has the form </span><span class="font2">[$type, $position, $data]</span><span class="font17">, where </span><span class="font2">$type </span><span class="font17">is just an identifying string, </span><span class="font2">$position </span><span class="font17">is the position in the input stream at which the error occurred, and the </span><span class="font2">$data </span><span class="font17">is optional and has a form that depends on the </span><span class="font2">$type</span><span class="font17">.</span></p>
<p><span class="font17">The middle section analyzes the input tokens that appear starting at </span><span class="font2">Sposition </span><span class="font17">and builds up </span><span class="font2">$pos_desc</span><span class="font17">, a string describing them. The end section examines </span><span class="font2">Stype </span><span class="font17">and prints an appropriate message. The case for </span><span class="font2">ALT </span><span class="font17">is the interesting one; in this case </span><span class="font2">Sdata </span><span class="font17">is an array of all the failure exceptions from the sub-parsers of the alternation. </span><span class="font2">display_failures </span><span class="font17">prints an appropriate header and calls itself recursively to display the sub-failures.</span></p>
<p><span class="font17">The top-level call of the main parser on the entire input needs to be protected by an </span><span class="font2">eval </span><span class="font17">block, so that the program has a chance to recover from an uncaught exception:</span></p>
<p><span class="font2">my (Sval, Srest) = eval { $program-&gt;($lexer) };</span></p>
<p><span class="font2">if (S@) {</span></p>
<p><span class="font2">display_failures(S@);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">or we could just use:</span></p>
<p><span class="font2">my (Sval, Srest) = error(Sprogram)-&gt;(Slexer);</span></p>
<p><span class="font17">Let’s consider the example </span><span class="font2">&quot;a=3; b + 7; c=5;&quot; </span><span class="font17">and see what comes out:</span></p>
<p><span class="font2">Wanted EOI instead of '[IDENTIFIER b] [OP +] [INT 7] [TERMINATOR ;]...'</span></p>
<p><span class="font17">The parser is reporting that it was unhappy with the “</span><span class="font2">b + 7</span><span class="font17">;” part of the input; it would have preferred to see the input end right after the “</span><span class="font2">a= 3</span><span class="font17">;” part.</span></p>
<p><span class="font17">We can get better reporting by using the </span><span class="font2">error() </span><span class="font17">function to insert error reporting at appropriate places inside the parser. For example, if we change:</span></p>
<p><span class="font2">Sstatement = alternate(...);</span></p>
<p><span class="font17">to:</span></p>
<p><span class="font2">Sstatement = error(alternate(...));</span></p>
<p><span class="font17">then all erroneous statements will be diagnosed. Now the output includes:</span></p>
<p><span class="font2">Any of the following:</span></p>
<p><span class="font2">Wanted [PRINT] instead of '[IDENTIFIER b] [OP +] [INT 7] [TERMINATOR ;]...'</span></p>
<p><span class="font2">Wanted [OP =] instead of '[OP +] [INT 7] [TERMINATOR ;] [IDENTIFIER c]...'</span></p>
<p><span class="font17">It wanted to see </span><span class="font2">&quot;print&quot; </span><span class="font17">after </span><span class="font2">&quot;a=3;&quot;</span><span class="font17">, or else </span><span class="font2">&quot;=&quot; </span><span class="font17">instead of </span><span class="font2">&quot;+&quot; </span><span class="font17">after the </span><span class="font2">&quot;b&quot;</span><span class="font17">.</span></p>
<p><span class="font17">This parser aborts at the first sign of trouble. We could add error recovery to the reporting behavior of </span><span class="font2">error() </span><span class="font17">and get the parser to continue and perhaps diagnose more errors.</span></p>
<ul style="list-style:none;"><li>
<h5><a name="bookmark173"></a><span class="font19">8.4.8 Big Numbers</span></h5></li></ul>
<p><span class="font17">As a final improvement, we’ll change the calculator to support arbitrarily large numbers. This is trivial; we add:</span></p>
<p><span class="font2">use Math::BigFloat;</span></p>
<p><span class="font17">to the top of the program, and change the part of the parser that assigns a value to an </span><span class="font2">INT </span><span class="font17">token:</span></p>
<p><span class="font2">lookfor('INT')</span></p>
<p><span class="font17">becomes:</span></p>
<p><span class="font2">lookfor('INT', sub { Math::BigFloat-&gt;new($_[0][1]) });</span></p>
<p><span class="font17">which passes the token’s string representation to </span><span class="font2">Math::BigFloat</span><span class="font17">, which constructs a big number object for it. </span><span class="font2">Math::BigFloat </span><span class="font17">overloads the normal arithmetic operators to work on arbitrary-precision numbers, so we don’t need to change anything else. It would be almost as easy to get the calculator to support complex numbers; we would use </span><span class="font2">Math::Complex</span><span class="font17">, and add a line to the lexer to properly interpret constants that matched </span><span class="font2">/\d+i/</span><span class="font17">.</span></p>
<ul style="list-style:none;"><li>
<h5><a name="bookmark174"></a><span class="font18">8.5 PARSING REGEXES</span></h5></li></ul>
<p><span class="font17">As an example that’s probably more practical than the calculator, we’ll implement a parser for a subset of Perl’s regular expressions. In Chapter 6 we saw a program that generated a (possibly infinite) stream of all the strings matched by a certain regex. But it wasn’t convenient to use this program. To get a list of the strings matched by </span><span class="font2">/(a|b)*c+/</span><span class="font17">, for example, we had to write the following code:</span></p>
<p><span class="font2">my $z = concat(star(union(literal(&quot;a&quot;), literal(&quot;b&quot;))), plus(literal(&quot;c&quot;)),</span></p>
<p><span class="font2">);</span></p>
<p><span class="font17">What we’d like is to be able to put in a regex in the usual notation and get out the same stream. Our parsing technology will do this. We’ll build a parser that can analyze the structure of a regex. As it determines the structure of the regex, it will call the appropriate stream functions to manufacture the stream of matching strings.</span></p>
<p><span class="font17">First, the lexer. Regexes contain the following operators: </span><span class="font2">+ * ? ( ) |</span><span class="font17">. Other than this, they contain atomic expressions, or “atoms,” such as </span><span class="font2">w</span><span class="font17">, </span><span class="font2">\r</span><span class="font17">, and </span><span class="font2">\x0d</span><span class="font17">. They also contain other items such as character classes, non-capturing parentheses, lookahead items, and embedded Perl code; we’ll ignore these because they’re not particularly instructive.</span></p>
<p><span class="font17">Of these lexical types, the atoms are all syntactically equivalent; any valid regex that contains a </span><span class="font2">w </span><span class="font17">is still valid if the </span><span class="font2">w </span><span class="font17">is replaced by </span><span class="font2">\r </span><span class="font17">or by </span><span class="font2">\x0d</span><span class="font17">. Similarly, the quantifiers </span><span class="font2">+</span><span class="font17">, </span><span class="font2">*</span><span class="font17">, and </span><span class="font2">? </span><span class="font17">are all syntactically equivalent. This suggests the following lexer:</span></p>
<div>
<p><span class="font9" style="font-weight:bold;">CODE LIBRARY</span></p>
</div><br clear="all">
<p><span class="font2">use Lexer ':all';</span></p>
<p><span class="font0">regex-parser</span></p>
<p><span class="font2">use Stream 'node';</span></p>
<p><span class="font2">my ($regex, $alternative, $atom, $qatom);</span></p>
<p><span class="font2">sub regex_to_stream {</span></p>
<p><span class="font2">my @input = @_;</span></p>
<p><span class="font2">my $input = sub { shift @input };</span></p>
<p><span class="font2">my $lexer = iterator_to_stream(</span></p>
<p><span class="font2">make_lexer($input,</span></p>
<p><span class="font2">['ATOM', &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;qr/\\x[0-9a-fA-F]{0,2} # hex escape</span></p>
<p><span class="font2">|\\\d+ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# octal escape</span></p>
<table border="1">
<tr><td></td><td>
<p><span class="font2">|\\.</span></p>
<p><span class="font2">/x,</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">],</span></p></td><td>
<p><span class="font2"># other \</span></p></td></tr>
<tr><td style="vertical-align:bottom;">
<p><span class="font2">['PAREN',</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">qr/[()]/,</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">],</span></p></td><td></td></tr>
<tr><td style="vertical-align:bottom;">
<p><span class="font2">['QUANT',</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">qr/[*+?]/</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">],</span></p></td><td></td></tr>
<tr><td style="vertical-align:bottom;">
<p><span class="font2">['BAR',</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">qr/[|]/,</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">],</span></p></td><td></td></tr>
<tr><td style="vertical-align:bottom;">
<p><span class="font2">['ATOM',</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">qr/./,</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">],</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2"># other char</span></p></td></tr>
</table>
<p><span class="font2">)</span></p>
<p><span class="font2">);</span></p>
<p><span class="font2">my ($result) = $regex-&gt;($lexer); return $result;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">Regexes are similar in structure to arithmetic expressions, only with fewer different operators. The lowest-precedence operator is the vertical bar, </span><span class="font2">|</span><span class="font17">. A regex is a series of alternatives separated by vertical bars. Each alternative is a (possibly empty) sequence of (possibly quantified) atoms. For example, in the regex </span><span class="font2">/(a|b)*c+/</span><span class="font17">, there is a single alternative, consisting of two quantified atoms: </span><span class="font2">(a|b)* </span><span class="font17">and </span><span class="font2">c+</span><span class="font17">. The parentheses around </span><span class="font2">a|b </span><span class="font17">group the contents into a single atomic expression. </span><span class="font2">a|b</span><span class="font17">, of course, contains two alternatives, each with one unquantified atom.</span></p>
<p><span class="font17">The grammar is:</span></p>
<p><span class="font2">regex ^ alternative 'BAR' regex | alternative alternative ^ qatom alternative | (nothing) qatom ^ atom ('QUANT' | (nothing)) atom ^ 'ATOM' | '(' regex ')'</span></p>
<p><span class="font17">As before, we define eta-conversions of the parsers so that the parsers can be mututally recursive:</span></p>
<p><span class="font2">use Parser ':all';</span></p>
<p><span class="font2">my $Regex = parser { $regex -&gt;(@_) }; my $Alternative = parser { $alternative-&gt;(@_) }; my $Atom = parser { $atom -&gt;(@_) }; my $QAtom = parser { $qatom -&gt;(@_) };</span></p>
<p><span class="font17">Building the basic parser from the grammar is straightforward:</span></p>
<p><span class="font2"># regex -&gt; alternative 'BAR' regex | alternative</span></p>
<p><span class="font2">$regex = alternate(concatenate($Alternative,</span></p>
<p><span class="font2">lookfor('BAR'),</span></p>
<p><span class="font2">$Regex),</span></p>
<p><span class="font2">$Alternative);</span></p>
<p><span class="font17">This is fine if we want to generate ASTs for regexes. But what we really want is to generate streams of strings. Ifwe assume that the values returned for </span><span class="font2">$Alternative </span><span class="font17">and </span><span class="font2">$Regex </span><span class="font17">are streams, it’s easy to generate the result for the entire regex. We use the </span><span class="font2">union() </span><span class="font17">function from Section 6.5.1:</span></p>
<p><span class="font2">use Regex;</span></p>
<p><span class="font2"># regex -&gt; alternative 'BAR' regex | alternative</span></p>
<p><span class="font2" style="font-weight:bold;">$regex = alternate(T(concatenate($Alternative,</span></p>
<div>
<h4><a name="bookmark415"></a><span class="font20">438</span></h4>
</div><br clear="all">
<div>
<p><span class="font15">CHAPTER 8 Parsing</span></p>
</div><br clear="all">
<p><span class="font2">lookfor('BAR'),</span></p>
<p><span class="font2">SRegex),</span></p>
<p><span class="font2" style="font-weight:bold;">sub { Regex::union($_[0], $_[2])}),</span></p>
<p><span class="font2">SAlternative);</span></p>
<p><span class="font17">If the regex consists of a single alternative, then the list of strings it matches is the same as the list of strings matched by the single alternative, so nothing extra needs to be done.</span></p>
<p><span class="font17">Similarly, the </span><span class="font2">concat() </span><span class="font17">function from Section 6.5.1 takes the streams that list the strings matched by two regexes and returns the stream of strings that are matched by the concatenation of two regexes, so it’s just what we need to generate the value of a single alternative:</span></p>
<ul style="list-style:none;"><li>
<p><span class="font2"># alternative -&gt; qatom alternative | (nothing)</span></p></li></ul>
<p><span class="font2">Salternative = alternate(T(concatenate(SQAtom, SAlternative),</span></p>
<p><span class="font2">\&amp;Regex::concat),</span></p>
<p><span class="font2">T(\&amp;nothing, sub { Regex::literal(&quot;&quot;) }));</span></p>
<p><span class="font17">If the alternative is empty, it matches only the empty string. The call </span><span class="font2">Regex::literal(&quot;&quot;) </span><span class="font17">returns a stream that contains the empty string and nothing else.</span></p>
<p><span class="font2">my %quant;</span></p>
<ul style="list-style:none;"><li>
<p><span class="font2"># qatom -&gt; atom ('QUANT' | (nothing))</span></p></li></ul>
<p><span class="font2">Sqatom = T(concatenate(SAtom,</span></p>
<p><span class="font2">alternate(lookfor('QUANT'),</span></p>
<p><span class="font2">\&amp;nothing),</span></p>
<p><span class="font2">),</span></p>
<p><span class="font2">sub { my (Sat, Sq) = @_;</span></p>
<p><span class="font2">defined Sq ? Squant{Sq}-&gt;(Sat) : Sat });</span></p>
<p><span class="font2">%quant = ('*' =&gt; \&amp;Regex::star,</span></p>
<p><span class="font2">'+' =&gt; \&amp;Regex::plus,</span></p>
<p><span class="font2">'?' =&gt; \&amp;Regex::query,</span></p>
<p><span class="font2">);</span></p>
<p><span class="font17">For quantified atoms, we get a stream that represents the list of strings matched by the atom, to which we apply the appropriate quantifier. There might not be a quantifier, in which case the value of the second element of the concatenation is undefined, and we return the value of the atom unchanged. Note that </span><span class="font2">%quant </span><span class="font17">is nothing more than a dispatch table.</span></p>
<p><span class="font15">8.5 PARSING REGEXES </span><span class="font20">439</span></p>
<p><span class="font17">We saw </span><span class="font2">star() </span><span class="font17">and </span><span class="font2">plus() </span><span class="font17">back in Chapter 6, but not </span><span class="font2">query()</span><span class="font17">, which is trivial:</span></p>
<p><span class="font2">sub query {</span></p>
<p><span class="font2">my $s = shift;</span></p>
<p><span class="font2">union(literal(&quot;&quot;), $s);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">It matches anything its argument matches, and also the empty string.</span></p>
<p><span class="font2"># atom -&gt; 'ATOM' | '(' regex ')'</span></p>
<p><span class="font2">$atom = alternate(lookfor(&quot;ATOM&quot;, sub { Regex::literal($_[0][1]) }),</span></p>
<p><span class="font2">T(concatenate(lookfor([&quot;PAREN&quot;, &quot;(&quot;]),</span></p>
<p><span class="font2">$Regex,</span></p>
<p><span class="font2">lookfor([&quot;PAREN&quot;, &quot;)&quot;]),</span></p>
<p><span class="font2">),</span></p>
<p><span class="font2">sub { $_[1] }),</span></p>
<p><span class="font2">);</span></p>
<p><span class="font17">Finally, we’re down to atoms. If the atom is indeed a single atomic token, then the list of strings contains the value of the token itself; for example, the atomic regex </span><span class="font2">w </span><span class="font17">matches the string </span><span class="font2">'w' </span><span class="font17">and nothing else. If the atom is actually a complete regex in parentheses, we call the regex parser recursively and return the value it returns, throwing away the parentheses, just as we did in the arithmetic expression parser.</span></p>
<p><span class="font17">Calling </span><span class="font2">Regex::literal() </span><span class="font17">is a little too simple. When the atom is </span><span class="font2">\x0d</span><span class="font17">, it does </span><span class="font17" style="font-style:italic;">not</span><span class="font17"> match the string </span><span class="font2">' \x0d'</span><span class="font17">; it matches the single-character string that contains only a carriage return. We could fix this by passing the token to a string-interpreting function before passing the result to </span><span class="font2">Regex::literal()</span><span class="font17">.</span></p>
<p><span class="font17">Some atoms are more difficult to handle. This parser treats </span><span class="font2">\b</span><span class="font17">, a wordboundary assertion, as an atom. It is atomic, but it certainly doesn’t match the string </span><span class="font2">'\b'</span><span class="font17">. To handle this properly, we’d have to introduce a new kind of value in our string streams; the new values would denote strings with boundary requirements at the front, the back, or both. When the </span><span class="font2">concat() </span><span class="font17">operator tried to put together two strings with boundary requirements at the ends at which they were being joined, it would check the requirements for compatibility. If the requirements were incompatible, </span><span class="font2">concat() </span><span class="font17">would skip that pair of strings and move on. The same scheme could handle lookahead and look-behind assertions, although the lexer would have to be extended to understand the notations.</span></p>
<div>
<h4><a name="bookmark416"></a><span class="font20">440</span></h4>
</div><br clear="all">
<div>
<p><span class="font15">CHAPTER 8 Parsing</span></p>
</div><br clear="all">
<p><span class="font17">Still, for all its limitations, the string generator performs adequately for a first cut. If we give it the input </span><span class="font2">(a|b) + (c|d<a name="footnote35"></a><sup><a href="#bookmark417">35</a></sup>)</span><span class="font17">, it cheerfully returns an infinite</span></p>
<table border="1">
<tr><td colspan="3">
<p><span class="font17">stream that begins:</span></p></td></tr>
<tr><td style="vertical-align:bottom;">
<p><span class="font2">a</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">bbb</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">abba</span></p></td></tr>
<tr><td>
<p><span class="font2">b</span></p></td><td>
<p><span class="font2">add</span></p></td><td>
<p><span class="font2">abbb</span></p></td></tr>
<tr><td style="vertical-align:bottom;">
<p><span class="font2">aa</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">aac</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">baaa</span></p></td></tr>
<tr><td style="vertical-align:bottom;">
<p><span class="font2">ab</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">abc</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">baab</span></p></td></tr>
<tr><td>
<p><span class="font2">ba</span></p></td><td>
<p><span class="font2">bac</span></p></td><td>
<p><span class="font2">baba</span></p></td></tr>
<tr><td style="vertical-align:bottom;">
<p><span class="font2">bb</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">bbc</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">babb</span></p></td></tr>
<tr><td style="vertical-align:bottom;">
<p><span class="font2">ac</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">bdd</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">bbaa</span></p></td></tr>
<tr><td style="vertical-align:bottom;">
<p><span class="font2">ad</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">aad</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">bbab</span></p></td></tr>
<tr><td>
<p><span class="font2">bc</span></p></td><td>
<p><span class="font2">abd</span></p></td><td>
<p><span class="font2">bbba</span></p></td></tr>
<tr><td style="vertical-align:bottom;">
<p><span class="font2">bd</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">bad</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">bbbb</span></p></td></tr>
<tr><td style="vertical-align:bottom;">
<p><span class="font2">aaa</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">bbd</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">addd</span></p></td></tr>
<tr><td style="vertical-align:bottom;">
<p><span class="font2">aab</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">aaaa</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">aaac</span></p></td></tr>
<tr><td style="vertical-align:bottom;">
<p><span class="font2">aba</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">aaab</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">aabc</span></p></td></tr>
<tr><td>
<p><span class="font2">abb</span></p></td><td>
<p><span class="font2">aaba</span></p></td><td>
<p><span class="font2">abac</span></p></td></tr>
<tr><td style="vertical-align:bottom;">
<p><span class="font2">baa</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">aabb</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">abbc</span></p></td></tr>
<tr><td style="vertical-align:bottom;">
<p><span class="font2">bab</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">abaa</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">baac</span></p></td></tr>
<tr><td style="vertical-align:bottom;">
<p><span class="font2">bba</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">abab</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">...</span></p></td></tr>
</table>
<ul style="list-style:none;"><li>
<h5><a name="bookmark175"></a><span class="font18">8.6 OUTLINES</span></h5></li></ul>
<p><span class="font17">The regex and calculator examples have many similarities. Here’s an example that is quite different. We’ll write a program to read in topic outlines and infer a tree structure from the indentation. A typical input looks like this:</span></p>
<ul style="list-style:none;"><li>
<p><span class="font2">* Arithmetic Expressions</span></p></li>
<li>
<p><span class="font2">* A Calculator</span></p></li>
<li>
<p><span class="font2">* Left Recursion</span></p></li>
<li>
<p><span class="font2">* A Variation on 'star'</span></p></li>
<li>
<p><span class="font2">* Generic-Operator Parsers</span></p></li>
<li>
<p><span class="font2">* Debugging</span></p></li>
<li>
<p><span class="font2">* The Finished Calculator</span></p></li>
<li>
<p><span class="font2">* Error Diagnosis and Recovery</span></p></li>
<li>
<p><span class="font2">* Error-Recovery Parsers</span></p></li>
<li>
<p><span class="font2">* Exceptions</span></p></li>
<li>
<p><span class="font2">* Big Numbers</span></p></li>
<li>
<p><span class="font2">* Parsing Regexes</span></p></li>
<li>
<p><span class="font2">* Outlines</span></p></li>
<li>
<p><span class="font2">* Database-Query Parsing</span></p></li>
<li>
<p><span class="font2">* The Lexer</span></p></li>
<li>
<p><span class="font2">* The Parser</span></p></li>
<li>
<p><span class="font2">* Backtracking Parsers</span></p></li>
<li>
<p><span class="font2">* Continuations</span></p></li>
<li>
<p><span class="font2">* Parse Streams</span></p></li>
<li>
<p><span class="font2">* Overloading</span></p></li></ul>
<p><span class="font17">To keep the problem manageable, we’ll make a few simplifying assumptions. Each item occupies exactly one line, and begins with a “bullet” character. The first line is the root of the tree, and will be flush with the left margin; each sub-item will be indented two spaces farther right than its parent.</span></p>
<p><span class="font17">All the lexers we’ve seen so far have discarded whitespace. The lexer for this problem mustn’t do that because the whitespace is significant. But the input has a very simple lexical structure: each line is an “item,” and is separated from the next item by newlines. So the lexer is simply:</span></p>
<p><span class="font2">use Lexer ':all';</span></p>
<div>
<p><span class="font9" style="font-weight:bold;">CODE LIBRARY</span></p>
</div><br clear="all">
<div>
<p><span class="font0">outline-parser</span></p>
</div><br clear="all">
<p><span class="font2">use Stream 'node';</span></p>
<p><span class="font2">my ($tree, $subtree);</span></p>
<p><span class="font2">sub outline_to_array {</span></p>
<p><span class="font2">my @input = @_;</span></p>
<p><span class="font2">my $input = sub { shift @input };</span></p>
<p><span class="font2">my $lexer = iterator_to_stream( make_lexer($input,</span></p>
<p><span class="font2">['ITEM', &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;qr/*.*$/m],</span></p>
<div>
<h4><a name="bookmark418"></a><span class="font20">442</span></h4>
</div><br clear="all">
<div>
<p><span class="font15">CHAPTER 8 Parsing</span></p>
</div><br clear="all">
<p><span class="font2">['NEWLINE', qr/\n+/ &nbsp;&nbsp;&nbsp;&nbsp;, sub { &quot;&quot;&nbsp;} ],</span></p>
<p><span class="font2">)</span></p>
<p><span class="font2">);</span></p>
<p><span class="font2">my (Sresult) = $tree-&gt;($lexer); return Sresult;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">The grammar is almost as simple. A tree has a root item, followed by zero or more subtrees. The subtrees must be indented farther to the right than the root item. The grammar will look something like this:</span></p>
<p><span class="font2">input ^ tree 'End_of_input' tree ^ 'ITEM' star(subtree) subtree ^ tree</span></p>
<p><span class="font17">This isn’t exactly right, because it doesn’t take into account the indentations. When the parser sees the root item of a new tree, it needs to record that item’s indentation; when it tries to parse a subtree, it should succeed if the next item is indented farther right than the previous root, and fail if it isn’t. Consider this simple example:</span></p>
<p><span class="font2">* A</span></p>
<ul style="list-style:none;"><li>
<p><span class="font2">* B</span></p></li></ul>
<p><span class="font2">* C</span></p>
<ul style="list-style:none;"><li>
<p><span class="font2">* D</span></p></li></ul>
<p><span class="font17">Item C here is a sub-item of B, because it’s indented farther to the right. At this point, the parser will be looking for sub-items of C. The next item is D. D is not to the right of C, so it is not a sub-item of C. Moreover, it is not to the right of B, so it is not a sub-item ofB. But D is to the right of A, so D is a sub-item of A.</span></p>
<p><span class="font17">The grammar needs to be extended to take the indentations into account:</span></p>
<p><span class="font2">input ^ tree 'End_of_input'</span></p>
<p><span class="font2">tree ^ 'ITEM' &lt;&lt;record indentation of root node&gt;&gt; star(subtree) subtree ^ &lt;&lt;check indentation of next item&gt;&gt; tree</span></p>
<p><span class="font17">Here, </span><span class="font2">&lt;&lt;record indentation of root node&gt;&gt; </span><span class="font17">is a special version of the null parser. It consumes no input, always succeeds, and returns a meaningless value. But it also examines the item that was just parsed and makes a note of how far it was indented. Similarly, </span><span class="font2">&lt;&lt;check indentation of next item&gt;&gt; </span><span class="font17">also consumes</span></p>
<p><span class="font3">8.6 OUTLINES 443</span></p>
<p><span class="font17">no input and returns a meaningless value. But it also examines the head of the input token stream to make sure that the upcoming item is indented to the right of the current root node. If so, it succeeds, allowing the </span><span class="font17" style="font-style:italic;">subtree</span><span class="font17"> parser to proceed to the real business of parsing the subtree, which it does by calling the </span><span class="font17" style="font-style:italic;">tree</span><span class="font17"> parser recursively. If not, it fails, causing the </span><span class="font17" style="font-style:italic;">subtree</span><span class="font17"> parser to fail also.</span></p>
<p><span class="font17">Here’s the main parser:</span></p>
<p><span class="font2">use Parser ':all';</span></p>
<p><span class="font2">use Stream 'head';</span></p>
<p><span class="font2">my STree &nbsp;&nbsp;&nbsp;= parser { $tree-&gt;(@_) };</span></p>
<p><span class="font2">my SSubtree = parser { $subtree-&gt;(@_) };</span></p>
<p><span class="font2">my SLEVEL = 0;</span></p>
<p><span class="font2">Stree = concatenate(lookfor('ITEM', sub { trim(S_[0][1]) }),</span></p>
<p><span class="font2">action(sub { SLEVEL++ }),</span></p>
<p><span class="font2">star(SSubtree),</span></p>
<p><span class="font2">action(sub { SLEVEL-- }));</span></p>
<p><span class="font2">my SBULLET = '[#*ox.+-]\s+';</span></p>
<p><span class="font2">sub trim {</span></p>
<p><span class="font2">my Ss = shift;</span></p>
<p><span class="font2">Ss =- s/~ *//;</span></p>
<p><span class="font2">Ss =- s/~$BULLET//o;</span></p>
<p><span class="font2">return Ss;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">The item’s string value is passed to </span><span class="font2">trim()</span><span class="font17">, which just trims off the leading whitespace and bullet, if any. The next item in the concatenation is an </span><span class="font2">action() </span><span class="font17">item, which performs the indicated action, incrementing the current indentation level. Then follow zero or more subtrees, and when the parser has finished parsing the subtrees, it invokes another action to put the indentation level back the way it was.</span></p>
<p><span class="font17">This is </span><span class="font2">action()</span><span class="font17">:</span></p>
<p><span class="font2">sub action {</span></p>
<p><span class="font2">my Saction = shift;</span></p>
<p><span class="font2">return parser {</span></p>
<p><span class="font2">my Sinput = shift;</span></p>
<p><span class="font2">Saction-&gt;(Sinput);</span></p>
<p><span class="font2">return (undef, Sinput);</span></p>
<p><span class="font2">};</span></p>
<p><span class="font2">}</span></p>
<p><span class="font20">444 </span><span class="font15">CHAPTER 8 Parsing</span></p>
<p><span class="font17">It takes an action argument and generates a parser that invokes the action, consumes no tokens, and always succeeds.</span></p>
<p><span class="font17">As it stands, the value returned by </span><span class="font17" style="font-style:italic;">tree</span><span class="font17"> is a list of four items, of which two are the meaningless </span><span class="font2">undef</span><span class="font17">s returned by the </span><span class="font2">action() </span><span class="font17">parsers. As usual, we’ll use </span><span class="font2">T() </span><span class="font17">to adjust the return value to the tree structure that we want.</span></p>
<p><span class="font17">The tree structure we’ll construct will be an array. The first element of the array will be the root node, and the other elements will be the subtrees, in order. The tree for this example is </span><span class="font2">[&quot;A&quot;, [&quot;B&quot;, [&quot;C&quot;]], [&quot;D&quot;]]</span><span class="font17">:</span></p>
<p><span class="font2">* A</span></p>
<ul style="list-style:none;"><li>
<p><span class="font2">* B</span></p></li></ul>
<p><span class="font2">* C</span></p>
<ul style="list-style:none;"><li>
<p><span class="font2">* D</span></p></li></ul>
<p><span class="font17">The main tree has two subtrees, one rooted at B and one at D. The B subtree has a sub-subtree, with root C.</span></p>
<p><span class="font2">concatenate() </span><span class="font17">will pass </span><span class="font2">T() </span><span class="font17">four arguments, as noted before; two will be </span><span class="font2">undef</span><span class="font17">. The other two will be </span><span class="font2">S_[0]</span><span class="font17">, the string value returned by </span><span class="font2">lookfor()</span><span class="font17">, and </span><span class="font2">S_[2]</span><span class="font17">, an array of the subtrees. To assemble these into a tree structure, we just need to make them into a single array:</span></p>
<p><span class="font2">Stree = T(concatenate(lookfor('ITEM', sub { trim($_[0][1]) }), action(sub { SLEVEL++; }), star(SSubtree), action(sub { SLEVEL--; })), </span><span class="font2" style="font-weight:bold;">sub { [ $_[0], @{$_[2]} ] });</span></p>
<p><span class="font17">The other half of the parser is easier in some ways, more complicated in others:</span></p>
<p><span class="font2">Ssubtree = T(concatenate(test(sub { my Sinput = shift; return unless Sinput; my Snext = head(Sinput); return unless Snext-&gt;[0] eq 'ITEM'; return level_of(Snext-&gt;[1]) &gt;= SLEVEL;</span></p>
<p><span class="font2">}), STree, ),</span></p>
<p><span class="font2">sub { S_[1] });</span></p>
<p><span class="font2">sub level_of {</span></p>
<p><span class="font2">my (Sspace) = S_[0] =- /&quot;( *)/;</span></p>
<p><span class="font2">return length(Sspace)/2;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">The parser built by </span><span class="font2">test() </span><span class="font17">is like the one built by </span><span class="font2">action()</span><span class="font17">, except that it doesn’t always succeed. Instead, it looks at the value returned by the action, and succeeds only if the value is true:</span></p>
<p><span class="font2">sub test {</span></p>
<p><span class="font2">my Saction = shift;</span></p>
<p><span class="font2">return parser {</span></p>
<p><span class="font2">my Sinput = shift;</span></p>
<p><span class="font2">my Sresult = Saction-&gt;(Sinput);</span></p>
<p><span class="font2">return Sresult ? (undef, Sinput) : ();</span></p>
<p><span class="font2">};</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">The action here makes sure there is an item coming up, and extracts the text from it. It then uses the </span><span class="font2">level_of() </span><span class="font17">utility function to figure out the nesting depth of the item’s text, and returns success if it is far enough to the right, failure if not. If the action succeeds, the </span><span class="font17" style="font-style:italic;">subtree</span><span class="font17"> parser then invokes </span><span class="font2">STree </span><span class="font17">to parse the subtree. Note that the item examined by the action is </span><span class="font17" style="font-style:italic;">not</span><span class="font17"> removed from the input stream. If </span><span class="font2">STree </span><span class="font17">returns successfully, </span><span class="font2">T() </span><span class="font17">throws away the meaningless value returned by the action, and returns the tree structure from </span><span class="font2">STree </span><span class="font17">as the value of the subtree.</span></p>
<p><span class="font17">This parser is complete. Now we’ll make it a little more clever, by having it detect when the entire input is indented (and ignore the uniform indentation if so) and having it handle different amounts of indentation at each level. These two inputs should parse the same:</span></p>
<table border="1">
<tr><td>
<p><span class="font2">A</span></p></td><td>
<p><span class="font2">* A</span></p></td></tr>
<tr><td style="vertical-align:bottom;">
<p><span class="font2">* B</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">* B</span></p></td></tr>
<tr><td style="vertical-align:bottom;">
<p><span class="font2">* C</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">* C</span></p></td></tr>
<tr><td style="vertical-align:bottom;">
<p><span class="font2">* D</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">* D</span></p></td></tr>
<tr><td style="vertical-align:bottom;">
<p><span class="font2">* E</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">* E</span></p></td></tr>
<tr><td style="vertical-align:bottom;">
<p><span class="font2">* F</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">* F</span></p></td></tr>
<tr><td style="vertical-align:bottom;">
<p><span class="font2">* G</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">* G</span></p></td></tr>
<tr><td style="vertical-align:bottom;">
<p><span class="font2">* H</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">* H</span></p></td></tr>
<tr><td style="vertical-align:bottom;">
<p><span class="font2">* I</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">* I</span></p></td></tr>
<tr><td style="vertical-align:bottom;">
<p><span class="font2">* J</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">* J</span></p></td></tr>
</table>
<p><span class="font17">Now that indentations vary, the action that records the current indentation level will have to actually examine the current item; simply incrementing a counter is</span></p>
<p><span class="font17">no longer sufficient. We didn’t give </span><span class="font2">action() </span><span class="font17">parsers any good way to examine values that have already been parsed, so the easiest way to get what we want is to attach the action to the </span><span class="font2">lookfor('ITEM') </span><span class="font17">parser:</span></p>
<div>
<p><span class="font9" style="font-weight:bold;">CODE LIBRARY</span></p>
</div><br clear="all">
<p><span class="font2">my @LEVEL;</span></p>
<p><span class="font0">^line-p^er<sup>-2</sup> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="font2">Stree = T(concatenate(T(lookfor('ITEM', sub { $_[0] }),</span></p>
<p><span class="font2">sub { my Ss = $_[1]; push @LEVEL, level_of(Ss); return trim(Ss); }), star(SSubtree), action(sub { pop @LEVEL })), sub { [ $_[0], @{$_[1]} ]}, );</span></p>
<p><span class="font17">The task of looking up the level of an item and recording it has been delegated to the </span><span class="font2">lookfor('ITEM') </span><span class="font17">parser, since it has easy access to the item’s text. We use </span><span class="font2">T() </span><span class="font17">to hang an action on the </span><span class="font2">lookfor() </span><span class="font17">parser. But since </span><span class="font2">T() </span><span class="font17">was designed for use with </span><span class="font2">concatenate()</span><span class="font17">, which returns a list of values, we need to override the normal return value of </span><span class="font2">lookfor() </span><span class="font17">to deliver the entire token instead of just the string data as usual. The string is extracted from the token and assigned to </span><span class="font2">$s</span><span class="font17">, and its level is computed and pushed on a stack. The parser needs to record the levels in a stack because when it finishes parsing the current tree, it will need to recall the level of the parent root. Let’s return to the small example:</span></p>
<p><span class="font2">* A</span></p>
<ul style="list-style:none;"><li>
<p><span class="font2">* B</span></p></li></ul>
<p><span class="font2">* C</span></p>
<ul style="list-style:none;"><li>
<p><span class="font2">* D</span></p></li></ul>
<p><span class="font17">While parsing the C tree, the parser will remember that the current root, B, is indented two spaces. When it sees item D, also indented two spaces, it will know that D is not a sub-item of B. This will conclude the parsing of the B subtree, and the action function will pop the stack. The top stack item will then be 0, the indentation of A. Since D is to the right of this, D will be parsed as a subtree of A.</span></p>
<p><span class="font17">The </span><span class="font17" style="font-style:italic;">subtree</span><span class="font17"> parser is almost identical to the previous version:</span></p>
<p><span class="font2">Ssubtree = T(concatenate(test(sub { my Sinput = shift; return unless Sinput;</span></p>
<p><span class="font3">8.6 OUTLINES 447</span></p>
<p><span class="font2">my Snext = head(Sinput);</span></p>
<p><span class="font2">return unless Snext-&gt;[0] eq 'ITEM';</span></p>
<p><span class="font2" style="font-weight:bold;">return level_of($next-&gt;[1]) &gt;&nbsp;$LEVEL[-1];</span></p>
<p><span class="font2">}), STree,),</span></p>
<p><span class="font2">sub { $_[1] });</span></p>
<p><span class="font17">The only difference is that the action compares the level of the current item with the top of the stack rather than with a scalar counter.</span></p>
<p><span class="font2">level_of() </span><span class="font17">is a little more complicated, because the entire outline might be indented, and this has to be accounted for:</span></p>
<p><span class="font2">my SPREFIX;</span></p>
<p><span class="font2">sub level_of {</span></p>
<p><span class="font2">my Scount = 0;</span></p>
<p><span class="font2">my Ss = shift;</span></p>
<p><span class="font2">if (! defined SPREFIX) {</span></p>
<p><span class="font2">(SPREFIX) = Ss =- /&quot;(\s*)/;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">Ss =<sub>-</sub> s/~SPREFIX//o</span></p>
<p><span class="font2">or die &quot;Item 'Ss' wasn’t indented the same as the previous items.\n&quot;;</span></p>
<p><span class="font2">my (Sindent) = Ss =- /~(\s*)/;</span></p>
<p><span class="font2">my Slevel = length(Sindent);</span></p>
<p><span class="font2">return Slevel;</span></p>
<p><span class="font2">SPREFIX </span><span class="font17">is a string of whitespace indicating the indentation of the very first item. All subsequent indentations are figured relative to this. The </span><span class="font2">SPREFIX </span><span class="font17">is trimmed off each item before its indentation is figured; if an item doesn’t begin with the same </span><span class="font2">SPREFIX </span><span class="font17">as the others, the parser dies.</span></p>
<p><span class="font17">Here’s the example tree again, and the result of parsing it:</span></p>
<p><span class="font2">[ 'A',</span></p>
<p><span class="font2">[ 'B', [ 'C', [ 'D' ] ] ],</span></p>
<p><span class="font2">[ 'E', [ 'F' ], [ 'G' ] ],</span></p>
<p><span class="font2">[ 'H', [ 'I' ] ],</span></p>
<p><span class="font2">[ 'J' ]</span></p>
<ul style="list-style:none;"><li>
<h5><a name="bookmark176"></a><span class="font18">8.7 DATABASE-QUERY PARSING</span></h5></li></ul>
<p><span class="font17">In Chapter 4, we saw a simple database system, </span><span class="font2">FlatDB</span><span class="font17">, which supported the combination of simpler queries into more complex ones:</span></p>
<p><span class="font2">query_or($dbh-&gt;query('STATE', 'NY'), query_and($dbh-&gt;callbackquery(sub { my %F = @_; $F{OWES} &gt;&nbsp;100 }), $dbh-&gt;query('STATE', 'MA') ))</span></p>
<p><span class="font17">I promised that we would attach this to a parser so that we could simply write something like:</span></p>
<p><span class="font2">complex_query(&quot;STATE = 'NY' | OWES &gt;&nbsp;100 &amp;&nbsp;STATE = 'MA'&quot;)</span></p>
<p><span class="font17">and get the same result. The lexer will turn this example into the following tokens:</span></p>
<p><span class="font2">[FIELD, 'STATE']</span></p>
<p><span class="font2">[OP, ' = ']</span></p>
<p><span class="font2">[STRING, 'NY']</span></p>
<p><span class="font2">[OR]</span></p>
<p><span class="font2">[FIELD, 'OWES']</span></p>
<p><span class="font2">[OP, '&gt;']</span></p>
<p><span class="font2">[NUMBER, 100]</span></p>
<p><span class="font2">[AND]</span></p>
<p><span class="font2">[FIELD, 'STATE']</span></p>
<p><span class="font2">[OP, ' = ']</span></p>
<p><span class="font2">[STRING, 'MA']</span></p>
<ul style="list-style:none;"><li>
<h5><a name="bookmark177"></a><span class="font19">8.7.1 The Lexer</span></h5></li></ul>
<p><span class="font17">Here’s the lexer for our database query language. It has a few novel features:</span></p>
<div>
<p><span class="font9" style="font-weight:bold;">CODE LIBRARY</span></p>
</div><br clear="all">
<p><span class="font2">use Lexer ':all';</span></p>
<p><span class="font0">dqp.pl</span></p>
<p><span class="font2">sub lex_input {</span></p>
<p><span class="font2">my @input = @_;</span></p>
<p><span class="font2">my Sinput = sub { shift @input };</span></p>
<p><span class="font2">my Slexer = iterator_to_stream(</span></p>
<p><span class="font2">make_lexer(Sinput,</span></p>
<p><span class="font2">['STRING', qr/' (?: \\. | [“'] )*</span></p>
<div>
<p><span class="font2">|&quot; (?: \\. I [’&quot;] )*</span></p>
</div><br clear="all">
<div>
<p><span class="font2">/sx,</span></p>
</div><br clear="all">
<p><span class="font2">sub { my Ss = shift;</span></p>
<p><span class="font2">Ss =- s/.//; Ss =- s/.S//;</span></p>
<p><span class="font2">Ss =- s/\\(.)/S1/g;</span></p>
<p><a href="#bookmark419"><span class="font2">['STRING', Ss] }</span></a></p>
<p><a href="#bookmark420"><span class="font2">['FIELD', &nbsp;qr/[A-Z]+/</span></a></p>
<p><a href="#bookmark421"><span class="font2">['AND', &nbsp;&nbsp;&nbsp;qr/&amp;/</span></a></p>
<p><a href="#bookmark422"><span class="font2">['OR', &nbsp;&nbsp;&nbsp;&nbsp;qr/\|/</span></a></p>
<p><span class="font2">['OP', &nbsp;&nbsp;&nbsp;&nbsp;qr/[!&lt;&gt;=] = |[&lt;&gt;=]/,</span></p>
<p><span class="font2">sub { S_[0] =- s/~=S/==/;</span></p>
<p><a href="#bookmark423"><span class="font2">[ 'OP', S_[0] ] }</span></a></p>
<p><a href="#bookmark424"><span class="font2">['LPAREN', qr/[(]/</span></a></p>
<p><a href="#bookmark425"><span class="font2">['RPAREN', qr/[)]/</span></a></p>
<p><a href="#bookmark426"><span class="font2">['NUMBER', qr/\d+ (?:\.\d*)? | \.\d+/x</span></a></p>
<p><a href="#bookmark427"><span class="font2">['SPACE', &nbsp;qr/\s+/, sub { </span><span class="font2" style="font-style:italic;">&quot;&quot;</span><span class="font2">&nbsp;}</span></a></p>
<p><span class="font2">)</span></p>
<p><span class="font2">);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">Most of this is old hat. The exception is the first rule, which recognizes string constants, which have a fairly complicated lexical structure. First, we’ll look at the regex, which is in two parts, one for single-quoted strings and one for double-quoted strings. The two kinds of strings will have identical behavior in this language; we’re including them both only to suit the preferences of users for one or the other. The obvious regex to match a single-quoted string is </span><span class="font2">/' .* '/x</span><span class="font17">, but a little thought shows this isn’t correct, since it will match </span><span class="font2">'O'Reilly'</span><span class="font17">, which is syntactically incorrect. Really, the characters inside the quotes are forbidden to be quotes themselves, so we want </span><span class="font2">/' [&quot;']* '/x</span><span class="font17">. But now there’s no way to write a string that contains a single-quote character, so we introduce backslash escapes. If a backslash appears inside a single-quoted string, the following character is</span></p>
<p><span class="font20">450 </span><span class="font15">CHAPTER 8 Parsing</span></p>
<p><span class="font17">accepted unconditionally, whether or not it’s a quote. The pattern becomes </span><span class="font2">/'(?: \\. I I&quot;'])* '/sx</span><span class="font17">. (The </span><span class="font2">/s </span><span class="font17">tells the regex engine that it is acceptable for the . character to match a newline; normally it won’t.) The corresponding pattern for double-quoted strings is similar.</span></p>
<p><span class="font17">The default method for building a token from a quoted string isn’t exactly what we want, because the input </span><span class="font2">'O\'Reilly' </span><span class="font17">represents the string </span><span class="font2">O'Reilly</span><span class="font17">, not </span><span class="font2">O\'Reilly</span><span class="font17">. So the </span><span class="font2">STRING </span><span class="font17">rule makes use of a feature we haven’t used much yet, which is the option to specify a token-manufacturing function to replace the default:</span></p>
<p><span class="font2">sub { my $s = shift;</span></p>
<p><span class="font2">$s =- s/.//; $s =- s/.$//;</span></p>
<p><span class="font2">$s =- s/\\(.)/$1/g;</span></p>
<p><span class="font2">['STRING', $s] }</span></p>
<p><span class="font17">The token-manufacturing function trims off the leading and trailing quotation marks, and then expands the backslash escapes. If we wanted to support more backslash escapes, such as </span><span class="font2">\t </span><span class="font17">for a tab character, this would be the place to do it:</span></p>
<p><span class="font2">sub { my $s = shift;</span></p>
<p><span class="font2">$s =- s/.//; $s =- s/.$//;</span></p>
<p><span class="font2" style="font-weight:bold;">$s =</span><span class="font2">- </span><span class="font2" style="font-weight:bold;">s/</span><span class="font2">\\</span><span class="font2" style="font-weight:bold;">t/</span><span class="font2">\</span><span class="font2" style="font-weight:bold;">t/g;</span></p>
<p><span class="font2">$s =- s/\\(.)/$1/g;</span></p>
<p><span class="font2">['STRING', $s] }</span></p>
<p><span class="font17">Note that once a </span><span class="font2">STRING </span><span class="font17">token comes out of the lexer, the parser won’t be able to tell whether it was originally a single-quoted string or a double-quoted string. Since the two kinds of strings have the same semantics, that’s just what we want; there’s no reason for the parser to concern itself with this irrelevant distinction.</span></p>
<p><span class="font17">This kind of behavior is typical of lexers. The lexer’s job is to convert the incoming sequence of characters into meaningful tokens, and if two incoming sequences have the same meaning, they should turn into the same tokens. The Perl lexer does the same thing; by the time the parser gets hold of the input:</span></p>
<p><span class="font2">$a = &quot;O'Reilly&quot;;</span></p>
<p><span class="font17">it can’t tell that the input wasn’t originally:</span></p>
<p><span class="font2">$a = 'O\'Reilly';</span></p>
<p><span class="font15">8.7 D AT A B A S E - QU E R Y PARSING</span></p>
<div>
<p><span class="font20">451</span></p>
</div><br clear="all">
<p><span class="font17">instead, or:</span></p>
<p><span class="font2">Sa = qq{\x4f\47\x52\x65\151\x6c\x6c\171};</span></p>
<p><span class="font17">for that matter. Similarly, the Perl lexer absorbs the two keywords </span><span class="font2">for </span><span class="font17">and </span><span class="font2">foreach</span><span class="font17">, which are identical, and grinds both of them down to identical </span><span class="font2">OPERATOR(FOR) </span><span class="font17">tokens. By the time the parser gets the input, it doesn’t know which one you wrote. We saw another example of this earlier, when the lexer for our calculator treated </span><span class="font2">/;\n*/ </span><span class="font17">and </span><span class="font2">/\n+/ </span><span class="font17">as the same kind of token.</span></p>
<p><span class="font17">The only other lexer rule that’s a little different from those we’ve seen before is </span><span class="font2">OP</span><span class="font17">, the rule for matching operators. An operator is one of the following:</span></p>
<p><span class="font2">!=&lt;=&gt;= ==</span></p>
<p><span class="font2">== </span><span class="font17">and </span><span class="font2">= </span><span class="font17">are considered the same; we’re including both forms as a convenience for the user. The token-manufacturing function transforms </span><span class="font2">= </span><span class="font17">to </span><span class="font2">==</span><span class="font17">, again eliminating a distinction that is of no concern to the parser.</span></p>
<ul style="list-style:none;"><li>
<h5><a name="bookmark178"></a><span class="font19">8.7.2 The Parser</span></h5></li></ul>
<p><span class="font17">The grammar for the query language is simple, and doesn’t contain anything new: </span><span class="font2">complex_query ^ term star('OR' complex_query)</span></p>
<p><span class="font2">term ^ simple_query star('AND' term)</span></p>
<p><span class="font2">simple_query ^ 'FIELD' 'OP' 'STRING'</span></p>
<p><span class="font2">simple_query ^ 'FIELD' 'OP' 'NUMBER'</span></p>
<p><span class="font2">simple_query ^ 'LPAREN' complex_query 'RPAREN'</span></p>
<p><span class="font17">The code for </span><span class="font17" style="font-style:italic;">complex_query</span><span class="font17"> and </span><span class="font17" style="font-style:italic;">term</span><span class="font17"> is completely handled by the </span><span class="font2">operator() </span><span class="font17">function we wrote in Section 8.4:</span></p>
<p><span class="font2">use Parser ':all';</span></p>
<p><span class="font2">use FlatDB_Composable qw(query_or query_and);</span></p>
<p><span class="font2">my (Scquery, Ssquery, Sterm);</span></p>
<p><span class="font2">my SCQuery = parser { Scquery-&gt;(@_) };</span></p>
<p><span class="font2">my SSQuery = parser { Ssquery-&gt;(@_) };</span></p>
<p><span class="font2">my STerm = parser { Sterm-&gt;(@_) };</span></p>
<div>
<p><span class="font20">452</span></p>
</div><br clear="all">
<p><span class="font15">CHAPTER 8 Parsing</span></p>
<p><span class="font2">use FlatDB;</span></p>
<p><span class="font2">Scquery = operator(STerm, [lookfor('OR'), \&amp;query_or]);</span></p>
<p><span class="font2">Sterm = operator($SQuery, [lookfor('AND'), \&amp;query_and]);</span></p>
<p><span class="font17">The code for </span><span class="font2">simple_query() </span><span class="font17">is more interesting, because it is the main interface with the flat database library.</span></p>
<p><span class="font17">Recall that there are three productions for </span><span class="font17" style="font-style:italic;">simple_query:</span></p>
<p><span class="font2">simple_query ^ 'FIELD' 'OP' 'STRING' simple_query ^ 'FIELD' 'OP' 'NUMBER' simple_query ^ 'LPAREN' complex_query 'RPAREN'</span></p>
<h6><a name="bookmark428"></a><span class="font17">The third of these is just like several other parsers that we’ve seen before:</span></h6>
<ul style="list-style:none;"><li>
<p><span class="font2"># This needs to be up here so that the following Ssquery</span></p></li>
<li>
<p><span class="font2"># definition can see Sparser_dbh</span></p></li></ul>
<p><span class="font2">my Sparser_dbh;</span></p>
<p><span class="font2">sub set_parser_dbh { Sparser_dbh = shift }</span></p>
<p><span class="font2">sub parser_dbh { Sparser_dbh }</span></p>
<p><span class="font2">Ssquery = alternate(</span></p>
<p><span class="font2">T(concatenate(lookfor('LPAREN'),</span></p>
<p><span class="font2">SCQuery,</span></p>
<p><span class="font2">lookfor('RPAREN'),</span></p>
<p><span class="font2">),</span></p>
<p><span class="font2">sub { $_[1] }),</span></p>
<p><span class="font17">The first two are separate productions because they have different meanings. </span><span class="font2">&quot;STATE = 'NY'&quot; </span><span class="font17">is quite different from </span><span class="font2">&quot;AMOUNT = 0&quot;</span><span class="font17">, because the </span><span class="font2">query() </span><span class="font17">method can be used for the first query but not for the second — recall that </span><span class="font2">query() </span><span class="font17">always uses </span><span class="font2">eq </span><span class="font17">to detect matches. Because the </span><span class="font2">FIELD OP NUMBER </span><span class="font17">production must always use </span><span class="font2">callbackquery()</span><span class="font17">, never </span><span class="font2">query()</span><span class="font17">, it’s a little simpler and we’ll see it first:</span></p>
<p><span class="font2">T(concatenate(lookfor('FIELD'),</span></p>
<p><span class="font2">lookfor('OP'),</span></p>
<p><span class="font2">lookfor('NUMBER')),</span></p>
<p><span class="font2">sub {</span></p>
<p><span class="font2">my (Sfield, Sop, Sval) = @_;</span></p>
<p><span class="font2">my Scmp_code = 'sub { S_[0] OP S_[1] }';</span></p>
<p><span class="font2">$cmp_code =- s/OP/$op/;</span></p>
<p><span class="font2">my $cmp = eval($cmp_code) or die;</span></p>
<p><span class="font2">my $cb = sub { my %F = @_;</span></p>
<p><span class="font2">$cmp-&gt;($F{$field}, $val)};</span></p>
<p><span class="font2">$parser_dbh-&gt;callbackquery($cb);</span></p>
<p><span class="font2">}),</span></p>
<p><span class="font17">The callback for the callback query is </span><span class="font2">$cb. $cb </span><span class="font17">sets up a hash </span><span class="font2">%F </span><span class="font17">that maps field names to values, indexes </span><span class="font2">%F </span><span class="font17">to get the value of the appropriate field, and compares the field value with the specified number </span><span class="font2">$val</span><span class="font17">. When </span><span class="font2">$op </span><span class="font17">is </span><span class="font2">==</span><span class="font17">, the comparison needs to be </span><span class="font2">$F{$field} == $val</span><span class="font17">; when </span><span class="font2">$op </span><span class="font17">is </span><span class="font2">&lt;=</span><span class="font17">, the comparison needs to be </span><span class="font2">$F{$field} &lt;= $val</span><span class="font17">, and so on. There are essentially two ways to do this. One way is to select a function that performs the comparison from a dispatch table:</span></p>
<table border="1">
<tr><td>
<p><span class="font2">%compare = ('=='</span></p></td><td>
<p><span class="font2">=&gt; sub</span></p></td><td>
<p><span class="font2">{</span></p></td><td>
<p><span class="font2">my</span></p></td><td>
<p><span class="font2">%F</span></p></td><td>
<p><span class="font2">= @_;</span></p></td><td>
<p><span class="font2">$F{$field}</span></p></td><td>
<p><span class="font2">== $val</span></p></td><td>
<p><span class="font2">},</span></p></td></tr>
<tr><td style="vertical-align:bottom;">
<p><span class="font2">'&lt;='</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">=&gt; sub</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">{</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">my</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">%F</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">= @_;</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">$F{$field}</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">&lt;= $val</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">},</span></p></td></tr>
<tr><td style="vertical-align:bottom;">
<p><span class="font2">'&lt;'</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">=&gt; sub</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">{</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">my</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">%F</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">= @_;</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">$F{$field}</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">&lt; $val</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">},</span></p></td></tr>
<tr><td style="vertical-align:bottom;">
<p><span class="font2">'&gt;='</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">=&gt; sub</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">{</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">my</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">%F</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">= @_;</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">$F{$field}</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">&gt;= $val</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">},</span></p></td></tr>
<tr><td style="vertical-align:bottom;">
<p><span class="font2">'&gt;'</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">=&gt; sub</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">{</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">my</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">%F</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">= @_;</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">$F{$field}</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">&gt; $val</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">},</span></p></td></tr>
<tr><td style="vertical-align:bottom;">
<p><span class="font2">'! = '</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">=&gt; sub</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">{</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">my</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">%F</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">= @_;</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">$F{$field}</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">!= $val</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">},</span></p></td></tr>
</table>
<p><span class="font2">);</span></p>
<p><span class="font2">my $cb = $compare{$op};</span></p>
<p><span class="font17">This technique requires the construction of six anonymous functions, from which we select one to use and discard the other five. The other technique is to generate the desired code by textual substitution at run time; this is what the preceding implementation does. The code for a comparison function is manufactured by replacing </span><span class="font2">OP </span><span class="font17">in </span><span class="font2">sub { $_[0] OP $_[1] } </span><span class="font17">with the actual value of </span><span class="font2">$op</span><span class="font17">, and then using </span><span class="font2">eval </span><span class="font17">to compile the resulting string. </span><span class="font2">$cb </span><span class="font17">then calls the resulting function to actually compare the values. With the </span><span class="font2">eval </span><span class="font17">approach we run the risk of accidentally generating syntactically incorrect code; building Perl code is always fraught with peril because Perl’s syntax is so irregular. I chose the </span><span class="font2">eval </span><span class="font17">approach because the peril seemed small in this case, because the code was smaller, and because I didn’t like the idea of manufacturing six functions on every call just to throw five of them away.<a name="footnote36"></a><sup><a href="#bookmark429">36</a></sup><sup></sup></span></p>
<div>
<h4><a name="bookmark430"></a><span class="font20">454</span></h4>
</div><br clear="all">
<div>
<p><span class="font15">CHAPTER 8 Parsing</span></p>
</div><br clear="all">
<p><span class="font17">The </span><span class="font2">$parser_dbh </span><span class="font17">variable in the final line is a bit of a puzzle. </span><span class="font2">callbackquery() </span><span class="font17">is a method, that is called on a database handle object. In order to perform a </span><span class="font2">callbackquery()</span><span class="font17">, the parser needs to know which database to query.</span></p>
<p><span class="font17">The cleanest way to accomplish this might be to provide each parser with a user-parameter argument, which it would then pass to its sub-parsers. Then we would supply the desired database handle to the top-level parser, and it would percolate down to the </span><span class="font2">T() </span><span class="font17">function in </span><span class="font2">simple_query()</span><span class="font17">, which would use it as the target object of the </span><span class="font2">callbackquery() </span><span class="font17">method. Unfortunately, this would require redesigning all our parser-generation functions to accommodate a new argument format. At present, the argument convention for </span><span class="font2">alternate() </span><span class="font17">and </span><span class="font2">concatenate() </span><span class="font17">is utterly simple and straightforward: You just pass in the parsers you want to alternate or concatenate. If a user-parameter argument were allowed, it would have to be distinguished specially somehow. The </span><span class="font2">alternate() </span><span class="font17">and </span><span class="font2">concatenate() </span><span class="font17">functions wouldn’t be able to recognize a user argument just by looking at it, the way they recognized the debugging labels of Section 8.4, because a user argument might have any value at all.</span></p>
<p><span class="font17">There’s an alternative that is preferable in this case. In Chapter 2, we saw how to use user parameters to avoid having to communicate with callbacks via global variables. Now we’re going to turn around and use a global variable anyway. But our “global” variable, </span><span class="font2">$parser_dbh</span><span class="font17">, won’t be truly global. It will actually be a lexical variable whose scope includes the parser-callback functions. To use the parser, the caller will first set </span><span class="font2">$parser_dbh</span><span class="font17">, then invoke the top-level parser. To avoid requiring that the caller also be in the scope of </span><span class="font2">$parser_dbh</span><span class="font17">, we’ll provide a setter function that has access to it:</span></p>
<p><span class="font2">my $parser_dbh;</span></p>
<p><span class="font2">sub set_parser_dbh { $parser_dbh = shift } sub parser_dbh { $parser_dbh }</span></p>
<p><span class="font2">Ssquery = alternate(...</span></p>
<p><span class="font2">... $parser_dbh-&gt;callbackquery($cb) ...</span></p>
<p><span class="font2">);</span></p>
<p><span class="font17">The big drawback of </span><span class="font17" style="font-style:italic;">this</span><span class="font17"> approach is that the parser can’t change databases in the middle of a parse without saving </span><span class="font2">$parser_dbh </span><span class="font17">before and restoring it after. For our examples, this isn’t important, but it means that we can’t easily support queries on more than one database at a time.</span></p>
<p><span class="font17">With all that out of the way, here’s the third production for </span><span class="font17" style="font-style:italic;">simple_query:</span></p>
<p><span class="font2">T(concatenate(lookfor('FIELD'),</span></p>
<p><span class="font2">lookfor('OP'),</span></p>
<p><span class="font15">8.7 D AT A B A S E - QU E R Y PARSING</span></p>
<div>
<p><span class="font20">455</span></p>
</div><br clear="all">
<p><span class="font2">lookfor('STRING')),</span></p>
<p><span class="font2">sub {</span></p>
<p><span class="font2">if ($_[1] eq '==') {</span></p>
<p><span class="font2">Sparser_dbh-&gt;query(S_[0], S_[2]);</span></p>
<p><span class="font2">} else {</span></p>
<p><span class="font2">my (Sfield, $op, Sval) = @_;</span></p>
<p><span class="font2">my Scmp_code = 'sub { S_[0] OP S_[1] }';</span></p>
<p><span class="font2">Scmp_code =- s/OP/Sstring_version{Sop}/;</span></p>
<p><span class="font2">my Scmp = eval(Scmp_code) or die;</span></p>
<p><span class="font2">my Scb = sub { my %F = @_;</span></p>
<p><span class="font2">Scmp-&gt;(SF{Sfield}, Sval)};</span></p>
<p><span class="font2">Sparser_dbh-&gt;callbackquery(Scb);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}),</span></p>
<p><span class="font2">);</span></p>
<p><span class="font17">There are only two differences between this and the production for numeric comparison. First, there’s a special case for when </span><span class="font2">Sop </span><span class="font17">is </span><span class="font2">==</span><span class="font17">. In this case, instead of using the slower and more general </span><span class="font2">callbackquery() </span><span class="font17">to perform the query, we use the simpler and faster </span><span class="font2">query()</span><span class="font17">, which is hardwired to do a string-equality test. Second, in the other cases, when we do use </span><span class="font2">callbackquery()</span><span class="font17">, instead of replacing </span><span class="font2">OP </span><span class="font17">with </span><span class="font2">Sop </span><span class="font17">in the comparison function for the callback, we must replace </span><span class="font2">OP </span><span class="font17">with the string version of </span><span class="font2">Sop — </span><span class="font17">if </span><span class="font2">Sop </span><span class="font17">is </span><span class="font2">&lt;=</span><span class="font17">, the string version is </span><span class="font2">le</span><span class="font17">, and so on. String versions are provided by a simple hash table:</span></p>
<p><span class="font2">my %string_version = ('&gt;' =&gt; 'gt', '&gt;=' =&gt; 'ge', '==' =&gt; 'eq', '&lt;' =&gt; 'lt', '&lt;=' =&gt; 'le', '!=' =&gt; 'ne');</span></p>
<h6><a name="bookmark431"></a><span class="font17">We need one last function to serve as an entry point from programs that want to use our parser:</span></h6>
<p><span class="font2">package FlatDB::Parser;</span></p>
<p><span class="font2">use base FlatDB_Composable;</span></p>
<p><span class="font2">sub parse_query {</span></p>
<p><span class="font2">my Sself = shift;</span></p>
<p><span class="font2">my Squery = shift;</span></p>
<p><span class="font2">my Slexer = main::lex_input(Squery);</span></p>
<p><span class="font2">my Sold_parser_dbh = main::parser_dbh();</span></p>
<p><span class="font2">main::set_parser_dbh(Sself);</span></p>
<p><span class="font2">my (Sresult) = Scquery-&gt;(Slexer); main::set_parser_dbh(Sold_parser_dbh); return Sresult;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">Our parser for database queries is now complete.</span></p>
<ul style="list-style:none;"><li>
<h5><a name="bookmark179"></a><span class="font18">8.8 BACKTRACKING PARSERS</span></h5></li></ul>
<p><span class="font17">The parser technique we’ve seen so far has a serious problem: It doesn’t always work. Here’s a contrived but very simple example:</span></p>
<p><span class="font2">S ^ A B | B c c</span></p>
<p><span class="font2">A ^ a a | a</span></p>
<p><span class="font2">B ^ a b c | a b</span></p>
<p><span class="font17">Now consider the sentence </span><span class="font2">a a b c</span><span class="font17">. </span><span class="font17" style="font-style:italic;">S</span><span class="font17"> will try the first alternative, </span><span class="font17" style="font-style:italic;">AB. A</span><span class="font17"> will try its first alternative, </span><span class="font2">a a</span><span class="font17">, which will succeed. Then </span><span class="font17" style="font-style:italic;">B</span><span class="font17"> will try both of its alternatives, each of which will fail, because they begin with </span><span class="font2">a </span><span class="font17">and the remaining input is </span><span class="font2">b c</span><span class="font17">. </span><span class="font17" style="font-style:italic;">B</span><span class="font17"> will report failure, and so </span><span class="font17" style="font-style:italic;">AB</span><span class="font17"> will fail. </span><span class="font17" style="font-style:italic;">S</span><span class="font17"> will then try its second alternative, </span><span class="font17" style="font-style:italic;">B</span><span class="font2"> c c</span><span class="font17">, which will also fail, because the input doesn’t end with </span><span class="font2">c c</span><span class="font17">.</span></p>
<p><span class="font17">But the grammar </span><span class="font17" style="font-style:italic;">does</span><span class="font17"> generate the string </span><span class="font2">a a b c</span><span class="font17">, by the derivation:</span></p>
<p><span class="font2">S</span></p>
<p><a href="#bookmark432"><span class="font2">AB &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# S clause</span></a></p>
<p><a href="#bookmark433"><span class="font2">a B &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# A clause</span></a></p>
<p><a href="#bookmark434"><span class="font2">a a b c &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# B clause</span></a></p>
<p><span class="font17">Why didn’t the parser find the answer? The problem is that after the first alternative for</span><span class="font17" style="font-style:italic;">A</span><span class="font17"> succeeded, the rest of the parse failed. The parser should have tried the second alternative for </span><span class="font17" style="font-style:italic;">A</span><span class="font17">, since it would have led to success. But that’s not how our </span><span class="font2">alternate() </span><span class="font17">function works. Once it commits to an alternative, it’s too late for it to come back and try something else. The chosen alternative looked good in the short term. </span><span class="font2">alternate() </span><span class="font17">had no way to find out that its choice turned out bad in the long run, and that the parser called after it failed.</span></p>
<p><span class="font17">We’ve seen a number of useful parser examples already, and this problem didn’t come up; often it doesn’t. But what do we need to do if it does come up?</span></p>
<p><span class="font17">The </span><span class="font2">alternate() </span><span class="font17">parser can’t assume success just because one or another of its alternatives succeeds. It would need to find out if the following parsing succeeded too. If so, then fine; if not, it would need to try another alternative.</span></p>
<div>
<p><span class="font15">8.8 BACKTRACKING PARSERS</span></p>
</div><br clear="all">
<div>
<h4><a name="bookmark435"></a><span class="font20">457</span></h4>
</div><br clear="all">
<ul style="list-style:none;"><li>
<h5><a name="bookmark180"></a><span class="font19">8.8.1 Continuations</span></h5></li></ul>
<p><span class="font17">How can </span><span class="font2">alternate() </span><span class="font17">find out if the rest of the parse succeeded? It would need to invoke a parser for the entire rest of the input. We’ll pass it one in its argument list.</span></p>
<p><span class="font17">We’ll make each parser responsible for completing the entire parse. Parsers formerly handled a bit of input and then returned. Now they’ll get an extra argument, called a </span><span class="font17" style="font-style:italic;">continuation,</span><span class="font17"> for parsing the rest of the input after the bit that they’ve handled themselves. A parser will look for whatever it normally looks for, and if it is successful, it will invoke the continuation on the rest of the input, returning success if and only if the continuation succeeds.</span></p>
<p><span class="font17">In the preceding example, </span><span class="font17" style="font-style:italic;">B</span><span class="font17"> is the continuation of </span><span class="font17" style="font-style:italic;">A. A</span><span class="font17"> will try the first alternative, </span><span class="font2">a a</span><span class="font17">, which will succeed. </span><span class="font17" style="font-style:italic;">A</span><span class="font17"> will then try its continuation, </span><span class="font17" style="font-style:italic;">B</span><span class="font17">, on the remaining input, </span><span class="font2">b c</span><span class="font17">; this will fail. So </span><span class="font17" style="font-style:italic;">A</span><span class="font17"> will know that even though </span><span class="font2">a a </span><span class="font17">looked good, it ultimately fails, and is incorrect. </span><span class="font17" style="font-style:italic;">A</span><span class="font17"> will then try the second alternative, </span><span class="font2">a</span><span class="font17">, which will also succeed, so </span><span class="font17" style="font-style:italic;">A</span><span class="font17"> will try the continuation again, this time on the remaining input </span><span class="font2">a b c</span><span class="font17">. </span><span class="font17" style="font-style:italic;">B</span><span class="font17"> will succeed this time, so </span><span class="font17" style="font-style:italic;">A</span><span class="font17"> will report success, having selected the second alternative rather than the first.</span></p>
<p><span class="font17">With this structure, parsers no longer need to return the unused portion of the input. Instead, they’ll pass the unused portion to the continuation. Formerly, parsers got one argument, which was the input stream, and returned two results, which were the calculated value and the remaining input stream. Parsers now get two arguments, which are the input stream and the continuation, and return one result, which is the calculated value.</span></p>
<p><span class="font17">Here’s the rewrite of </span><span class="font2">alternate() </span><span class="font17">to handle continuation arguments:</span></p>
<p><span class="font2">sub alternate {</span></p>
<div>
<p><span class="font9" style="font-weight:bold;">CODE LIBRARY</span></p>
</div><br clear="all">
<div>
<p><span class="font0">alternate-cont</span></p>
</div><br clear="all">
<p><span class="font2">my @p = @_;</span></p>
<p><span class="font2">return parser { return () } if @p == 0;</span></p>
<p><span class="font2">return $p[0] &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if @p == 1;</span></p>
<p><span class="font2">my $p;</span></p>
<p><span class="font2">$p = parser {</span></p>
<p><span class="font2">my ($input, $continuation) = @_;</span></p>
<p><span class="font2">for (@p) {</span></p>
<p><span class="font2">if (my ($v) = $_-&gt;($input, $continuation)) { return $v;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">return; # Failure</span></p>
<p><span class="font2">};</span></p>
<p><span class="font2">$N{$p} = &quot;(&quot; . join(&quot; | &quot;, map $N{$_}, @p) . &quot;)&quot;;</span></p>
<p><span class="font2">return $p;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">Sp </span><span class="font17">tries the alternatives (the elements of </span><span class="font2">@p</span><span class="font17">) in order. When one leads to a complete successful parse, the resulting value is returned. If an alternative fails, </span><span class="font2">Sp </span><span class="font17">tries the next alternative.</span></p>
<p><span class="font17">Note that </span><span class="font2">Sp </span><span class="font17">doesn’t have to invoke the continuation itself. It just passes the continuation to the chosen alternative; the chosen alternative will take care of invoking the continuation if it succeeds.</span></p>
<p><span class="font17">Who actually invokes the continuation? Parsers generated by </span><span class="font2">lookfor() </span><span class="font17">invoke the continuation:</span></p>
<div>
<p><span class="font9" style="font-weight:bold;">CODE LIBRARY</span></p>
</div><br clear="all">
<p><span class="font2">sub lookfor {</span></p>
<div>
<p><span class="font0">lookfor-cont</span></p>
</div><br clear="all">
<p><span class="font2">my Swanted = shift;</span></p>
<p><span class="font2">my Svalue = shift || sub { S_[0] };</span></p>
<p><span class="font2">my Su = shift;</span></p>
<p><span class="font2">Swanted = [Swanted] unless ref Swanted;</span></p>
<p><span class="font2">my Sparser = parser {</span></p>
<p><span class="font2" style="font-weight:bold;">my (Sinput, Scontinuation) = @_;</span></p>
<p><span class="font2">return unless defined Sinput;</span></p>
<p><span class="font2">my Snext = head(Sinput);</span></p>
<p><span class="font2">for my Si (0 .. S#Swanted) {</span></p>
<p><span class="font2">next unless defined Swanted-&gt;[Si];</span></p>
<p><span class="font2">return unless Swanted-&gt;[Si] eq Snext-&gt;[Si]; }</span></p>
<p><span class="font2">my Swanted_value = Svalue-&gt;(Snext, Su);</span></p>
<p><span class="font2" style="font-weight:bold;"># Try continuation</span></p>
<p><span class="font2" style="font-weight:bold;">if (my (Sv) = Scontinuation-&gt;(tail(Sinput))) {</span></p>
<p><span class="font2" style="font-weight:bold;">return Swanted_value;</span></p>
<p><span class="font2" style="font-weight:bold;">} else {</span></p>
<p><span class="font2" style="font-weight:bold;">return;</span></p>
<p><span class="font2" style="font-weight:bold;">}</span></p>
<p><span class="font2">};</span></p>
<p><span class="font2">SN{Sparser} = &quot;[@Swanted]&quot;;</span></p>
<p><span class="font2">return Sparser;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">The process of checking the next token to see if it’s what was expected is exactly the same, and, as before, if this fails, then the parser fails and returns false. But if it succeeds, the </span><span class="font2">lookfor() </span><span class="font17">parser doesn’t immediately return success. Instead, it</span></p>
<div>
<p><span class="font15">8.8 BACKTRACKING PARSERS</span></p>
</div><br clear="all">
<div>
<h4><a name="bookmark436"></a><span class="font20">459</span></h4>
</div><br clear="all">
<div>
<p><span class="font17">invokes the continuation to try to parse the rest of the input. It returns success only if the continuation succeeds as well.</span></p>
<p><span class="font17">The null parser is still simple. It does nothing, passing the buck to the continuation. If the continuation succeeds, </span><span class="font2">nothing() </span><span class="font17">is happy; if not, </span><span class="font2">nothing() </span><span class="font17">reports the failure to its caller:</span></p>
</div><br clear="all">
<div>
<p><span class="font2">sub nothing {</span></p>
<p><span class="font2">my (Sinput, Scontinuation) = @_;</span></p>
<p><span class="font2">return Scontinuation-&gt;(Sinput);</span></p>
<p><span class="font2">}</span></p>
</div><br clear="all">
<div>
<p><span class="font9" style="font-weight:bold;">CODE LIBRARY</span></p>
</div><br clear="all">
<div>
<p><span class="font0">nothing-continuation</span></p>
</div><br clear="all">
<div>
<p><span class="font17">The </span><span class="font2">End_of_Input() </span><span class="font17">parser doesn’t change at all. It doesn’t even get a continuation, because there’s nothing left to do after </span><span class="font2">End_of_Input() </span><span class="font17">is finished. It just checks to make sure that the input is exhausted, succeeding if it is.</span></p>
<p><span class="font2">concatenate() </span><span class="font17">is a little trickier. Suppose we have:</span></p>
</div><br clear="all">
<div>
<p><span class="font2">S -&gt; Z blah de blah</span></p>
<p><span class="font2">Z -&gt; A B</span></p>
</div><br clear="all">
<div>
<p><span class="font17">Here </span><span class="font17" style="font-style:italic;">Z</span><span class="font17"> is the concatenation of </span><span class="font17" style="font-style:italic;">A</span><span class="font17"> and </span><span class="font17" style="font-style:italic;">B;</span><span class="font17"> the continuation of </span><span class="font17" style="font-style:italic;">Z</span><span class="font17"> is a parser for </span><span class="font2">blah de blah</span><span class="font17">. What does </span><span class="font17" style="font-style:italic;">Z</span><span class="font17">do?</span></p>
<p><span class="font17">Clearly, the first thing it needs to do is to invoke the parser for </span><span class="font17" style="font-style:italic;">A</span><span class="font17">. But what is the continuation for </span><span class="font17" style="font-style:italic;">A</span><span class="font17">? It’s </span><span class="font17" style="font-style:italic;">B</span><span class="font17">, followed by </span><span class="font2">blah de blah</span><span class="font17">. So the continuation for </span><span class="font17" style="font-style:italic;">A</span><span class="font17"> is a parser that invokes </span><span class="font17" style="font-style:italic;">B</span><span class="font17"> with </span><span class="font2">blah de blah </span><span class="font17">as </span><span class="font17" style="font-style:italic;">its</span><span class="font17"> continuation. The code may make this clearer:</span></p>
</div><br clear="all">
<div>
<p><span class="font2">sub concatenate? {</span></p>
<p><span class="font2">my (SA, SB) = @_;</span></p>
<p><span class="font2">my Sp;</span></p>
<p><span class="font2">Sp = parser {</span></p>
<p><span class="font2">my (Sinput, Scontinuation) = @_;</span></p>
<p><span class="font2">my (Saval, Sbval);</span></p>
<p><span class="font2">my SBC = parser {</span></p>
<p><span class="font2">my (Snewinput) = @_;</span></p>
<p><span class="font2">return unless (Sbval) = SB-&gt;(Snewinput, Scontinuation);</span></p>
<p><span class="font2">};</span></p>
<p><span class="font2">SN{SBC} = &quot;SN{SB} SN{Scontinuation}&quot;;</span></p>
<p><span class="font2">if ((Saval) = SA-&gt;(Sinput, SBC)) {</span></p>
<p><span class="font2">return ([Saval, Sbval]);</span></p>
<p><span class="font2">} else {</span></p>
<p><span class="font2">return;</span></p>
</div><br clear="all">
<div>
<p><span class="font9" style="font-weight:bold;">CODE LIBRARY</span></p>
</div><br clear="all">
<div>
<p><span class="font0">concatenate2-cont</span></p>
</div><br clear="all">
<div>
<h4><a name="bookmark437"></a><span class="font20">460</span></h4>
</div><br clear="all">
<div>
<p><span class="font15">CHAPTER 8 Parsing</span></p>
</div><br clear="all">
<p><span class="font2">}</span></p>
<p><span class="font2">};</span></p>
<p><span class="font2">$N{$p} = &quot;SN{SA} SN{SB}&quot;;</span></p>
<p><span class="font2">return Sp;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">The parser for </span><span class="font17" style="font-style:italic;">A B</span><span class="font17"> gets a continuation, which is a parser for </span><span class="font2">blah de blah</span><span class="font17">. It builds a new parser, </span><span class="font2">SBC</span><span class="font17">, which invokes </span><span class="font17" style="font-style:italic;">B</span><span class="font17">, telling </span><span class="font17" style="font-style:italic;">B</span><span class="font17"> that it is followed by </span><span class="font2">blah de blah</span><span class="font17">. It then invokes </span><span class="font17" style="font-style:italic;">A</span><span class="font17">, giving it the continuation </span><span class="font2">SBC</span><span class="font17">. If both </span><span class="font17" style="font-style:italic;">A</span><span class="font17"> and </span><span class="font17" style="font-style:italic;">B</span><span class="font17"> succeed, it packages the two values into an array and returns the array.</span></p>
<p><span class="font17">This concatenates only two parsers. To concatenate more than two, we call </span><span class="font2">concatenate2() </span><span class="font17">repeatedly:</span></p>
<div>
<p><span class="font9" style="font-weight:bold;">CODE LIBRARY</span></p>
</div><br clear="all">
<div>
<p><span class="font0">concatenate-cont</span></p>
</div><br clear="all">
<p><span class="font2">sub concatenate { my (@p) = @_; return \&amp;nothing if @p == 0; my Sp0 = shift @p;</span></p>
<p><span class="font2">return concatenate2(Sp0, concatenate(@p));</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">T() </span><span class="font17">doesn’t change significantly. The parser it builds expects a continuation argument, which it passes along:</span></p>
<div>
<p><span class="font9" style="font-weight:bold;">CODE LIBRARY</span></p>
</div><br clear="all">
<div>
<p><span class="font0">T-continuation</span></p>
</div><br clear="all">
<p><span class="font2">sub T { my (Sparser, Stransform) = @_; my Sp = sub {</span></p>
<p><span class="font2">my (Sinput, Scontinuation) = @_;</span></p>
<p><span class="font2">if (my Sv = Sparser-&gt;(Sinput, Scontinuation)) { Sv = Stransform-&gt;(@Sv);</span></p>
<p><span class="font2">return Sv;</span></p>
<p><span class="font2">} else { return;</span></p>
<p><span class="font2">} };</span></p>
<p><span class="font2">SN{Sp} = SN{Sparser}; return Sp;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">There’s one final detail: Where does the first continuation come from? This is almost the simplest part of the whole operation. Say the top-level symbol is </span><span class="font17" style="font-style:italic;">S</span><span class="font17">.</span></p>
<div>
<p><span class="font15">8.8 BACKTRACKING PARSERS</span></p>
</div><br clear="all">
<div>
<h4><a name="bookmark438"></a><span class="font20">461</span></h4>
</div><br clear="all">
<p><span class="font17">Like all parsers, the parser </span><span class="font17" style="font-style:italic;">S</span><span class="font17"> expects two arguments: the upcoming input, and the continuation parser. The upcoming input, of course, is the entire input. The continuation of </span><span class="font17" style="font-style:italic;">S</span><span class="font17"> is simply the </span><span class="font2">End_of_Input() </span><span class="font17">parser.</span></p>
<p><span class="font17">With these changes, the parser from the beginning of the section succeeds:</span></p>
<p><span class="font2">SS = alternate(concatenate(SA, SB), concatenate(SB, lookfor('c'), lookfor('c')));</span></p>
<p><span class="font2">my Sresults = SS-&gt;(Sinput, \&amp;End_of_Input);</span></p>
<p><span class="font2">Sresults </span><span class="font17">is assigned a value representing the correct parse, </span><span class="font17" style="font-style:italic;">S</span><span class="font3"> ^ </span><span class="font17" style="font-style:italic;">AB ^</span><span class="font2"> a </span><span class="font17" style="font-style:italic;">B ^ </span><span class="font2">a a b c</span><span class="font17">.</span></p>
<ul style="list-style:none;"><li>
<h5><a name="bookmark181"></a><span class="font19">8.8.2 Parse Streams</span></h5></li></ul>
<p><span class="font17">We introduced continuations to solve the problems caused by </span><span class="font2">alternate()</span><span class="font17">, not really knowing whether an alternative has succeeded until the following parsers reached the end of the input. Another way to solve the problem is to change the parsers so that instead of returning a single result from the first parse they find, they return </span><span class="font17" style="font-style:italic;">all</span><span class="font17"> the results from </span><span class="font17" style="font-style:italic;">all</span><span class="font17"> possible parses. Since this would be a big waste of time in the event that the caller cared about only the first parse, we would want to do it in a lazy fashion, returning a stream of possible parses.</span></p>
<p><span class="font17">This solves the problem too, because in this model, </span><span class="font2">alternate() </span><span class="font17">returns a stream that is the lazy merge of the streams returned by its arguments; if any of these streams is empty, it is ignored. </span><span class="font2">concatenate() </span><span class="font17">is responsible for combining two streams of parses into a stream of concatenations; if either input is empty, so is the output. If the first argument to </span><span class="font2">alternate() </span><span class="font17">succeeds but some later-concatenated part of the parsing process fails, that later part will return an empty stream, the concatenation with the successful alternative will be empty, and </span><span class="font2">alternate() </span><span class="font17">will effectively skip that alternative.</span></p>
<p><span class="font17">Before we see the changes to the parser constructors themselves, here are some utility functions we’ll need. </span><span class="font2">single() </span><span class="font17">manufactures a stream of length 1, with specified head and empty tail:</span></p>
<p><span class="font2">sub single {</span></p>
<p><span class="font2">my Sv = shift;</span></p>
<p><span class="font2">node(Sv, undef);</span></p>
<p><span class="font2">}</span></p>
<div>
<p><span class="font20">462</span></p>
</div><br clear="all">
<p><span class="font15">CHAPTER 8 Parsing</span></p>
<p><span class="font17">We saw </span><span class="font2">union() </span><span class="font17">before; it gets a list of streams, and produces a single stream formed by appending the arguments end-to-end. </span><span class="font2">sunion() </span><span class="font17">is similar, except that its argument is a stream of streams rather than a list of streams:</span></p>
<p><span class="font2">sub sunion {</span></p>
<p><span class="font2">my ($s) = @_;</span></p>
<p><span class="font2">my $cur_stream;</span></p>
<p><span class="font2">while ($s &amp;&amp;&nbsp;! $cur_stream) {</span></p>
<p><span class="font2">$cur_stream = head($s);</span></p>
<p><span class="font2">$s = tail ($s);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">return undef unless $cur_stream;</span></p>
<p><span class="font2">return node(head($cur_stream),</span></p>
<p><span class="font2">promise { sunion(node(tail($cur_stream), $s)) }</span></p>
<p><span class="font2">);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">Note that this is unsuitable if parsers might produce an infinite stream of possible parses; if so, we’d need to use a different version of </span><span class="font2">sunion() </span><span class="font17">that mingled the argument streams instead of appending them end-to-end.</span></p>
<p><span class="font2">lookfor() </span><span class="font17">is the same as before, except that it returns an empty stream on failure and a singleton stream on success:</span></p>
<p><span class="font2">sub lookfor {</span></p>
<p><span class="font2">...</span></p>
<p><span class="font2">my $parser = parser {</span></p>
<p><span class="font2">...</span></p>
<p><span class="font2">for my $i (0 .. $#$wanted) {</span></p>
<p><span class="font2">next unless defined $wanted-&gt;[$i];</span></p>
<p><span class="font2">unless ($wanted-&gt;[$i] eq $next-&gt;[$i]) {</span></p>
<p><span class="font2" style="font-weight:bold;">return undef;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">my $wanted_value = $value-&gt;($next, $u);</span></p>
<p><span class="font2" style="font-weight:bold;">return single([$wanted_value, tail($input)]);</span></p>
<p><span class="font2">};</span></p>
<p><span class="font2">$N{$parser} = &quot;[@$wanted]&quot;;</span></p>
<p><span class="font2">return $parser;</span></p>
<p><span class="font2">}</span></p>
<div>
<p><span class="font15">8.8 BACKTRACKING PARSERS</span></p>
</div><br clear="all">
<div>
<h4><a name="bookmark439"></a><span class="font20">463</span></h4>
</div><br clear="all">
<p><span class="font17">Similarly, </span><span class="font2">End_of_input() </span><span class="font17">and </span><span class="font2">nothing() </span><span class="font17">return singleton streams when they succeed:</span></p>
<p><span class="font2">sub End_of_Input {</span></p>
<p><span class="font2">my Sinput = shift;</span></p>
<p><span class="font2" style="font-weight:bold;">defined(Sinput) ? () : single([&quot;EOI&quot;, undef]);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">sub nothing {</span></p>
<p><span class="font2">my Sinput = shift;</span></p>
<p><span class="font2" style="font-weight:bold;">return single([undef, Sinput]);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">alternate() </span><span class="font17">becomes much simpler; it’s merely a call to </span><span class="font2">union() </span><span class="font17">to join together the streams returned by its argument parsers:</span></p>
<p><span class="font2">sub alternate {</span></p>
<p><span class="font2">my @p = @_;</span></p>
<p><span class="font2" style="font-weight:bold;">return parser { return undef } if @p == 0;</span></p>
<p><span class="font2">return Sp[0] &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if @p == 1;</span></p>
<p><span class="font2">my Sp;</span></p>
<p><span class="font2">Sp = parser {</span></p>
<p><span class="font2" style="font-weight:bold;">my Sinput = shift;</span></p>
<p><span class="font2" style="font-weight:bold;">union(map S_-&gt;(Sinput), @p);</span></p>
<p><span class="font2">};</span></p>
<p><span class="font2">SN{Sp} = &quot;(&quot; . join(&quot; | &quot;, map SN{S_}, @p) . &quot;)&quot;;</span></p>
<p><span class="font2">return Sp;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">concatenate()</span><span class="font17">, however, is trickier. To concatenate parsers </span><span class="font17" style="font-style:italic;">S</span><span class="font17"> and </span><span class="font17" style="font-style:italic;">T,</span><span class="font17"> we must first call </span><span class="font17" style="font-style:italic;">S</span><span class="font17"> on the main input, returning a stream of </span><span class="font2">[Ssvalue, Sinputl] </span><span class="font17">pairs. We then call </span><span class="font17" style="font-style:italic;">T</span><span class="font17"> on each of the </span><span class="font2">Sinputl </span><span class="font17">values, producing a stream of </span><span class="font2">[Stvalue, Sinput2] </span><span class="font17">pairs. The parser produced by </span><span class="font2">concatenate() </span><span class="font17">then produces a stream of </span><span class="font2">[[Ssvalue, Stvalue]</span><span class="font17">, </span><span class="font2">Sinput2] </span><span class="font17">pairs for each </span><span class="font2">Stvalue </span><span class="font17">and its corresponding </span><span class="font2">Ssvalue</span><span class="font17">:</span></p>
<p><span class="font2">sub concatenate2 {</span></p>
<p><span class="font2">my (SS, ST) = @_;</span></p>
<p><span class="font2">my Sp;</span></p>
<div>
<p><span class="font4">I</span></p>
<p><span class="font20">464</span></p>
</div><br clear="all">
<p><span class="font15">CHAPTER 8 Parsing</span></p>
<p><span class="font2">Sp = parser {</span></p>
<p><span class="font2">my Sinput = shift;</span></p>
<p><span class="font2">my Ssparses = SS-&gt;(Sinput);</span></p>
<p><span class="font2">sunion(transform {</span></p>
<p><span class="font2">my (Ssv, Sinputl) = @{S_[0]};</span></p>
<p><span class="font2">my Stparses = ST-&gt;(Sinput1); transform {</span></p>
<p><span class="font2">my (Stv, Sinput2) = @{S_[0]};</span></p>
<p><span class="font2">[[Ssv, Stv], Sinput2];</span></p>
<p><span class="font2">} Stparses;</span></p>
<p><span class="font2">} Ssparses);</span></p>
<p><span class="font2">};</span></p>
<p><span class="font2">SN{Sp} = &quot;@N{SS, ST}&quot;;</span></p>
<p><span class="font2">return Sp;</span></p>
<p><span class="font2">}</span></p>
<h6><a name="bookmark440"></a><span class="font17">This concatenates only two parsers; to concatenate more than two, we repeat the process as necessary:</span></h6>
<p><span class="font2">sub concatenate { my @p = @_;</span></p>
<p><span class="font2">return \&amp;null if @p == 0;</span></p>
<p><span class="font2">my Sp = shift @p;</span></p>
<p><span class="font2">return Sp if @p == 0;</span></p>
<p><span class="font2">my Sresult = concatenate2(Sp, concatenate(@p));</span></p>
<p><span class="font2">SN{Sresult} = &quot;@N{Sp, @p}&quot;;</span></p>
<p><span class="font2">return Sresult;</span></p>
<p><span class="font2">}</span></p>
<h6><a name="bookmark441"></a><span class="font17">Finally, </span><span class="font2">T </span><span class="font17">needs to be changed to apply its transformation function to each of the values returned by its argument parser:</span></h6>
<p><span class="font2">sub T {</span></p>
<p><span class="font2">my (Sparser, Stransform) = @_;</span></p>
<p><span class="font2">my Sp = parser {</span></p>
<p><span class="font2">my Sinput = shift;</span></p>
<p><span class="font2" style="font-weight:bold;">transform {</span></p>
<p><span class="font2" style="font-weight:bold;">my (Sv, Sinputl) = @{S_[0]};</span></p>
<p><span class="font2" style="font-weight:bold;">[Stransform-&gt;(Sv), Sinputl];</span></p>
<div>
<p><span class="font15">8.9 OVERLOADING</span></p>
</div><br clear="all">
<div>
<h4><a name="bookmark442"></a><span class="font20">465</span></h4>
</div><br clear="all">
<p><span class="font2">} Sparser-&gt;(Sinput); };</span></p>
<p><span class="font2">$N{$p} = SN{Sparser};</span></p>
<p><span class="font2">return Sp;</span></p>
<p><span class="font2">}</span></p>
<ul style="list-style:none;"><li>
<h5><a name="bookmark182"></a><span class="font18">8.9 OVERLOADING</span></h5></li></ul>
<p><span class="font17">The recursive-descent parsing system works well, and it’s easy to compose small parsers into bigger ones and to capture common patterns in larger parsergenerating functions, such as </span><span class="font2">operator() </span><span class="font17">of Section 8.4.4. But the notation looks awful. We can clean this up a little bit by using Perl’s operator-overloading feature, introduced in Chapter 7.</span></p>
<p><span class="font17">The most frequently-used parser operators have been </span><span class="font2">concatenate()</span><span class="font17">, </span><span class="font2">alternate()</span><span class="font17">, and </span><span class="font2">T()</span><span class="font17">. We’ll overload three operators to invoke these functions, so that what we once wrote as:</span></p>
<p><span class="font2">Sfactor = alternate(lookfor('INT'),</span></p>
<p><span class="font2">T(</span></p>
<p><span class="font2">concatenate(lookfor(['OP', '(']),</span></p>
<p><span class="font2">SExpression,</span></p>
<p><span class="font2">lookfor(['OP', ')'])),</span></p>
<p><span class="font2">sub { $_[1] })</span></p>
<p><span class="font2">);</span></p>
<p><span class="font17">will become:</span></p>
<p><span class="font2">Sfactor = lookfor('INT')</span></p>
<p><span class="font2">| lookfor(['OP', '(']) - SExpression - lookfor(['OP', ')']) &gt;&gt;&nbsp;sub { S_[1] }</span></p>
<p><span class="font3"><sup>;</sup></span></p>
<p><span class="font17">which looks almost exactly like the grammar rules it represents. The - is used for concatenation, the | is of course used for alternation, and the </span><span class="font2">&gt;&gt;&nbsp;</span><span class="font17">replaces </span><span class="font2">T()</span><span class="font17">, because it visually suggests that the value from the parser on the left is being passed into the function on the right. The precedences of these three operators just happen to have the order we need: - has higher precedence than both | and </span><span class="font2">&gt;&gt;</span><span class="font17">, so </span><span class="font2">a | b - c &gt;&gt;&nbsp;d </span><span class="font17">means </span><span class="font2">a | ((b - c) &gt;&gt;&nbsp;d)</span><span class="font17">, which is almost always what we want.</span></p>
<h6><a name="bookmark443"></a><span class="font17">The remaining syntactic clutter is mostly the calls to </span><span class="font2">lookfor()</span><span class="font17">. If we want to trim this as well, it’s easy: just give </span><span class="font2">lookfor() </span><span class="font17">a shorter name:<a name="footnote37"></a><sup><a href="#bookmark444">37</a></sup><sup></sup></span></h6>
<p><span class="font2">sub _ { @_ = [@_]; goto &amp;lookfor }</span></p>
<p><span class="font2">Sfactor = _(&quot;INT&quot;)</span></p>
<p><span class="font2">| _('OP', '(') - SExpression - _('OP', ')')</span></p>
<p><span class="font2">&gt;&gt; sub { $_[1] }</span></p>
<p><span class="font3"><sup>;</sup></span></p>
<p><span class="font17">To pull this off, we must engage the Perl overloading features by turning parsers into objects blessed into a class that defines the operators. We’ll change the formerly trivial </span><span class="font2">parser() </span><span class="font17">function to do that:</span></p>
<p><span class="font2">package Parser;</span></p>
<p><span class="font2">sub parser (&amp;) { bless S_[0] =&gt; __PACKAGE__ }</span></p>
<h6><a name="bookmark445"></a><span class="font17">We have the </span><span class="font2">Parser </span><span class="font17">class overload the relevant operators:</span></h6>
<p><span class="font2">use overload '-' =&gt; \&amp;concatenate2,</span></p>
<p><span class="font2">'|' =&gt; \&amp;alternate2,</span></p>
<p><span class="font2">'&gt;&gt;' =&gt; \&amp;T,</span></p>
<p><span class="font2">'&quot;&quot;' =&gt; \&amp;overload::StrVal,</span></p>
<p><span class="font17">I’ve used </span><span class="font2">concatenate2() </span><span class="font17">and </span><span class="font2">alternate2() </span><span class="font17">here just in case I someday want to have a place to hang some extra semantics on the overloaded operators. In the meantime, these binary functions just call their more general counterparts:</span></p>
<p><span class="font2">sub concatenate2 {</span></p>
<p><span class="font2">my (SA, SB) = @_;</span></p>
<p><span class="font2">concatenate(SA, SB);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">sub alternate2 {</span></p>
<p><span class="font2">my (SA, SB) = @_;</span></p>
<p><span class="font2">alternate(SA, SB);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">The function associated with the &quot;&quot;&nbsp;</span><span class="font17" style="font-style:italic;">(stringification)</span><span class="font17"> pseudo-operator is invoked by Perl when a </span><span class="font2">Parser </span><span class="font17">object needs to be converted to astring. This occurs in debugging messages and also whenever we use a parser as a key to the debugging names in the </span><span class="font2">%N </span><span class="font17">hash. The function </span><span class="font2">\&amp;overload::StrVal </span><span class="font17">restores the default behavior of converting the </span><span class="font2">Parser </span><span class="font17">objects to strings of the form </span><span class="font2">Parser=CODE(0x83bb36c)</span><span class="font17">. An alternative would be to associate the stringification operator with a function that looks up the parser’s name in the </span><span class="font2">%N </span><span class="font17">hash:</span></p>
<p><span class="font2">use overload '&quot;&quot;' =&gt; \&amp;parser_name;</span></p>
<p><span class="font2">sub parser_name {</span></p>
<p><span class="font2">my $parser = shift;</span></p>
<p><span class="font2">my $key = overload::StrVal($parser);</span></p>
<p><span class="font2">exists($N{$key}) ? $N{$key} : $key;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">Ifwe did this, we would never need to refer explicitly to </span><span class="font2">%N </span><span class="font17">in debugging messages; just printing out a parser as if it were a string would print the name assigned to it from the </span><span class="font2">%N </span><span class="font17">hash.</span></p>
<p><span class="font17">There are a few technical problems associated with the change. The assignment:</span></p>
<p><span class="font2">$parser = $A - $B - $C</span></p>
<p><span class="font17">is not exactly equivalent to:</span></p>
<p><span class="font2">$parser = concatenate($A, $B, $C) ;</span></p>
<p><span class="font17">but rather to:</span></p>
<p><span class="font2">$parser = concatenate(concatenate($A, $B), $C) ;</span></p>
<p><span class="font17">If the values returned by </span><span class="font2">$A</span><span class="font17">, </span><span class="font2">$B</span><span class="font17">, and </span><span class="font2">$C </span><span class="font17">are </span><span class="font2">a</span><span class="font17">, </span><span class="font2">b</span><span class="font17">, and </span><span class="font2">c</span><span class="font17">, the first parser would have returned </span><span class="font2">[a, b, c]</span><span class="font17">, but the overloaded version will return </span><span class="font2">[[a, b], c]</span><span class="font17">. It might seem that we could fix this by having </span><span class="font2">concatenate() </span><span class="font17">flatten its first argument. But a little thought shows that this won’t work, because </span><span class="font2">$A - $B </span><span class="font17">would try to flatten </span><span class="font2">a</span><span class="font17">, which would be an error. And </span><span class="font2">concatenate() </span><span class="font17">can’t have a policy of flattening its first argument whenever the first argument is an array reference, because </span><span class="font2">$A </span><span class="font17">might actually return a legitimate array reference value.</span></p>
<p><span class="font17">Probably the best way to handle this is to leave </span><span class="font2">concatenate() </span><span class="font17">mostly alone and let it return values like </span><span class="font2">[[[a, b], c], d]</span><span class="font17">. Almost all compound values returned by </span><span class="font2">concatenate() </span><span class="font17">are passed through </span><span class="font2">T() </span><span class="font17">anyway, so we’ll let </span><span class="font2">T() </span><span class="font17">take care of undoing the nesting of the values. But we need some way to signal to </span><span class="font2">T() </span><span class="font17">the difference between a value returned by </span><span class="font2">SA - SB - SC</span><span class="font17">, where </span><span class="font2">[[a, b], c] </span><span class="font17">needs to be flattened to </span><span class="font2">[a, b, c]</span><span class="font17">, and the same value returned by </span><span class="font2">SA - SC</span><span class="font17">, where </span><span class="font2">$A </span><span class="font17">happened to return an array reference </span><span class="font2">[a, b]</span><span class="font17">, which doesn’t need to be flattened. A solution is to tag the pairs returned by </span><span class="font2">concatenate </span><span class="font17">so that </span><span class="font2">T() </span><span class="font17">can recognize them. Instead of:</span></p>
<p><span class="font2">for (©p) {</span></p>
<p><span class="font2">(Sv, Sinput) = $_-&gt;($input);</span></p>
<p><span class="font2">push ©values, Sv;</span></p>
<p><span class="font2">return (\©values, Sinput);</span></p>
<p><span class="font17">we have:</span></p>
<p><span class="font2">for (©p) {</span></p>
<p><span class="font2">(Sv, Sinput) = S_-&gt;(Sinput);</span></p>
<p><span class="font2">push ©values, Sv;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2" style="font-weight:bold;">return (bless(</span><span class="font2">\</span><span class="font2" style="font-weight:bold;">©values =&gt; 'Pair'), Sinput);</span></p>
<p><span class="font17">We must also add code to </span><span class="font2">T() </span><span class="font17">to recognize and flatten lists of these special </span><span class="font2">Pair </span><span class="font17">objects:</span></p>
<p><span class="font2">my (Svalue, Snewinput) = Sparser-&gt;(Sinput);</span></p>
<p><span class="font2" style="font-weight:bold;"># Flatten nested lists returned by concatenated my ©values;</span></p>
<p><span class="font2" style="font-weight:bold;">while (ref(Svalue) eq 'Pair') { unshift ©values, Svalue-&gt;[1]; Svalue = Svalue-&gt;[0];</span></p>
<p><span class="font2" style="font-weight:bold;">}</span></p>
<p><span class="font2" style="font-weight:bold;">unshift ©values, Svalue;</span></p>
<p><span class="font2" style="font-weight:bold;">Svalue = Stransform-&gt;(©values);</span></p>
<p><span class="font2">return (Svalue, Snewinput);</span></p>
<p><span class="font17">Only a few other changes need to be made. Expressions like:</span></p>
<p><span class="font2">T(\&amp;nothing, sub { 1 })</span></p>
<p><span class="font17">don’t translate as they should. The corresponding expression,</span></p>
<p><span class="font2">\&amp;nothing &gt;&gt;&nbsp;sub { 1 }</span></p>
<p><span class="font15">8.9 OVERLOADING</span></p>
<div>
<p><span class="font20">469</span></p>
</div><br clear="all">
<h6><a name="bookmark446"></a><span class="font17">doesn’t work, because </span><span class="font2">\&amp;nothing </span><span class="font17">is not an overloaded </span><span class="font2">Parser </span><span class="font17">object. (It hasn’t been blessed.) The solution is simple; instead of using </span><span class="font2">\&amp;nothing </span><span class="font17">directly, provide a blessed version:</span></h6>
<p><span class="font2">bless(Snothing = \&amp;nothing, &quot;Parser&quot;);</span></p>
<p><span class="font2">SN{Snothing} = &quot;(nothing)&quot;;</span></p>
<h6><a name="bookmark447"></a><span class="font17">and then use </span><span class="font2">Snothing </span><span class="font17">instead of </span><span class="font2">\&amp;nothing</span><span class="font17">:</span></h6>
<p><span class="font2">Snothing &gt;&gt;&nbsp;sub { 1 }</span></p>
<h6><a name="bookmark448"></a><span class="font17">With the new syntax, the parser for the final calculator example of Section 8.4.6 becomes:</span></h6>
<p><span class="font2">Sprogram = star(SStatement) - SParser::End_of_Input;</span></p>
<p><span class="font2">Sstatement = _(&quot;PRINT&quot;) - SExpression - _(&quot;TERMINATOR&quot;)</span></p>
<p><span class="font2">&gt;&gt; sub { print &quot;&gt;&gt;&nbsp;S_[1]\n&quot; }</span></p>
<p><span class="font2">| _(&quot;IDENTIFIER&quot;) -_('OP', '=')</span></p>
<p><span class="font2">- SExpression - _(&quot;TERMINATOR&quot;)</span></p>
<p><span class="font2">&gt;&gt; sub { SVAR{S_[0]} = S_[2] };</span></p>
<p><span class="font2">Sexpression = STerm - star(_('OP', '+') - STerm</span></p>
<p><span class="font2">&gt;&gt; sub { my Sterm = S_[1];</span></p>
<p><span class="font2">sub { S_[0] + Sterm } }</span></p>
<p><span class="font2">|</span></p>
<p><span class="font2">_('OP', '-') - STerm</span></p>
<p><span class="font2">&gt;&gt; sub { my Sterm = S_[1];</span></p>
<p><span class="font2">sub { S_[0] - Sterm } }</span></p>
<p><span class="font2">)</span></p>
<p><span class="font2">&gt;&gt; sub { my (Sfirst, Srest) = @_;</span></p>
<p><span class="font2">for my Sf (@Srest) {</span></p>
<p><span class="font2">Sfirst = Sf-&gt;(Sfirst);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">Sfirst;</span></p>
<p><span class="font2">};</span></p>
<p><span class="font2">Sterm = SFactor - star(_('OP', '*') - SFactor</span></p>
<div>
<h4><a name="bookmark449"></a><span class="font20">470</span></h4>
</div><br clear="all">
<div>
<p><span class="font15">CHAPTER 8 Parsing</span></p>
</div><br clear="all">
<p><span class="font2">&gt;&gt; sub { my Sfactor = S_[1];</span></p>
<p><span class="font2">sub { S_[0] * Sfactor } }</span></p>
<p><span class="font2">I</span></p>
<p><span class="font2">_('OP', '/') - SFactor</span></p>
<p><span class="font2">&gt;&gt; sub { my Sfactor = S_[1];</span></p>
<p><span class="font2">sub { S_[0] / Sfactor } }</span></p>
<p><span class="font2">)</span></p>
<p><span class="font2">&gt;&gt; sub { my (Sfirst, Srest) = @_;</span></p>
<p><span class="font2">for my Sf (@Srest) {</span></p>
<p><span class="font2">Sfirst = Sf-&gt;(Sfirst);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">Sfirst;</span></p>
<p><span class="font2">};</span></p>
<p><span class="font2">Sfactor = SBase - (</span></p>
<p><span class="font2">_('OP', '**') - SFactor &gt;&gt;&nbsp;sub { S_[1] }</span></p>
<p><span class="font2">I</span></p>
<p><span class="font2">SParser::null &gt;&gt;&nbsp;sub { 1 }</span></p>
<p><span class="font2">)</span></p>
<p><span class="font2">&gt;&gt; sub { S_[0] ** S_[1] };</span></p>
<p><span class="font2">Sbase = _(&quot;INT&quot;)</span></p>
<p><span class="font2">| lookfor('IDENTIFIER', sub { SVAR{S_[0][1]} })</span></p>
<p><span class="font2">| _('OP', '(') - SExpression - _('OP', ')') &gt;&gt;&nbsp;sub { S_[1] }</span></p>
<p><span class="font3"><sup>;</sup></span></p>
<p><span class="font17">The overloaded version is substantially less bulky and much easier to read.</span></p>
<p><span class="font14">CHAPTER</span></p>
<h3><a name="bookmark183"></a><span class="font25">DECLARATIVE</span></h3>
<h3><span class="font25">PROGRAMMING</span></h3>
<p><span class="font17">Beginning programmers often wish for a way to simply tell the computer what they want, and have the computer figure out how to do it. Declarative programming is an attempt to do that. The idea is that the programmer will put in the specifications for the value to be computed, and the computer will use the appropriate algorithm.</span></p>
<p><span class="font17">Nobody knows how to do this in general, and it may turn out to be impossible. But there are some interesting results we can get in specific problem domains. Regular expressions are a highly successful example of declarative programming. You write a pattern that represents the form of the text you are looking for, and then sit back and let the regex engine figure out the best way of locating the matching text.</span></p>
<p><span class="font17">Searching in general lends itself to declarative methods: the programmer specifies what they are searching for, and then lets a generic heuristic searching algorithm look for it. Database query languages are highly visible examples of this; consider SQL, or the query language of Chapter 8. The programming language Prolog is an extension of this idea to allow general computations.</span></p>
<div>
<p><span class="font20">472</span></p>
</div><br clear="all">
<p><span class="font15">CHAPTER 9 Declarative Programming</span></p>
<p><span class="font17">We’ve seen searching in some detail already, so in this chapter we’ll look at some other techniques and applications of declarative programming.</span></p>
<ul style="list-style:none;"><li>
<h5><a name="bookmark184"></a><span class="font18">9.1 CONSTRAINT SYSTEMS</span></h5></li></ul>
<p><span class="font17">Suppose you wrote a program to translate Fahrenheit temperatures into Celsius:</span></p>
<p><span class="font2">sub f2c {</span></p>
<p><span class="font2">my $f = shift;</span></p>
<p><span class="font2">return ($f - 32) * 5/9;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">Now you’d like to have a program to perform the opposite conversion, from Celsius to Fahrenheit. Although this calculation is in some sense the same, you’d have to write completely new code, from scratch:</span></p>
<p><span class="font2">sub c2f {</span></p>
<p><span class="font2">my $c = shift;</span></p>
<p><span class="font2">return 9/5 * $c + 32;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">The idea of constraint systems is to permit the computer to be able to run this sort of calculation in either direction.</span></p>
<ul style="list-style:none;"><li>
<h5><a name="bookmark185"></a><span class="font18">9.2 LOCAL PROPAGATION NETWORKS</span></h5></li></ul>
<p><span class="font17">One approach that seems promising is to distribute the logic for the calculation among several objects in a </span><span class="font17" style="font-style:italic;">constraint network</span><span class="font17"> as shown in Figure 9.1.</span></p>
<p><span class="font17">There is a node in the network for each constant, variable, and operator. Lines between the nodes communicate numeric values between nodes, and they are called </span><span class="font17" style="font-style:italic;">wires.</span><span class="font17"> A node can set the value on one of its wires; this sends a notification to the node at the other end of the wire that the value has changed. Because values are propagated only from nodes to their adjacent wires to the nodes attached at the other end of the wire, the network is called a </span><span class="font17" style="font-style:italic;">local propagation network</span><span class="font17">.</span></p>
<p><span class="font17">A constant node has one incident wire, and when the network is started up, the constant node immediately tries to set its wire to the appropriate constant</span></p><img src="HigherOrderPerl_files/HigherOrderPerl-56.jpg" alt="" style="width:143pt;height:66pt;">
<p><span class="font14" style="font-variant:small-caps;">figure 9.1 </span><span class="font16">A constraint network for turning Fahrenheit temperatures to Celsius and back.</span></p>
<p><span class="font17">value. In the network shown in Figure 9.1, wire </span><span class="font17" style="font-style:italic;">j</span><span class="font17"> initially has the value 32, and wire </span><span class="font17" style="font-style:italic;">l</span><span class="font17"> initially has the value 5/9.</span></p>
<p><span class="font17">The nodes marked with variable names, </span><span class="font2">c </span><span class="font17">and </span><span class="font2">f </span><span class="font17">in this example, are inputoutput nodes. Initially, they do nothing, but the user of the program has the option to tell them to set their incident wires to certain values; that is how the user sends input into the network. If an input-output node notices that its incident wire has changed value, it announces that fact to the user; that’s how output is emitted from the network.</span></p>
<p><span class="font17">We’ll use the network of Figure 9.1 to calculate the Celsius equivalent for 212 Fahrenheit. We start by informing the </span><span class="font2">f </span><span class="font17">node that we want </span><span class="font17" style="font-style:italic;">f</span><span class="font17"> to have the value 212. The </span><span class="font2">f </span><span class="font17">node obliges by setting the value of wire </span><span class="font17" style="font-style:italic;">i</span><span class="font17"> to 212.</span></p>
<p><span class="font17">The change on wire </span><span class="font17" style="font-style:italic;">i</span><span class="font17"> wakes up the attached - node, which notices that both of its input wires now have values: Wire </span><span class="font17" style="font-style:italic;">i</span><span class="font17"> has the value 212 and wire </span><span class="font17" style="font-style:italic;">j</span><span class="font17"> has the value 32. The - node performs subtraction; it subtracts 32 from 212 and sets its output wire </span><span class="font17" style="font-style:italic;">k</span><span class="font17"> to the difference, 180.</span></p>
<p><span class="font17">The change on wire </span><span class="font17" style="font-style:italic;">k</span><span class="font17"> wakes up the attached * node, which notices that both of </span><span class="font17" style="font-style:italic;">its</span><span class="font17"> input wires now have values: Wire </span><span class="font17" style="font-style:italic;">k</span><span class="font17"> has the value 180 and wire </span><span class="font17" style="font-style:italic;">l</span><span class="font17"> has the value 5/9. The * node performs multiplication; it multiplies 180 by 5/9 and sets its output wire </span><span class="font17" style="font-style:italic;">m</span><span class="font17"> to the product, 100.</span></p>
<p><span class="font17">The change on wire </span><span class="font17" style="font-style:italic;">m</span><span class="font17"> wakes up the attached input-output node </span><span class="font2">c</span><span class="font17">, which notices that its input wire now has the value 100. It announces this fact to the user, saying something like:</span></p>
<p><span class="font2">c = 100</span></p>
<p><span class="font17">which is in fact the Celsius equivalent of 212 Fahrenheit.</span></p>
<p><span class="font17">What makes this interesting is that the components are so simple and so easily reversible. There’s nothing about this process that requires that the calculation proceed from left to right. Let’s suppose that instead of calculating the Celsius equivalent of 212 Fahrenheit, we wanted the Fahrenheit equivalent of 37 Celsius. We begin by informing the </span><span class="font2">c </span><span class="font17">input-output node that we want the</span></p>
<p><span class="font17">value of </span><span class="font17" style="font-style:italic;">c</span><span class="font17"> to be 37. The </span><span class="font2">c </span><span class="font17">node will set wire </span><span class="font17" style="font-style:italic;">m</span><span class="font17"> to value 37. This will wake up the * node, which will notice that two of its three incoming wires have values: </span><span class="font17" style="font-style:italic;">l</span><span class="font17"> has value 5/9 and </span><span class="font17" style="font-style:italic;">m</span><span class="font17"> has value 37. It will then conclude that wire </span><span class="font17" style="font-style:italic;">k</span><span class="font17"> must have the value 37/(5/9) </span><span class="font3">= </span><span class="font17">66.6, and set wire </span><span class="font17" style="font-style:italic;">k</span><span class="font17"> accordingly.</span></p>
<p><span class="font17">The change in the value of wire </span><span class="font17" style="font-style:italic;">k</span><span class="font17"> will wake up the attached - node, which will notice that the subtrahend </span><span class="font17" style="font-style:italic;">j</span><span class="font17"> is 32 and the difference </span><span class="font17" style="font-style:italic;">k</span><span class="font17"> is 66.6, and conclude that the minuend, </span><span class="font17" style="font-style:italic;">i,</span><span class="font17"> must have the value 98.6. It will then set </span><span class="font17" style="font-style:italic;">i</span><span class="font17"> to 98.6. This will wake up the attached </span><span class="font2">f </span><span class="font17">node, which will announce something like:</span></p>
<p><span class="font2">f = 98.6</span></p>
<p><span class="font17">which is indeed the Fahrenheit equivalent of 37 Celsius.</span></p>
<p><span class="font17">It’s no trouble to attach more input-output nodes to the network to have it calculate several things at once. For example, we might extend the network as shown in Figure 9.2.</span></p>
<p><span class="font17">Now setting </span><span class="font2">c </span><span class="font17">to 37 causes values to propagate in two directions. The 37 will propagate left along wire </span><span class="font17" style="font-style:italic;">m</span><span class="font17"> as before, eventually causing node </span><span class="font2">f </span><span class="font17">to announce the value 98.6. But wire </span><span class="font17" style="font-style:italic;">m</span><span class="font17"> now has three ends, and the 37 will also propagate rightward, causing the - node to set wire</span><span class="font17" style="font-style:italic;">p</span><span class="font17"> to 310.15, which is the value announced by the </span><span class="font2">k </span><span class="font17">node. The output looks something like:</span></p>
<p><span class="font2">f = 98.6</span></p>
<p><span class="font2">k = 310.15</span></p>
<p><span class="font17">which are the Fahrenheit and kelvin equivalents of 37 Celsius. Alternatively, we could have set node </span><span class="font2">k </span><span class="font17">to 0, which would have resulted in wire </span><span class="font17" style="font-style:italic;">m</span><span class="font17"> being set to </span><span class="font3">-</span><span class="font17">273.15. Node </span><span class="font2">c </span><span class="font17">would announce that fact, and the * node would also</span></p><img src="HigherOrderPerl_files/HigherOrderPerl-57.jpg" alt="" style="width:215pt;height:110pt;">
<p><span class="font14" style="font-variant:small-caps;">figure 9.2 </span><span class="font16">A constraint network for interconverting Fahrenheit, Celsius, and absolute temperatures.</span></p>
<div>
<p><span class="font15">9.2 LOCAL PROPAGATION NETWORKS</span></p>
</div><br clear="all">
<div>
<h4><a name="bookmark450"></a><span class="font20">475</span></h4>
</div><br clear="all">
<div>
<p><span class="font17">take note; eventually wire </span><span class="font17" style="font-style:italic;">i</span><span class="font17"> would be set to </span><span class="font3">-</span><span class="font17">459.67, and the output from the entire network would be:</span></p>
</div><br clear="all">
<div>
<p><span class="font2">c = -273.15</span></p>
<p><span class="font2">f = -459.67</span></p>
<p><span class="font17">which are the Celsius and Fahrenheit temperatures of absolute zero.</span></p>
</div><br clear="all">
<div>
<h5><a name="bookmark186"></a><span class="font19">9.2.1 Implementing a Local Propagation Network</span></h5>
<p><span class="font17">Clearly we will have two kinds of objects: wires and nodes. Wires store values. When a wire’s value is set by a node, the wire remembers the value and also which node was responsible for setting it. This is so that the node can change or retract the value later. If the wire didn’t remember the original source of its information, it wouldn’t be able to distinguish the situation where the source changed its mind from the situation in which it was being given conflicting information. We’d like it to diagnose the latter but not the former:</span></p>
</div><br clear="all">
<div>
<p><span class="font2">package Wire;</span></p>
<p><span class="font2">my SN = 0;</span></p>
<p><span class="font2">sub new {</span></p>
<p><span class="font2">my (Sclass, Sname) = @_;</span></p>
<p><span class="font2">$name ||= &quot;wire&quot; . ++SN;</span></p>
<p><span class="font2">bless { N =&gt; Sname, S =&gt; undef, V =&gt; undef, A =&gt; [] } =&gt; Sclass; }</span></p>
</div><br clear="all">
<div>
<p><span class="font9" style="font-weight:bold;">CODE LIBRARY</span></p>
</div><br clear="all">
<div>
<p><span class="font0">Wire.pm</span></p>
</div><br clear="all">
<div>
<p><span class="font17">The </span><span class="font2">Sname </span><span class="font17">here is used for debugging purposes; we can supply a name to the constructor, or else the constructor will auto-generate one. </span><span class="font2">V </span><span class="font17">will be the stored value, initially undefined. </span><span class="font2">S </span><span class="font17">will be the identity of the node that supplied the stored value (“settor”), also initially undefined. </span><span class="font2">A </span><span class="font17">is a list of attached nodes. When the wire’s value changes, it will notify the attached nodes.</span></p>
<p><span class="font17">It’s common to need to manufacture several wires at once, so here’s a utility function that does that:</span></p>
</div><br clear="all">
<div>
<p><span class="font2">sub make {</span></p>
<p><span class="font2">my Sclass = shift;</span></p>
<p><span class="font2">my SN = shift;</span></p>
<p><span class="font2">my @wires;</span></p>
</div><br clear="all">
<div>
<p><span class="font20">476</span></p>
</div><br clear="all">
<p><span class="font15">CHAPTER 9 Declarative Programming</span></p>
<p><span class="font2">push @wires, $class-&gt;new while $N--;</span></p>
<p><span class="font2">@wires;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">Wire-&gt;make(5) </span><span class="font17">returns a list of five new wires.</span></p>
<p><span class="font17">The principal </span><span class="font2">Wire </span><span class="font17">method is </span><span class="font2">set</span><span class="font17">, which assigns a value to a wire:</span></p>
<p><span class="font2">sub set {</span></p>
<p><span class="font2">my ($self, $settor, $value) = @_;</span></p>
<p><span class="font2">if (! $self-&gt;has_settor || $self-&gt;settor_is($settor)) { $self-&gt;{V} = $value;</span></p>
<p><span class="font2">$self-&gt;{S} = $settor;</span></p>
<p><span class="font2">$self-&gt;notify_all_but($settor, $value);</span></p>
<p><span class="font2">} elsif ($self-&gt;has_settor) {</span></p>
<p><span class="font2">unless ($value == $self-&gt;value) {</span></p>
<p><span class="font2">my $v = $self-&gt;value;</span></p>
<p><span class="font2">my $N = $self-&gt;name;</span></p>
<p><span class="font2">warn &quot;Wire $N inconsistent value ($value != $v)\n&quot;;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">The normal case is if the wire had no value before (</span><span class="font2">! $self-&gt;has_settor</span><span class="font17">) or if the old settor is changing the value, in which case the wire remembers the new value and the settor, and then calls </span><span class="font2">notify_all_but() </span><span class="font17">to notify the other attached nodes that the value has changed.</span></p>
<p><span class="font17">The other case of interest occurs when some other node, not the original settor, tries to notify the wire of a new value. In this case, if the old and new values are the same, all is well, and nothing need be done. But if the values differ, the wire should issue a diagnostic message. This might occur, for example, if we set the Fahrenheit input of a network to 212, and then tried to set the Celsius input to something other than 100.</span></p>
<p><span class="font17">The </span><span class="font2">notify_all_but() </span><span class="font17">function takes care of notifying the attached nodes of a change in value:</span></p>
<p><span class="font2">sub notify_all_but {</span></p>
<p><span class="font2">my ($self, $exception, $value) = @_;</span></p>
<p><span class="font2">for my $node ($self-&gt;attachments) { next if $node == $exception;</span></p>
<p><span class="font2">$node-&gt;notify;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
<ul style="list-style:none;"><li>
<p class="font15">9.2 LOCAL PROPAGATION NETWORKS</p>
<div>
<p><span class="font20">477</span></p>
</div><br clear="all"></li></ul>
<p><span class="font17">When a wire is set to a certain value, it notifies all its attached nodes of the change </span><span class="font17" style="font-style:italic;">except</span><span class="font17"> the one that set the value in the first place; this avoids infinite loops.</span></p>
<p><span class="font17">The accessors for attachments are trivial:</span></p>
<p><span class="font2">sub attach {</span></p>
<p><span class="font2">my (Sself, @nodes) = @_;</span></p>
<p><span class="font2">push @{Sself-&gt;{A}}, @nodes;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">sub attachments { @{S_[0]-&gt;{A}} }</span></p>
<p><span class="font17">The other </span><span class="font2">Wire </span><span class="font17">accessor methods are similarly trivial:</span></p>
<p><span class="font2">sub name {</span></p>
<p><span class="font2">S_[0]{N} || &quot;$_[0]&quot;;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">sub settor { S_[0]{S} }</span></p>
<p><span class="font2">sub has_settor { defined S_[0]{S} }</span></p>
<p><span class="font2">sub settor_is { S_[0]{S} == S_[1] }</span></p>
<p><span class="font17">The only unusual method here is </span><span class="font2">settor_is()</span><span class="font17">. </span><span class="font2">Swire-&gt;settor_is(Snode) </span><span class="font17">asks if the wire’s settor is </span><span class="font2">Snode</span><span class="font17">, and returns true if so. Note that objects can be compared for identity with the </span><span class="font2">== </span><span class="font17">operator; this actually compares the underlying machine addresses at which the objects are stored.</span></p>
<p><span class="font17">The opposite of </span><span class="font2">set() </span><span class="font17">is </span><span class="font2">revoke()</span><span class="font17">, which allows the settor node to revoke a previously set value:</span></p>
<p><span class="font2">sub revoke {</span></p>
<p><span class="font2">my (Sself, Srevoker) = @_;</span></p>
<p><span class="font2">return unless Sself-&gt;has_value;</span></p>
<p><span class="font2">return unless Sself-&gt;settor_is(Srevoker);</span></p>
<p><span class="font2">undef Sself-&gt;{V};</span></p>
<p><span class="font2">Sself-&gt;notify_all_but(Srevoker, undef);</span></p>
<p><span class="font2">undef Sself-&gt;{S};</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">As far as the attached nodes are concerned, a revocation of a value is the same as setting the value to </span><span class="font2">undef</span><span class="font17">.</span></p>
<div>
<p><span class="font20">478</span></p>
</div><br clear="all">
<p><span class="font15">CHAPTER 9 Declarative Programming</span></p>
<p><span class="font17">The final methods in the </span><span class="font2">Wire </span><span class="font17">class are the ones that query a wire for its current value. The code is short, but a little tricky. They’re </span><span class="font17" style="font-style:italic;">almost</span><span class="font17"> straightforward accessors, simply returning the value of </span><span class="font2">Sself-&gt;{V} </span><span class="font17">or its definedness:</span></p>
<p><span class="font2">sub value { my (Sself, Squerent) = @_;</span></p>
<p><span class="font2">return if Sself-&gt;settor_is(Squerent);</span></p>
<p><span class="font2">Sself-&gt;{V};</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">sub has_value { my (Sself, Squerent) = @_;</span></p>
<p><span class="font2">return if Sself-&gt;settor_is(Squerent);</span></p>
<p><span class="font2">defined S_[0]{V};</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">The exception is if the wire’s settor is asking about the value. In this case, the wire returns </span><span class="font2">undef</span><span class="font17">, indicating that it doesn’t know. This is necessary to support revocation of values. To see the reason for this, consider an adder node with addend wires </span><span class="font17" style="font-style:italic;">A</span><span class="font17"> and </span><span class="font17" style="font-style:italic;">B,</span><span class="font17"> and sum wire </span><span class="font17" style="font-style:italic;">C.</span><span class="font17"> Suppose </span><span class="font17" style="font-style:italic;">A</span><span class="font17"> and </span><span class="font17" style="font-style:italic;">B</span><span class="font17"> have been set to 1 and 2 by some other components; the adder node itself then sets the sum </span><span class="font17" style="font-style:italic;">C</span><span class="font17"> to 3. Now suppose the value of </span><span class="font17" style="font-style:italic;">B</span><span class="font17"> is revoked. The adder node receives a notification and inspects the values of the wires. If not for the special case in </span><span class="font2">value()</span><span class="font17">, it would learn that </span><span class="font17" style="font-style:italic;">A</span><span class="font17"> had value 1 and </span><span class="font17" style="font-style:italic;">C</span><span class="font17"> had value 3, and conclude that </span><span class="font17" style="font-style:italic;">B</span><span class="font17"> must have value 2, a conclusion that is no longer warranted. To avoid this, wire </span><span class="font17" style="font-style:italic;">C</span><span class="font17"> will report a value of 3 to any </span><span class="font17" style="font-style:italic;">other</span><span class="font17"> node that asks, but if the adder itself asks, the wire will say </span><span class="font2">undef</span><span class="font17">, meaning “If you’re not sure what my value is supposed to be, then I’m not sure either.”</span></p>
<p><span class="font17">We’ll use an abstract class to represent nodes. We could subclass this to make the various node types, but since most of the node behavior is the same in all node types, we won’t bother; the variable part of the behavior can be specified by supplying an anonymous function that will be stored in the node object.</span></p>
<p><span class="font17">Here’s the generic constructor:</span></p>
<div>
<p><span class="font9" style="font-weight:bold;">CODE LIBRARY</span></p>
</div><br clear="all">
<div>
<p><span class="font0">Node.pm</span></p>
</div><br clear="all">
<p><span class="font2">package Node;</span></p>
<p><span class="font2">my %NAMES;</span></p>
<p><span class="font2">sub new {</span></p>
<p><span class="font2">my (Sclass, Sbase_name, Sbehavior, Swiring) = @_;</span></p>
<p><span class="font2">my Sself = {N =&gt; Sbase_name . ++SNAMES{Sbase_name}, B =&gt; Sbehavior, W =&gt; Swiring,</span></p>
<p><span class="font2">};</span></p>
<p><span class="font2">for my Swire (values %Swiring) {</span></p>
<p><span class="font2">Swire-&gt;attach(Sself);</span></p>
<p><span class="font2">}</span></p>
<ul style="list-style:none;"><li>
<p class="font15">9.2 LOCAL PROPAGATION NETWORKS</p>
<div>
<p><span class="font20">479</span></p>
</div><br clear="all"></li></ul>
<p><span class="font2">bless Sself =&gt; Sclass;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">The constructor’s first argument is a node type name, such as </span><span class="font2">adder</span><span class="font17">, which is used to construct a name for debugging. The important arguments are the other two. </span><span class="font2">Sbehavior </span><span class="font17">is a function that is invoked when one of the attached wires changes values; it is the responsibility of </span><span class="font2">Sbehavior </span><span class="font17">to calculate new values and to propagate them through the network. </span><span class="font2">Swiring </span><span class="font17">is a hash whose values are the wires themselves; each wire is associated with a name, through which </span><span class="font2">Sbehavior </span><span class="font17">will access it.</span></p>
<p><span class="font17">The primary method is </span><span class="font2">notify()</span><span class="font17">. When a node is notified that a wire has changed, it builds a hash of its current wire values, and passes the hash to its behavior function:</span></p>
<p><span class="font2">sub notify {</span></p>
<p><span class="font2">my Sself = shift;</span></p>
<p><span class="font2">my %vals;</span></p>
<p><span class="font2">while (my (Sname, Swire) = each %{Sself-&gt;{W}}) {</span></p>
<p><span class="font2">Svals{Sname} = Swire-&gt;value(Sself);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">Sself-&gt;{B}-&gt;(Sself, %vals);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">The rest of the </span><span class="font2">Node </span><span class="font17">methods are simple utilities, intended to be used by the behavior function:</span></p>
<p><span class="font2">sub name {</span></p>
<p><span class="font2">my Sself = shift;</span></p>
<p><span class="font2">Sself-&gt;{N} || &quot;Sself&quot;;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">wire() </span><span class="font17">takes a name and returns the associated wire object:</span></p>
<p><span class="font2">sub wire { S_[0]{W}{S_[1]} }</span></p>
<p><span class="font2">sub set_wire {</span></p>
<p><span class="font2">my (Sself, Swire_name, Svalue) = @_;</span></p>
<p><span class="font2">my Swire = Sself-&gt;wire(Swire_name);</span></p>
<p><span class="font2">Swire-&gt;set(Sself, Svalue);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">sub revoke_wire {</span></p>
<p><span class="font2">my (Sself, Swire_name) = @_;</span></p>
<div>
<p><span class="font20">480</span></p>
</div><br clear="all">
<p><span class="font15">CHAPTER 9 Declarative Programming</span></p>
<p><span class="font2">my Swire = $self-&gt;wire($wire_name);</span></p>
<p><span class="font2">$wire-&gt;revoke($self);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">We’re finally at the meat of the program; we’re ready to see the components themselves. Here’s the behavior function for an adder:</span></p>
<p><span class="font2">{</span></p>
<p><span class="font2">my Sadder = sub {</span></p>
<p><span class="font2">my (Sself, %v) = @_;</span></p>
<p><span class="font2">if (defined Sv{A1} &amp;&amp;&nbsp;defined Sv{A2}) {</span></p>
<p><span class="font2">Sself-&gt;set_wire('S', Sv{A1} + Sv{A2});</span></p>
<p><span class="font2">} else {</span></p>
<p><span class="font2">Sself-&gt;revoke_wire('S');</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">if (defined Sv{A1} &amp;&amp;&nbsp;defined Sv{S}) {</span></p>
<p><span class="font2">Sself-&gt;set_wire('A2', Sv{S} - Sv{A1});</span></p>
<p><span class="font2">} else {</span></p>
<p><span class="font2">Sself-&gt;revoke_wire('A2');</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">if (defined Sv{A2} &amp;&amp;&nbsp;defined Sv{S}) {</span></p>
<p><span class="font2">Sself-&gt;set_wire('A1', Sv{S} - Sv{A2});</span></p>
<p><span class="font2">} else {</span></p>
<p><span class="font2">Sself-&gt;revoke_wire('A1');</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">};</span></p>
<ul style="list-style:none;"><li>
<p><span class="font2"># continues...</span></p></li></ul>
<p><span class="font17">An adder has three wires: two addends, named </span><span class="font2">A1 </span><span class="font17">and </span><span class="font2">A2</span><span class="font17">, and a sum, named </span><span class="font2">S</span><span class="font17">. When it receives a notification, it checks to see if </span><span class="font2">A1 </span><span class="font17">and </span><span class="font2">A2 </span><span class="font17">both have values; if so, it sets </span><span class="font2">S </span><span class="font17">to be the sum. If not, it revokes any value that it might have given to </span><span class="font2">S</span><span class="font17">; note that if </span><span class="font2">S </span><span class="font17">has no value, or if some other component was responsible for setting </span><span class="font2">S</span><span class="font17">, the revocation is harmless, because of the way we defined the </span><span class="font2">Wire::revoke() </span><span class="font17">method. There are two analogous blocks of code for inferring the two addends from the sum.</span></p>
<p><span class="font17">The function to build an adder node gets three wires as arguments and invokes </span><span class="font2">Node::new() </span><span class="font17">to build a node with those three wires and the adder behavior function:</span></p>
<ul style="list-style:none;"><li>
<p><span class="font2"># continued...</span></p></li></ul>
<p><span class="font2">sub new_adder {</span></p>
<p><span class="font2">my (Sa1, Sa2, Ss) = @_;</span></p>
<ul style="list-style:none;"><li>
<p class="font15">9.2 LOCAL PROPAGATION NETWORKS</p>
<div>
<p><span class="font20">481</span></p>
</div><br clear="all"></li></ul>
<p><span class="font2">Node-&gt;new('adder',</span></p>
<p><span class="font2">Sadder,</span></p>
<p><span class="font2">{ A1 =&gt; Sal, A2 =&gt; Sa2, S =&gt; Ss });</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">The behavior function for a multiplier node is a little more complicated. Not only does it need to infer a product from the two factors, and vice versa, but when a factor is 0, it can infer the product even without the other factor:</span></p>
<p><span class="font2">{</span></p>
<p><span class="font2">my Smultiplier = sub {</span></p>
<p><span class="font2">my (Sself, %v) = @_;</span></p>
<p><span class="font2">if (defined Sv{F1} &amp;&amp;&nbsp;defined Sv{F2}) {</span></p>
<p><span class="font2">Sself-&gt;set_wire('P', Sv{F1} * Sv{F2});</span></p>
<p><span class="font2">} elsif (defined Sv{F1} &amp;&amp;&nbsp;Sv{F1} == 0) {</span></p>
<p><span class="font2">Sself-&gt;set_wire('P', 0);</span></p>
<p><span class="font2">} elsif (defined Sv{F2} &amp;&amp;&nbsp;Sv{F2} == 0) {</span></p>
<p><span class="font2">Sself-&gt;set_wire('P', 0);</span></p>
<p><span class="font2">} else {</span></p>
<p><span class="font2">Sself-&gt;revoke_wire('P');</span></p>
<p><span class="font2">}</span></p>
<ul style="list-style:none;"><li>
<p><span class="font2"># continues...</span></p></li></ul>
<p><span class="font17">The price of this free inference, however, is that the wires can be in an inconsistent state, which corresponds to a division by zero. If one factor is zero while the product is nonzero, the node won’t be able to reason backwards, and will become upset:</span></p>
<ul style="list-style:none;"><li>
<p><span class="font2"># continued...</span></p></li></ul>
<p><span class="font2">if (defined Sv{F1} &amp;&amp;&nbsp;defined Sv{P}) {</span></p>
<p><span class="font2">if (Sv{F1} != 0) {</span></p>
<p><span class="font2">Sself-&gt;set_wire('F2', Sv{P} / Sv{F1});</span></p>
<p><span class="font2">} elsif (Sv{P} != 0) {</span></p>
<p><span class="font2">warn &quot;Division by zero\n&quot;;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">} else {</span></p>
<p><span class="font2">Sself-&gt;revoke_wire('F2');</span></p>
<p><span class="font2">}</span></p>
<div>
<p><span class="font4">I</span></p>
<p><span class="font20">482</span></p>
</div><br clear="all">
<p><span class="font15">CHAPTER 9 Declarative Programming</span></p>
<p><span class="font2">if (defined $v{F2} &amp;&amp;&nbsp;defined $v{P}) { if ($v{F2} != 0) { Sself-&gt;set_wire('F1', $v{P} / $v{F2});</span></p>
<p><span class="font2">} elsif ($v{P} != 0) { warn &quot;Division by zero\n&quot;;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">} else {</span></p>
<p><span class="font2">$self-&gt;revoke_wire('F1');</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">};</span></p>
<ul style="list-style:none;"><li>
<p><span class="font2"># continues...</span></p></li></ul>
<h6><a name="bookmark451"></a><span class="font17">The function for building a multiplier node, </span><span class="font2">new_multiplier()</span><span class="font17">, is similar to </span><span class="font2">new_adder()</span><span class="font17">:</span></h6>
<ul style="list-style:none;"><li>
<p><span class="font2"># continued...</span></p></li></ul>
<p><span class="font2">sub new_multiplier {</span></p>
<p><span class="font2">my (Sf1, Sf2, $p) = @_;</span></p>
<p><span class="font2">Node-&gt;new('multiplier', Smultiplier,</span></p>
<p><span class="font2">{ F1 =&gt; Sf1, F2 =&gt; Sf2, P =&gt; Sp });</span></p>
<p><span class="font2">} }</span></p>
<p><span class="font17">We could go on and build a subtraction node, but there’s no need.</span></p>
<div><img src="HigherOrderPerl_files/HigherOrderPerl-58.jpg" alt="" style="width:77pt;height:36pt;">
</div><br clear="all">
<p><span class="font17">This network fragment expresses the constraint </span><span class="font17" style="font-style:italic;">A — B = C</span><span class="font17">. But that’s the same as </span><span class="font17" style="font-style:italic;">C</span><span class="font3"> + </span><span class="font17" style="font-style:italic;">B = A</span><span class="font17">, so the network shown below expresses the same thing.</span></p>
<div><img src="HigherOrderPerl_files/HigherOrderPerl-59.jpg" alt="" style="width:77pt;height:36pt;">
</div><br clear="all">
<ul style="list-style:none;"><li>
<p class="font15">9.2 LOCAL PROPAGATION NETWORKS</p>
<div>
<p><span class="font20">483</span></p>
</div><br clear="all"></li></ul>
<p><span class="font17">With the transformation shown above, our Fahrenheit-to-Celsius network becomes the network shown here.</span></p>
<div><img src="HigherOrderPerl_files/HigherOrderPerl-60.jpg" alt="" style="width:89pt;height:75pt;">
</div><br clear="all">
<p><span class="font17">But for convenience, we could define:</span></p>
<ul style="list-style:none;"><li>
<p><span class="font2"># S - M = D</span></p></li></ul>
<p><span class="font2">sub new_subtractor {</span></p>
<p><span class="font2">my ($s, $m, $d) = @_;</span></p>
<p><span class="font2">new_adder($d, $m, $s);</span></p>
<p><span class="font2">}</span></p>
<ul style="list-style:none;"><li>
<p><span class="font2"># V / S = Q</span></p></li></ul>
<p><span class="font2">sub new_divider {</span></p>
<p><span class="font2">my ($v, $s, $q) = @_;</span></p>
<p><span class="font2">new_multiplier($q, $s, $v);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">if we wanted.</span></p>
<p><span class="font17">Now all we need are constant nodes and input-output (IO) nodes. Constants, as you would expect, are very simple:</span></p>
<p><span class="font2">sub new_constant {</span></p>
<p><span class="font2">my ($val, $w) = @_;</span></p>
<p><span class="font2">my $node = Node-&gt;new('constant',</span></p>
<p><span class="font2">sub {},</span></p>
<p><span class="font2">{'W' =&gt; $w},</span></p>
<p><span class="font2">);</span></p>
<p><span class="font2">$w-&gt;set($node, $val);</span></p>
<p><span class="font2">$node;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">The two arguments here are </span><span class="font2">$val</span><span class="font17">, the constant value, and </span><span class="font2">$w</span><span class="font17">, the outgoing wire. The behavior function is trivial and does nothing. The only fine point is that</span></p>
<div>
<p><span class="font20">484</span></p>
</div><br clear="all">
<p><span class="font15">CHAPTER 9 Declarative Programming</span></p>
<p><span class="font17">the constructor needs to notify the attached wire of the outgoing constant value immediately after constructing the node, before anything else happens in the network.</span></p>
<p><span class="font17">Most of the code for IO nodes is for announcing changes in values on the one attached wire. </span><span class="font2">Sannounce </span><span class="font17">is a curried function. Its argument is the name of the IO node, and it returns a behavior function for that node:</span></p>
<p><span class="font2">{</span></p>
<p><span class="font2">my Sannounce = sub {</span></p>
<p><span class="font2">my Sname = shift;</span></p>
<p><span class="font2">sub {</span></p>
<p><span class="font2">my (Sself, %val) = @_;</span></p>
<p><span class="font2">my Sv = Sval{W};</span></p>
<p><span class="font2">if (defined Sv) {</span></p>
<p><span class="font2">print &quot;Sname : Sv\n&quot;;</span></p>
<p><span class="font2">} else {</span></p>
<p><span class="font2">print &quot;Sname : no longer defined\n&quot;;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">};</span></p>
<p><span class="font2">};</span></p>
<ul style="list-style:none;"><li>
<p><span class="font2"># continues...</span></p></li></ul>
<p><span class="font17">The IO node itself is an ordinary node with this announcing behavior:</span></p>
<ul style="list-style:none;"><li>
<p><span class="font2"># continued...</span></p></li></ul>
<p><span class="font2">sub new_io { my (Sname, Sw) = @_; Node-&gt;new('io',</span></p>
<p><span class="font2">Sannounce-&gt;(Sname), { W =&gt; Sw });</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">There are two utility functions exposed to the main program for setting and revoking the values of IO nodes:</span></p>
<p><span class="font2">sub input {</span></p>
<p><span class="font2">my (Sself, Svalue) = @_;</span></p>
<p><span class="font2">Sself-&gt;wire('W')-&gt;set(Sself, Svalue);</span></p>
<p><span class="font2">}</span></p>
<ul style="list-style:none;"><li>
<p class="font15">9.2 LOCAL PROPAGATION NETWORKS <span class="font20">485</span></p></li></ul>
<p><span class="font2">sub revoke {</span></p>
<p><span class="font2">my Sself = shift;</span></p>
<p><span class="font2">Sself-&gt;wire('W')-&gt;revoke(Sself);</span></p>
<p><span class="font2">}</span></p>
<h6><a name="bookmark452"></a><span class="font17">We can now build local propagation networks:</span></h6>
<p><span class="font2">my (SF, SC);</span></p>
<p><span class="font2">{ my (Si, Sj, Sk, Sl, Sm) = Wire-&gt;make(5);</span></p>
<p><span class="font2">SF = new_io('Fahrenheit', Si);</span></p>
<p><span class="font2">SC = new_io('Celsius', Sm);</span></p>
<p><span class="font2">new_constant(32, Sj);</span></p>
<p><span class="font2">new_constant(5/9, Sl);</span></p>
<p><span class="font2">new_adder(Si,Sk,Sj);</span></p>
<p><span class="font2">new_multiplier(Sk,Sl,Sm);</span></p>
<p><span class="font2">}</span></p>
<h6><a name="bookmark453"></a><span class="font17">And now we can use the network to calculate values:</span></h6>
<p><span class="font2">input(SF, 212);</span></p>
<p><span class="font2" style="font-weight:bold;">Celsius : 100 </span><span class="font2">input(SF, 32); </span><span class="font2" style="font-weight:bold;">Celsius : 0 </span><span class="font2">revoke(SF);</span></p>
<p><span class="font2" style="font-weight:bold;">Celsius : no longer defined </span><span class="font2">input(SC, 37);</span></p>
<p><span class="font2" style="font-weight:bold;">Fahrenheit : 98.6</span></p>
<p><span class="font2">input(SF, 100);</span></p>
<p><span class="font2" style="font-weight:bold;">Wire wire3 inconsistent value (100 != 98.6) </span><span class="font2">revoke(SC);</span></p>
<p><span class="font2" style="font-weight:bold;">Fahrenheit : no longer defined </span><span class="font2">input(SF, 100);</span></p>
<p><span class="font2" style="font-weight:bold;">Celsius : 37.7777777777778</span></p>
<h6><a name="bookmark454"></a><span class="font17">We can extend the network to handle kelvins by adding:</span></h6>
<p><span class="font2">my (SF, SC);</span></p>
<p><span class="font2" style="font-weight:bold;">my $K;</span></p>
<p><span class="font2">{ my (Si, Sj, Sk, Sl, Sm) = Wire-&gt;make(5);</span></p>
<p><span class="font2">SF = new_io('Fahrenheit', Si);</span></p>
<p><span class="font2">SC = new_io('Celsius', Sm]); new_constant(32, Sj); new_constant(5/9, Sl); new_adder(Si,Sk,Sj); new_multiplier($k,$l,$m);</span></p>
<p><span class="font2" style="font-weight:bold;">my ($n, $p) = Wire-&gt;make(2); $K = new_io('kelvin', $n); new_constant(273.15, $p); new_adder($m, $p, $n);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">The final adder node expresses the constraint that </span><span class="font17" style="font-style:italic;">C</span><span class="font3"> + </span><span class="font17">273.15 </span><span class="font3">= </span><span class="font17" style="font-style:italic;">K</span><span class="font17">. Note that the wire </span><span class="font2">$m </span><span class="font17">has been attached to three nodes, as shown here.</span></p><img src="HigherOrderPerl_files/HigherOrderPerl-61.jpg" alt="" style="width:157pt;height:117pt;">
<p><span class="font17">These definitions of local propagation networks are quite verbose, but it’s easy to imagine attaching a front-end that would allow the programmer to enter the desired constraints in ordinary algebraic notation:</span></p>
<p><span class="font2">C = (F+32)*5/9 ;</span></p>
<p><span class="font2">K = C + 273.15 ;</span></p>
<p><span class="font17">The front-end would have a parser for expressions like the ones we’ve already seen. The output from the parser would be a constraint network corresponding to the input expressions. Central to the parser would be productions like these, that would build up the appropriate constraint network as the input expression was analyzed:</span></p>
<p><span class="font2">Sexpression = operator($Term,</span></p>
<p><span class="font2">[lookfor(['OP', ' + ']),</span></p>
<table border="1">
<tr><td></td><td>
<p><span class="font15">9.2 LOCAL PROPAGATION NETWORKS &nbsp;&nbsp;</span><span class="font20">487</span></p></td></tr>
<tr><td>
<p><span class="font2">sub {</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">my Ssum = Wire-&gt;new;</span></p>
<p><span class="font2">new_adder(S_[0], $_[1], Ssum); return Ssum;</span></p></td></tr>
</table>
<p><span class="font2">}</span></p>
<p><span class="font2">[lookfor(['OP', '-']),</span></p>
<table border="1">
<tr><td>
<p><span class="font2">sub {</span></p></td><td>
<p><span class="font2">my Sdifference = Wire-&gt;new;</span></p>
<p><span class="font2">new_adder(Sdifference, $_[1], S_[0]); return Sdifference;</span></p></td></tr>
</table>
<p><span class="font2">} );</span></p>
<ul style="list-style:none;"><li>
<h5><a name="bookmark187"></a><span class="font19">9.2.2 Problems with Local Propagation</span></h5></li></ul>
<p><span class="font17">If you’ve ever seen a discussion of local propagation networks before, you’ve probably seen the Fahrenheit-Celsius converter example. There’s a good reason for this: It’s one of the few examples for which local propagation actually works.</span></p>
<p><span class="font17">Let’s consider a different problem, almost as simple. Suppose we’re building a drawing system. A horizontal line has two endpoints at </span><span class="font17" style="font-variant:small-caps;">(</span><span class="font18" style="font-style:italic;font-variant:small-caps;">x</span><span class="font17" style="font-variant:small-caps;">i, </span><span class="font17" style="font-style:italic;">y)</span><span class="font17"> and (</span><span class="font17" style="font-style:italic;">X</span><span class="font15">2</span><span class="font17">, </span><span class="font17" style="font-style:italic;">y). </span><span class="font17">Its center point is at </span><span class="font17" style="font-style:italic;">(c, y</span><span class="font17">), and its length is </span><span class="font17" style="font-style:italic;">l</span><span class="font17">. </span><span class="font17" style="font-style:italic;">y</span><span class="font17"> is independent of the other parameters, but any two of </span><span class="font18" style="font-style:italic;font-variant:small-caps;">x</span><span class="font17" style="font-variant:small-caps;">i, </span><span class="font17" style="font-style:italic;">X</span><span class="font15">2</span><span class="font17">, </span><span class="font17" style="font-style:italic;">c</span><span class="font17">, and </span><span class="font17" style="font-style:italic;">l</span><span class="font17"> determine the other two. We might reason that the center point is the one that is the same distance from each endpoint, and define the center point with the equation:</span></p>
<p><span class="font17" style="font-style:italic;">C — X</span><span class="font8" style="font-style:italic;">1 </span><span class="font17" style="font-style:italic;">= X</span><span class="font8" style="font-style:italic;">2 </span><span class="font17" style="font-style:italic;">— c</span></p>
<p><span class="font17">The length, of course, is the distance between the endpoints:</span></p>
<p><span class="font17" style="font-style:italic;">X</span><span class="font15">2 </span><span class="font3">— </span><span class="font18" style="font-style:italic;font-variant:small-caps;">x</span><span class="font17" style="font-variant:small-caps;">i</span><span class="font3"> = </span><span class="font17" style="font-style:italic;">l</span></p>
<p><span class="font17">These two constraints yield the network shown here.</span></p><img src="HigherOrderPerl_files/HigherOrderPerl-62.jpg" alt="" style="width:129pt;height:87pt;">
<p><span class="font17">If we set </span><span class="font17" style="font-style:italic;">x</span><span class="font8" style="font-style:italic;">i</span><span class="font17"> to 3 and </span><span class="font17" style="font-style:italic;">c</span><span class="font17"> to 5, everything works out. The 5 is propagated along wire </span><span class="font17" style="font-style:italic;">n</span><span class="font17"> to the leftmost </span><span class="font2">+ </span><span class="font17">node, which sets wire </span><span class="font17" style="font-style:italic;">m</span><span class="font17"> to 2. This value, plus the 5 reaching the upper-right </span><span class="font2">+ </span><span class="font17">node along wire </span><span class="font17" style="font-style:italic;">n</span><span class="font17">, causes wire </span><span class="font17" style="font-style:italic;">o</span><span class="font17"> to be set to 7, which is reported as the value of </span><span class="font17" style="font-style:italic;">X</span><span class="font15">2</span><span class="font17">. Wire </span><span class="font17" style="font-style:italic;">o</span><span class="font17">, carrying 7, and wire </span><span class="font17" style="font-style:italic;">p,</span><span class="font17"> carrying </span><span class="font17" style="font-style:italic;">x</span><span class="font15">i</span><span class="font17">’s value of 3, arrive at the lower </span><span class="font2">+ </span><span class="font17">node, allowing the network to deduce that the value of </span><span class="font17" style="font-style:italic;">l</span><span class="font17"> is 4.</span></p>
<p><span class="font17">But suppose instead we set </span><span class="font17" style="font-style:italic;">x</span><span class="font15">i </span><span class="font17">to 3 and </span><span class="font17" style="font-style:italic;">X</span><span class="font15">2 </span><span class="font17">to 7. The two values arrive at the lower </span><span class="font2">+ </span><span class="font17">node, allowing the calculation of </span><span class="font17" style="font-style:italic;">l</span><span class="font17"> as before. But there’s a problem in the upper part of the diagram. Each of the two upper </span><span class="font2">+ </span><span class="font17">nodes has only one defined input. Neither </span><span class="font17" style="font-style:italic;">m</span><span class="font17"> nor </span><span class="font17" style="font-style:italic;">n</span><span class="font17"> is defined, and each is needed for the deduction of the other one. Since wire </span><span class="font17" style="font-style:italic;">n</span><span class="font17"> defines the value of </span><span class="font17" style="font-style:italic;">c</span><span class="font17">, the network has failed. Similarly, although the network above can compute </span><span class="font17" style="font-style:italic;">X</span><span class="font15">2 </span><span class="font17">from </span><span class="font17" style="font-style:italic;">x</span><span class="font15">i </span><span class="font17">and </span><span class="font17" style="font-style:italic;">l</span><span class="font17">, it fails to compute </span><span class="font17" style="font-style:italic;">c</span><span class="font17">.</span></p>
<p><span class="font17">This kind of problem often arises when local constraint networks contain loops. In general, we can’t avoid constraints that result in loops, so we need another technique.</span></p>
<p><span class="font17">One technique that’s commonly used in such cases is called </span><span class="font17" style="font-style:italic;">relaxation.</span><span class="font17"> We tell the network to </span><span class="font17" style="font-style:italic;">guess</span><span class="font17"> a value for </span><span class="font17" style="font-style:italic;">c</span><span class="font17">, and to compute the consequences of the guess. In general, this will result in an inconsistent network. In the preceding example, we might guess that </span><span class="font17" style="font-style:italic;">c</span><span class="font17"> is 0. This means that </span><span class="font17" style="font-style:italic;">n</span><span class="font17"> is 0, and then the two upper addition nodes can compute values for wire </span><span class="font17" style="font-style:italic;">m</span><span class="font17">. The leftmost one computes that </span><span class="font17" style="font-style:italic;">m</span><span class="font17"> is </span><span class="font3">-</span><span class="font17">3, and the rightmost one that </span><span class="font17" style="font-style:italic;">m</span><span class="font17"> is </span><span class="font3">-</span><span class="font17">7. These are inconsistent, so the network averages them, getting </span><span class="font3">-</span><span class="font17">4, and tries that out as a value for </span><span class="font17" style="font-style:italic;">m</span><span class="font17">. If </span><span class="font17" style="font-style:italic;">m</span><span class="font17"> is </span><span class="font3">-</span><span class="font17">4, then the two addition nodes want to set wire </span><span class="font17" style="font-style:italic;">n</span><span class="font17"> to </span><span class="font3">—</span><span class="font17">1 and to 11, respectively. So the network once again tries the average, 5, for </span><span class="font17" style="font-style:italic;">n</span><span class="font17">. This time, the two addition nodes agree that </span><span class="font17" style="font-style:italic;">m</span><span class="font17"> should be 2 — so the relaxation is complete, and has solved the constraint equations.</span></p>
<p><span class="font17">As with nearly all numerical techniques, relaxation is fraught with peril. Sometimes the relaxation process will diverge: Instead of reaching the correct value, the successive steps produce more and more grossly incorrect values. Sometimes the relaxation process converges slowly to the correct values, getting closer and closer but never quite making it.</span></p>
<p><span class="font17">Getting local propagation networks to work well is an active research area. I introduced the technique because it’s an interesting exercise and a good introduction to the idea of constraint systems. But for the rest of the chapter, we’re going to go a different way.</span></p>
<ul style="list-style:none;"><li>
<h5><a name="bookmark188"></a><span class="font18">9.3 LINEAR EQUATIONS</span></h5></li></ul>
<p><span class="font17">As a large example, we’ll develop a system, called </span><span class="font2">linogram</span><span class="font17">, for drawing diagrams.</span></p>
<p><span class="font17">Diagrams are usually drawn with a WYSIWYG structured drawing system. The big drawback of this kind of system is that if you want to change the diagram globally, you essentially have to start over. For example, suppose you were drawing a family tree, and you decided to represent each person with a rectangle 0.75 inches wide by 0.5 inches tall. You get the diagram done, but then you learn that the diagram will need to be printed in landscape mode, rather than portrait mode. You want to make the boxes shorter, to fit on the shorter page, but wider, to fit the text in — say 1 inch wide and only 0.4 inches tall. Also, you want to see how the diagram looks if the corners of the boxes are rounded off.</span></p>
<p><span class="font17">In the typical structured drawing system, you’d have to manually adjust each box and the text inside it. In a declarative drawing system, however, this kind of change is easy. A diagram is like a program, and there is a definition in the program that describes the kind of box you want to use for a person. By changing the definition, you change every box of that type in the entire diagram.</span></p>
<p><span class="font17">In the declarative drawing system, you can tell the computer to calculate the positions and sizes of drawing elements based on the positions and sizes of other elements. So, for example, you can easily tell the system that you want all the squares to be made into rectangles, or all the straight arrows made into curved arrows, or all the parts of the diagram that represent widgets to be drawn with three round knobs instead of two square knobs, just by changing a small part of the description of the diagram.</span></p>
<p><span class="font17">Since the input to the declarative system is a plain text file, it’s also easy to get another program to generate diagrams as output.</span></p>
<p><span class="font17">If we’re going to describe objects by giving constraints, we need some way of solving the constraints to figure out where the objects actually are. As we saw, local propagation won’t do it. In general, the problem is very difficult, because constraints are equations, so solving constraints means solving equations. If solving equations were easy, we wouldn’t have to suffer through four years of high school algebra learning how to do it, and we wouldn’t need mathematicians to figure it out.</span></p>
<p><span class="font17">For general geometric problems, we have to solve general sorts of equations; these may involve higher algebra, or even trigonometry. There is one kind of equation, however, that’s easy to solve. Linear equations are easy. The solution of:</span></p>
<p><span class="font17" style="font-style:italic;">ax</span><span class="font3"> + </span><span class="font17" style="font-style:italic;">b = c</span></p>
<p><span class="font17">is:</span></p>
<p><span class="font17">Because diagrams usually involve many straight lines, linear equations usually do most of what we want. The kind of curves that appear in diagrams are unusually simple and highly constrained. It may require advanced mathematics to find the intersection of a lemniscate and a cardioid, but how often do you draw a diagram with a lemniscate and a cardioid? Diagrams do involve circles (which potentially opens up a can of trigonometric worms), but typically the circle is used as just another kind of box. If we allow drawing elements to be attached to circles only at the “corners” (the northmost, northwestmost, etc. points) then the circle is essentially an octagon as far as the equations are concerned; then once we figure out where the corners are located, we can join them with curves instead of straight sides.</span></p>
<ul style="list-style:none;"><li>
<h5><a name="bookmark189"></a><span class="font18">9.4 </span><span class="font3">linogram </span><span class="font18">:A DRAWING SYSTEM</span></h5></li></ul>
<p><span class="font17">The entities with which our program deals are called </span><span class="font17" style="font-style:italic;">features.</span><span class="font17"> A feature represents something like a box or a line. It might contain sub-features; for example, a box feature contains four sub-features that represent its four sides. A feature also contains a list of constraint equations that define the relationships between its sub-features; for example, in a box feature, the top and left sides are constrained to start at the same point.</span></p>
<p><span class="font17">The input to the drawing system will be a specification for a large compound feature, called the </span><span class="font17" style="font-style:italic;">root feature,</span><span class="font17"> which represents the entire drawing. Here’s an example specification for a root feature:</span></p>
<p><span class="font2">box F, plus, con32, times, C, con59;</span></p>
<p><span class="font2">line i, j, k, l, m;</span></p>
<p><span class="font2">number hspc, vspc, boxht, boxwd;</span></p>
<p><span class="font2">constraints {</span></p>
<p><span class="font2">boxht = 1; boxwd = 1;</span></p>
<p><span class="font2">hspc = 1 + boxwd; vspc = 1 + boxht;</span></p>
<p><span class="font2">F.ht = boxht; F.wd = boxwd;</span></p>
<p><span class="font2">plus = F + (hspc, 0);</span></p>
<p><span class="font2">con32 = plus + (hspc, 0);</span></p>
<p><span class="font2">times = plus + (0, vspc);</span></p>
<p><span class="font2">C = times + (hspc, 0);</span></p>
<p><span class="font2">con59 + (hspc, 0) = times;</span></p>
<ul style="list-style:none;"><li>
<p><span class="font2">i. start = F.e; &nbsp;&nbsp;&nbsp;i.end = plus.nw;</span></p></li></ul>
<p><span class="font2">j. start = plus.e; j.end = con32.w;</span></p>
<p><span class="font2">k. start = plus.sw; k.end = times.nw;</span></p>
<ul style="list-style:none;"><li>
<p><span class="font2">l. start = con59.e; l.end = times.sw;</span></p></li></ul>
<p><span class="font2">m. start = times.e; m.end = C.w;</span></p>
<p><span class="font2">F.nw = (0,0);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">The first three lines declare the sub-features of the root feature; it contains six boxes, five lines, and four numbers. Numbers are primitive, and don’t contain sub-features. The numbers </span><span class="font2">hspc </span><span class="font17">and </span><span class="font2">vspc </span><span class="font17">will be used to determine the amount of space between the boxes. If we want to move all the boxes closer together in the horizontal direction, we will need only to change the definition of </span><span class="font2">hspc </span><span class="font17">to a smaller value. Similarly, </span><span class="font2">boxht </span><span class="font17">and </span><span class="font2">boxwd </span><span class="font17">will be the height and width of each of the six boxes.</span></p>
<p><span class="font17">The </span><span class="font2">constraints </span><span class="font17">section is the really interesting part. It’s a list of linear equations that specify the sizes and relative locations of the boxes and lines. The first four equations define the four numeric parameters </span><span class="font2">boxht</span><span class="font17">, </span><span class="font2">boxwd</span><span class="font17">, </span><span class="font2">hspc</span><span class="font17">, and </span><span class="font2">vspc</span><span class="font17">. </span><span class="font2">hspc </span><span class="font17">represents the minimum center-to-center horizontal separation of two nearby boxes, so it’s defined in terms of </span><span class="font2">boxwd</span><span class="font17">: The distance between the two centers is the width of one box, plus one unit of space.</span></p>
<p><span class="font17">The next two equations define the height and the width of the </span><span class="font2">F </span><span class="font17">box by establishing constraints on its subfeatures </span><span class="font2">F.ht </span><span class="font17">and </span><span class="font2">F.wd</span><span class="font17">. The definition of the </span><span class="font2">box </span><span class="font17">type (which we’ll see later) contains a declaration like:</span></p>
<p><span class="font2">number ht, wd;</span></p>
<p><span class="font17">to say that every box has these two properties, and other declarations that relate these numbers to the positions of the four sides.</span></p>
<p><span class="font17">The next equation,</span></p>
<p><span class="font2">plus = F + (hspc, 0);</span></p>
<p><span class="font17">constrains the size, shape, and position of the </span><span class="font2">plus </span><span class="font17">box. The </span><span class="font2">(hspc, 0) </span><span class="font17">is called a </span><span class="font17" style="font-style:italic;">tuple expression</span><span class="font17"> and represents a displacement. The constraint says that the box </span><span class="font2">plus </span><span class="font17">is exactly like </span><span class="font2">F</span><span class="font17">, only displaced eastward by </span><span class="font2">hspc </span><span class="font17">units and southward by 0 units. Internally, this will translate into a series of constraints that force each of </span><span class="font2">plus</span><span class="font17">’s four corners and four sides to be </span><span class="font2">hspc </span><span class="font17">units east and 0 units south of the corresponding corners and sides of </span><span class="font2">F</span><span class="font17">.</span></p>
<p><span class="font17">Although this equation looks like an assignment, it isn’t; it’s a declaration. If </span><span class="font2">linogram </span><span class="font17">knows about </span><span class="font2">F</span><span class="font17">, it can deduce the corresponding information about </span><span class="font2">plus — </span><span class="font17">or vice versa. It can also deduce complete information about both from partial information. For example, if only the left side of </span><span class="font2">F </span><span class="font17">and the top side of </span><span class="font2">plus </span><span class="font17">are known, then the other sides of the two boxes can all be deduced: The left side of </span><span class="font2">plus </span><span class="font17">is like the left side of </span><span class="font2">F</span><span class="font17">, and the top side of </span><span class="font2">F </span><span class="font17">is like the top side of </span><span class="font2">plus</span><span class="font17">.</span></p>
<p><span class="font17">We could also have written this equation in any of these mathematically equivalent forms:</span></p>
<p><span class="font2">F + (hspc, 0) = plus;</span></p>
<p><span class="font2">plus + (-hspc, 0) = F;</span></p>
<p><span class="font2">plus - F = (-hspc, 0);</span></p>
<p><span class="font2">plus - (hspc, 0) - F = 0;</span></p>
<p><span class="font17">Sometimes it’s convenient to write equations like this. For example, suppose we have four features, </span><span class="font2">A</span><span class="font17">, </span><span class="font2">B</span><span class="font17">, </span><span class="font2">C</span><span class="font17">, and </span><span class="font2">D</span><span class="font17">. We’re not sure where </span><span class="font2">A</span><span class="font17">, </span><span class="font2">B</span><span class="font17">, and </span><span class="font2">C </span><span class="font17">are, but we know that we want </span><span class="font2">D</span><span class="font17">’s position relative to </span><span class="font2">C </span><span class="font17">to be the same as </span><span class="font2">B</span><span class="font17">’s position relative to </span><span class="font2">A — </span><span class="font17">if </span><span class="font2">B </span><span class="font17">is one furlong due north of </span><span class="font2">A</span><span class="font17">, we want </span><span class="font2">D </span><span class="font17">one furlong due north of </span><span class="font2">C</span><span class="font17">, or whatever. It’s quite straightforward and intuitive to express it like this:</span></p>
<p><span class="font2">D - C = B - A;</span></p>
<p><span class="font17">Or suppose we wanted point </span><span class="font2">Z </span><span class="font17">to be one-third of the way from </span><span class="font2">X </span><span class="font17">to </span><span class="font2">Y </span><span class="font17">along the straight line between them:</span></p>
<p><span class="font2">Z - X = 1/3 * (Y - X);</span></p>
<p><span class="font17">In addition to a height and a width, every box has thirteen more subfeatures: four lines and nine points. The lines represent the four sides, and are named </span><span class="font2">top</span><span class="font17">, </span><span class="font2">bottom</span><span class="font17">, </span><span class="font2">left</span><span class="font17">, and </span><span class="font2">right</span><span class="font17">. The points aren’t strictly necessary, but they’re convenient. They are the four corner points, called </span><span class="font2">nw</span><span class="font17">, </span><span class="font2">ne</span><span class="font17">, </span><span class="font2">sw</span><span class="font17">, and </span><span class="font2">se</span><span class="font17">, the midpoints of the four sides, called </span><span class="font2">n</span><span class="font17">, </span><span class="font2">s</span><span class="font17">, </span><span class="font2">e</span><span class="font17">, and </span><span class="font2">w</span><span class="font17">, and the center point, called </span><span class="font2">c</span><span class="font17">.</span></p>
<p><span class="font17">Similarly, aline contains two sub-features, called </span><span class="font2">start </span><span class="font17">and </span><span class="font2">end</span><span class="font17">, that denote its two endpoints.</span></p>
<p><span class="font17">The next few declarations in our specification define the endpoints of the five lines </span><span class="font2">i </span><span class="font17">through </span><span class="font2">m</span><span class="font17">.</span></p>
<p><span class="font17">The declarations:</span></p>
<p><span class="font2">i.start = F.e; i.end = plus.nw; </span><span class="font17">constrain line </span><span class="font2">i </span><span class="font17">to start at the midpoint of </span><span class="font2">F</span><span class="font17">’s east side, and to end at the northwest corner of box </span><span class="font2">plus</span><span class="font17">.</span></p>
<p><span class="font17">Finally, we have to tell the program the absolute location of at least one of the features, or it won’t be able to figure out where anything is located. We force the issue by attaching the northwest corner of box </span><span class="font2">F </span><span class="font17">arbitrarily to </span><span class="font2">(0,0)</span><span class="font17">, although it doesn’t really matter; we could as easily have attached any other point of any of the boxes.</span></p>
<p><span class="font17">In addition to these manifest constraints, there are a large number of hidden constraints that we don’t see, inherent in the definitions of the </span><span class="font2">box </span><span class="font17">and </span><span class="font2">line </span><span class="font17">types. For example, the definition of </span><span class="font2">box </span><span class="font17">has, among others,</span></p>
<p><span class="font2">top.start = left.start;</span></p>
<p><span class="font2">nw = top.start;</span></p>
<p><span class="font2">top.start + wd = top.end;</span></p>
<p><span class="font2">n = top.center;</span></p>
<p><span class="font17">and the definition of </span><span class="font2">line </span><span class="font17">has:</span></p>
<p><span class="font2">center = (start + end)/2;</span></p>
<p><span class="font17">Again, although this looks like an assignment, it isn’t; it’s symmetric. If the start and end points of the line are known, the center will be calculated from them; if the start and center are known instead, the position of the end point will be calculated instead. Any two of the points imply the third.</span></p>
<p><span class="font17">The program’s strategy for drawing a diagram is as follows. First it will read in the definition of the root feature, including the implied definitions of common sub-features such as </span><span class="font2">box</span><span class="font17">. It will accumulate a large set of linear constraint equations. These will include the explicit constraints, as well as many automatically generated implicit constraints. If the root feature contains a </span><span class="font2">box </span><span class="font17">named </span><span class="font2">F</span><span class="font17">, then it will also include </span><span class="font2">F</span><span class="font17">’s constraints implicitly, in the form of equations like these:</span></p>
<p><span class="font2">F.top.start = F.left.start;</span></p>
<p><span class="font2">F.nw = F.top.start;</span></p>
<p><span class="font2">F.top.start + F.wd = F.top.end;</span></p>
<p><span class="font2">F.n = F.top.center;</span></p>
<p><span class="font2">...</span></p>
<p><span class="font17">In fact, since </span><span class="font2">F </span><span class="font17">itself contains several sub-features, it will inherit constraints from these. </span><span class="font2">F</span><span class="font17">’s top side is a line, so </span><span class="font2">F </span><span class="font17">will inherit the constraint:</span></p>
<p><span class="font2">top.center = (top.start + top.end)/2;</span></p>
<div>
<p><span class="font20">494</span></p>
</div><br clear="all">
<p><span class="font15">CHAPTER 9 Declarative Programming</span></p>
<p><span class="font17">from the definition of </span><span class="font2">line</span><span class="font17">; this will in turn be inherited by the root feature as:</span></p>
<p><span class="font2">F.top.center = (F.top.start + F.top.end)/2;</span></p>
<p><span class="font17">After accumulating all the constraint equations, the program will solve the equations. The result will be a complete description of where every part of each feature is located.</span></p>
<p><span class="font17">Associated with each feature will be one or more drawing functions. The program will invoke the drawing functions for each feature, passing them a hash containing the relevant variables. It’s up to the drawing functions to generate the appropriate output. The output might be instructions in PostScript to be sent to a printer, or perhaps a “canvas” object containing a bitmap of the finished diagram.</span></p>
<p><span class="font17">Before we go any further with the main program, let’s look at the definitions of the simpler sub-features such as boxes, which will be instructive. The simplest features that the program deals with are numbers, which are atomic. These are the only features whose definitions are built into the program. All other features are defined by a library file that specifies the feature’s sub-features, constraints, and drawing methods.</span></p>
<p><span class="font17">After a number, the simplest feature is a </span><span class="font2">point</span><span class="font17">, which has </span><span class="font2">x </span><span class="font17">and </span><span class="font2">y </span><span class="font17">coordinates, but no constraints on them:</span></p>
<p><span class="font2">define point { number x, y;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">When </span><span class="font2">linogram </span><span class="font17">wants to draw a feature, its default behavior is to recursively draw all the feature’s sub-features. Thus it draws a </span><span class="font2">point </span><span class="font17">by trying to “draw” the two numbers </span><span class="font2">x </span><span class="font17">and </span><span class="font2">y</span><span class="font17">. Numbers are considered to be invisible, so the aggregate behavior for drawing a point is also to do nothing. The simplest visible feature is a line, which has start and end points:</span></p>
<p><span class="font2">define line {</span></p>
<p><span class="font2">point start, end, center;</span></p>
<p><span class="font2">constraints { center = (start + end)/2; }</span></p>
<p><span class="font2">draw { &amp;draw_line; }</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">As mentioned before, a line also has a </span><span class="font2">center </span><span class="font17">point, for convenience; it’s constrained to be halfway between the start and end points (see Figure 9.3).</span></p><img src="HigherOrderPerl_files/HigherOrderPerl-63.jpg" alt="" style="width:210pt;height:68pt;">
<p><span class="font14">FIGURE 9.3 </span><span class="font16">A line and its subfeatures.</span></p>
<p><span class="font17">The </span><span class="font2">draw </span><span class="font17">section is new. The declaration shown here is the name of a Perl subroutine responsible for drawing the feature. The </span><span class="font2">&amp;&nbsp;</span><span class="font17">is a lexical marker that indicates that this is the name of a subroutine. When invoked, the subroutine will be passed a hash that indicates the positions of the sub-features of the line:</span></p>
<p><span class="font2">(&quot;start.x&quot; =&gt; 5, &quot;start.y&quot; =&gt; 3,</span></p>
<p><span class="font2">&quot;end.x&quot; =&gt; 3, &quot;end.y&quot; =&gt; 7,</span></p>
<p><span class="font2">&quot;center.x&quot; =&gt; 4, &quot;center.y&quot; =&gt; 5,</span></p>
<p><span class="font2">)</span></p>
<p><span class="font17">If any of the sub-features are unknown, they’ll be omitted from the hash; in that case, the function should complain. Since this chapter is about declarative programming, and not about graphics, we’ll weasel out of doing any actual drawing, and use the following drawing function, which claims to draw lines even though it doesn’t really draw anything. It does, however, give us a clear description of the line it </span><span class="font17" style="font-style:italic;">would have</span><span class="font17"> drawn, which is enough to see whether the program is doing what it should be doing:</span></p>
<p><span class="font2">sub draw_line {</span></p>
<p><span class="font2">my $env = shift;</span></p>
<p><span class="font2">my $GOOD = 1;</span></p>
<p><span class="font2">for my $k (qw(start.x start.y end.x end.y)) {</span></p>
<p><span class="font2">unless (defined $env-&gt;{$k}) {</span></p>
<p><span class="font2">warn &quot;Can’t draw line because '$k' is missing\n&quot;;</span></p>
<p><span class="font2">$GOOD = 0;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">if ($GOOD) {</span></p>
<p><span class="font2">print &quot;Drawing line from ($env-&gt;{'start.x'}, $env-&gt;{'start.y'}) to ($env-&gt;{'end.x'}, $env-&gt;{'end.y'})\n&quot;;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">Given the preceding hash, this will produce the output:</span></p>
<p><span class="font2">Drawing line from (5, 3) to (3, 7)</span></p>
<p><span class="font17">Even though we weaseled out of the drawing, creating a diagram in PostScript is barely more difficult. We would need to generate output something like this:</span></p>
<p><span class="font2">50 30 moveto 30 70 lineto stroke</span></p>
<p><span class="font17">This is almost the same, but there are a (very) few additional complications that I didn’t want to have to consider, so we’ll stick with the weasel drawing technique.</span></p>
<p><span class="font17">The other possible inhabitants of a </span><span class="font2">draw </span><span class="font17">section are the names of some of the sub-features that make up the feature. Only these sub-features will be drawn. If there is no </span><span class="font2">draw </span><span class="font17">section at all, the default is to draw all the sub-features.</span></p>
<p><span class="font17">We have enough machinery now to define boxes directly, but </span><span class="font2">linogram</span><span class="font17">’s standard library goes through a set of intermediate definitions first. The top and bottom sides of a box are constrained to be horizontal, and it’s convenient to define a new feature type to represent a horizontal line:</span></p>
<p><span class="font2">define hline extends line {</span></p>
<p><span class="font2">number y, length;</span></p>
<p><span class="font2">constraints {</span></p>
<p><span class="font2">start.y = end.y;</span></p>
<p><span class="font2">start.y = y;</span></p>
<p><span class="font2">start.x + length = end.x;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">This defines a new type, called </span><span class="font2">hline</span><span class="font17">, which has all of the sub-features and constraints that an ordinary </span><span class="font2">line </span><span class="font17">has, and some additional ones. The start and end points must have the same </span><span class="font17" style="font-style:italic;">j</span><span class="font17">-coordinate, and an </span><span class="font2">hline </span><span class="font17">also has an additional sub-feature, called </span><span class="font2">y</span><span class="font17">, which is defined to be equal to this </span><span class="font17" style="font-style:italic;">j</span><span class="font17">-coordinate. If we were trying to specify the location of a box </span><span class="font2">F</span><span class="font17">, this would allow us to abbreviate </span><span class="font2">F.top.start.y </span><span class="font17">as simply </span><span class="font2">F.top.y</span><span class="font17">, which is more natural. An </span><span class="font2">hline </span><span class="font17">also has a length, which is the distance between the endpoints. In general, the length of a line is not a linear function of the positions of the endpoints (because </span><span class="font17" style="font-style:italic;">length = sqrt((end.x — start.x</span><span class="font17">)<sup>2</sup> </span><span class="font3">+ </span><span class="font17" style="font-style:italic;">(end</span><span class="font17">.</span><span class="font17" style="font-style:italic;">j</span><span class="font3"> — </span><span class="font17" style="font-style:italic;">start</span><span class="font17">.</span><span class="font17" style="font-style:italic;">j</span><span class="font17">)<sup>2</sup>)) and computing one point given the length and the other endpoint requires trigonometry, which </span><span class="font2">linogram </span><span class="font17">won’t do. But for horizontal lines, the calculation is trivial.</span></p>
<p><span class="font17">The constraints in this definition are adjoined to those inherited from </span><span class="font2">line</span><span class="font17">, which imply the position of the </span><span class="font2">center </span><span class="font17">point of an </span><span class="font2">hline</span><span class="font17">, even though we never</span></p>
<ul style="list-style:none;"><li>
<p class="font15">9.4 <span class="font2">linogram: </span><span class="font15" style="font-variant:small-caps;">a drawing system</span></p></li></ul>
<p><span class="font17">mentioned it explicitly. The </span><span class="font2">draw </span><span class="font17">section is also inherited from </span><span class="font2">line</span><span class="font17">, so that the Perl </span><span class="font2">draw_line </span><span class="font17">function will be used for </span><span class="font2">hline </span><span class="font17">as well.</span></p>
<p><span class="font17">Vertical lines are almost exactly the same:</span></p>
<p><span class="font2">define vline extends line { number x, height; constraints { start.x = end.x; start.x = x;</span></p>
<p><span class="font2">start.y + height = end.y;</span></p>
<p><span class="font2">} }</span></p>
<h6><a name="bookmark455"></a><span class="font17">Now we’re ready to define </span><span class="font2">box</span><span class="font17">. It has a lot of machinery, but none of it is new:</span></h6>
<p><span class="font2">define box { vline left, right; hline top, bottom; point nw, n, ne, e, se, s, sw, w, c; number ht, wd;</span></p>
<p><span class="font2">constraints { left.start = top.start; right.start = top.end; left.end = bottom.start; right.end = bottom.end;</span></p>
<p><span class="font2">nw = left.start; ne = right.start; sw = left.end; se = right.end; n = top.center;</span></p>
<p><span class="font2">s = bottom.center; w = left.center; e = right.center;</span></p>
<p><span class="font2">c = (n + s)/2;</span></p>
<p><span class="font2">ht = left.height; wd = top.length;</span></p>
<p><span class="font2">} }</span></p>
<div>
<p><span class="font20">497</span></p>
</div><br clear="all">
<div>
<p><span class="font20">498</span></p>
</div><br clear="all">
<p><span class="font15">CHAPTER 9 Declarative Programming</span></p>
<div>
<p><span class="font2">ht</span></p>
</div><br clear="all">
<div>
<p><span class="font2">top</span></p>
</div><br clear="all">
<p><span class="font2">bottom</span></p>
<p><span class="font2">-----------wd -----------►</span></p>
<p><span class="font14">FIGURE 9.4 </span><span class="font16">A box and its subfeatures.</span></p>
<p><span class="font17">A box has a left and a right side, which are </span><span class="font2">vline</span><span class="font17">s, and a top and a bottom side, which are </span><span class="font2">hline</span><span class="font17">s. It has nine named points, which are identical to various parts of the four sides, except for </span><span class="font2">c</span><span class="font17">, the center, which is halfway between the north and south points. It also has a height and a width, which are the same as the lengths of the left and top sides, respectively (see Figure 9.4). We didn’t need to require that </span><span class="font2">ht = right.height</span><span class="font17">; this is already implicit in the other equations, although it wouldn’t have hurt to put it in.</span></p>
<p><span class="font17">The </span><span class="font2">box </span><span class="font17">definition doesn’t contain a </span><span class="font2">draw </span><span class="font17">section. The default behavior is for </span><span class="font2">linogram </span><span class="font17">to draw a box by drawing each of its fifteen sub-features. For the nine points and the two numbers, this does nothing at all; the other four subfeatures are the four sides, which </span><span class="font2">linogram </span><span class="font17">draws by calling </span><span class="font2">draw_line</span><span class="font17">. Each box will therefore result in four calls to </span><span class="font2">draw_line</span><span class="font17">, which is just what we want.</span></p>
<p><span class="font17">To define a square, we need only write:</span></p>
<p><span class="font2">define square extends box { constraints { ht = wd; }</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">which defines a </span><span class="font2">square </span><span class="font17">to be the same as a </span><span class="font2">box </span><span class="font17">but with the height and width constrained to be equal. Another common constituent of diagrams is an arrow. From </span><span class="font2">linogram</span><span class="font17">’s point of view, this is nothing more than an oddly-drawn line:</span></p>
<p><span class="font2">define arrow extends line { draw { &amp;draw_arrow; }</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">An arrow has a start and end point, just like a line; these are the start and end points of the arrow’s shaft. The </span><span class="font2">draw_arrow </span><span class="font17">function is responsible for drawing the shaft (which it can do by calling </span><span class="font2">draw_line</span><span class="font17">) and then filling in the two whiskers at the endpoint.</span></p>
<p><span class="font17">If we’re feeling creative, we might go on:</span></p>
<p><span class="font2">define golden_rectangle extends box { constraints { ht * 1.618 = wd; }</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">define circle {</span></p>
<p><span class="font2">number r, d;</span></p>
<p><span class="font2">point c, nw, n, ne, e, se, s, sw, w; constraints {</span></p>
<p><span class="font2">d = 2*r;</span></p>
<p><span class="font2">n = c - (0, r);</span></p>
<p><span class="font2">s = c + (0, r);</span></p>
<p><span class="font2">e = c + (r, 0);</span></p>
<p><span class="font2">w = c - (r, 0);</span></p>
<p><span class="font2">se = c + ( r, r)/1.4142;</span></p>
<p><span class="font2">sw = c + (-r, r)/1.4142;</span></p>
<p><span class="font2">ne = c + ( r,-r)/1.4142;</span></p>
<p><span class="font2">nw = c + (-r,-r)/1.4142;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">draw { &amp;draw_circle; }</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">define diamond extends box { line nw_side(start=n, end=w), sw_side(start=s, end=w), ne_side(start=n, end=e), se_side(start=s, end=e);</span></p>
<p><span class="font2">draw { nw_side;</span></p>
<p><span class="font2">sw_side;</span></p>
<p><span class="font2">ne_side;</span></p>
<p><span class="font2">se_side;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">The </span><span class="font2">nw_side(start=n, end=w) </span><span class="font17">declaration in the last definition is a shorthand for:</span></p>
<p><span class="font2">line nw_side;</span></p>
<p><span class="font2">constraints { nw_side.start = n;</span></p>
<p><span class="font2">nw_side.end = w;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">linogram </span><span class="font17">has a few other features, but we’ll see them in the course of seeing the program code. The program code comprises three major classes and several less-important classes. The three major classes are </span><span class="font2">Constraint</span><span class="font17">, which represents constraints; </span><span class="font2">Type</span><span class="font17">, which represents feature types such as </span><span class="font2">box </span><span class="font17">and </span><span class="font2">line</span><span class="font17">; and </span><span class="font2">Value</span><span class="font17">, which represents the value of an expression as it is being converted to a set of constraints. We’ll see constraints and equations first.</span></p>
<ul style="list-style:none;"><li>
<h5><a name="bookmark190"></a><span class="font19">9.4.1 Equations</span></h5></li></ul>
<p><span class="font17">The heart of </span><span class="font2">linogram </span><span class="font17">will be the module that solves systems of linear equations. The usual way to do this is to represent the system as a matrix, and then perform sequences of matrix transformations on it until the matrix is in a canonical form; this is called </span><span class="font17" style="font-style:italic;">Gaussian elimination.</span><span class="font17"> Methods for doing this are well studied, and also available on CPAN. But for various reasons, the CPAN modules I found for solving linear equations didn’t seem to be what I wanted, so I’ll develop one here.</span></p>
<p><span class="font17">An </span><span class="font2">Equation </span><span class="font17">object is a hash. The equation:</span></p>
<p><span class="font17" style="font-style:italic;">14x</span><span class="font3"> + </span><span class="font17" style="font-style:italic;">9y - 3.5z =</span><span class="font17"> 28</span></p>
<p><span class="font17">is represented by the hash:</span></p>
<p><span class="font2">{ &quot;x&quot; =&gt; 14,</span></p>
<p><span class="font2">&quot;y&quot; =&gt; 9,</span></p>
<p><span class="font2">&quot;z&quot; =&gt; -3.5,</span></p>
<p><span class="font2">&quot;&quot; =&gt; -28,</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">The values 14, 9, and </span><span class="font3">-</span><span class="font17">3.5, are called the </span><span class="font17" style="font-style:italic;">coefficients</span><span class="font17"> of </span><span class="font17" style="font-style:italic;">x</span><span class="font17">,</span><span class="font17" style="font-style:italic;">y</span><span class="font17">, and </span><span class="font17" style="font-style:italic;">z,</span><span class="font17"> respectively. The </span><span class="font3">-</span><span class="font17">28 is the </span><span class="font17" style="font-style:italic;">constant part.</span><span class="font17"> It’s negative because the equation is actually:</span></p>
<p><span class="font17">14</span><span class="font17" style="font-style:italic;">x</span><span class="font3"> + </span><span class="font17">9</span><span class="font17" style="font-style:italic;">y</span><span class="font3"> - </span><span class="font17">3.5</span><span class="font17" style="font-style:italic;">z</span><span class="font3"> - </span><span class="font17">28 </span><span class="font3">= </span><span class="font17">0</span></p>
<ul style="list-style:none;"><li>
<p class="font15">9.4 <span class="font2">linogram: </span><span class="font15" style="font-variant:small-caps;">a drawing system</span><span class="font20"> 501</span></p></li></ul>
<p><span class="font17">The &quot;&quot;&nbsp;key in the hash is mandatory because every linear equation has a constant part, even if the constant part is 0. The equation:</span></p>
<p><span class="font17" style="font-style:italic;">x =</span><span class="font17"> 0</span></p>
<p><span class="font17">corresponds to the hash:</span></p>
<p><span class="font2">{ &quot;x&quot; =&gt; 1, &quot;&quot;&nbsp;=&gt; 0, }</span></p>
<p><span class="font17">and the trivial equation 0 </span><span class="font3">= </span><span class="font17">0 is represented by the hash </span><span class="font2">{ &quot;&quot;&nbsp;=&gt; 0 }</span><span class="font17">.</span></p>
<p><span class="font17">Manipulating equations through these hashes is straightforward and easy to debug, although slow. If speed is an issue, the </span><span class="font2">Equation </span><span class="font17">module of the program should be replaced with one that uses a more abbreviated representation of equations, perhaps one implemented in C.</span></p>
<p><span class="font17">The constructor function takes an argument hash and puts it into a canonical form: </span><span class="font2">sub new {</span></p>
<div>
<p><span class="font9" style="font-weight:bold;">CODE LIBRARY</span></p>
</div><br clear="all">
<p><span class="font2">my ($base, %self) = @_; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="font0"><sup>Equation</sup>.<sup>pm</sup></span></p>
<p><span class="font2">$class = ref($base) || $base; $self{&quot;&quot;} = 0 unless exists $self{&quot;&quot;}; for my $k (keys %self) {</span></p>
<p><span class="font2">if ($self{$k} == 0 &amp;&amp;&nbsp;$k ne &quot;&quot;) { delete $self{$k} } } bless \%self =&gt; $class; }</span></p>
<p><span class="font17">If the constant part is missing, the constructor sets it to 0; if the coefficients of any of the variables are 0, they are deleted. For example, </span><span class="font2">-&gt;new(&quot;x&quot; =&gt; 0, &quot;y&quot; =&gt; 1)</span><span class="font17">, which represents 0</span><span class="font17" style="font-style:italic;">x</span><span class="font3"> + </span><span class="font17" style="font-style:italic;">1y =</span><span class="font17"> 0, is turned into </span><span class="font2">{ &quot;y&quot; =&gt; 1, &quot;&quot;&nbsp;=&gt; 0 }</span><span class="font17">.</span></p>
<p><span class="font3">ref($base) || $base</span></p>
<p><span class="font17">One idiom used here and elsewhere that you may not have seen is the </span><span class="font2">ref($base) || $base </span><span class="font17">trick. The goal is to write a function that can be called as either an object or a class method, either as:</span></p>
<p><span class="font2">Equation-&gt;new(...)</span></p>
<p><span class="font17">or as;</span></p>
<p><span class="font2">Ssome_equation-&gt;new(...)</span></p>
<p><span class="font17">In the former case, </span><span class="font2">Sbase </span><span class="font17">is the string </span><span class="font2">Equation</span><span class="font17">, and </span><span class="font2">ref Sbase </span><span class="font17">is false, since </span><span class="font2">Sbase </span><span class="font17">is a string rather than a reference. </span><span class="font2">Sclass </span><span class="font17">is therefore set equal to </span><span class="font2">Sbase</span><span class="font17">. In the latter case, </span><span class="font2">Sbase </span><span class="font17">is the object </span><span class="font2">Ssome_equation</span><span class="font17">, and </span><span class="font2">ref(Sbase) </span><span class="font17">is the class into which </span><span class="font2">Ssome_equation </span><span class="font17">was blessed. </span><span class="font2">Sclass </span><span class="font17">is therefore set equal to </span><span class="font2">Ssome_equation</span><span class="font17">’s class. This is convenient when we’ll be writing several other constructor methods that might get an </span><span class="font2">Equation </span><span class="font17">object as an argument and will want to create another object similar to it. For example, here’s a method that makes a copy of an </span><span class="font2">Equation </span><span class="font17">object:</span></p>
<p><span class="font2">sub duplicate {</span></p>
<p><span class="font2">my Sself = shift;</span></p>
<p><span class="font2">$self-&gt;new(%$self);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">Note that:</span></p>
<p><span class="font2"># WRONG!</span></p>
<p><span class="font2">sub duplicate {</span></p>
<p><span class="font2">my Sself = shift;</span></p>
<p><span class="font2" style="font-weight:bold;">Equation-&gt;new(%$self);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">doesn’t work properly if its argument is an object of a class derived from </span><span class="font2">Equation</span><span class="font17">. The correct code creates a new object from the same derived subclass; the incorrect code creates a new </span><span class="font2">Equation </span><span class="font17">object regardless.</span></p>
<p><span class="font17">SOLVING EQUATIONS</span></p>
<p><span class="font17">For convenience, we set up a constant for the important trivial equation 0 </span><span class="font3">= </span><span class="font17">0:</span></p>
<p><span class="font2">BEGIN { SZero = Equation-&gt;new() }</span></p>
<p><span class="font17">Equations have three important accessors. One retrieves the coefficient of a given variable:</span></p>
<p><span class="font2">sub coefficient { my (Sself, Sname) = @_;</span></p>
<ul style="list-style:none;"><li>
<p class="font15">9.4 <span class="font2">linogram: </span><span class="font15" style="font-variant:small-caps;">a drawing system</span><span class="font20"> 503</span></p></li></ul>
<p><span class="font2">$self-&gt;{$name} || 0; }</span></p>
<p><span class="font17">The second recovers the constant part:</span></p>
<p><span class="font2"># Constant part of an equation</span></p>
<p><span class="font2">sub constant {</span></p>
<p><span class="font2">$_[0]-&gt;coefficient(&quot;&quot;);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">The other returns the names of all the variables that the equation mentions:</span></p>
<p><span class="font2">sub varlist {</span></p>
<p><span class="font2">my Sself = shift;</span></p>
<p><span class="font2">grep S_ ne &quot;&quot;, keys %Sself;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">All equations can be scaled and added. If an equation is known to be true, you can multiply its constant and its coefficients by any number </span><span class="font17" style="font-style:italic;">n,</span><span class="font17"> and the resulting equation is also true. For example, if:</span></p>
<p><span class="font17" style="font-style:italic;">14x</span><span class="font3"> + </span><span class="font17" style="font-style:italic;">9y - 3.5z =</span><span class="font17"> 28</span></p>
<p><span class="font17">then we can scale all the numbers by 2 and get:</span></p>
<p><span class="font17">28</span><span class="font17" style="font-style:italic;">x</span><span class="font3"> + </span><span class="font17">18</span><span class="font17" style="font-style:italic;">y</span><span class="font3"> - </span><span class="font17" style="font-style:italic;">7z =</span><span class="font17"> 56</span></p>
<p><span class="font17">which is equivalent.</span></p>
<p><span class="font17">If we have two equations that are true, we can add them together and get another true equation. For example, suppose we have:</span></p>
<p><span class="font17" style="font-style:italic;">x =</span><span class="font17"> 13</span></p>
<p><span class="font17">2</span><span class="font17" style="font-style:italic;">y =</span><span class="font17"> 7</span></p>
<p><span class="font17">we can add these, getting:</span></p>
<p><span class="font17" style="font-style:italic;">x</span><span class="font3"> + </span><span class="font17">2</span><span class="font17" style="font-style:italic;">y</span><span class="font3"> = </span><span class="font17">20</span></p>
<div>
<p><span class="font20">504</span></p>
</div><br clear="all">
<p><span class="font15">CHAPTER 9 Declarative Programming</span></p>
<p><span class="font17">These two operations are fundamental equations. For example, suppose we have:</span></p>
<div>
<p><span class="font17">to all methods of solving linear</span></p>
</div><br clear="all">
<p><span class="font17" style="font-style:italic;">x</span><span class="font3"> + </span><span class="font17" style="font-style:italic;">y =</span><span class="font17"> 12</span></p>
<p><span class="font17" style="font-style:italic;">x — y =</span><span class="font17"> 2</span></p>
<p><span class="font17">If we add these two equations together, the </span><span class="font3">+</span><span class="font17" style="font-style:italic;">y</span><span class="font17"> in the first and the </span><span class="font3">—</span><span class="font17" style="font-style:italic;">y</span><span class="font17"> in the second cancel, yielding:</span></p>
<p><span class="font17">2</span><span class="font17" style="font-style:italic;">x</span><span class="font3"> = </span><span class="font17">14</span></p>
<p><span class="font17">which we can then scale (by 1/2) to yield:</span></p>
<p><span class="font17" style="font-style:italic;">x =</span><span class="font17"> 7</span></p>
<p><span class="font17">We can then scale this by </span><span class="font3">—</span><span class="font17">1, yielding:</span></p>
<p><span class="font3">—</span><span class="font17" style="font-style:italic;">x =</span><span class="font3"> —</span><span class="font17">7</span></p>
<p><span class="font17">When we add this last equation to the very first equation, the </span><span class="font17" style="font-style:italic;">x</span><span class="font17">’s cancel, and we’re left with:</span></p>
<p><span class="font17" style="font-style:italic;">y</span><span class="font3"> = </span><span class="font17"><sup>5</sup></span></p>
<p><span class="font17">And in fact </span><span class="font17" style="font-style:italic;">x</span><span class="font3"> = </span><span class="font17">7, </span><span class="font17" style="font-style:italic;">y</span><span class="font3"> = </span><span class="font17">5 is the solution of the equations.</span></p>
<p><span class="font17">The most important function in the </span><span class="font2">Equation </span><span class="font17">module is </span><span class="font2">arithmetic()</span><span class="font17">, which scales and adds equations:</span></p>
<p><span class="font2">sub arithmetic {</span></p>
<p><span class="font2">my ($a, $ac, $b, $bc) = @_;</span></p>
<p><span class="font2">my %new;</span></p>
<p><span class="font2">for my $k (keys(%$a), keys %$b) {</span></p>
<p><span class="font2">my ($av) = $a-&gt;coefficient($k);</span></p>
<p><span class="font2">my ($bv) = $b-&gt;coefficient($k);</span></p>
<p><span class="font2">$new{$k} = $ac * $av + $bc * $bv;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">$a-&gt;new(%new);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">Given two equations, </span><span class="font2">$a </span><span class="font17">and </span><span class="font2">$b</span><span class="font17">, and two numbers, </span><span class="font2">$ac </span><span class="font17">and </span><span class="font2">$bc</span><span class="font17">, </span><span class="font2">arithmetic() </span><span class="font17">scales </span><span class="font2">$a </span><span class="font17">by </span><span class="font2">$ac</span><span class="font17">, scales </span><span class="font2">$b </span><span class="font17">by </span><span class="font2">$bc</span><span class="font17">, and adds the two scaled equations together. Built atop this base are several simpler utility functions. For example, to add two</span></p>
<ul style="list-style:none;"><li>
<p class="font15">9.4 <span class="font2">linogram: </span><span class="font15" style="font-variant:small-caps;">a drawing system</span><span class="font20"> 505</span></p></li></ul>
<p><span class="font17">equations together, we use </span><span class="font2">arithmetic()</span><span class="font17">, with both scale factors set to 1:</span></p>
<p><span class="font2">sub add_equations { my ($a, $b) = @_;</span></p>
<p><span class="font2">arithmetic($a, 1, $b, 1);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">Similarly, to subtract one equation from another is the same as adding them, but with the second one negated:</span></p>
<p><span class="font2">sub subtract_equations { my ($a, $b) = @_;</span></p>
<p><span class="font2">arithmetic($a, 1, $b, -1);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">Scaling a single equation is yet another special case, where the second equation is zero:</span></p>
<p><span class="font2">sub scale_equation { my ($a, $c) = @_; arithmetic($a, $c, $Zero, 0);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">Now suppose we have two equations:</span></p>
<p><span class="font17" style="font-style:italic;">ax</span><span class="font3"> + </span><span class="font17">some other stuff </span><span class="font3">= </span><span class="font17" style="font-style:italic;">c</span></p>
<p><span class="font17" style="font-style:italic;">bx</span><span class="font3"> + </span><span class="font17">more stuff </span><span class="font3">= </span><span class="font17" style="font-style:italic;">d</span></p>
<p><span class="font17">Here we can eliminate </span><span class="font17" style="font-style:italic;">x</span><span class="font17"> from the first equation by scaling the second by </span><span class="font17" style="font-style:italic;">-a/b</span></p>
<p><span class="font17">and adding the result to the first equation. The function </span><span class="font2">substitute_for()</span></p>
<p><span class="font17">is for eliminating a variable from an equation. The call:</span></p>
<p><span class="font2">$first-&gt;substitute_for(&quot;x&quot;, Ssecond);</span></p>
<p><span class="font17">eliminates variable </span><span class="font2">&quot;x&quot; </span><span class="font17">from equation </span><span class="font2">$first </span><span class="font17">in this way, by combining it with an appropriately scaled version of </span><span class="font2">$second</span><span class="font17">:</span></p>
<p><span class="font2"># Destructive sub substitute_for {</span></p>
<div>
<p><span class="font20">506</span></p>
</div><br clear="all">
<p><span class="font15">CHAPTER 9 Declarative Programming</span></p>
<p><span class="font2">my (Sself, $var, Svalue) = @_;</span></p>
<p><span class="font2">my Sa = Sself-&gt;coefficient(Svar);</span></p>
<p><span class="font2">return if Sa == 0;</span></p>
<p><span class="font2">my Sb = Svalue-&gt;coefficient(Svar);</span></p>
<p><span class="font2">die &quot;Oh NO&quot; if Sb == 0; # Should never happen my Sresult = arithmetic(Sself, 1, Svalue, -Sa/Sb);</span></p>
<p><span class="font2">%Sself = %Sresult;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">If </span><span class="font2">Sa </span><span class="font17">is zero, then the first equation didn’t contain the variable we were trying to eliminate, so nothing needs to be done. The </span><span class="font2">&quot;Oh NO&quot; </span><span class="font17">case occurs when the second equation doesn’t contain the variable we’re trying to eliminate; in this case there’s no way to use it to eliminate the variable from the first equation. Note that the function is destructive: It modifies </span><span class="font2">Sself </span><span class="font17">in place.</span></p>
<p><span class="font17">The cost of eliminating a variable like </span><span class="font17" style="font-style:italic;">x</span><span class="font17"> is that the resulting equation might be more complicated than what we started with, depending on what else is in the equation we’re using to reduce it. If we’re not careful, we might even get stuck in an infinite loop. Suppose we had:</span></p>
<p><span class="font17" style="font-style:italic;">x</span><span class="font3"> + </span><span class="font17" style="font-style:italic;">y = 3</span></p>
<p><span class="font17" style="font-style:italic;">y</span><span class="font3"> + </span><span class="font17" style="font-style:italic;">z =</span><span class="font17"> 5</span></p>
<p><span class="font17">and we scale the second equation by </span><span class="font3">—</span><span class="font17">1 and add it to the first, to eliminate </span><span class="font17" style="font-style:italic;">y</span><span class="font17">:</span></p>
<p><span class="font17" style="font-style:italic;">x — z =</span><span class="font3"> —</span><span class="font17">2</span></p>
<p><span class="font17">If we then add </span><span class="font17" style="font-style:italic;">this</span><span class="font17"> equation to the second one to eliminate </span><span class="font17" style="font-style:italic;">z</span><span class="font17">, we’re back where we started.</span></p>
<p><span class="font17">We’ll adopt a simple strategy that prevents infinite loops. We’ll take the first equation and use it to completely eliminate one of its variables from all the other equations. The variable will be present in that first equation only, so as long as we don’t use the first equation again, we can’t possibly reintroduce that variable. We’ll then move to the second equation and use </span><span class="font17" style="font-style:italic;">it</span><span class="font17"> to eliminate one of </span><span class="font17" style="font-style:italic;">its</span><span class="font17"> variables from all the other equations. We’ll repeat this for each equation.</span></p>
<p><span class="font17">To that end, here’s a method that returns an arbitrarily chosen variable from an equation:</span></p>
<p><span class="font2">sub a_var {</span></p>
<p><span class="font2">my Sself = shift;</span></p>
<ul style="list-style:none;"><li>
<p class="font15">9.4 <span class="font2">linogram: </span><span class="font15" style="font-variant:small-caps;">a drawing system</span><span class="font20"> 507</span></p></li></ul>
<p><span class="font2">my ($var) = $self-&gt;varlist;</span></p>
<p><span class="font2">$var;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">Let’s see a small example of how this works. Consider the equations:</span></p>
<p><span class="font17" style="font-style:italic;">A</span><span class="font3"> : </span><span class="font17" style="font-style:italic;">x</span><span class="font3"> + </span><span class="font17" style="font-style:italic;">2y</span><span class="font3"> = </span><span class="font17">8</span></p>
<p><span class="font17" style="font-style:italic;">B</span><span class="font3"> : </span><span class="font17">2</span><span class="font17" style="font-style:italic;">y</span><span class="font3"> + </span><span class="font17" style="font-style:italic;">z =</span><span class="font17"> 10</span></p>
<p><span class="font17" style="font-style:italic;">C</span><span class="font3"> : </span><span class="font17" style="font-style:italic;">x</span><span class="font3"> + </span><span class="font17" style="font-style:italic;">y</span><span class="font3"> + </span><span class="font17">2</span><span class="font17" style="font-style:italic;">z</span><span class="font3"> = </span><span class="font17">13</span></p>
<p><span class="font17">First we use </span><span class="font17" style="font-style:italic;">A</span><span class="font17"> to eliminate </span><span class="font17" style="font-style:italic;">x</span><span class="font17"> from the other two equations. For equation </span><span class="font17" style="font-style:italic;">B </span><span class="font17">there is nothing to do; eliminating </span><span class="font17" style="font-style:italic;">x</span><span class="font17"> from </span><span class="font17" style="font-style:italic;">C</span><span class="font17"> leaves:</span></p>
<p><span class="font17" style="font-style:italic;">A</span><span class="font3"> : </span><span class="font17" style="font-style:italic;">x</span><span class="font3"> + </span><span class="font17">2</span><span class="font17" style="font-style:italic;">y</span><span class="font3"> = </span><span class="font17">8</span></p>
<p><span class="font17" style="font-style:italic;">B</span><span class="font3"> : </span><span class="font17">2</span><span class="font17" style="font-style:italic;">y</span><span class="font3"> + </span><span class="font17" style="font-style:italic;">z =</span><span class="font17"> 10</span></p>
<p><span class="font17" style="font-style:italic;">C</span><span class="font3"> : &nbsp;— </span><span class="font17" style="font-style:italic;">y</span><span class="font3"> + </span><span class="font17">2</span><span class="font17" style="font-style:italic;">z</span><span class="font3"> = </span><span class="font17">5</span></p>
<p><span class="font17">Now we use </span><span class="font17" style="font-style:italic;">B</span><span class="font17"> to eliminate </span><span class="font17" style="font-style:italic;">y</span><span class="font17"> from the other two equations. Eliminating </span><span class="font17" style="font-style:italic;">y </span><span class="font17">from </span><span class="font17" style="font-style:italic;">A</span><span class="font17"> leaves:</span></p>
<p><span class="font17" style="font-style:italic;">A</span><span class="font3"> : </span><span class="font17" style="font-style:italic;">x — z =</span><span class="font3"> —</span><span class="font17">2</span></p>
<p><span class="font17" style="font-style:italic;">B</span><span class="font3"> : </span><span class="font17">2</span><span class="font17" style="font-style:italic;">y</span><span class="font3"> + </span><span class="font17" style="font-style:italic;">z =</span><span class="font17"> 10</span></p>
<p><span class="font17" style="font-style:italic;">C</span><span class="font3"> : &nbsp;— </span><span class="font17" style="font-style:italic;">y</span><span class="font3"> + </span><span class="font17">2</span><span class="font17" style="font-style:italic;">z</span><span class="font3"> = </span><span class="font17">5</span></p>
<p><span class="font17">Eliminating</span><span class="font17" style="font-style:italic;">y</span><span class="font17"> from </span><span class="font17" style="font-style:italic;">C</span><span class="font17"> leaves:</span></p>
<p><span class="font17" style="font-style:italic;">A</span><span class="font3"> : </span><span class="font17" style="font-style:italic;">x — z =</span><span class="font3"> —</span><span class="font17">2</span></p>
<p><span class="font17" style="font-style:italic;">B</span><span class="font3"> : </span><span class="font17">2</span><span class="font17" style="font-style:italic;">y</span><span class="font3"> + </span><span class="font17" style="font-style:italic;">z =</span><span class="font17"> 10</span></p>
<p><span class="font17" style="font-style:italic;">C : 2.5z =</span><span class="font17"> 10</span></p>
<p><span class="font17">Finally, we use </span><span class="font17" style="font-style:italic;">C</span><span class="font17"> to eliminate </span><span class="font17" style="font-style:italic;">z</span><span class="font17"> from the other two equations:</span></p>
<p><span class="font17" style="font-style:italic;">A</span><span class="font3"> : </span><span class="font17" style="font-style:italic;">x =</span><span class="font17"> 2</span></p>
<p><span class="font17" style="font-style:italic;">B</span><span class="font3"> : </span><span class="font17">2</span><span class="font17" style="font-style:italic;">y</span><span class="font3"> = </span><span class="font17">6</span></p>
<p><span class="font17" style="font-style:italic;">C</span><span class="font3"> : </span><span class="font17">2.5</span><span class="font17" style="font-style:italic;">z</span><span class="font3"> = </span><span class="font17">10</span></p>
<p><span class="font17">At this point we have finished one complete pass through all the equations, so we are done. There’s a final step that needs to be done to put the equations in</span></p>
<div>
<p><span class="font20">508</span></p>
</div><br clear="all">
<p><span class="font15">CHAPTER 9 Declarative Programming</span></p>
<p><span class="font17">standard form: We must adjust the coefficients to 1:</span></p>
<p><span class="font17" style="font-style:italic;">A</span><span class="font3"> : </span><span class="font17" style="font-style:italic;">x</span><span class="font3"> = </span><span class="font17">2</span></p>
<p><span class="font17" style="font-style:italic;">B</span><span class="font3"> : </span><span class="font17" style="font-style:italic;">y =</span><span class="font17"> 3</span></p>
<p><span class="font17" style="font-style:italic;">C</span><span class="font3"> : </span><span class="font17" style="font-style:italic;">z =</span><span class="font17"> 4</span></p>
<p><span class="font17">but this is a simple scaling operation.</span></p>
<p><span class="font17">Solving entire systems of equations is the job of the </span><span class="font2">Equation::System </span><span class="font17">module, whose objects represent whole systems of equations:</span></p>
<p><span class="font2">package Equation::System;</span></p>
<p><span class="font2">sub new {</span></p>
<p><span class="font2">my (Sbase, @eqns) = @_;</span></p>
<p><span class="font2">my Sclass = ref Sbase || Sbase;</span></p>
<p><span class="font2">bless \@eqns =&gt; Sclass;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">In the course of solving a system of equations, we often find that some of them are redundant. The way this appears in the mathematics is that we reduce an equation and find that we have nothing left. (That is, nothing but 0 </span><span class="font3">= </span><span class="font17">0, which adds no useful information.) We can detect such a ghostly equation with </span><span class="font2">Equation::is_tautology</span><span class="font17">:</span></p>
<p><span class="font2">package Equation;</span></p>
<p><span class="font2">sub is_tautology {</span></p>
<p><span class="font2">my Sself = shift;</span></p>
<p><span class="font2">return Sself-&gt;constant == 0 &amp;&amp;&nbsp;Sself-&gt;varlist == 0;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">In such a case, we’ll replace the ghostly equation with </span><span class="font2">undef</span><span class="font17">.</span></p>
<p><span class="font17">The important accessor for an </span><span class="font2">Equation::System </span><span class="font17">recovers the current list of equations, ignoring the ones we have nulled out:</span></p>
<p><span class="font2">package Equation::System;</span></p>
<p><span class="font2">sub equations {</span></p>
<p><span class="font2">my Sself = shift;</span></p>
<p><span class="font2">grep defined, @Sself;</span></p>
<p><span class="font2">}</span></p>
<ul style="list-style:none;"><li>
<p class="font15">9.4 <span class="font2">linogram: </span><span class="font15" style="font-variant:small-caps;">a drawing system</span><span class="font20"> 509</span></p></li></ul>
<h6><a name="bookmark456"></a><span class="font17">A typical operation on a system of equations will be to transform each equation in some way:</span></h6>
<p><span class="font2">sub apply {</span></p>
<p><span class="font2">my (Sself, Sfunc) = @_;</span></p>
<p><span class="font2">for my Seq (Sself-&gt;equations) {</span></p>
<p><span class="font2">Sfunc-&gt;(Seq);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
<h6><a name="bookmark457"></a><span class="font17">Now we’re ready to see </span><span class="font2">Equation::System::solve</span><span class="font17">, the end product of all this machinery.</span></h6>
<p><span class="font2">sub solve {</span></p>
<p><span class="font2">my Sself = shift;</span></p>
<p><span class="font2">my SN = my @E = Sself-&gt;equations;</span></p>
<p><span class="font2">for my Si (0 .. SN-1) {</span></p>
<p><span class="font2">next unless defined SE[Si];</span></p>
<p><span class="font2">my Svar = SE[Si]-&gt;a_var;</span></p>
<p><span class="font2">for my Sj (0 .. SN-1) {</span></p>
<p><span class="font2">next if Si == Sj;</span></p>
<p><span class="font2">next unless defined SE[Sj];</span></p>
<p><span class="font2">next unless SE[Sj]-&gt;coefficient(Svar);</span></p>
<p><span class="font2">SE[Sj]-&gt;substitute_for(Svar, SE[Si]);</span></p>
<p><span class="font2">if (SE[Sj]-&gt;is_tautology) {</span></p>
<p><span class="font2">undef SE[Sj];</span></p>
<p><span class="font2">} elsif (SE[Sj]-&gt;is_inconsistent) {</span></p>
<p><span class="font2">return ;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">Sself-&gt;normalize;</span></p>
<p><span class="font2">return 1;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">The main loop selects an equation number </span><span class="font17" style="font-style:italic;">i,</span><span class="font17"> selects one if its variables, </span><span class="font2">Svar</span><span class="font17">, and then scans over all the other equations </span><span class="font17" style="font-style:italic;">j</span><span class="font17"> reducing each one to remove </span><span class="font2">Svar</span><span class="font17">. If the result is the trivial equation 0 </span><span class="font3">= </span><span class="font17">0, equation </span><span class="font17" style="font-style:italic;">j</span><span class="font17"> is nulled out.</span></p>
<p><span class="font17">After each reduction, we test the resulting equation to make sure it makes sense. If we get an equation like 1 </span><span class="font3">= </span><span class="font17">0, we know something has gone wrong.</span></p>
<table border="1">
<tr><td>
<p><span class="font20">510</span></p></td><td style="vertical-align:bottom;">
<p><span class="font15">CHAPTER 9 Declarative Programming</span></p>
<p><span class="font17">This will occur if the original equations were inconsistent. For example:</span></p>
<p><span class="font17" style="font-style:italic;">start .y =</span><span class="font17"> 1;</span></p>
<p><span class="font17" style="font-style:italic;">y</span><span class="font3"> = </span><span class="font17">2;</span></p>
<p><span class="font17" style="font-style:italic;">start .y — y =</span><span class="font17"> 0;</span></p>
<p><span class="font17">Eliminating </span><span class="font17" style="font-style:italic;">start.y</span><span class="font17"> from the others yields:</span></p>
<p><span class="font17" style="font-style:italic;">start .y =</span><span class="font17"> 1;</span></p>
<p><span class="font17" style="font-style:italic;">y</span><span class="font3"> = </span><span class="font17">2;</span></p>
<p><span class="font3"><sup>—</sup> </span><span class="font17" style="font-style:italic;">y</span><span class="font3"> = <sup>—</sup></span><span class="font17"><sup>1;</sup></span></p>
<p><span class="font17">Then using the second equation to eliminate </span><span class="font17" style="font-style:italic;">y</span><span class="font17"> from the others yields:</span></p></td></tr>
</table>
<p><span class="font17" style="font-style:italic;">start .y = y =</span><span class="font17"> 2;</span></p>
<p><span class="font17">0 </span><span class="font3">= </span><span class="font17">1;</span></p>
<p><span class="font17">which is no good, because it says that 0 </span><span class="font3">= </span><span class="font17">1. The </span><span class="font2">Equation::is_inconsistent </span><span class="font17">method detects bad equations like 0 </span><span class="font3">= </span><span class="font17">1 that have no variables, but whose constant part is nonzero:</span></p>
<p><span class="font2">package Equation;</span></p>
<p><span class="font2">sub is_inconsistent {</span></p>
<p><span class="font2">my Sself = shift;</span></p>
<p><span class="font2">return Sself-&gt;constant != 0 &amp;&amp;&nbsp;Sself-&gt;varlist == 0;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">When the main loop is finished, we hope that the equations in the system have been reduced to the point where they contain only one variable each. As we saw, the equations might need one final adjustment. An equation like this:</span></p>
<p><span class="font17">2</span><span class="font17" style="font-style:italic;">y</span><span class="font3"> = </span><span class="font17">6</span></p>
<p><span class="font17">should be adjusted to this:</span></p>
<p><span class="font17" style="font-style:italic;">y</span><span class="font3"> = </span><span class="font17">3</span></p>
<ul style="list-style:none;"><li>
<p class="font15">9.4 <span class="font2">linogram: </span><span class="font15" style="font-variant:small-caps;">a drawing system</span><span class="font20"> 511</span></p></li></ul>
<p><span class="font17">The </span><span class="font2">Equation::System::normalize </span><span class="font17">method adjusts the equations in this way:</span></p>
<p><span class="font2">package Equation::System;</span></p>
<p><span class="font2">sub normalize {</span></p>
<p><span class="font2">my $self = shift;</span></p>
<p><span class="font2">$self-&gt;apply(sub { $_[0]-&gt;normalize });</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">To normalize a single equation, we scale it appropriately:</span></p>
<p><span class="font2">package Equation;</span></p>
<p><span class="font2">sub normalize {</span></p>
<p><span class="font2">my $self = shift;</span></p>
<p><span class="font2">my $var = $self-&gt;a_var;</span></p>
<p><span class="font2">return unless defined $var;</span></p>
<p><span class="font2">%$self = %{$self-&gt;scale_equation(1/$self-&gt;coefficient($var))};</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">An equation like </span><span class="font17" style="font-style:italic;">y =</span><span class="font17"> 3 is so simple that even the computer understands what it means. We say that this equation </span><span class="font17" style="font-style:italic;">defines</span><span class="font17"> the variable </span><span class="font17" style="font-style:italic;">y</span><span class="font17">. The </span><span class="font2">defines_var() </span><span class="font17">method reports on whether an equation defines a variable:</span></p>
<p><span class="font2">sub defines_var {</span></p>
<p><span class="font2">my $self = shift;</span></p>
<p><span class="font2">my @keys = keys %$self;</span></p>
<p><span class="font2">return unless @keys == 2;</span></p>
<p><span class="font2">my $var = $keys[0] || $keys[1];</span></p>
<p><span class="font2">return $self-&gt;{$var} == 1 ? $var : () ;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">To define a variable, an equation must have the form </span><span class="font17" style="font-style:italic;">var = val</span><span class="font17">, and so must contain exactly two keys. One is the name of the variable; the other is the empty string. Moreover, the coefficient of the one variable must be 1. If all this is true, </span><span class="font2">defines_var() </span><span class="font17">returns the name of the variable so defined. The value of the variable can be recovered with </span><span class="font2">- $equation-&gt;constant</span><span class="font17">. (The minus sign is because </span><span class="font17" style="font-style:italic;">y =</span><span class="font17"> 7 is represented as </span><span class="font17" style="font-style:italic;">y —</span><span class="font17"> 7 </span><span class="font3">= </span><span class="font17">0, which is </span><span class="font2">{ y =&gt; 1, &quot;&quot;&nbsp;=&gt; -7 }</span><span class="font17">.)</span></p>
<p><span class="font17">The main entry to the equation-solving subsystem for outside functions is the </span><span class="font2">values() </span><span class="font17">method. This takes a system of equations, solves the equations,</span></p>
<div>
<p><span class="font20">512</span></p>
</div><br clear="all">
<p><span class="font15">CHAPTER 9 Declarative Programming</span></p>
<p><span class="font17">and returns a hash that maps the names of known variables to their values:</span></p>
<p><span class="font2">package Equation::System;</span></p>
<p><span class="font2">sub values {</span></p>
<p><span class="font2">my Sself = shift;</span></p>
<p><span class="font2">my %values;</span></p>
<p><span class="font2">Sself-&gt;solve;</span></p>
<p><span class="font2">for my Seqn (Sself-&gt;equations) {</span></p>
<p><span class="font2">if (my Sname = Seqn-&gt;defines_var) { Svalues{Sname} = -Seqn-&gt;constant;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">%values;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">1;</span></p>
<div>
<p><span class="font9" style="font-weight:bold;">CODE LIBRARY</span></p>
</div><br clear="all">
<div>
<p><span class="font0">Constraint.pm</span></p>
</div><br clear="all">
<p><span class="font17">CONSTRAINTS</span></p>
<p><span class="font2">linogram </span><span class="font17">will have another class, called </span><span class="font2">Constraint</span><span class="font17">, which represents constraints. Since constraints are essentially equations, </span><span class="font2">Constraint </span><span class="font17">will be a derived class of </span><span class="font2">Equation</span><span class="font17">:</span></p>
<p><span class="font2">package Constraint;</span></p>
<p><span class="font2">use Equation;</span></p>
<p><span class="font2">@Constraint::ISA = 'Equation';</span></p>
<p><span class="font2">Constraint </span><span class="font17">adds a few utility methods to </span><span class="font2">Equation </span><span class="font17">that make more sense in the context of </span><span class="font2">linogram </span><span class="font17">than in the general context of equation solving. The most important is </span><span class="font2">qualify()</span><span class="font17">. A type like </span><span class="font2">hline </span><span class="font17">contains the constraint </span><span class="font17" style="font-style:italic;">start.y — y = </span><span class="font17">0. But when considered as part of a </span><span class="font2">box</span><span class="font17">, the </span><span class="font2">hline </span><span class="font17">has a name like </span><span class="font2">top </span><span class="font17">or </span><span class="font2">bottom</span><span class="font17">, and the constraint, when translated into the context of the box, turns into </span><span class="font17" style="font-style:italic;">top.start.y — top.y =</span><span class="font17"> 0. </span><span class="font2">qualify() </span><span class="font17">takes a constraint and a name prefix and produces a new, transformed constraint:</span></p>
<p><span class="font2">sub qualify {</span></p>
<p><span class="font2">my (Sself, Sprefix) = @_;</span></p>
<p><span class="font2">my %result = (&quot;&quot; =&gt; Sself-&gt;constant);</span></p>
<ul style="list-style:none;"><li>
<p class="font15">9.4 <span class="font2">linogram: </span><span class="font15" style="font-variant:small-caps;">a drawing system</span><span class="font20"> 513</span></p></li></ul>
<p><span class="font2">for my Svar (Sself-&gt;varlist) {</span></p>
<p><span class="font2">Sresult{&quot;Sprefix.Svar&quot;} = Sself-&gt;coefficient(Svar);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">Sself-&gt;new(%result);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">Constraint</span><span class="font17">’s other methods are simple things. In some places inside </span><span class="font2">linogram</span><span class="font17">, constraints are used as if they were expressions; when there is an expression with an addition in the drawing specification, we have to add together constraints. We’ll see this in more detail later; in the meantime, </span><span class="font2">new_constant() </span><span class="font17">manufactures a constraint like 0 </span><span class="font3">= </span><span class="font17">0 or 0 </span><span class="font3">= </span><span class="font17">1 that plays the role of a constant expression:</span></p>
<p><span class="font2">sub new_constant {</span></p>
<p><span class="font2">my (Sbase, Sval) = @_;</span></p>
<p><span class="font2">my Sclass = ref Sbase || Sbase;</span></p>
<p><span class="font2">Sclass-&gt;new(&quot;&quot; =&gt; Sval);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">add_constant() </span><span class="font17">adds a constant to a constraint, transforming something like </span><span class="font17" style="font-style:italic;">x =</span><span class="font17"> 0 to something like </span><span class="font17" style="font-style:italic;">x =</span><span class="font17"> 3, and </span><span class="font2">mul_constant() </span><span class="font17">multiplies a constraint by a constant, transforming something like </span><span class="font17" style="font-style:italic;">x =</span><span class="font17"> 3 to something like 4</span><span class="font17" style="font-style:italic;">x</span><span class="font3"> = </span><span class="font17">12:</span></p>
<p><span class="font2">sub add_constant {</span></p>
<p><span class="font2">my (Sself, Sv) = @_;</span></p>
<p><span class="font2">Sself-&gt;add_equations(Sself-&gt;new_constant(Sv));</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">sub mul_constant {</span></p>
<p><span class="font2">my (Sself, Sv) = @_;</span></p>
<p><span class="font2">Sself-&gt;scale_equation(Sv);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">All the other methods of </span><span class="font2">Constraint </span><span class="font17">are inherited from </span><span class="font2">Equation</span><span class="font17">.</span></p>
<p><span class="font17">Analogous to </span><span class="font2">Constraint</span><span class="font17">, there is a </span><span class="font2">Constraint_Set </span><span class="font17">class that is derived from </span><span class="font2">Equation::System</span><span class="font17">. It’s even simpler than </span><span class="font2">Constraint</span><span class="font17">. It has only one extra method:</span></p>
<p><span class="font2">package Constraint_Set;</span></p>
<p><span class="font2">@Constraint_Set::ISA = 'Equation::System';</span></p>
<p><span class="font2">sub constraints {</span></p>
<p><span class="font2">my Sself = shift;</span></p>
<p><span class="font2">$self-&gt;equations;</span></p>
<p><span class="font2">} 1;</span></p>
<ul style="list-style:none;"><li>
<h5><a name="bookmark194"></a><span class="font19">9.4.2 Values</span></h5></li></ul>
<p><span class="font17">In the course of reading and parsing the specification, we’ll need to deal with expressions. We saw the parsing end of this in detail in Chapter 8. The question that arises is what the values of the expressions will be; the answer turns out to be quite interesting. Values are not always numbers. For example, consider:</span></p>
<p><span class="font2">point P, Q;</span></p>
<p><span class="font2">P + (2, 3) = Q;</span></p>
<p><span class="font17">Here we have an expression </span><span class="font2">P + (2, 3)</span><span class="font17">. The value of this expression isn’t a simple number. It implies parts of two constraints, involving </span><span class="font17" style="font-style:italic;">Px</span><span class="font17"> and </span><span class="font17" style="font-style:italic;">Py.</span><span class="font17"> Later on, these partial constraints must be combined with </span><span class="font17" style="font-style:italic;">Q</span><span class="font17"> to yield the complete constraints, which are </span><span class="font17" style="font-style:italic;">P.x</span><span class="font3"> + </span><span class="font17">2 </span><span class="font3">= </span><span class="font17" style="font-style:italic;">Q.x</span><span class="font17"> and </span><span class="font17" style="font-style:italic;">P.y</span><span class="font3"> + </span><span class="font17">3 </span><span class="font3">= </span><span class="font17" style="font-style:italic;">Q.y.</span></p>
<p><span class="font17">One of </span><span class="font2">linogram</span><span class="font17">’s main classes is </span><span class="font2">Value</span><span class="font17">, which represents the value of an expression. </span><span class="font2">Value </span><span class="font17">is where the most interesting arithmetic takes place inside of </span><span class="font2">linogram</span><span class="font17">. </span><span class="font2">Value</span><span class="font17">s come in three kinds. </span><span class="font2">Value::Constant </span><span class="font17">represents a scalar constant value such as 3. </span><span class="font2">Value::Tuple </span><span class="font17">represents a lone tuple, such as </span><span class="font2">(2, 3)</span><span class="font17">, or a sum of tuples. And </span><span class="font2">Value::Feature </span><span class="font17">represents a feature type, even a scalar feature type, such as </span><span class="font17" style="font-style:italic;">P</span><span class="font17"> or </span><span class="font17" style="font-style:italic;">Q</span><span class="font17"> or </span><span class="font2">P + (2, 3)</span><span class="font17">. </span><span class="font2">Value </span><span class="font17">itself is an abstract base class, and doesn’t represent anything; it’s there only to provide methods that are inherited by the other classes, primarily for doing arithmetic.</span></p>
<p><span class="font2">Value </span><span class="font17">objects have one generic accessor, called </span><span class="font2">kindof()</span><span class="font17">, which returns </span><span class="font2">CONSTANT</span><span class="font17">, </span><span class="font2">TUPLE</span><span class="font17">, or </span><span class="font2">FEATURE</span><span class="font17">, depending on what kind of object it is called on. The other methods are arithmetic. The entry to these from the parser is via a quartet of operation methods called </span><span class="font2">add()</span><span class="font17">, </span><span class="font2">sub()</span><span class="font17">, </span><span class="font2">mul()</span><span class="font17">, and </span><span class="font2">div()</span><span class="font17">, which are just thin wrappers around the real workhorse, </span><span class="font2">op()</span><span class="font17">:</span></p>
<p><span class="font2">sub add { S_[0]-&gt;op(&quot;add&quot;, $_[1]) } sub sub { S_[0]-&gt;op(&quot;add&quot;, S_[1]-&gt;negate) }</span></p>
<p><span class="font2">sub mul { S_[0]-&gt;op(&quot;mul&quot;, S_[1]) }</span></p>
<p><span class="font2">sub div { S_[0]-&gt;op(&quot;mul&quot;, S_[1]-&gt;reciprocal) }</span></p>
<ul style="list-style:none;"><li>
<p class="font15">9.4 <span class="font2">linogram: </span><span class="font15" style="font-variant:small-caps;">a drawing system</span><span class="font20"> 515</span></p></li></ul>
<p><span class="font17">Note that subtraction and division are defined in terms of addition and multiplication, which cuts down on the amount of work we need to do for </span><span class="font2">op()</span><span class="font17">.</span></p>
<p><span class="font2">op() </span><span class="font17">itself is driven by a dispatch table because otherwise it would be quite complicated. The dispatch table is indexed by the operation name (either </span><span class="font2">add </span><span class="font17">or </span><span class="font2">mul</span><span class="font17">) and by the kinds of the two operands. It looks like this:</span></p>
<p><span class="font2">package Value;</span></p>
<div>
<p><span class="font9" style="font-weight:bold;">CODE LIBRARY</span></p>
</div><br clear="all">
<div>
<p><span class="font0">Value.pm</span></p>
</div><br clear="all">
<p><span class="font2">my %op = (&quot;add&quot; =&gt; {</span></p>
<table border="1">
<tr><td>
<p><span class="font2">&quot;FEATURE,FEATURE&quot;</span></p></td><td>
<p><span class="font2">=&gt;</span></p></td><td>
<p><span class="font2">'add_features',</span></p></td></tr>
<tr><td style="vertical-align:bottom;">
<p><span class="font2">&quot;FEATURE,CONSTANT&quot;</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">=&gt;</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">'add_feature_con',</span></p></td></tr>
<tr><td style="vertical-align:bottom;">
<p><span class="font2">&quot;FEATURE,TUPLE&quot;</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">=&gt;</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">'add_feature_tuple</span></p></td></tr>
<tr><td style="vertical-align:bottom;">
<p><span class="font2">&quot;TUPLE,TUPLE&quot;</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">=&gt;</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">'add_tuples',</span></p></td></tr>
<tr><td style="vertical-align:bottom;">
<p><span class="font2">&quot;TUPLE,CONSTANT&quot;</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">=&gt;</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">undef,</span></p></td></tr>
<tr><td style="vertical-align:bottom;">
<p><span class="font2">&quot;CONSTANT,CONSTANT&quot;</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">=&gt;</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">'add_constants',</span></p></td></tr>
<tr><td style="vertical-align:bottom;">
<p><span class="font2">NAME =&gt; &quot;Addition&quot;,</span></p></td><td></td><td></td></tr>
</table>
<p><span class="font2">},</span></p>
<p><span class="font2">&quot;mul&quot; =&gt;</span></p>
<p><span class="font2">{</span></p>
<table border="1">
<tr><td>
<p><span class="font2">&quot;FEATURE,CONSTANT&quot;</span></p></td><td>
<p><span class="font2">=&gt;</span></p></td><td>
<p><span class="font2">'mul_feature_con</span></p></td></tr>
<tr><td style="vertical-align:bottom;">
<p><span class="font2">&quot;TUPLE,CONSTANT&quot;</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">=&gt;</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">'mul_tuple_con',</span></p></td></tr>
<tr><td style="vertical-align:bottom;">
<p><span class="font2">&quot;CONSTANT,CONSTANT&quot;</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">=&gt;</span></p></td><td style="vertical-align:bottom;">
<p><span class="font2">'mul_constants',</span></p></td></tr>
<tr><td colspan="2" style="vertical-align:bottom;">
<p><span class="font2">NAME =&gt; &quot;Multiplication&quot;</span></p></td><td style="vertical-align:bottom;">
<p><span class="font3"><sup>,</sup></span></p></td></tr>
</table>
<p><span class="font2">}, );</span></p>
<p><span class="font17">Addition, surprisingly, turns out to be more complicated than multiplication. This is because we’ve restricted our system to linear operations, which means that multiplication is forbidden, except to multiply by constant values. Given two </span><span class="font2">Value </span><span class="font17">objects and an operation tag, </span><span class="font2">op() </span><span class="font17">consults the dispatch table, dispatches the appropriate arithmetic function, and returns the result:</span></p>
<p><span class="font2">sub op {</span></p>
<p><span class="font2">my ($self, $op, $operand) = @_;</span></p>
<p><span class="font2">my ($k1, $k2) = ($self-&gt;kindof, $operand-&gt;kindof);</span></p>
<p><span class="font2">my $method;</span></p>
<p><span class="font2">if ($method = $op{$op}{&quot;$k1,$k2&quot;}) {</span></p>
<p><span class="font2">$self-&gt;$method($operand);</span></p>
<p><span class="font2">} elsif ($method = $op{$op}{&quot;$k2,$k1&quot;}) {</span></p>
<div>
<p><span class="font20">516</span></p>
</div><br clear="all">
<p><span class="font15">CHAPTER 9 Declarative Programming</span></p>
<p><span class="font2">$operand-&gt;$method($self);</span></p>
<p><span class="font2">} else {</span></p>
<p><span class="font2">my $name = $op{$op}{NAME} || &quot;'$op'&quot;;</span></p>
<p><span class="font2">die &quot;$name of '$k1' and '$k2' not defined&quot;; }</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">The two operands are </span><span class="font2">$self </span><span class="font17">and </span><span class="font2">$operand</span><span class="font17">. </span><span class="font2">op() </span><span class="font17">starts by finding out what sorts of values these are, using </span><span class="font2">kindof</span><span class="font17">, which returns </span><span class="font2">CONSTANT </span><span class="font17">for </span><span class="font2">Value::Constant </span><span class="font17">objects, </span><span class="font2">TUPLE </span><span class="font17">for </span><span class="font2">Value::Tuple </span><span class="font17">objects, and so forth. It then looks in the dispatch table under the operator name (</span><span class="font2">&quot;add&quot; </span><span class="font17">or </span><span class="font2">&quot;mul&quot;</span><span class="font17">) and the value kinds. If it doesn’t find anything, it tries the operands in the opposite order, since a function for adding a tuple to a feature is the same as one for adding a feature to a tuple; this cuts down on the number of functions we have to write. If neither operand order works, then the </span><span class="font2">op </span><span class="font17">function fails with a message like </span><span class="font2">&quot;Addition of 'CONSTANT' and 'TUPLE' not defined&quot;</span><span class="font17">.</span></p>
<p><span class="font17">The only other generic methods in </span><span class="font2">Value </span><span class="font17">are for </span><span class="font2">negate()</span><span class="font17">, which is required for subtraction, and </span><span class="font2">reciprocal()</span><span class="font17">, which is required for division. </span><span class="font2">negate() </span><span class="font17">passes the buck to a general scaling method, which will be defined differently in each of the various subclasses:</span></p>
<p><span class="font2">sub negate { $_[0]-&gt;scale(-1) }</span></p>
<p><span class="font2">reciprocal() </span><span class="font17">is even simpler, because in general it’s illegal. You’re not allowed to divide by a tuple (what would it mean?) or by a feature (since this would mean that the equations were nonlinear; consider </span><span class="font17" style="font-style:italic;">x = 1/y</span><span class="font17">) so the default </span><span class="font2">reciprocal() </span><span class="font17">method dies:</span></p>
<p><span class="font2">sub reciprocal { die &quot;Nonlinear division&quot; }</span></p>
<p><span class="font17">You </span><span class="font17" style="font-style:italic;">are</span><span class="font17"> allowed to divide by a constant, so </span><span class="font2">Value::Constant::reciprocal() </span><span class="font17">will override this definition.</span></p>
<p><span class="font17">CONSTANT VALUES</span></p>
<p><span class="font17">Of the three kinds of </span><span class="font2">Value</span><span class="font17">, we’ll look at </span><span class="font2">Value::Constant </span><span class="font17">first, because it’s by far the simplest. </span><span class="font2">Value::Constant </span><span class="font17">objects are essentially numbers. The object is a hash with two members. One is the kind, which is </span><span class="font2">CONSTANT</span><span class="font17">; the other is the numeric value. The constructor accepts a number and generates</span></p>
<ul style="list-style:none;"><li>
<p class="font15">9.4 <span class="font2">linogram: </span><span class="font15" style="font-variant:small-caps;">a drawing system</span><span class="font20"> 517</span></p></li></ul>
<h6><a name="bookmark458"></a><span class="font17">a </span><span class="font2">Value::Constant </span><span class="font17">value with the number inside it:</span></h6>
<p><span class="font2">package Value::Constant;</span></p>
<p><span class="font2">@Value::Constant::ISA = 'Value';</span></p>
<p><span class="font2">sub new {</span></p>
<p><span class="font2">my ($base, $con) = @_;</span></p>
<p><span class="font2">my $class = ref $base || $base;</span></p>
<p><span class="font2">bless { WHAT =&gt; $base-&gt;kindof, VALUE =&gt; $con, } =&gt; $class;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">sub kindof { &quot;CONSTANT&quot; }</span></p>
<p><span class="font2">sub value { $_[0]{VALUE} }</span></p>
<h6><a name="bookmark459"></a><span class="font17">To perform the </span><span class="font2">scale() </span><span class="font17">operation, we multiply the constant by the argument:</span></h6>
<p><span class="font2">sub scale { my ($self, $coeff) = @_; $self-&gt;new($coeff * $self-&gt;value);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">Division is defined for constants, so we must override the fatal </span><span class="font2">reciprocal() </span><span class="font17">method with one that actually performs division. The reciprocal of a constant is a new constant with the reciprocal value:</span></p>
<p><span class="font2">sub reciprocal { my $self = shift; my $v = $self-&gt;value; if ($v == 0) {</span></p>
<p><span class="font2">die &quot;Division by zero&quot;;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">$self-&gt;new(1/$v);</span></p>
<p><span class="font2">}</span></p>
<h6><a name="bookmark460"></a><span class="font17">Finally, the dispatch table contains two methods for operating on constants.</span></h6>
<h6><span class="font17">One adds two constants, and the other multiplies them:</span></h6>
<p><span class="font2">sub add_constants { my ($c1, $c2) = @_;</span></p>
<p><span class="font20">518 </span><span class="font15">CHAPTER 9 Declarative Programming</span></p>
<p><span class="font2">$c1-&gt;new($c1-&gt;value + $c2-&gt;value); } sub mul_constants {</span></p>
<p><span class="font2">my ($c1, $c2) = @_;</span></p>
<p><span class="font2">$c1-&gt;new($c1-&gt;value * $c2-&gt;value); }</span></p>
<p><span class="font17">TUPLE VALUES</span></p>
<p><span class="font17">Tuples represent displacements. A tuple like </span><span class="font2">(2, 3) </span><span class="font17">represents a displacement of 2 units in the </span><span class="font17" style="font-style:italic;">x</span><span class="font17"> direction (east) and 3 units in the</span><span class="font17" style="font-style:italic;">y</span><span class="font17"> direction (south). As we’ll see, </span><span class="font2">linogram </span><span class="font17">isn’t restricted to two-dimensional drawings, so </span><span class="font2">(2, 3, 4) </span><span class="font17">could also be a legal displacement. Although it’s unlikely that any four-dimensional beings will be using </span><span class="font2">linogram</span><span class="font17">, there’s no harm in making it as general as possible, so internally, a tuple is a hash. The keys are component names (</span><span class="font17" style="font-style:italic;">x</span><span class="font17">, </span><span class="font17" style="font-style:italic;">y</span><span class="font17">, and so forth) and the values are the components. The tuple </span><span class="font2">(2, 3) </span><span class="font17">is represented by the hash </span><span class="font2">{ x =&gt; 2, y =&gt; 3 }</span><span class="font17">. </span><span class="font2">(2, 3, 4) </span><span class="font17">is represented by the hash </span><span class="font2">{ x =&gt; 2, y =&gt; 3, z =&gt; 4 }</span><span class="font17">. The tuple class itself doesn’t care what the component names are, although this version of </span><span class="font2">linogram </span><span class="font17">will refuse to generate tuples with any components other than </span><span class="font2">x</span><span class="font17">, </span><span class="font2">y</span><span class="font17">, and possibly </span><span class="font2">z</span><span class="font17">.</span></p>
<p><span class="font17">One possibly fine point is that tuple components need not be numbers; they might be arbitrary </span><span class="font2">Values</span><span class="font17">. A tuple like </span><span class="font2">(3, hspc) </span><span class="font17">will have a</span><span class="font17" style="font-style:italic;">y</span><span class="font17"> component that is a </span><span class="font2">Value::Feature</span><span class="font17">. It’s even conceivable that we could have a tuple whose components are other tuples. We’ll take some pains to forbid this last possibility, since it doesn’t seem to have any meaning in the context of drawings.</span></p>
<p><span class="font17">Here is the constructor, which gets a component hash and returns a tuple value object:</span></p>
<p><span class="font2">package Value::Tuple;</span></p>
<p><span class="font2">@Value::Tuple::ISA = 'Value';</span></p>
<p><span class="font2">sub kindof { &quot;TUPLE&quot; } sub new {</span></p>
<p><span class="font2">my (Sbase, %tuple) = @_;</span></p>
<p><span class="font2">my Sclass = ref Sbase || Sbase;</span></p>
<p><span class="font2">bless { WHAT =&gt; Sbase-&gt;kindof,</span></p>
<p><span class="font2">TUPLE =&gt; \%tuple,</span></p>
<p><span class="font2">} =&gt; Sclass;</span></p>
<p><span class="font2">}</span></p>
<h6><a name="bookmark461"></a><span class="font17">It has a few straightforward accessors:</span></h6>
<p><span class="font2">sub components { keys %{$_[0]{TUPLE}} }</span></p>
<p><span class="font2">sub has_component { exists $_[0]{TUPLE}{$_[1]} }</span></p>
<p><span class="font2">sub component { $_[0]{TUPLE}{$_[1]} }</span></p>
<p><span class="font2">sub to_hash { $_[0]{TUPLE} }</span></p>
<p><span class="font17">To perform subtraction on tuples, we will need a </span><span class="font2">scale() </span><span class="font17">operation that multiplies a tuple by a number. This is done componentwise; </span><span class="font2">2 * (2, 3) </span><span class="font17">is </span><span class="font2">(4, 6)</span><span class="font17">:</span></p>
<p><span class="font2">sub scale {</span></p>
<p><span class="font2">my (Sself, Scoeff) = @_;</span></p>
<p><span class="font2">my %new_tuple;</span></p>
<p><span class="font2">for my Sk (Sself-&gt;components) {</span></p>
<p><span class="font2">Snew_tuple{Sk} = Sself-&gt;component(Sk)-&gt;scale(Scoeff);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">Sself-&gt;new(%new_tuple);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">Note that we must use </span><span class="font2">Sself-&gt;component(Sk)-&gt;scale(Scoeff) </span><span class="font17">rather than </span><span class="font2">Sself-&gt;component(Sk)-&gt;value * Scoeff</span><span class="font17">, because the component value might not be a number.</span></p>
<p><span class="font17">Adding tuples will also be done componentwise. We want to make sure that the user doesn’t try to add tuples with different components. It’s not clear what </span><span class="font2">(2, 3) + (2, 3, 4) </span><span class="font17">would mean, for example. This function takes two tuples and returns true if their component lists are identical:</span></p>
<p><span class="font2">sub has_same_components_as {</span></p>
<p><span class="font2">my (St1, St2) = @_;</span></p>
<p><span class="font2">my %t1c;</span></p>
<p><span class="font2">for my Sc (St1-&gt;components) {</span></p>
<p><span class="font2">return unless St2-&gt;has_component(Sc);</span></p>
<p><span class="font2">St1c{Sc} = 1;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">for my Sc (St2-&gt;components) {</span></p>
<p><span class="font2">return unless St1c{Sc};</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">return 1;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">Adding two tuples is one of the functions from the dispatch table:</span></p>
<p><span class="font2">sub add_tuples {</span></p>
<p><span class="font2">my ($t1, $t2) = @_;</span></p>
<p><span class="font2">croak(&quot;Nonconformable tuples&quot;) unless $t1-&gt;has_same_components_as($t2);</span></p>
<p><span class="font2">my %result ;</span></p>
<p><span class="font2">for my $c ($t1-&gt;components) {</span></p>
<p><span class="font2">$result{$c} = $t1-&gt;component($c) + $t2-&gt;component($c);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">$t1-&gt;new(%result);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">The other dispatch table function that can return a tuple involves multiplying a tuple by a constant. This is a simple application of </span><span class="font2">scale()</span><span class="font17">:</span></p>
<p><span class="font2">sub mul_tuple_con { my ($t, $c) = @_;</span></p>
<p><span class="font2">$t-&gt;scale($c-&gt;value);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">FEATURE VALUES</span></p>
<p><span class="font17">The code for handling feature values isn’t much longer than the code for handling tuples or constants, but it’s more complex, because arithmetic of features is more complex. This is partly because it’s not really clear what it should mean to add two boxes together.</span></p>
<p><span class="font17">What </span><span class="font17" style="font-style:italic;">does</span><span class="font17"> it mean to add two boxes together? Suppose that </span><span class="font17" style="font-style:italic;">A</span><span class="font17"> and </span><span class="font17" style="font-style:italic;">B</span><span class="font17"> are </span><span class="font2">hline</span><span class="font17">s, and that we have the constraint </span><span class="font17" style="font-style:italic;">A = B</span><span class="font17">, or, equivalently, </span><span class="font17" style="font-style:italic;">A — B =</span><span class="font17"> 0, which involves a subtraction of two </span><span class="font2">hline </span><span class="font17">features. What does this mean?</span></p>
<p><span class="font17" style="font-style:italic;">A</span><span class="font17"> contains several intrinsic constraints, including </span><span class="font2">A.start.x + A.length = A.end.x</span><span class="font17">, and </span><span class="font17" style="font-style:italic;">B</span><span class="font17"> similarly contains </span><span class="font2">B.start.x + B.length = B.end.x</span><span class="font17">. The end value of </span><span class="font17" style="font-style:italic;">A — B</span><span class="font17"> must contain both of these constraints. The subtraction won’t affect them at all. We will need to carry along all the intrinsic constraints from both input features into the result, but these intrinsic constraints don’t otherwise participate in the arithmetic.</span></p>
<p><span class="font17">But the end value also must include some constraints that relate the two inputs, such as </span><span class="font2">A.end.y - B.end.y = 0, A.end.x - B.end.x = 0</span><span class="font17">, and so on. We’ll call these </span><span class="font17" style="font-style:italic;">synthetic constraints,</span><span class="font17"> because they must be synthesized out of information that we find in the input values.</span></p>
<p><span class="font17">A feature value has two parts, the </span><span class="font17" style="font-style:italic;">intrinsic constraints</span><span class="font17"> and the </span><span class="font17" style="font-style:italic;">synthetic constraints.</span><span class="font17"> Each is a set of constraints. The intrinsic constraints are those contributed by the definitions of the features themselves, and are internal to particular features. The synthetic constraints are those derived from the structure of the expression and the interactions between the features in the expression. The intrinsic constraints don’t participate in arithmetic, while the synthetic constraints do participate in arithmetic.</span></p>
<p><span class="font17">When we want to add (or subtract) two boxes, we unite their two intrinsic constraint sets into a single set, which becomes the intrinsic constraint set of the result. But to combine the two synthetic constraint sets, we perform arithmetic on </span><span class="font17" style="font-style:italic;">corresponding</span><span class="font17"> synthetic constraints. To keep track of which synthetic constraints correspond, each one is labeled with a string. A synthetic constraint that involves the </span><span class="font2">start.x </span><span class="font17">components of two </span><span class="font2">hlines </span><span class="font17">will be labeled with the string </span><span class="font2">start.x </span><span class="font17">and will be combined with the </span><span class="font2">start.x </span><span class="font17">components of any other lines involved in the expression. Synthetic constraint sets will therefore be hashes.</span></p>
<p><span class="font18" style="font-variant:small-caps;">intrinsic constraints</span></p>
<p><span class="font17">Intrinsic constraint sets are represented by the class </span><span class="font2">Intrinsic_Constraint_Set</span><span class="font17">. An intrinsic constraint set is a simple container class that holds a list of </span><span class="font2">Constraint </span><span class="font17">objects:</span></p>
<p><span class="font2">package Intrinsic_Constraint_Set;</span></p>
<p><span class="font2">sub new {</span></p>
<p><span class="font2">my ($base, @constraints) = @_;</span></p>
<p><span class="font2">my $class = ref $base || $base;</span></p>
<p><span class="font2">bless \@constraints =&gt; $class;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">sub constraints { @{$_[0]} }</span></p>
<p><span class="font17">It has only a few methods. One is a </span><span class="font2">map</span><span class="font17">-like function for invoking a callback on each constraint in the set, and returning the set of the results:</span></p>
<p><span class="font2">sub apply {</span></p>
<p><span class="font2">my ($self, $func) = @_;</span></p>
<p><span class="font2">my @c = map $func-&gt;($_), $self-&gt;constraints;</span></p>
<p><span class="font2">$self-&gt;new(@c);</span></p>
<p><span class="font2">}</span></p>
<h6><a name="bookmark462"></a><span class="font17">This is used by </span><span class="font2">qualify()</span><span class="font17">, which qualifies all the constraints in the set:</span></h6>
<p><span class="font2">sub qualify {</span></p>
<p><span class="font2">my (Sself, Sprefix) = @_;</span></p>
<p><span class="font2">$self-&gt;apply(sub { S_[0]-&gt;qualify(Sprefix) }); }</span></p>
<h6><a name="bookmark463"></a><span class="font17">Last is </span><span class="font2">union()</span><span class="font17">, which takes one or more intrinsic constraint sets and generates a new set that contains all the constraints in the input sets:</span></h6>
<p><span class="font2">sub union {</span></p>
<p><span class="font2">my (Sself, @more) = @_;</span></p>
<p><span class="font2">Sself-&gt;new(Sself-&gt;constraints, map {S_-&gt;constraints} @more);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">SYNTHETIC CONSTRAINTS</span></p>
<p><span class="font2">Synthetic_Constraint_Set </span><span class="font17">is more interesting, because it supports arithmetic rather than mere aggregation. As mentioned earlier, a synthetic constraint set is represented by a hash, because each constraint in the set has a label that is used to determine which constraints in other sets it will fraternize with. For convenience, the constructor accepts either a regular hash or a reference to a hash:</span></p>
<p><span class="font2">package Synthetic_Constraint_Set;</span></p>
<p><span class="font2">sub new {</span></p>
<p><span class="font2">my Sbase = shift;</span></p>
<p><span class="font2">my Sclass = ref Sbase || Sbase;</span></p>
<p><span class="font2">my Sconstraints;</span></p>
<p><span class="font2">if (@_ == 1) {</span></p>
<p><span class="font2">Sconstraints = shift;</span></p>
<p><span class="font2">} elsif (@_ % 2 == 0) { my %constraints = @_; Sconstraints = \%constraints;</span></p>
<p><span class="font2">} else {</span></p>
<p><span class="font2">my Sn = @_;</span></p>
<p><span class="font2">require Carp;</span></p>
<p><span class="font2">Carp::croak(&quot;Sn arguments to Synthetic_Constraint_Set::new&quot;);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">bless Sconstraints =&gt; Sclass;</span></p>
<p><span class="font2">}</span></p>
<h6><a name="bookmark464"></a><span class="font17">It has the usual accessors:</span></h6>
<p><span class="font2">sub constraints { values %{S_[0]} }</span></p>
<p><span class="font2">sub constraint { $_[0]-&gt;{$_[1]} }</span></p>
<p><span class="font2">sub labels { keys %{S_[0]} }</span></p>
<p><span class="font2">sub has_label { exists $_[0]-&gt;{$_[1]} }</span></p>
<h6><a name="bookmark465"></a><span class="font17">Also a method for appending another constraint to the set:</span></h6>
<p><span class="font2">sub add_labeled_constraint {</span></p>
<p><span class="font2">my (Sself, Slabel, Sconstraint) = @_;</span></p>
<p><span class="font2">$self-&gt;{$label} = Sconstraint;</span></p>
<p><span class="font2">}</span></p>
<h6><a name="bookmark466"></a><span class="font17">It has another </span><span class="font2">map</span><span class="font17">-like function that applies a callback to each constraint and returns a new set with the results. This method leaves the labels unchanged:</span></h6>
<p><span class="font2">sub apply {</span></p>
<p><span class="font2">my (Sself, Sfunc) = @_;</span></p>
<p><span class="font2">my %result;</span></p>
<p><span class="font2">for my Sk (Sself-&gt;labels) {</span></p>
<p><span class="font2">$result{$k} = Sfunc-&gt;(Sself-&gt;constraint(Sk));</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">Sself-&gt;new(\%result);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">This function seems to be a good target for currying, but I decided to postpone that change.</span></p>
<p><span class="font17">Like </span><span class="font2">Intrinsic_Constraint_Set</span><span class="font17">, </span><span class="font2">Synthetic_Constraint_Set </span><span class="font17">also has a method for qualifying all of its constraints:</span></p>
<p><span class="font2">sub qualify {</span></p>
<p><span class="font2">my (Sself, Sprefix) = @_;</span></p>
<p><span class="font2">Sself-&gt;apply(sub { $_[0]-&gt;qualify($prefix) });</span></p>
<p><span class="font2">}</span></p>
<h6><a name="bookmark467"></a><span class="font17" style="font-style:italic;">Unlike</span><span class="font2"> Intrinsic_Constraint_Set</span><span class="font17">, whose constraints are not involved in arith</span></h6>
<h6><span class="font17">metic, </span><span class="font2">Synthetic_Constraint_Set </span><span class="font17">has a method for scaling all of its constraints:</span></h6>
<p><span class="font2">sub scale {</span></p>
<p><span class="font2">my (Sself, Scoeff) = @_;</span></p>
<div>
<p><span class="font20">524</span></p>
</div><br clear="all">
<p><span class="font15">CHAPTER 9 Declarative Programming</span></p>
<p><span class="font2">Sself-&gt;apply(sub { $_[0]-&gt;scale_equation($coeff) });</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">Yet another </span><span class="font2">map</span><span class="font17">-like function takes </span><span class="font17" style="font-style:italic;">two</span><span class="font17"> synthetic constraint sets and applies the callback function to pairs of corresponding constraints, building a new set of the results:</span></p>
<p><span class="font2">sub apply2 {</span></p>
<p><span class="font2">my (Sself, $arg, Sfunc) = @_;</span></p>
<p><span class="font2">my %result;</span></p>
<p><span class="font2">for my Sk (Sself-&gt;labels) {</span></p>
<p><span class="font2">next unless Sarg-&gt;has_label(Sk);</span></p>
<p><span class="font2">Sresult{Sk} = Sfunc-&gt;(Sself-&gt;constraint(Sk),</span></p>
<p><span class="font2">Sarg-&gt;constraint(Sk));</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">Sself-&gt;new(\%result);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">This function will be used for addition of features. </span><span class="font2">apply2() </span><span class="font17">will be called to add the matching constraints from the sets of its two operands.</span></p>
<p><span class="font17">This brings up a fine point: What if the labels in the two sets don’t match?</span></p>
<p><span class="font17">For example, what if we have:</span></p>
<p><span class="font2">line L;</span></p>
<p><span class="font2">hline H;</span></p>
<p><span class="font2">L + H = ... ;</span></p>
<p><span class="font17">Here </span><span class="font2">H </span><span class="font17">will have synthetic constraints:</span></p>
<table border="1">
<tr><td>
<p><span class="font17">center.x</span></p></td><td>
<p><span class="font3">^ </span><span class="font17">H.center.x </span><span class="font3">= </span><span class="font17">0</span></p></td></tr>
<tr><td style="vertical-align:bottom;">
<p><span class="font17">center.y</span></p></td><td style="vertical-align:bottom;">
<p><span class="font3">^ </span><span class="font17">H.center.y </span><span class="font3">= </span><span class="font17">0</span></p></td></tr>
<tr><td style="vertical-align:middle;">
<p><span class="font17">end.x</span></p></td><td style="vertical-align:middle;">
<p><span class="font3">^ </span><span class="font17">H.end.x </span><span class="font3">= </span><span class="font17">0</span></p></td></tr>
<tr><td style="vertical-align:bottom;">
<p><span class="font17">end.y</span></p></td><td style="vertical-align:bottom;">
<p><span class="font3">^ </span><span class="font17">H.end.y </span><span class="font3">= </span><span class="font17">0</span></p></td></tr>
<tr><td style="vertical-align:middle;">
<p><span class="font17">length</span></p></td><td style="vertical-align:middle;">
<p><span class="font3">^ </span><span class="font17">H.length </span><span class="font3">= </span><span class="font17">0</span></p></td></tr>
<tr><td style="vertical-align:middle;">
<p><span class="font17">start.x</span></p></td><td style="vertical-align:middle;">
<p><span class="font3">^ </span><span class="font17">H.start.x </span><span class="font3">= </span><span class="font17">0</span></p></td></tr>
<tr><td style="vertical-align:bottom;">
<p><span class="font17">start.y</span></p></td><td style="vertical-align:bottom;">
<p><span class="font3">^ </span><span class="font17">H.start.y </span><span class="font3">= </span><span class="font17">0</span></p></td></tr>
<tr><td style="vertical-align:bottom;">
<p><span class="font17"><sup>y</sup></span></p></td><td style="vertical-align:bottom;">
<p><span class="font3">^ </span><span class="font17">H.y </span><span class="font3">= </span><span class="font17">0</span></p></td></tr>
</table>
<p><span class="font17">but </span><span class="font2">L </span><span class="font17">will be missing a few of these, and will have only:</span></p>
<table border="1">
<tr><td>
<p><span class="font17">center.x</span></p></td><td>
<p><span class="font3">^ </span><span class="font17">L.center.x </span><span class="font3">= </span><span class="font17">0</span></p></td></tr>
<tr><td style="vertical-align:bottom;">
<p><span class="font17">center.y</span></p></td><td style="vertical-align:bottom;">
<p><span class="font3">^ </span><span class="font17">L.center.y </span><span class="font3">= </span><span class="font17">0</span></p></td></tr>
<tr><td style="vertical-align:middle;">
<p><span class="font17">end.x</span></p></td><td style="vertical-align:middle;">
<p><span class="font3">^ </span><span class="font17">L.end.x </span><span class="font3">= </span><span class="font17">0</span></p></td></tr>
<tr><td style="vertical-align:bottom;">
<p><span class="font17">end.y</span></p></td><td style="vertical-align:bottom;">
<p><span class="font3">^ </span><span class="font17">L.end.y </span><span class="font3">= </span><span class="font17">0</span></p></td></tr>
<tr><td style="vertical-align:middle;">
<p><span class="font17">start.x</span></p></td><td style="vertical-align:middle;">
<p><span class="font3">^ </span><span class="font17">L.start.x </span><span class="font3">= </span><span class="font17">0</span></p></td></tr>
<tr><td style="vertical-align:bottom;">
<p><span class="font17">start.y</span></p></td><td style="vertical-align:bottom;">
<p><span class="font3">^ </span><span class="font17">L.start.y </span><span class="font3">= </span><span class="font17">0</span></p></td></tr>
</table>
<p><span class="font17">What happens to </span><span class="font2">H</span><span class="font17">’s </span><span class="font17" style="font-style:italic;">length</span><span class="font17"> and </span><span class="font17" style="font-style:italic;">y</span><span class="font17"> constraints? The right thing to do here is to discard them. The result set is:</span></p>
<p><span class="font17">center.x </span><span class="font3">^ </span><span class="font17">L.center.x </span><span class="font3">+ </span><span class="font17">H.center.x </span><span class="font3">= </span><span class="font17">0 center.y </span><span class="font3">^ </span><span class="font17">L.center.y </span><span class="font3">+ </span><span class="font17">H.center.y </span><span class="font3">= </span><span class="font17">0</span></p>
<p><span class="font17">end.x &nbsp;&nbsp;</span><span class="font3">^ </span><span class="font17">L.end.x </span><span class="font3">+ </span><span class="font17">H.end.x </span><span class="font3">= </span><span class="font17">0</span></p>
<p><span class="font17">end.y &nbsp;</span><span class="font3">^ </span><span class="font17">L.end.y </span><span class="font3">+ </span><span class="font17">H.end.y </span><span class="font3">= </span><span class="font17">0</span></p>
<p><span class="font17">start.x &nbsp;</span><span class="font3">^ </span><span class="font17">L.start.x </span><span class="font3">+ </span><span class="font17">H.start.x </span><span class="font3">= </span><span class="font17">0</span></p>
<p><span class="font17">start.y &nbsp;</span><span class="font3">^ </span><span class="font17">L.start.y </span><span class="font3">+ </span><span class="font17">H.start.y </span><span class="font3">= </span><span class="font17">0</span></p>
<p><span class="font17">Thus, the result of adding an </span><span class="font2">hline </span><span class="font17">and a </span><span class="font2">line </span><span class="font17">is just a </span><span class="font2">line</span><span class="font17">. Similarly if we try to equate an </span><span class="font2">hline </span><span class="font17">and a </span><span class="font2">vline</span><span class="font17">, the resulting expression contains synthetic constraints only for the parts they have in common. The horizontalness and verticalosity are handled by the intrinsic constraint sets instead. There should probably be a check to make sure that the two operands in an addition are of compatible types, but that’s something for the next version. In the meantime, the code in </span><span class="font2">apply2() </span><span class="font17">silently discards constraints with labels present in one but not both argument sets.</span></p>
<p><span class="font17">The final method in </span><span class="font2">Synthetic_Constraint_Set </span><span class="font17">is a special one for handling arithmetic involving features and tuples. Adding a feature to a tuple is interesting. The trick here is that the tuple’s </span><span class="font17" style="font-style:italic;">x</span><span class="font17"> component must be added to all the synthetic constraints that represent </span><span class="font17" style="font-style:italic;">x</span><span class="font17"> coordinates, and similarly for the </span><span class="font17" style="font-style:italic;">y</span><span class="font17"> component. (And similarly also the </span><span class="font17" style="font-style:italic;">z</span><span class="font17"> component in a three-dimensional drawing.) Suppose we had:</span></p>
<p><span class="font2">hline H;</span></p>
<p><span class="font2">H + (3, 4) = ...</span></p>
<p><span class="font17">The synthetic constraint set for </span><span class="font2">H </span><span class="font17">is:</span></p>
<table border="1">
<tr><td>
<p><span class="font17">center.x</span></p></td><td>
<p><span class="font3">^ </span><span class="font17">H.center.x </span><span class="font3">= </span><span class="font17">0</span></p></td></tr>
<tr><td style="vertical-align:bottom;">
<p><span class="font17">center.y</span></p></td><td style="vertical-align:bottom;">
<p><span class="font3">^ </span><span class="font17">H.center.y </span><span class="font3">= </span><span class="font17">0</span></p></td></tr>
<tr><td style="vertical-align:middle;">
<p><span class="font17">end.x</span></p></td><td style="vertical-align:middle;">
<p><span class="font3">^ </span><span class="font17">H.end.x </span><span class="font3">= </span><span class="font17">0</span></p></td></tr>
<tr><td style="vertical-align:bottom;">
<p><span class="font17">end.y</span></p></td><td style="vertical-align:bottom;">
<p><span class="font3">^ </span><span class="font17">H.end.y </span><span class="font3">= </span><span class="font17">0</span></p></td></tr>
<tr><td style="vertical-align:middle;">
<p><span class="font17">length</span></p></td><td style="vertical-align:middle;">
<p><span class="font3">^ </span><span class="font17">H.length </span><span class="font3">= </span><span class="font17">0</span></p></td></tr>
<tr><td style="vertical-align:middle;">
<p><span class="font17">start.x</span></p></td><td style="vertical-align:middle;">
<p><span class="font3">^ </span><span class="font17">H.start.x </span><span class="font3">= </span><span class="font17">0</span></p></td></tr>
<tr><td style="vertical-align:bottom;">
<p><span class="font17">start.y</span></p></td><td style="vertical-align:bottom;">
<p><span class="font3">^ </span><span class="font17">H.start.y </span><span class="font3">= </span><span class="font17">0</span></p></td></tr>
<tr><td style="vertical-align:bottom;">
<p><span class="font17"><sup>y</sup></span></p></td><td style="vertical-align:bottom;">
<p><span class="font3">^ </span><span class="font17">H.y </span><span class="font3">= </span><span class="font17">0</span></p></td></tr>
</table>
<p><span class="font17">The synthetic constraint set of the sum is:</span></p>
<p><span class="font17">center.x </span><span class="font3">^ </span><span class="font17">H.center.x </span><span class="font3">+ </span><span class="font17">3 </span><span class="font3">= </span><span class="font17">0 center.y </span><span class="font3">^ </span><span class="font17">H.center.y </span><span class="font3">+ </span><span class="font17">4 </span><span class="font3">= </span><span class="font17">0 end.x &nbsp;</span><span class="font3">^ </span><span class="font17">H.end.x </span><span class="font3">+ </span><span class="font17">3 </span><span class="font3">= </span><span class="font17">0</span></p>
<p><span class="font17">end.y &nbsp;</span><span class="font3">^ </span><span class="font17">H.end.y </span><span class="font3">+ </span><span class="font17">4 </span><span class="font3">= </span><span class="font17">0</span></p>
<p><span class="font17">length </span><span class="font3">^ </span><span class="font17">H.length </span><span class="font3">= </span><span class="font17">0 start.x </span><span class="font3">^ </span><span class="font17">H.start.x </span><span class="font3">+ </span><span class="font17">3 </span><span class="font3">= </span><span class="font17">0 start.y </span><span class="font3">^ </span><span class="font17">H.start.y </span><span class="font3">+ </span><span class="font17">4 </span><span class="font3">= </span><span class="font17">0 y </span><span class="font3">^ </span><span class="font17">H.y </span><span class="font3">+ </span><span class="font17">4 </span><span class="font3">= </span><span class="font17">0</span></p>
<p><span class="font17">How do we decide whether a synthetic constraint represents an </span><span class="font17" style="font-style:italic;">x</span><span class="font17"> or a </span><span class="font17" style="font-style:italic;">y </span><span class="font17">coordinate? </span><span class="font2">linogram </span><span class="font17">assumes that any feature named </span><span class="font17" style="font-style:italic;">x</span><span class="font17"> is an </span><span class="font17" style="font-style:italic;">x</span><span class="font17"> coordinate, and that any feature named </span><span class="font17" style="font-style:italic;">y</span><span class="font17"> is a </span><span class="font17" style="font-style:italic;">y</span><span class="font17"> coordinate. The tuple’s </span><span class="font17" style="font-style:italic;">x</span><span class="font17"> component should be combined with any synthetic constraint whose label ends in </span><span class="font2">.x </span><span class="font17">or is plain </span><span class="font2">x</span><span class="font17">. This selective combination is handled by yet another </span><span class="font2">map</span><span class="font17">-like function, </span><span class="font2">apply_hash()</span><span class="font17">:</span></p>
<p><span class="font2">sub apply_hash {</span></p>
<p><span class="font2">my (Sself, $hash, Sfunc) = @_; my %result;</span></p>
<p><span class="font2">for my Sc (keys %Shash) { my Sdotc = &quot;.Sc&quot;;</span></p>
<p><span class="font15">9.4 </span><span class="font2">linogram: </span><span class="font15" style="font-variant:small-caps;">a drawing system</span><span class="font20"> 527</span></p>
<p><span class="font2">for my Sk (Sself-&gt;labels) {</span></p>
<p><span class="font2">next unless Sk eq Sc || substr(Sk, -length(Sdotc)) eq Sdotc;</span></p>
<p><span class="font2">Sresult{Sk} = Sfunc-&gt;(Sself-&gt;constraint(Sk), Shash-&gt;{Sc});</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">Sself-&gt;new(\%result);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">Each component of the argument hash has a label, </span><span class="font2">Sc</span><span class="font17">. The function scans the labels of the constraints in the set, which are indexed by </span><span class="font2">Sk</span><span class="font17">. If the constraint label matches the tuple component label, the callback is invoked and its return value is added to the result set. The labels match if they are equal (as with </span><span class="font2">x </span><span class="font17">and </span><span class="font2">x</span><span class="font17">) or if the constraint label ends with a dot followed by the tuple label (as with </span><span class="font2">start.x </span><span class="font17">and </span><span class="font2">x</span><span class="font17">.) The dot is important, because we don’t want a label like </span><span class="font2">max </span><span class="font17">or </span><span class="font2">box </span><span class="font17">to match </span><span class="font2">x</span><span class="font17">.</span></p>
<p><span class="font18" style="font-variant:small-caps;">feature-value methods</span></p>
<p><span class="font17">Now we can see the methods for operating on feature-value objects. The objects themselves contain nothing more than an intrinsic and a synthetic constraint set:</span></p>
<p><span class="font2">package Value::Feature;</span></p>
<p><span class="font2">@Value::Feature::ISA = 'Value';</span></p>
<p><span class="font2">sub kindof { &quot;FEATURE&quot; }</span></p>
<p><span class="font2">sub new {</span></p>
<p><span class="font2">my (Sbase, Sintrinsic, Ssynthetic) = @_;</span></p>
<p><span class="font2">my Sclass = ref Sbase || Sbase;</span></p>
<p><span class="font2">my Sself = {WHAT =&gt; Sbase-&gt;kindof,</span></p>
<p><span class="font2">SYNTHETIC =&gt; Ssynthetic,</span></p>
<p><span class="font2">INTRINSIC =&gt; Sintrinsic,</span></p>
<p><span class="font2">};</span></p>
<p><span class="font2">bless Sself =&gt; Sclass;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">There’s another very important constructor in the </span><span class="font2">Value::Feature </span><span class="font17">class. Instead of building a value from given sets of constraints, it takes a </span><span class="font2">Type </span><span class="font17">object, which represents a type such as </span><span class="font2">box </span><span class="font17">or </span><span class="font2">line</span><span class="font17">, figures out what its constraint sets</span></p>
<div>
<p><span class="font20">528</span></p>
</div><br clear="all">
<p><span class="font15">CHAPTER 9 Declarative Programming</span></p>
<h6><a name="bookmark468"></a><span class="font17">should be, and builds a new value with those constraint sets:</span></h6>
<p><span class="font2">sub new_from_var {</span></p>
<p><span class="font2">my (Sbase, $name, Stype) = @_;</span></p>
<p><span class="font2">my Sclass = ref Sbase || Sbase;</span></p>
<p><span class="font2">Sbase-&gt;new(Stype-&gt;qualified_intrinsic_constraints(Sname), Stype-&gt;qualified_synthetic_constraints(Sname), );</span></p>
<p><span class="font2">}</span></p>
<h6><a name="bookmark469"></a><span class="font2">Value::Feature </span><span class="font17">naturally has two accessors, one for the intrinsic and one for the synthetic constraint sets:</span></h6>
<p><span class="font2">sub intrinsic { S_[0]-&gt;{INTRINSIC} }</span></p>
<p><span class="font2">sub synthetic { S_[0]-&gt;{SYNTHETIC} }</span></p>
<h6><a name="bookmark470"></a><span class="font17">For its scaling operation, it passes the buck to the synthetic constraint set. The intrinsic constraints don’t participate in arithmetic, so they remain the same:</span></h6>
<p><span class="font2">sub scale {</span></p>
<p><span class="font2">my (Sself, Scoeff) = @_;</span></p>
<p><span class="font2">return</span></p>
<p><span class="font2">Sself-&gt;new(Sself-&gt;intrinsic,</span></p>
<p><span class="font2">Sself-&gt;synthetic-&gt;scale(Scoeff), );</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">The four other methods are the ones from the dispatch table. To add two features, we unite their intrinsic constraint sets, and add corresponding constraints from their synthetic constraint sets:</span></p>
<p><span class="font2">sub add_features {</span></p>
<p><span class="font2">my (Sol, So2) = @_;</span></p>
<p><span class="font2">my Sintrinsic = So1-&gt;intrinsic-&gt;union(So2-&gt;intrinsic);</span></p>
<p><span class="font2">my Ssynthetic = Sol-&gt;synthetic-&gt;apply2(So2-&gt;synthetic,</span></p>
<p><span class="font2">sub { S_[0]-&gt;add_equations(S_[1]) }, );</span></p>
<p><span class="font2">So1-&gt;new(Sintrinsic, Ssynthetic);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">Adding constraints is performed by </span><span class="font2">add_equations()</span><span class="font17">, which is inherited from </span><span class="font2">Equation</span><span class="font17">.</span></p>
<p><span class="font17">As with tuples, multiplying a feature by a constant is trivial, since it’s the same as </span><span class="font2">scale()</span><span class="font17">:</span></p>
<p><span class="font2">sub mul_feature_con {</span></p>
<p><span class="font2">my (So, Sc) = @_;</span></p>
<p><span class="font2">So-&gt;scale(Sc-&gt;value);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">Adding a feature to a constant isn’t hard, once we decide what it should mean. The current version of </span><span class="font2">linogram </span><span class="font17">adds the constant to each synthetic constraint. This happens to be correct for features that represent numbers, since, as we’ll see, they have a single synthetic constraint with label </span><span class="font2">&quot;&quot;</span><span class="font17">. But it doesn’t make much sense for most other features. Probably this function should contain a type check to make sure that its feature argument represents a scalar, but that isn’t present in this version:</span></p>
<p><span class="font2">sub add_feature_con {</span></p>
<p><span class="font2">my (So, Sc) = @_;</span></p>
<p><span class="font2">my Sv = Sc-&gt;value;</span></p>
<p><span class="font2">my Ssynthetic = So-&gt;synthetic-&gt;apply(sub { S_[0]-&gt;add_constant(Sv) });</span></p>
<p><span class="font2">So-&gt;new(So-&gt;intrinsic, Ssynthetic);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">Once again, the intrinsic constraints don’t participate in arithmetic, so they’re unchanged.</span></p>
<p><span class="font17">The final method is for adding a feature to a tuple. We use the </span><span class="font2">apply_hash() </span><span class="font17">function that was specifically intended for adding features to tuples. Its callback argument is complicated by the fact that tuple components might not be simple numbers. If the component </span><span class="font17" style="font-style:italic;">is</span><span class="font17"> a simple number (a </span><span class="font2">Value::Constant </span><span class="font17">object), then we use the </span><span class="font2">add_constant() </span><span class="font17">method as in the previous function:</span></p>
<p><span class="font2">sub add_feature_tuple {</span></p>
<p><span class="font2">my (So, St) = @_;</span></p>
<p><span class="font2">my Ssynthetic =</span></p>
<p><span class="font2">So-&gt;synthetic-&gt;apply_hash(St-&gt;to_hash,</span></p>
<p><span class="font2">sub {</span></p>
<p><span class="font2">my (Sconstr, Scomp) = @_;</span></p>
<p><span class="font2">my Skind = Scomp-&gt;kindof;</span></p>
<p><span class="font2">if (Skind eq &quot;CONSTANT&quot;) {</span></p>
<p><span class="font2">Sconstr-&gt;add_constant(Scomp-&gt;value);</span></p>
<div>
<p><span class="font20">530</span></p>
</div><br clear="all">
<p><span class="font15">CHAPTER 9 Declarative Programming</span></p>
<p><span class="font17">If the tuple component is a feature, we assume that it’s a scalar, which has only a single constraint, with label </span><span class="font2">&quot;&quot;</span><span class="font17">:</span></p>
<p><span class="font2">} elsif (Skind eq &quot;FEATURE&quot;) {</span></p>
<p><span class="font2">$constr-&gt;add_equations($comp-&gt;synthetic-&gt;constraint(&quot;&quot;));</span></p>
<p><span class="font17">If the tuple component is another tuple, we croak, because that’s not allowed. This freak tuple should have been forbidden earlier, but there’s little harm in adding more than one check for the same thing:</span></p>
<p><span class="font2">} elsif (Skind eq &quot;TUPLE&quot;) {</span></p>
<p><span class="font2">die &quot;Tuple with subtuple component&quot;;</span></p>
<p><span class="font2">} else {</span></p>
<p><span class="font2">die &quot;Unknown tuple component type 'Skind'&quot;;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">},</span></p>
<p><span class="font2">);</span></p>
<p><span class="font2">So-&gt;new(So-&gt;intrinsic, Ssynthetic);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">1;</span></p>
<p><span class="font17">Once again, the intrinsic constraints are unchanged because they don’t participate in arithmetic.</span></p>
<ul style="list-style:none;"><li>
<h5><a name="bookmark201"></a><span class="font19">9.4.3 Feature Types</span></h5></li></ul>
<p><span class="font17">Where do the constraints come from? If the equation solver is the heart of </span><span class="font2">linogram</span><span class="font17">, then its liver is the parser, which parses the input specification, including the constraint equations. The result of parsing is a hierarchy of feature types such as </span><span class="font2">box </span><span class="font17">and </span><span class="font2">line</span><span class="font17">. These are Perl objects from the class </span><span class="font2">Type</span><span class="font17">. Each type of feature is represented by a </span><span class="font2">Type </span><span class="font17">object, which records the sub-features, the constraints, and the other properties of that kind of feature object.</span></p>
<p><span class="font17">To construct a new type, we call </span><span class="font2">Type::new</span><span class="font17">:</span></p>
<div>
<p><span class="font9" style="font-weight:bold;">CODE LIBRARY</span></p>
</div><br clear="all">
<p><span class="font2">package Type;</span></p>
<p><span class="font0">Type.pm</span></p>
<p><span class="font2">sub new {</span></p>
<p><span class="font2">my (Sold, Sname, Sparent) = @_;</span></p>
<p><span class="font2">my Sclass = ref Sold || Sold;</span></p>
<p><span class="font15">9.4 </span><span class="font2">linogram: </span><span class="font15" style="font-variant:small-caps;">a drawing system</span><span class="font20"> 531</span></p>
<p><span class="font2">my Sself = {N =&gt; $name, P =&gt; Sparent, C =&gt; [], O =&gt; {}, D =&gt; [],</span></p>
<p><span class="font2">};</span></p>
<p><span class="font2">bless Sself =&gt; Sclass;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">Sname </span><span class="font17">is the name of the new type. </span><span class="font2">Sparent </span><span class="font17">is optional, and, if present, is a </span><span class="font2">Type </span><span class="font17">object representing the type from which the new type is extended. For example, the parent of </span><span class="font2">vline </span><span class="font17">is </span><span class="font2">line</span><span class="font17">; the parent of </span><span class="font2">line </span><span class="font17">is undefined. The parent type is stored under member </span><span class="font2">P </span><span class="font17">for &quot;parent&quot;; the name is stored under </span><span class="font2">N</span><span class="font17">.</span></p>
<p><span class="font17">The other members of the </span><span class="font2">Type </span><span class="font17">object are:</span></p>
<ul style="list-style:none;"><li>
<p><span class="font17">• &nbsp;&nbsp;</span><span class="font17" style="font-weight:bold;">C</span><span class="font17">: The constraints defined for the object.</span></p></li>
<li>
<p><span class="font17">• &nbsp;&nbsp;</span><span class="font17" style="font-weight:bold;">O</span><span class="font17">: The sub-features of the type. This is a hash. The keys are the names of the sub-features, and the values are the </span><span class="font2">Type </span><span class="font17">objects representing the types of the sub-features.</span></p></li>
<li>
<p><span class="font17">• &nbsp;&nbsp;</span><span class="font17" style="font-weight:bold;">D</span><span class="font17">: A list of “drawables,” either Perl code references or sub-feature names.</span></p></li></ul>
<p><span class="font18" style="font-variant:small-caps;">scalar types</span></p>
<p><span class="font2">Type </span><span class="font17">has a subclass, </span><span class="font2">Type::Scalar</span><span class="font17">, which represents trivial types, such as </span><span class="font2">number</span><span class="font17">, that have no constraints and no sub-features. </span><span class="font2">linogram </span><span class="font17">has no scalar types other than </span><span class="font2">number</span><span class="font17">, but a future version might introduce some.</span></p>
<p><span class="font17">Sometimes these types behave a little differently from compound types such as points and boxes, so it’s convenient to put their methods into a separate class. One principal difference is the trivial </span><span class="font2">is_scalar </span><span class="font17">method, which returns true for a scalar type object and false for a nonscalar object. </span><span class="font2">Type::Scalar </span><span class="font17">also overrides the methods that are used to install constraints and sub-features into type objects:</span></p>
<p><span class="font2">package Type::Scalar;</span></p>
<p><span class="font2">@Type::Scalar::ISA = 'Type';</span></p>
<p><span class="font2">sub is_scalar { 1 }</span></p>
<p><span class="font2">sub add_constraint {</span></p>
<p><span class="font2">die &quot;Added constraint to scalar type&quot;;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">sub add_subfeature {</span></p>
<p><span class="font2">die &quot;Added subfeature to scalar type&quot;;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">We should never be extending scalar types like </span><span class="font2">number </span><span class="font17">with sub-features or constraints, so overriding these methods provides us with early warning if something is going terribly wrong.</span></p>
<p><span class="font3">Type </span><span class="font17">METHODS</span></p>
<p><span class="font17">The simplest </span><span class="font2">Type </span><span class="font17">method says that types are not scalars, except when the method is overridden by the </span><span class="font2">Type::Scalar </span><span class="font17">version of the method:</span></p>
<p><span class="font2">package Type;</span></p>
<p><span class="font2">sub is_scalar { 0 }</span></p>
<p><span class="font17">Many of the accessor methods on </span><span class="font2">Type </span><span class="font17">objects are straightforward; for example:</span></p>
<p><span class="font2">sub parent { $_[0]{P} }</span></p>
<p><span class="font17">But in some cases, an accessor needs to be referred up the derivation chain to the parent type. For example, a </span><span class="font2">vline </span><span class="font17">has a sub-feature named </span><span class="font2">start</span><span class="font17">, but it’s not stored in the type object for </span><span class="font2">vline</span><span class="font17">; it’s inherited from </span><span class="font2">line</span><span class="font17">. So if we want find out about the type of the </span><span class="font2">start </span><span class="font17">sub-feature of </span><span class="font2">vline</span><span class="font17">, we must search in </span><span class="font2">line</span><span class="font17">. Moreover, a </span><span class="font2">vline </span><span class="font17">has a sub-feature named </span><span class="font2">start.x</span><span class="font17">, which is the </span><span class="font2">x </span><span class="font17">subfeature of the </span><span class="font2">start </span><span class="font17">sub-feature. The </span><span class="font2">subfeature </span><span class="font17">method handles all of these situations:</span></p>
<p><span class="font2">sub subfeature {</span></p>
<p><span class="font2">my ($self, $name, $nocroak) = @_;</span></p>
<p><span class="font2">return $self unless defined $name;</span></p>
<p><span class="font2">my ($basename, $suffix) = split /\./, $name, 2;</span></p>
<p><span class="font2">if (exists $self-&gt;{O}{$basename}) {</span></p>
<p><span class="font2">return $self-&gt;{O}{$basename}-&gt;subfeature($suffix);</span></p>
<p><span class="font2">} elsif (my $parent = $self-&gt;parent) {</span></p>
<p><span class="font2">$parent-&gt;subfeature($name);</span></p>
<p><span class="font2">} elsif ($nocroak) {</span></p>
<p><span class="font2">return;</span></p>
<p><span class="font2">} else {</span></p>
<p><span class="font2">Carp::croak(&quot;Asked for nonexistent subfeature '$name' of type '$self-&gt;{N}'&quot;);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">$type-&gt;subfeature($name) </span><span class="font17">returns the type of the sub-feature of </span><span class="font2">Stype </span><span class="font17">with name </span><span class="font2">Sname</span><span class="font17">. If </span><span class="font2">Sname </span><span class="font17">is a compound name, which contains a dot, it is split into a </span><span class="font2">Sbasename </span><span class="font17">(the component before the first dot) and a </span><span class="font2">Ssuffix </span><span class="font17">(everything after the first dot); the </span><span class="font2">Sbasename </span><span class="font17">is looked up directly, and the </span><span class="font2">Ssuffix </span><span class="font17">is referred to a recursive call to </span><span class="font2">subfeature</span><span class="font17">. If the specified type does not contain a sub-feature with the appropriate basename, then its parent object is consulted instead. If there is no parent type, then the requested sub-feature doesn’t exist, and the function croaks. This is because the error is most likely to be caused by an incorrect specification in the drawing, asking for a nonexistent sub-feature. To disable the croaking behavior, the user of the function can pass the optional third parameter, which makes the function return false instead. An example of this is the simple </span><span class="font2">has_subfeature </span><span class="font17">method, which returns true if the target has a sub-feature of the specified name, and false if not:</span></p>
<p><span class="font2">sub has_subfeature</span></p>
<p><span class="font2">{</span></p>
<p><span class="font2">my (Sself, Sname) = @_;</span></p>
<p><span class="font2">defined($self-&gt;subfeature($name, &quot;don’t croak&quot;));</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">The recursion in </span><span class="font2">subfeature() </span><span class="font17">is in two different directions. Sometimes we recurse from a feature to one of its sub-features, and sometimes we recurse up the type inheritance tree to the parent type. Suppose </span><span class="font2">Sbox</span><span class="font17">, </span><span class="font2">Shline</span><span class="font17">, </span><span class="font2">Sline</span><span class="font17">, </span><span class="font2">Spoint</span><span class="font17">, and </span><span class="font2">Snumber </span><span class="font17">are the </span><span class="font2">Type </span><span class="font17">objects that represent the indicated types. Let’s see how the call </span><span class="font2">Sbox-&gt;subfeature(&quot;top.start.x&quot;) </span><span class="font17">is resolved:</span></p>
<p><span class="font2">Sbox-&gt;subfeature(&quot;top.start.x&quot;)</span></p>
<p><span class="font2">Sbox </span><span class="font17">has a sub-feature called </span><span class="font2">&quot;top&quot;</span><span class="font17">, which is an </span><span class="font2">hline</span><span class="font17">, so the call is referred to the sub-feature type:</span></p>
<p><span class="font2">Shline-&gt;subfeature(&quot;start.x&quot;);</span></p>
<p><span class="font2">Shline </span><span class="font17">has no sub-feature called </span><span class="font2">&quot;start&quot;</span><span class="font17">, so the call is referred to the parent type:</span></p>
<p><span class="font2">Sline-&gt;subfeature(&quot;start.x&quot;);</span></p>
<p><span class="font2">Sline </span><span class="font17">does have a sub-feature called </span><span class="font2">&quot;start&quot;</span><span class="font17">, which is a </span><span class="font2">point</span><span class="font17">, so the call is referred to the sub-feature type:</span></p>
<p><span class="font2">Spoint-&gt;subfeature(&quot;x&quot;);</span></p>
<div>
<p><span class="font20">534</span></p>
</div><br clear="all">
<p><span class="font15">CHAPTER 9 Declarative Programming</span></p>
<p><span class="font2">Spoint </span><span class="font17">does have a sub-feature called </span><span class="font2">&quot;x&quot;</span><span class="font17">, which is a </span><span class="font2">number</span><span class="font17">, so the call is referred to the sub-feature type:</span></p>
<p><span class="font2">Snumber-&gt;subfeature(undef);</span></p>
<p><span class="font17">The call reaches the base case and returns </span><span class="font2">Snumber</span><span class="font17">, which is indeed the type of the </span><span class="font2">top.start.x </span><span class="font17">feature of </span><span class="font2">box</span><span class="font17">.</span></p>
<p><span class="font17">A similar process occurs in the </span><span class="font2">Type::constraints </span><span class="font17">method, which delivers an array of all the constraints of a type, including those implied by the subfeatures and the parent type:</span></p>
<p><span class="font2">sub constraints { my Sself = shift;</span></p>
<p><span class="font17">First the function obtains the constraints inherent in the type itself:</span></p>
<p><span class="font2">my ©constraints = @{Sself-&gt;{C}};</span></p>
<p><span class="font17">Then it obtains the constraints that are inherited from the parent type, and, via recursion, from all the ancestor types:</span></p>
<p><span class="font2">my Sp = Sself-&gt;parent;</span></p>
<p><span class="font2">if (defined Sp) { push ©constraints, ©{Sp-&gt;constraints} }</span></p>
<p><span class="font17">Then it obtains the constraints that it gets from its sub-features, including any constraints that </span><span class="font17" style="font-style:italic;">they</span><span class="font17"> inherit from their ancestor types:</span></p>
<p><span class="font2">while (my (Sname, Stype) = each %{Sself-&gt;{O}}) {</span></p>
<p><span class="font2">my ©subconstraints = ©{Stype-&gt;constraints};</span></p>
<p><span class="font2">push ©constraints, map S_-&gt;qualify(Sname), ©subconstraints;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">\©constraints;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">constraint_set() </span><span class="font17">is the same, except that it returns a </span><span class="font2">Constraint_Set </span><span class="font17">object instead of a raw array reference:</span></p>
<p><span class="font2">sub constraint_set {</span></p>
<p><span class="font2">my Sself = shift;</span></p>
<p><span class="font2">Constraint_Set-&gt;new(©{Sself-&gt;constraints});</span></p>
<p><span class="font2">}</span></p><img src="HigherOrderPerl_files/HigherOrderPerl-64.jpg" alt="" style="width:249pt;height:110pt;">
<p><span class="font17">These constraints are precisely the intrinsic constraints that are used by </span><span class="font2">Value::Feature </span><span class="font17">objects, so we have:</span></p>
<p><span class="font2">sub intrinsic_constraints {</span></p>
<p><span class="font2">my Sconstraints = S_[0]-&gt;constraints;</span></p>
<p><span class="font2">Intrinsic_Constraint_Set-&gt;new(@Sconstraints);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">The </span><span class="font2">new_from_type </span><span class="font17">method of </span><span class="font2">Value::Feature </span><span class="font17">actually wants the </span><span class="font17" style="font-style:italic;">qualified </span><span class="font17">intrinsic constraints:</span></p>
<p><span class="font2">sub qualified_intrinsic_constraints {</span></p>
<p><span class="font2">S_[0]-&gt;intrinsic_constraints-&gt;qualify(S_[1]);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">As usual, the synthetic constraints for a type are rather more interesting. In the absence of any other information, an expression like </span><span class="font2">P </span><span class="font17">is interpreted as the constraint </span><span class="font17" style="font-style:italic;">P =</span><span class="font17"> 0. Later, the </span><span class="font17" style="font-style:italic;">P =</span><span class="font17"> 0 might be combined with a </span><span class="font17" style="font-style:italic;">Q</span><span class="font3"> = </span><span class="font17">0 to produce </span><span class="font17" style="font-style:italic;">P</span><span class="font3"> + </span><span class="font17" style="font-style:italic;">Q</span><span class="font3"> = </span><span class="font17">0or </span><span class="font17" style="font-style:italic;">P — Q =</span><span class="font17"> 0, and we’ll see that we can treat </span><span class="font17" style="font-style:italic;">P = Q</span><span class="font17"> as if it were </span><span class="font17" style="font-style:italic;">P — Q =</span><span class="font17"> 0. So figuring out the synthetic constraints for a type like </span><span class="font2">point </span><span class="font17">involves locating all the scalar type subfeatures of </span><span class="font2">point</span><span class="font17">, and then setting each one to 0.</span></p>
<p><span class="font17">The recursive auxiliary method </span><span class="font2">all_leaf_subfeatures() </span><span class="font17">recovers the names of all the scalar sub-features of the given type (see Figure 9.5). Its name refers to the fact that the sub-feature relation makes each type into a tree. The scalar sub-features are the leaves of the tree.</span></p>
<p><span class="font2">sub all_leaf_subfeatures {</span></p>
<p><span class="font2">my Sself = shift;</span></p>
<p><span class="font2">my @all;</span></p>
<p><span class="font2">my %base = Sself-&gt;subfeatures;</span></p>
<p><span class="font2">while (my (Sname, Stype) = each %base) {</span></p>
<div>
<p><span class="font20">536</span></p>
</div><br clear="all">
<p><span class="font15">CHAPTER 9 Declarative Programming</span></p>
<p><span class="font2">push @all, map {$_ eq &quot;&quot;&nbsp;? Sname : &quot;$name.$_&quot;} $type-&gt;all_leaf_subfeatures;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">@all;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">The function starts by getting all the direct sub-features. These include those defined directly by the target type and also those defined by its ancestor types. Some of these sub-features might be compound features and have sub-features of their own, and some might be leaves. The function loops over them to do the recursion on each one. It qualifies the names appropriately and adds the information to the result array. The special case in the </span><span class="font2">map </span><span class="font17">is to avoid extra periods from appearing at the end of the key names in some cases.</span></p>
<p><span class="font17">To build the synthetic constraint set for a particular type, we locate all the scalar sub-features and make a constraint for each one. If </span><span class="font17" style="font-style:italic;">name</span><span class="font17"> is the name of a scalar subfeature, we introduce the synthetic constraint that has </span><span class="font17" style="font-style:italic;">name =</span><span class="font17"> 0 with label </span><span class="font17" style="font-style:italic;">name</span><span class="font17">:</span></p>
<p><span class="font2">sub synthetic_constraints {</span></p>
<p><span class="font2">my @subfeatures = S_[0]-&gt;all_leaf_subfeatures;</span></p>
<p><span class="font2">Synthetic_Constraint_Set-&gt;new(map {S_ =&gt; Constraint-&gt;new(S_ =&gt; 1)} @subfeatures</span></p>
<p><span class="font2">);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">sub qualified_synthetic_constraints {</span></p>
<p><span class="font2">S_[0]-&gt;synthetic_constraints-&gt;qualify(S_[1]);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">All but one of the remaining </span><span class="font2">Type </span><span class="font17">methods are accessors, most of them fairly simple:</span></p>
<p><span class="font2">sub add_drawable { my (Sself, Sdrawable) = @_; push @{Sself-&gt;{D}}, Sdrawable;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">subfeatures() </span><span class="font17">returns all the direct sub-features of a type, but not the sub-subfeatures. For </span><span class="font2">box</span><span class="font17">, it will return </span><span class="font2">top </span><span class="font17">and </span><span class="font2">nw</span><span class="font17">, but not </span><span class="font2">top.center </span><span class="font17">or </span><span class="font2">nw.y</span><span class="font17">:</span></p>
<p><span class="font2">sub subfeatures { my Sself = shift;</span></p>
<ul style="list-style:none;"><li>
<p class="font15">9.4 <span class="font2">linogram: </span><span class="font15" style="font-variant:small-caps;">a drawing system</span><span class="font20"> 537</span></p></li></ul>
<p><span class="font2">my %all;</span></p>
<p><span class="font2">while (Sself) {</span></p>
<p><span class="font2">%all = (%{Sself-&gt;{O}}, %all); Sself = Sself-&gt;parent;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">%all;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">The function that retrieves the list of drawable sub-features and drawing functions for a type recurses up the type inheritance tree using </span><span class="font2">subfeatures()</span><span class="font17">.</span></p>
<p><span class="font17">It doesn’t need to recurse into the sub-features, because the drawing method will do that itself. We’ll see the drawing method later; here’s the </span><span class="font2">drawables() </span><span class="font17">method, which returns a list of the drawables:</span></p>
<p><span class="font2">sub drawables { my (Sself) = @_; return @{Sself-&gt;{D}} if Sself-&gt;{D} &amp;&amp;&nbsp;@{Sself-&gt;{D}}; if (my Sp = Sself-&gt;parent) { my @drawables = Sp-&gt;drawables; return @drawables if @drawables;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">my %subfeature = Sself-&gt;subfeatures;</span></p>
<p><span class="font2">my @drawables = grep ! Ssubfeature{S_}-&gt;is_scalar, keys %subfeature; @drawables;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">If the type definition contains an explicit drawable list, the method returns it.</span></p>
<p><span class="font17">If not, it uses the drawable list of its parent object, if it has one. If the type has no parent type, the method generates and returns the default, which is a list of all the sub-features that aren’t scalars. There’s no point returning scalars, since they’re not drawable, so they’re filtered out.</span></p>
<p><span class="font17">New sub-features are installed into a type with </span><span class="font2">add_subfeature()</span><span class="font17">. Its arguments are a name and a sub-feature type:</span></p>
<p><span class="font2">sub add_subfeature { my (Sself, Sname, Stype) = @_; Sself-&gt;{O}{Sname} = Stype;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">Similarly, new constraints are installed into a type with </span><span class="font2">add_constraints()</span><span class="font17">.</span></p>
<p><span class="font17">Its arguments are </span><span class="font2">Value::Feature </span><span class="font17">objects. The method extracts the constraints</span></p>
<p><span class="font20">538 </span><span class="font15">CHAPTER 9 Declarative Programming</span></p>
<p><span class="font17">from the values and inserts them into the </span><span class="font2">Type </span><span class="font17">object:</span></p>
<p><span class="font2">sub add_constraints {</span></p>
<p><span class="font2">my (Sself, ©values) = @_;</span></p>
<p><span class="font2">for my Svalue (©values) {</span></p>
<p><span class="font2">next unless Svalue-&gt;kindof eq 'FEATURE';</span></p>
<p><span class="font2">push ©{Sself-&gt;{C}},</span></p>
<p><span class="font2">Svalue-&gt;intrinsic-&gt;constraints,</span></p>
<p><span class="font2">Svalue-&gt;synthetic-&gt;constraints;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">I’ve left the most important </span><span class="font2">Type </span><span class="font17">method for the end. It’s the most important method in the entire program, because it’s the method that actually draws the picture. Its primary argument is a </span><span class="font2">Type </span><span class="font17">object. When invoked for the root type, it draws the entire picture. It’s a little longer than the other methods, so we’ll see it a bit at a time:</span></p>
<p><span class="font2">sub draw {</span></p>
<p><span class="font2">my (Sself, Senv) = ©_;</span></p>
<p><span class="font17">The primary argument, </span><span class="font2">Sself</span><span class="font17">, is the type to draw. The other argument is an </span><span class="font17" style="font-style:italic;">environment,</span><span class="font17"> which belongs to an </span><span class="font2">Environment </span><span class="font17">class we didn’t see. The environment is nothing more than a hash with the names and values of the solutions of the constraints.<a name="footnote38"></a><sup><a href="#bookmark471">38</a></sup><sup></sup> The initial call to </span><span class="font2">draw()</span><span class="font17">, which draws the root feature, omits the environment, because the equations haven’t been solved yet; the missing </span><span class="font2">Senv </span><span class="font17">parameter triggers </span><span class="font2">draw() </span><span class="font17">to solve the equations:</span></p>
<p><span class="font2">unless (Senv) {</span></p>
<p><span class="font2">my Sequations = Sself-&gt;constraint_set;</span></p>
<p><span class="font2">my %solutions = Sequations-&gt;values;</span></p>
<p><span class="font2">Senv = Environment-&gt;new(%solutions);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">The rest of the function does the actual drawing. It scans the list of drawables for the feature being drawn. If the drawable is a reference to an actual drawing</span></p>
<ul style="list-style:none;"><li>
<p class="font15">9.4 <span class="font2">linogram: </span><span class="font15" style="font-variant:small-caps;">a drawing system</span><span class="font20"> 539 </span><span class="font17">function, the function is invoked, and is passed the environment:</span></p></li></ul>
<p><span class="font2">for my Sname (Sself-&gt;drawables) { if (ref Sname) { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# actually a coderef, not a name</span></p>
<p><span class="font2">Sname-&gt;(Senv);</span></p>
<p><span class="font17">Otherwise, the drawable is the name of a sub-feature on which the </span><span class="font2">draw() </span><span class="font17">method is recursively called. The function recovers the type of the sub-feature. It also uses the </span><span class="font2">Environment::subset() </span><span class="font17">method to construct a new environment that contains only the variables relevant to that sub-feature: </span><span class="font2">} else { my Stype = Sself-&gt;subfeature(Sname); my Ssubenv = Senv-&gt;subset(Sname); Stype-&gt;draw(Ssubenv); } } }</span></p>
<p><span class="font2">1;</span></p>
<p><span class="font17">For completeness, here is </span><span class="font2">Environment::subset()</span><span class="font17">:</span></p>
<p class="font2">package Environment;</p>
<div>
<p><span class="font9" style="font-weight:bold;">CODE LIBRARY</span></p>
</div><br clear="all">
<p><span class="font2">sub subset { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="font0"><sup>E</sup>n<sup>vir</sup>on<sup>me</sup>nt.p<sup>m</sup></span></p>
<p><span class="font2">my (Sself, Sname) = @_; my %result; for my Sk (keys %Sself) { my Skk = Sk; if (Skk =- s/~\QSname.//) { Sresult{Skk} = Sself-&gt;{Sk}; } } Sself-&gt;new(%result); }</span></p>
<ul style="list-style:none;"><li>
<h5><a name="bookmark204"></a><span class="font19">9.4.4 The Parser</span></h5></li></ul>
<p class="font17">We’re now ready to see the core of <span class="font2">linogram</span><span class="font17">, which is the parser that parses drawing specifications. First, the lexer, which is straightforward: </span><span class="font2">use Parser ':all';</span></p>
<div>
<p><span class="font9" style="font-weight:bold;">CODE LIBRARY</span></p>
</div><br clear="all">
<p><span class="font2">use Lexer ':all'; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="font0"><sup>lino</sup>g<sup>ram</sup>.p<sup>l</sup></span></p>
<p><span class="font20">540 </span><span class="font15">CHAPTER 9 Declarative Programming</span></p>
<p><span class="font2">my Sinput = sub { read INPUT, my(Sbuf), 8192 or return; $buf };</span></p>
<table border="1">
<tr><td></td><td>
<p><span class="font2">my ©keywords = map [uc(S_), qr/\bS_\b/], qw(constraints define extends draw);</span></p>
<p><span class="font2">my Stokens = iterator_to_stream( make_lexer(Sinput, ©keywords, ['ENDMARKER', qr/__END__.*/s, sub { my Ss = shift; Ss =- s/*__END__\s*//; ['ENDMARKER', Ss] } ], ['IDENTIFIER', qr/[a-zA-Z_]\w*/], ['NUMBER', qr/(?: \d+ (?: \.\d*)?</span></p>
<p><span class="font2">1 \.\d+)</span></p>
<p><span class="font2">(?: [eE] \d+)? /x ], ['FUNCTION', &nbsp;&nbsp;qr/&amp;/],</span></p>
<p><span class="font2">['DOT', &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;qr/\./],</span></p>
<p><span class="font2">['COMMA', &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;qr/,/],</span></p>
<p><span class="font2">['OP', &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;qr|[-+*/]|],</span></p>
<p><span class="font2">['EQUALS', &nbsp;&nbsp;&nbsp;&nbsp;qr/=/],</span></p>
<p><span class="font2">['LPAREN', &nbsp;&nbsp;&nbsp;&nbsp;qr/[(]/],</span></p>
<p><span class="font2">['RPAREN', &nbsp;&nbsp;&nbsp;&nbsp;qr/[)]/],</span></p>
<p><span class="font2">['LBRACE', &nbsp;&nbsp;&nbsp;&nbsp;qr/[{]/],</span></p>
<p><span class="font2">['RBRACE', &nbsp;&nbsp;&nbsp;&nbsp;qr/[}]\n*/],</span></p>
<p><span class="font2">['TERMINATOR', qr/;\n*/],</span></p>
<p><span class="font2">['WHITESPACE', qr/\s+/, sub { &quot;&quot;&nbsp;}],</span></p>
<p><span class="font2">));</span></p></td></tr>
</table>
<p><span class="font17">Only a few of these need comment. </span><span class="font2">IDENTIFIER </span><span class="font17">is a simple variable name, such as </span><span class="font2">box </span><span class="font17">or </span><span class="font2">start</span><span class="font17">. Compound names like </span><span class="font2">start.x </span><span class="font17">will be assembled later, by the parser.</span></p>
<p><span class="font2">ENDMARKER </span><span class="font17">consists of the sequence__</span><span class="font2">END__</span><span class="font17">and </span><span class="font17" style="font-style:italic;">all</span><span class="font17"> the following text up</span></p>
<p><span class="font17">to the end of the file. The lexer preprocesses this to delete the__</span><span class="font2">END__</span><span class="font17">itself,</span></p>
<p><span class="font17">leaving only the following text.</span></p>
<p><span class="font17">Several similar definitions for the </span><span class="font2">CONSTRAINTS</span><span class="font17">, </span><span class="font2">DEFINE</span><span class="font17">, </span><span class="font2">EXTENDS</span><span class="font17">, and </span><span class="font2">DRAW </span><span class="font17">tokens are generated programmatically, and are inserted at the beginning of the lexer definition via the </span><span class="font2">©keywords </span><span class="font17">array.</span></p>
<p><span class="font17">Whitespace, as in earlier parsers, is discarded.</span></p>
<ul style="list-style:none;"><li>
<p class="font15">9.4 <span class="font2">linogram: </span><span class="font15" style="font-variant:small-caps;">a drawing system</span></p>
<div>
<p><span class="font20">541</span></p>
</div><br clear="all"></li></ul>
<p><span class="font17">PARSER EXTENSIONS</span></p>
<p><span class="font17">The parser module used in </span><span class="font2">linogram </span><span class="font17">is based on our functional parser library of Chapter 8, with some additions. Suppose that </span><span class="font2">$A </span><span class="font17">and </span><span class="font2">$B </span><span class="font17">are parsers. Recall the following features supplied by the parser of Chapter 8:</span></p>
<ul style="list-style:none;"><li>
<p><span class="font17">• &nbsp;&nbsp;</span><span class="font2">empty() </span><span class="font17">is a parser that consumes no tokens and always succeeds.</span></p></li>
<li>
<p><span class="font17">• &nbsp;&nbsp;</span><span class="font2">$A - $B </span><span class="font17" style="font-style:italic;">(&quot;A,</span><span class="font17"> then </span><span class="font17" style="font-style:italic;">B&quot;)</span><span class="font17"> is a parser that matches whatever </span><span class="font2">$A </span><span class="font17">matches, consuming the appropriate tokens, and then applies </span><span class="font2">$B </span><span class="font17">to the remaining input, possibly consuming more tokens. It succeeds only if both </span><span class="font2">$A </span><span class="font17">and </span><span class="font2">$B </span><span class="font17">succeed in sequence.</span></p></li>
<li>
<p><span class="font17">• &nbsp;&nbsp;</span><span class="font2">$A | $B </span><span class="font17">(&quot;</span><span class="font17" style="font-style:italic;">A</span><span class="font17"> or </span><span class="font17" style="font-style:italic;">B</span><span class="font17">&quot;) is a parser that tries to apply </span><span class="font2">$A </span><span class="font17">to its input, and, if that doesn’t work, tries </span><span class="font2">$B </span><span class="font17">instead. It succeeds if either of </span><span class="font2">$A </span><span class="font17">or </span><span class="font2">$B </span><span class="font17">succeeds.</span></p></li>
<li>
<p><span class="font17">• &nbsp;&nbsp;</span><span class="font2">star($A) </span><span class="font17">matches zero or more occurrences of whatever </span><span class="font2">$A </span><span class="font17">matches; it is equivalent to </span><span class="font2">empty() | $A - star($A)</span><span class="font17">.</span></p></li>
<li>
<p><span class="font17">• &nbsp;&nbsp;</span><span class="font2">_(...) </span><span class="font17">is a synonym for </span><span class="font2">lookfor([...])</span><span class="font17">, which builds a parser that looks for a single token of the indicated kind. If the next token is of the correct kind, it is consumed and the parser succeeds; otherwise the parser fails.</span></p></li>
<li>
<p><span class="font17">• &nbsp;&nbsp;</span><span class="font2">$A &gt;&gt;&nbsp;$coderef </span><span class="font17">is a synonym for </span><span class="font2">T($A, $coderef)</span><span class="font17">, a parser that applies </span><span class="font2">$A </span><span class="font17">to its input stream, and then uses </span><span class="font2">$coderef </span><span class="font17">to transform the result returned by </span><span class="font2">$A </span><span class="font17">into a different form. It assumes that </span><span class="font2">$A </span><span class="font17">is a concatenation of other parsers.</span></p></li></ul>
<p><span class="font17">To these operations, we’ll add a few extras:</span></p>
<ul style="list-style:none;"><li>
<p><span class="font17">• &nbsp;&nbsp;</span><span class="font2">option($item) </span><span class="font17">indicates that the syntax matched by the </span><span class="font2">$item </span><span class="font17">parser is optional. It builds a parser equivalent to:</span></p></li></ul>
<p><span class="font2">$item | empty()</span></p>
<ul style="list-style:none;"><li>
<p><span class="font17">• &nbsp;&nbsp;</span><span class="font2">labeledblock($label, $contents) </span><span class="font17">is for matching labeled blocks like:</span></p></li></ul>
<p><span class="font2">draw {</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">and:</span></p>
<p><span class="font2">define line {</span></p>
<p><span class="font2">...</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">It’s equivalent to:</span></p>
<p><span class="font2">Slabel - _('LBRACE') - star(Scontents) -_('RBRACE')</span></p>
<p><span class="font2">&gt;&gt; sub { [ $_[0], @{S_[2]} ] }</span></p>
<p><span class="font2">commalist(Sitem, Sseparator) </span><span class="font17">is for matching comma-separated lists of items. The </span><span class="font2">Sseparator </span><span class="font17">defaults to </span><span class="font2">_('COMMA')</span><span class="font17">. It is otherwise equivalent to:</span></p>
<p><span class="font2">Sitem - star(Sseparator - Sitem &gt;&gt;&nbsp;sub { S_[1] })</span></p>
<p><span class="font2">- option(Sseparator)</span></p>
<p><span class="font2">&gt;&gt; sub { [ S_[0], @{S_[1]} ] }</span></p>
<p><span class="font17">The first </span><span class="font2">sub </span><span class="font17">throws away the values associated with the separators, leaving only the values of the items. The second </span><span class="font2">sub </span><span class="font17">accumulates all the item values into a single array, which is the value returned by the </span><span class="font2">commalist </span><span class="font17">parser.</span></p>
<p><span class="font2">Sparser &gt;&nbsp;Scoderef </span><span class="font17">is like </span><span class="font2">Sparser &gt;&gt;&nbsp;Scoderef</span><span class="font17">, except that it doesn’t assume that </span><span class="font2">Sparser </span><span class="font17">is a concatenation. Instead of assuming that the value returned by </span><span class="font2">Sparser </span><span class="font17">is an array reference, and passing the elements of the array to the coderef, it passes the value returned by </span><span class="font2">Sparser </span><span class="font17">directly to </span><span class="font2">Scoderef </span><span class="font17">as a single argument.</span></p>
<p><span class="font2">Sparser / Scondition </span><span class="font17">is like </span><span class="font2">Sparser</span><span class="font17">, with a side condition on the result. It runs </span><span class="font2">Sparser </span><span class="font17">as usual, and then passes the resulting value to the coderef in </span><span class="font2">Scondition</span><span class="font17">. If the condition returns true, the parser succeeds, and the final result is the same value originally returned by </span><span class="font2">Sparser</span><span class="font17">. If the coderef returns false, the parser fails.</span></p>
<p><span class="font3">%TYPES</span></p>
<p><span class="font17">The main data structure in </span><span class="font2">linogram </span><span class="font17">is </span><span class="font2">%TYPES</span><span class="font17">, which is a hash that maps known type names to the </span><span class="font2">Type </span><span class="font17">objects that represent them. When the program starts, </span><span class="font2">%TYPES </span><span class="font17">is initialized with two predefined types:</span></p>
<p><span class="font2">my SROOT_TYPE = Type-&gt;new('ROOT');</span></p>
<p><span class="font2">my %TYPES = ('number' =&gt; Type::Scalar-&gt;new('number'),</span></p>
<p><span class="font2">'ROOT' =&gt; SROOT_TYPE,</span></p>
<p><span class="font2">);</span></p>
<p><span class="font17">Initially, </span><span class="font2">linogram </span><span class="font17">knows about the type </span><span class="font2">number</span><span class="font17">, which is a trivial type with no sub-features and no constraints, and the type </span><span class="font2">ROOT</span><span class="font17">, which represents the entire diagram.</span></p>
<p><span class="font17">PROGRAMS</span></p>
<p><span class="font17">A program in </span><span class="font2">linogram </span><span class="font17">is a series of subtype definitions and feature and constraint declarations which together define the root type. As subtype definitions are encountered, the corresponding </span><span class="font2">Type </span><span class="font17">objects are manufactured and installed in </span><span class="font2">%TYPES</span><span class="font17">. As feature and constraint declarations are encountered, they are installed into the root type object.</span></p>
<p><span class="font17">The top-level parser looks like this:</span></p>
<p><span class="font2">Sprogram = star(SDefinition</span></p>
<p><span class="font2">| SDeclaration</span></p>
<p><span class="font2">&gt; sub { add_declarations(SROOT_TYPE, $_[0]) }</span></p>
<p><span class="font2">)</span></p>
<p><span class="font2">- option(SPerl_code) - SEnd_of_Input</span></p>
<p><span class="font2">&gt;&gt; sub {</span></p>
<p><span class="font2">SROOT_TYPE-&gt;draw();</span></p>
<p><span class="font2">};</span></p>
<p><span class="font17">The </span><span class="font2">Sdefinition </span><span class="font17">parser will take care of manufacturing new type objects and installing them into </span><span class="font2">%TYPES</span><span class="font17">. When a declaration is parsed, </span><span class="font2">add_declarations() </span><span class="font17">will install it into the root type object </span><span class="font2">SROOT_TYPE</span><span class="font17">. The program may be followed with an optional section of plain Perl code, which is a convenient place to stick auxiliary functions like </span><span class="font2">draw_line</span><span class="font17">. When the parser finishes parsing the entire specification, it invokes the </span><span class="font2">draw </span><span class="font17">method on the root type object, drawing the entire diagram.</span></p>
<p><span class="font2">Sperl_code </span><span class="font17">is an optional section at the end of the drawing specification. It’s an arbitrary segment of Perl code, separated from the rest of the specification with the endmarker__</span><span class="font2">END__</span><span class="font17">:</span></p>
<p><span class="font2">Sperl_code = _(&quot;ENDMARKER&quot;) &gt;&nbsp;sub { eval S_[0];</span></p>
<p><span class="font2">die if S@;</span></p>
<p><span class="font2">};</span></p>
<p><span class="font17">The lexer has already trimmed off the endmarker itself. The Perl code is then passed to </span><span class="font2">eval</span><span class="font17">, which compiles the Perl code and installs it into the program.</span></p>
<p><span class="font18" style="font-variant:small-caps;">definitions</span></p>
<p><span class="font2">Sdefinition </span><span class="font17">is a parser for a block of the form: </span><span class="font2">define point { ... }</span></p>
<h6><a name="bookmark472"></a><span class="font17">or:</span></h6>
<p><span class="font2">define hline extends line { ... }</span></p>
<h6><a name="bookmark473"></a><span class="font17">We use the </span><span class="font2">labeledblock </span><span class="font17">function to construct this parser:</span></h6>
<p><span class="font2">Sdefinition = labeledblock(SDefheader, SDeclaration)</span></p>
<p><span class="font2">&gt;&gt; sub {...};</span></p>
<h6><a name="bookmark474"></a><span class="font2">Sdeclaration </span><span class="font17">is the parser for a declaration, which will see shortly. </span><span class="font2">Sdefheader </span><span class="font17">is the part of the definition block before the curly braces:</span></h6>
<p><span class="font2">Sdefheader = _(&quot;DEFINE&quot;) - _(&quot;IDENTIFIER&quot;) - SExtends</span></p>
<p><span class="font2">&gt;&gt; sub { [&quot;DEFINITION&quot;, @_[1,2] ]};</span></p>
<p><span class="font2">Sextends = option(_(&quot;EXTENDS&quot;) - _(&quot;IDENTIFIER&quot;) &gt;&gt;&nbsp;sub { S_[1] }) ;</span></p>
<p><span class="font17">The value from the </span><span class="font2">Sdefinition </span><span class="font17">parser is passed to a postprocessing function that is responsible for constructing a new </span><span class="font2">Type </span><span class="font17">object and installing it into </span><span class="font2">%TYPES</span><span class="font17">; the code is all straightforward. For a definition that begins </span><span class="font2">define hline extends line</span><span class="font17">, </span><span class="font2">Sname </span><span class="font17">is </span><span class="font2">hline </span><span class="font17">and </span><span class="font2">Sextends </span><span class="font17">is </span><span class="font2">Sline</span><span class="font17">:</span></p>
<p><span class="font2">Sdefinition = labeledblock(Sdefheader, SDeclaration)</span></p>
<p><span class="font2">&gt;&gt; sub {</span></p>
<p><span class="font2">my (Sdefheader, ©declarations) = @_;</span></p>
<p><span class="font2">my (Sname, Sextends) = ©Sdefheader[1,2];</span></p>
<p><span class="font2">my Sparent_type = (defined Sextends) ? STYPES{Sextends} : undef;</span></p>
<p><span class="font2">my Snew_type;</span></p>
<p><span class="font2">if (exists STYPES{Sname}) {</span></p>
<p><span class="font2">lino_error(&quot;Type 'Sname' redefined&quot;);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">if (defined Sextends &amp;&amp;&nbsp;! defined Sparent_type) {</span></p>
<p><span class="font2">lino_error(&quot;Type 'Sname' extended from unknown type 'Sextends'&quot;);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">Snew_type = Type-&gt;new(Sname, Sparent_type);</span></p>
<p><span class="font2">add_declarations(Snew_type, ©declarations);</span></p>
<p><span class="font2">STYPES{Sname} = Snew_type;</span></p>
<p><span class="font2">};</span></p>
<ul style="list-style:none;"><li>
<p class="font15">9.4 <span class="font2">linogram: </span><span class="font15" style="font-variant:small-caps;">a drawing system</span></p>
<div>
<p><span class="font20">545</span></p>
</div><br clear="all"></li></ul>
<p><span class="font17">DECLARATIONS</span></p>
<p><span class="font17">A declaration takes one of three forms. One is the declaration of one or more sub-features:</span></p>
<p><span class="font2">hline top, bottom;</span></p>
<p><span class="font17">Two others are </span><span class="font2">constraints </span><span class="font17">and </span><span class="font2">draw </span><span class="font17">sections:</span></p>
<p><span class="font2">constraints { ... } draw { ... }</span></p>
<p><span class="font17">Here’s the declaration parser:</span></p>
<p><span class="font2">$declaration = $Type - commalist($Declarator) - _(&quot;TERMINATOR&quot;) &gt;&gt;&nbsp;sub { ... } | $Constraint_section | $Draw_section </span><span class="font3"><sup>;</sup></span></p>
<p><span class="font17">A </span><span class="font2">$type </span><span class="font17">is the same as an identifier, with the side condition that it must be mentioned in the </span><span class="font2">%TYPES </span><span class="font17">hash:</span></p>
<p><span class="font2">$type = lookfor(&quot;IDENTIFIER&quot;, sub { exists($TYPES{$_[0][1]}) || lino_error(&quot;Unrecognized type '$_[0][1]'&quot;); $_[0][1];</span></p>
<p><span class="font2">} );</span></p>
<p><span class="font17">A declaration might declare more than one variable, as with:</span></p>
<p><span class="font2">hline top, bottom;</span></p>
<p><span class="font17">Each of the sub-parts of the declaration is called a </span><span class="font17" style="font-style:italic;">declarator;</span><span class="font17"> the preceding declaration has two declarators. In its simplest form, a declarator is nothing more than a variable name:</span></p>
<p><span class="font2">$declarator = _(&quot;IDENTIFIER&quot;)</span></p>
<p><span class="font2">- option(_(&quot;LPAREN&quot;) - commalist($Param_Spec) - _(&quot;RPAREN&quot;) &gt;&gt;&nbsp;sub { $_[1] } )</span></p>
<p><span class="font2">&gt;&gt; sub {</span></p>
<p><span class="font2">{ WHAT =&gt; 'DECLARATOR', NAME =&gt; $_[0], PARAM_SPECS =&gt; $_[1],</span></p>
<p><span class="font2">};</span></p>
<p><span class="font2">};</span></p>
<h6><a name="bookmark475"></a><span class="font17">The optional section in the middle is for a parenthesis-delimited list of “parameter specifications.” A declarator might look like this:</span></h6>
<p><span class="font2">... F(ht=3, wd=boxwid), ...</span></p>
<h6><a name="bookmark476"></a><span class="font17">which is equivalent to:</span></h6>
<p><span class="font2">... F, ...</span></p>
<p><span class="font2">F.ht = 3;</span></p>
<p><span class="font2">F.wd = boxwid;</span></p>
<p><span class="font17">The </span><span class="font2">sub { $_[1] } </span><span class="font17">discards the parentheses; the parameter specifications are packaged into the resulting value under the key </span><span class="font2">PARAM_SPECS</span><span class="font17">. The format of a parameter specification is simple:</span></p>
<p><span class="font2">Sparam_spec = _(&quot;IDENTIFIER&quot;) - _(&quot;EQUALS&quot;) - SExpression &gt;&gt;&nbsp;sub {</span></p>
<p><span class="font2">{ WHAT =&gt; &quot;PARAM_SPEC&quot;, NAME =&gt; S_[0], VALUE =&gt; S_[2],</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
<p><span class="font3"><sup>;</sup></span></p>
<h6><a name="bookmark477"></a><span class="font17">Thus the value manufactured for the declarator </span><span class="font2">F(ht=3, wd=boxwid) </span><span class="font17">looks like this:</span></h6>
<p><span class="font2">{ WHAT =&gt; 'DECLARATOR', NAME =&gt; 'F', PARAM_SPECS =&gt;</span></p>
<p><span class="font2">[ { WHAT =&gt; 'PARAM_SPEC', NAME =&gt; 'ht', VALUE =&gt; (expression representing constant 3), },</span></p>
<p><span class="font2">{ WHAT =&gt; 'PARAM_SPEC',</span></p>
<p><span class="font2">NAME =&gt; 'wd',</span></p>
<p><span class="font2">VALUE =&gt; (expression representing variable 'boxwid'), },</span></p>
<p><span class="font2">]</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">We haven’t yet seen the representation for expressions.</span></p>
<p><span class="font17">The </span><span class="font2">$declaration </span><span class="font17">parser gets a type name and a list of declarators and manufactures a declaration value; later on, the </span><span class="font2">add_declarations() </span><span class="font17">function will install this declaration into the appropriate </span><span class="font2">Type </span><span class="font17">object. The declaration value is manufactured as follows:</span></p>
<p><span class="font2">$declaration = $Type - commalist($Declarator) - _(&quot;TERMINATOR&quot;) &gt;&gt;&nbsp;sub { my ($type, $decl_list) = @_;</span></p>
<p><span class="font2">unless (exists $TYPES{$type}) { lino_error(&quot;Unknown type name '$type' in declaration '@_'\n&quot;);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">for (@$decl_list) { $_-&gt;{TYPE} = $type; check_declarator($TYPES{$type}, $_);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">{WHAT =&gt; 'DECLARATION', DECLARATORS =&gt; $decl_list }; }</span></p>
<p><span class="font2">| $Constraint_section</span></p>
<p><span class="font2">| $Draw_section</span></p>
<h6><a name="bookmark478"></a><span class="font17">The construction function checks to make sure the type used in the declaration actually exists. It then installs the type into each declarator value, transforming:</span></h6>
<p><span class="font2">{ WHAT =&gt; 'DECLARATOR',</span></p>
<p><span class="font2">NAME =&gt; 'F',</span></p>
<p><span class="font2">PARAM_SPECS =&gt; [ ... ],</span></p>
<p><span class="font2">}</span></p>
<h6><a name="bookmark479"></a><span class="font17">into:</span></h6>
<p><span class="font2">{ WHAT =&gt; 'DECLARATOR',</span></p>
<p><span class="font2">NAME =&gt; 'F', PARAM_SPECS =&gt; [ ... ],</span></p>
<p><span class="font2" style="font-weight:bold;">TYPE =&gt; $type,</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">Each declarator is also checked to make sure the names in its parameter specifications are actually the names of sub-features of its type. </span><span class="font2">box F(ht=3) </span><span class="font17">passes the check, but </span><span class="font2">box F(age=34) </span><span class="font17">fails, because boxes don’t have ages. This check is performed by </span><span class="font2">check_declarator()</span><span class="font17">:</span></p>
<p><span class="font2">sub check_declarator {</span></p>
<p><span class="font2">my ($type, $declarator) = @_;</span></p>
<p><span class="font2">for my $pspec (@{$declarator-&gt;{PARAM_SPECS}}) {</span></p>
<p><span class="font2">my $name = $pspec-&gt;{NAME};</span></p>
<p><span class="font2">unless ($type-&gt;has_subfeature($name)) { lino_error(&quot;Declaration of '$declarator-&gt;{NAME}' &quot;&nbsp;. &quot;specifies unknown subfeature '$name' &quot;&nbsp;. &quot;for type '$type-&gt;{N}'\n&quot;);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">Declarator values are combined into declaration values; a typical declaration value, for the declaration </span><span class="font2">box C, F(ht=3, wd=boxwid);</span><span class="font17">, looks like this:</span></p>
<p><span class="font2">{ WHAT =&gt; 'DECLARATION', DECLARATORS =&gt;</span></p>
<p><span class="font2">[ { WHAT =&gt; 'DECLARATOR',</span></p>
<p><span class="font2">NAME =&gt; 'C', PARAM_SPECS =&gt; [], TYPE =&gt; 'box',</span></p>
<p><span class="font2">},</span></p>
<p><span class="font2">{ WHAT =&gt; 'DECLARATOR', NAME =&gt; 'F', PARAM_SPECS =&gt;</span></p>
<p><span class="font2">[ { WHAT =&gt; 'PARAM_SPEC', NAME =&gt; 'ht',</span></p>
<ul style="list-style:none;"><li>
<p class="font15">9.4 <span class="font2">linogram: </span><span class="font15" style="font-variant:small-caps;">a drawing system</span></p></li></ul>
<p><span class="font2">VALUE =&gt; </span><span class="font2" style="font-style:italic;">(expression representing constant 3),</span></p>
<p><span class="font2">},</span></p>
<p><span class="font2">{ WHAT =&gt; 'PARAM_SPEC',</span></p>
<p><span class="font2">NAME =&gt; 'wd',</span></p>
<p><span class="font2">VALUE =&gt; </span><span class="font2" style="font-style:italic;">(expression representing variable 'boxwid')</span></p>
<p><span class="font2">},</span></p>
<p><span class="font2">]</span></p>
<p><span class="font2">TYPE =&gt; 'box',</span></p>
<p><span class="font2">},</span></p>
<p><span class="font2">]</span></p>
<p><span class="font2">}</span></p>
<h6><a name="bookmark480"></a><span class="font17">The other two kinds of declarations we’ve seen before have been constraint and draw sections, which have their own productions in the grammar:</span></h6>
<p><span class="font2">$declaration = ...</span></p>
<p><span class="font2">| $Constraint_section</span></p>
<p><span class="font2">| $Draw_section</span></p>
<p><span class="font2">;</span></p>
<h6><a name="bookmark481"></a><span class="font17">The overall structure of a constraint section is a block, labeled with the word </span><span class="font2">constraints</span><span class="font17">:</span></h6>
<p><span class="font2">$constraint_section = labeledblock(_(&quot;CONSTRAINTS&quot;), $Constraint) &gt;&gt;&nbsp;sub { shift;</span></p>
<p><span class="font2">{ WHAT =&gt; 'CONSTRAINTS', CONSTRAINTS =&gt; [@_] } };</span></p>
<h6><a name="bookmark482"></a><span class="font17">A constraint is simply an equation, which is a pair of expressions with an equal sign between them:</span></h6>
<p><span class="font2">$constraint = $Expression - _(&quot;EQUALS&quot;) - $Expression - _(&quot;TERMINATOR&quot;) &gt;&gt;&nbsp;sub { Expression-&gt;new('-', $_[0], $_[2]) } ;</span></p>
<p><span class="font17">The value of the constraint is not actually a </span><span class="font2">Constraint </span><span class="font17">object, but rather an </span><span class="font2">Expression </span><span class="font17">object. Since the constraint </span><span class="font17" style="font-style:italic;">A = B</span><span class="font17"> is semantically equivalent to </span><span class="font17" style="font-style:italic;">A — B =</span><span class="font17"> 0, we compile it into an expression that represents </span><span class="font2">A - B </span><span class="font17">and leave it at that. The finished value for a constraint section, say for:</span></p>
<p><span class="font2">constraints { start.x = end.x;</span></p>
<p><span class="font2">start.x = x;</span></p>
<p><span class="font2">start.y + height = end.y;</span></p>
<p><span class="font2">}</span></p>
<div>
<p><span class="font20">549</span></p>
</div><br clear="all">
<h6><a name="bookmark483"></a><span class="font17">is the hash:</span></h6>
<p><span class="font2">{ WHAT =&gt; 'CONSTRAINTS', CONSTRAINTS =&gt;</span></p>
<p><span class="font2">[ </span><span class="font2" style="font-style:italic;">(expression representing start.x - end.x), (expression representing start.x - x), (expression representing start.y + height - end.y),</span></p>
<p><span class="font2">] }</span></p>
<h6><a name="bookmark484"></a><span class="font17">The third sort of declaration is a </span><span class="font2">draw </span><span class="font17">section, which might look like this:</span></h6>
<p><span class="font2">draw { &amp;draw_line; }</span></p>
<h6><a name="bookmark485"></a><span class="font17">or like this:</span></h6>
<p><span class="font2">draw { top; bottom; left; right; }</span></p>
<h6><a name="bookmark486"></a><span class="font17">Once again, it is a labeled block, very similar to the definition of the constraint section:</span></h6>
<p><span class="font2">$draw_section = labeledblock(_(&quot;DRAW&quot;), $Drawable) &gt;&gt;&nbsp;sub { shift; { WHAT =&gt; 'DRAWABLES', DRAWABLES =&gt; [@_] } };</span></p>
<h6><a name="bookmark487"></a><span class="font17">Since there are two possible formats for a drawable, however, the definition of </span><span class="font2">$drawable </span><span class="font17">is a little more complicated than the definition of </span><span class="font2">$constraint</span><span class="font17">:</span></h6>
<p><span class="font2">$drawable = $Name - _(&quot;TERMINATOR&quot;) &gt;&gt;&nbsp;sub { { WHAT =&gt; 'NAMED_DRAWABLE',</span></p>
<p><span class="font2">NAME =&gt; $_[1], } }</span></p>
<p><span class="font2">| _(&quot;FUNCTION&quot;) - _(&quot;IDENTIFIER&quot;) - _(&quot;TERMINATOR&quot;) &gt;&gt;&nbsp;sub { my $ref = \&amp;{$_[1]};</span></p>
<p><span class="font2">{ WHAT =&gt; 'FUNCTIONAL_DRAWABLE', REF =&gt; $ref, NAME =&gt; $_[1],</span></p>
<p><span class="font2">};</span></p>
<p><span class="font2">};</span></p>
<p><span class="font17">The first clause handles the case where the drawable is the name of a subfeature of the feature being defined, say </span><span class="font2">top;</span><span class="font17">. In this case we construct</span></p>
<ul style="list-style:none;"><li>
<p class="font15">9.4 <span class="font2">linogram: </span><span class="font15" style="font-variant:small-caps;">a drawing system</span><span class="font20"> 551</span></p></li></ul>
<p><span class="font17">the value:</span></p>
<p><span class="font2">{ WHAT =&gt; 'NAMED_DRAWABLE', NAME =&gt; 'top',</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">The other clause handles the case where the drawable is the name of a Perl function, say </span><span class="font2">&amp;draw_line;</span><span class="font17">. In this case we construct the value:</span></p>
<p><span class="font2">{ WHAT =&gt; 'FUNCTIONAL_DRAWABLE',</span></p>
<p><span class="font2">NAME =&gt; 'draw_line',</span></p>
<p><span class="font2">REF =&gt; \&amp;draw_line,</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">The </span><span class="font2">NAME </span><span class="font17">member here is just for debugging purposes; only the reference is actually used. Drawables of both types may be mixed in the same </span><span class="font2">draw </span><span class="font17">section. A draw section like </span><span class="font2">draw { top; &amp;draw_line; } </span><span class="font17">turns into the value:</span></p>
<p><span class="font2">{ WHAT =&gt; 'DRAWABLES',</span></p>
<p><span class="font2">DRAWABLES =&gt; [ { WHAT =&gt; 'NAMED_DRAWABLE', NAME =&gt; 'TOP',</span></p>
<p><span class="font2">},</span></p>
<p><span class="font2">{ WHAT =&gt; 'FUNCTIONAL_DRAWABLE', NAME =&gt; 'draw_line', REF =&gt; \&amp;draw_line,</span></p>
<p><span class="font2">},</span></p>
<p><span class="font2">]</span></p>
<p><span class="font17">When a complete type definition has been parsed, several values will be available: the type name; the name of the parent type, if there is one; and the list of declarations. The parser function manufactures a new type object from class </span><span class="font2">Type</span><span class="font17">, and calls </span><span class="font2">add_declarations() </span><span class="font17">to install the declarations into the new object.</span></p>
<p><span class="font2">add_declarations() </span><span class="font17">is rather complicated, because it has many different branches to handle the different kinds of declarations. Each branch individually is simple, which argues for a dispatch table structure:</span></p>
<p><span class="font2">my %add_decl = ('DECLARATION' =&gt; \&amp;add_subfeature_declaration, 'CONSTRAINTS' =&gt; \&amp;add_constraint_declaration, 'DRAWABLES' =&gt; \&amp;add_draw_declaration,</span></p>
<div>
<p><span class="font20">552</span></p>
</div><br clear="all">
<p><span class="font15">CHAPTER 9 Declarative Programming</span></p>
<p><span class="font2">'DEFAULT' =&gt; sub {</span></p>
<p><span class="font2">lino_error(&quot;Unknown declaration kind 'S[1]{WHAT}'&quot;);</span></p>
<p><span class="font2">},</span></p>
<p><span class="font2">);</span></p>
<p><span class="font2">sub add_declarations {</span></p>
<p><span class="font2">my (Stype, @declarations) = @_;</span></p>
<p><span class="font2">for my Sdeclaration (@declarations) {</span></p>
<p><span class="font2">my Sdecl_kind = Sdeclaration-&gt;{WHAT};</span></p>
<p><span class="font2">my Sfunc = Sadd_decl{Sdecl_kind} || Sadd_decl{DEFAULT};</span></p>
<p><span class="font2">Sfunc-&gt;(Stype, Sdeclaration);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
<h6><a name="bookmark488"></a><span class="font17">Sub-feature declarations to </span><span class="font2">Type </span><span class="font17">objects are added by this function, which loops over the declarators, adding them one at a time:</span></h6>
<p><span class="font2">sub add_subfeature_declaration {</span></p>
<p><span class="font2">my (Stype, Sdeclaration) = @_;</span></p>
<p><span class="font2">my Sdeclarators = Sdeclaration-&gt;{DECLARATORS};</span></p>
<p><span class="font2">for my Sdecl (@Sdeclarators) {</span></p>
<p><span class="font2">my Sname = Sdecl-&gt;{NAME};</span></p>
<p><span class="font2">my Sdecl_type = Sdecl-&gt;{TYPE};</span></p>
<p><span class="font2">my Sdecl_type_obj = STYPES{Sdecl_type};</span></p>
<p><span class="font2">Sdecl_type </span><span class="font17">is the name of the type of the sub-feature being declared; </span><span class="font2">Sdecl_type_obj </span><span class="font17">is the </span><span class="font2">Type </span><span class="font17">object that represents that type. The first thing the function does is record the name and the type of the new sub-feature:</span></p>
<p><span class="font2">Stype-&gt;add_subfeature(Sname, Sdecl_type_obj);</span></p>
<p><span class="font17">Unless the declarator came with parameter specifications, the function is done. If there were parameter specifications, the function turns them into constraints and adds them to the type’s list of constraints:</span></p>
<p><span class="font2">for my Spspec (@{Sdecl-&gt;{PARAM_SPECS}}) {</span></p>
<p><span class="font2">my Spspec_name = Spspec-&gt;{NAME};</span></p>
<p><span class="font2">my Sconstraints = convert_param_specs(Stype, Sname, Spspec);</span></p>
<p><span class="font2">Stype-&gt;add_constraints(Sconstraints);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
<ul style="list-style:none;"><li>
<p class="font15">9.4 <span class="font2">linogram: </span><span class="font15" style="font-variant:small-caps;">a drawing system</span><span class="font20"> 553</span></p></li></ul>
<p><span class="font2">convert_param_specs() </span><span class="font17">turns the parameter specifications into constraints. We’ll see this function later, after we’ve discussed the way in which expressions are turned into constraints.</span></p>
<p><span class="font2">sub add_constraint_declaration {</span></p>
<p><span class="font2">my (Stype, Sdeclaration) = @_;</span></p>
<p><span class="font2">my Sconstraint_expressions = Sdeclaration-&gt;{CONSTRAINTS};</span></p>
<p><span class="font2">my ©constraints</span></p>
<p><span class="font2">= map expression_to_constraints(Stype, S_),</span></p>
<p><span class="font2">©Sconstraint_expressions;</span></p>
<p><span class="font2">Stype-&gt;add_constraints(©constraints);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">This function is invoked to install a </span><span class="font2">constraints </span><span class="font17">block into a type object. The contents of the </span><span class="font2">constraints </span><span class="font17">block have been turned into </span><span class="font2">Expression </span><span class="font17">objects, but these objects are still essentially abstract syntax trees, and haven’t yet been turned into constraints. The function </span><span class="font2">expression_to_constraints() </span><span class="font17">performs that conversion. </span><span class="font2">add_constraints() </span><span class="font17">then inserts the new constraints into the type object’s constraint list. We’ll see </span><span class="font2">expression_to_constraints() </span><span class="font17">later, along with the other functions that deal with expressions.</span></p>
<p><span class="font17">The third sort of declaration is a </span><span class="font2">draw </span><span class="font17">section, whose contents are drawables. These are installed into a type object by </span><span class="font2">add_draw_declaration()</span><span class="font17">:</span></p>
<p><span class="font2">sub add_draw_declaration {</span></p>
<p><span class="font2">my (Stype, Sdeclaration) = ©_;</span></p>
<p><span class="font2">my Sdrawables = Sdeclaration-&gt;{DRAWABLES};</span></p>
<p><span class="font2">for my Sd (©Sdrawables) {</span></p>
<p><span class="font2">my Sdrawable_type = Sd-&gt;{WHAT};</span></p>
<p><span class="font2">if (Sdrawable_type eq &quot;NAMED_DRAWABLE&quot;) {</span></p>
<p><span class="font2">unless (Stype-&gt;has_subfeature(Sd-&gt;{NAME})) {</span></p>
<p><span class="font2">lino_error(&quot;Unknown drawable feature 'Sd-&gt;{NAME}'</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">Stype-&gt;add_drawable(Sd-&gt;{NAME});</span></p>
<p><span class="font2">} elsif (Sdrawable_type eq &quot;FUNCTIONAL_DRAWABLE&quot;) {</span></p>
<p><span class="font2">Stype-&gt;add_drawable(Sd-&gt;{REF});</span></p>
<p><span class="font2">} else {</span></p>
<p><span class="font2">lino_error(&quot;Unknown drawable type 'Stype'&quot;);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">There are two branches here, for the two kinds of drawables. One is a functional drawable, typified by </span><span class="font2">&amp;draw_line</span><span class="font17">; here we insert a reference to the Perl </span><span class="font2">draw_line </span><span class="font17">function into the drawables list. The other kind of drawable is a named drawable, which is the name of a sub-feature; here we insert the name into the drawables list. The only real difference in handling is that we make sure that the name of a named drawable is already known.</span></p>
<p><span class="font17">EXPRESSIONS</span></p>
<p><span class="font17">The expression parser is similar to the ones we saw in Chapter 8. Its output is essentially an abstract syntax tree, blessed into the </span><span class="font2">Expression </span><span class="font17">class. Expressions appear in constraints and on the right-hand sides of parameter specifications. The grammar is:</span></p>
<p><span class="font2">Sexpression = operator(STerm,</span></p>
<p><span class="font2">[_('OP', '+'), sub { Expression-&gt;new('+', @_) } ],</span></p>
<p><span class="font2">[_('OP', '-'), sub { Expression-&gt;new('-', @_) } ], );</span></p>
<p><span class="font2">Sterm = operator(SAtom,</span></p>
<p><span class="font2">[_('OP', '*'), sub { Expression-&gt;new('*', @_) } ],</span></p>
<p><span class="font2">[_('OP', '/'), sub { Expression-&gt;new('/', @_) } ], );</span></p>
<p><span class="font17">which is nothing new. Expressions, as mentioned before, are nothing more than abstract syntax trees. </span><span class="font2">Expression::new() </span><span class="font17">is trivial:</span></p>
<p><span class="font2">package Expression;</span></p>
<p><span class="font2">sub new {</span></p>
<p><span class="font2">my (Sbase, Sop, @args) = @_;</span></p>
<p><span class="font2">my Sclass = ref Sbase || Sbase;</span></p>
<p><span class="font2">bless [ Sop, @args ] =&gt; Sclass;</span></p>
<p><span class="font2">}</span></p>
<ul style="list-style:none;"><li>
<p class="font15">9.4 <span class="font2">linogram: </span><span class="font15" style="font-variant:small-caps;">a drawing system</span><span class="font20"> 555</span></p></li></ul>
<p><span class="font17">The </span><span class="font2">Satom </span><span class="font17">parser accepts the usual numbers and parenthesized compound expressions. But there are a few additional atoms of interest:</span></p>
<p><span class="font2">package main;</span></p>
<p><span class="font2">Satom = SName</span></p>
<p><span class="font2">| STuple</span></p>
<p><span class="font2">| lookfor(&quot;NUMBER&quot;, sub { Expression-&gt;new('CON', S_[0][1]) })</span></p>
<p><span class="font2">| _('OP', '-') - SExpression</span></p>
<p><span class="font2">&gt;&gt; sub { Expression-&gt;new('-', Expression-&gt;new('CON', 0), S_[1]) }</span></p>
<p><span class="font2">| _(&quot;LPAREN&quot;) - SExpression - _(&quot;RPAREN&quot;) &gt;&gt;&nbsp;sub {S_[1]};</span></p>
<p><span class="font17">The </span><span class="font2">_('OP', '-') </span><span class="font17">production handles unary minus expressions such as </span><span class="font2">-A</span><span class="font17">; this</span></p>
<p><span class="font17">is compiled as if it had been written </span><span class="font2">0-A</span><span class="font17">.</span></p>
<p><span class="font2">Sname </span><span class="font17">is a variable name, possibly a compound variable name containing</span></p>
<p><span class="font17">dots; it is turned into an expression object containing </span><span class="font2">['VAR', Svarname]</span><span class="font17">:</span></p>
<p><span class="font2">Sname = SBase_name</span></p>
<p><span class="font2">- star(_(&quot;DOT&quot;) - _(&quot;IDENTIFIER&quot;) &gt;&gt;&nbsp;sub { S_[1] })</span></p>
<p><span class="font2">&gt;&gt; sub { Expression-&gt;new('VAR', join(&quot;.&quot;, S_[0], @{S_[1]})) }</span></p>
<p><span class="font2">Sbase_name = _&quot;IDENTIFIER&quot;;</span></p>
<p><span class="font17">Similarly, a number is turned into an expression object containing </span><span class="font2">['CON', Snumber]</span><span class="font17">. (</span><span class="font2">CON </span><span class="font17">is an abbreviation for “constant.”)</span></p>
<p><span class="font2">Stuple </span><span class="font17">is a tuple expression, which we saw before in connection with the constraint:</span></p>
<p><span class="font2">plus = F + (hspc, 0);</span></p>
<p><span class="font17">The </span><span class="font2">(hspc, 0) </span><span class="font17">is a tuple expression. Syntactically, a tuple is a parenthesized, comma-separated list of expressions. But its parser has some interesting features:</span></p>
<p><span class="font2">Stuple = _(&quot;LPAREN&quot;)</span></p>
<ul style="list-style:none;"><li>
<p><span class="font2">- commalist(SExpression) / sub { @{S_[0]} &gt;&nbsp;1 }</span></p></li>
<li>
<p><span class="font2">- _(&quot;RPAREN&quot;)</span></p></li></ul>
<p><span class="font17">The side condition </span><span class="font2">sub { @{S_[0]} &gt;&nbsp;1 } </span><span class="font17">requires that the comma-separated list have more than one value in it. This prevents something like </span><span class="font2">(3) </span><span class="font17">from ever being parsed as a 1-tuple.</span></p>
<p><span class="font20">556 </span><span class="font15">CHAPTER 9 Declarative Programming</span></p>
<p><span class="font17">The value of the tuple expression is generated as follows:</span></p>
<p><span class="font2">&gt;&gt; sub {</span></p>
<p><span class="font2">my (Sexplist) = S_[1];</span></p>
<p><span class="font2">my SN = @Sexplist;</span></p>
<p><span class="font2">my @axis = qw(x y z);</span></p>
<p><span class="font2">if (SN == 2 || SN == 3) {</span></p>
<p><span class="font2">return [ 'TUPLE',</span></p>
<p><span class="font2">{ map { Saxis[S_] =&gt; Sexplist-&gt;[S_] } (0 .. SN-1) } ];</span></p>
<p><span class="font2">} else {</span></p>
<p><span class="font2">lino_error(&quot;SN-tuples are not supported \n&quot;);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">} ;</span></p>
<p><span class="font17">This does two things. First, it checks to make sure that the tuple has exactly two or three elements. For two-dimensional diagrams, only 2-tuples make sense.</span></p>
<p><span class="font17">3-tuples are supported because </span><span class="font2">linogram </span><span class="font17">might as easily be used for threedimensional diagrams. One would have to write another standard library, including definitions like:</span></p>
<p><span class="font2">define point { number x, y, z; }</span></p>
<p><span class="font17">and with replacement drawing functions that understood about perspective. But once this was done, </span><span class="font2">linogram </span><span class="font17">would handle three-dimensional diagrams as well as it handles two-dimensional ones. Many of the standard library definitions would remain exactly the same. For example, the definition of </span><span class="font2">line </span><span class="font17">would not need to change; a line is determined by its two endpoints, regardless of whether those endpoints are considered to be points in two or three dimensions. </span><span class="font17" style="font-style:italic;">n</span><span class="font17">-tuples for </span><span class="font17" style="font-style:italic;">n</span><span class="font17"> larger than three are forbidden until someone thinks of a use for them.</span></p>
<p><span class="font17">The value returned from the tuple parser for a tuple such as </span><span class="font2">(5, 12) </span><span class="font17">is:</span></p>
<p><span class="font2">[ 'TUPLE',</span></p>
<p><span class="font2">{ x =&gt; 5,</span></p>
<p><span class="font2">y =&gt; 12, }</span></p>
<p><span class="font2">]</span></p>
<p><span class="font17">For 3-tuples, there is an additional </span><span class="font2">z </span><span class="font17">member of the hash. The special treatment of the names </span><span class="font2">x</span><span class="font17">, </span><span class="font2">y</span><span class="font17">, and </span><span class="font2">z </span><span class="font17">comes ultimately from here.</span></p>
<ul style="list-style:none;"><li>
<p class="font15">9.4 <span class="font2">linogram: </span><span class="font15" style="font-variant:small-caps;">a drawing system</span><span class="font20"> 557</span></p></li></ul>
<p><span class="font17">The result of parsing an expression, as mentioned before, is an abstract syntax tree. For the expression </span><span class="font2">x + 2 * y</span><span class="font17">, the tree is:</span></p>
<p><span class="font2">[ ' + ', ['VAR', 'x'],</span></p>
<p><span class="font2">['*', ['CON', 2],</span></p>
<p><span class="font2">['VAR', 'y'],</span></p>
<p><span class="font2">],</span></p>
<p><span class="font2">]</span></p>
<p><span class="font17">which should be familiar.</span></p>
<p><span class="font17">When constraint and parameter declarations are processed, they contain these raw </span><span class="font2">Expression </span><span class="font17">objects. Later, expressions need to be converted to constraints. This is probably the most complicated part of the program. The process of conversion is essentially evaluation, except that instead of producing a number result, the result is an object from class </span><span class="font2">Value</span><span class="font17">. This evaluation is performed by the function </span><span class="font2">expression_to_constraints()</span><span class="font17">:</span></p>
<p><span class="font2">sub expression_to_constraints { my ($context, $expr) = @_;</span></p>
<p><span class="font17">Variables in an expression have associated types, and to map from a variable’s name to its type we need a context. To see why, consider the following example:</span></p>
<p><span class="font2">define type_A { number age; age = 4;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">define type_B {</span></p>
<p><span class="font2">box age;</span></p>
<p><span class="font2">age = 4;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">The constraint </span><span class="font2">age = 4 </span><span class="font17">in the first definition makes sense, but the same constraint in the second definition does not make sense because 4 is not a box.</span></p>
<p><span class="font17">More generally, the meaning of a constraint might depend in a complex way on the types of the variables it contains. So </span><span class="font2">expression_to_constraints </span><span class="font17">requires a context that maps variable names to their types. This is nothing more than a </span><span class="font2">Type </span><span class="font17">object; the mapping is performed by </span><span class="font2">Type::subfeature()</span><span class="font17">.</span></p>
<p><span class="font17">Continuing with the evaluation function:</span></p>
<p><span class="font2">unless (defined Sexpr) {</span></p>
<p><span class="font2">Carp::croak(&quot;Missing expression in 'expression_to_constraints'&quot;);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">my (Sop, @s) = @$expr;</span></p>
<p><span class="font17">Here we break up the top-level expression into an operator </span><span class="font2">Sop </span><span class="font17">and zero or more subexpressions, </span><span class="font2">@s</span><span class="font17">. We then switch on the operator type. It might be a variable, a constant, a tuple, or some binary operator such as </span><span class="font2">+ </span><span class="font17">or </span><span class="font2">*</span><span class="font17">:</span></p>
<p><span class="font2">if (Sop eq 'VAR') {</span></p>
<p><span class="font2">my Sname = $s[0];</span></p>
<p><span class="font2">return Value::Feature-&gt;new_from_var(Sname, Scontext-&gt;subfeature(Sname));</span></p>
<p><span class="font17">If it’s a variable, we build a new </span><span class="font2">Value::Feature </span><span class="font17">object of the indicated name and type. </span><span class="font2">new_from_var()</span><span class="font17">, which we saw earlier, is responsible for manufacturing the appropriate set of constraints.</span></p>
<p><span class="font2">} elsif (Sop eq 'CON') {</span></p>
<p><span class="font2">return Value::Constant-&gt;new(Ss[0]);</span></p>
<p><span class="font17">If the expression is a constant, the code is simple; we build a </span><span class="font2">Value::Constant </span><span class="font17">object.</span></p>
<p><span class="font17">Tuples are where things start to get interesting. As we saw earlier, tuples are </span><span class="font17" style="font-style:italic;">not</span><span class="font17"> required to be constants; </span><span class="font2">(hspc + 3,2* top.start.y) </span><span class="font17">is a perfectly legitimate tuple. Since the components of a tuple may be arbitrary expressions, we call </span><span class="font2">expression_to_constraints() </span><span class="font17">recursively:</span></p>
<p><span class="font2">} elsif (Sop eq 'TUPLE') { my %components;</span></p>
<p><span class="font2">for my Sk (keys %{Ss[0]}) {</span></p>
<p><span class="font2">Scomponents{Sk} = expression_to_constraints(Scontext, Ss[0]{Sk});</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">return Value::Tuple-&gt;new(%components);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">There should probably be a check here to make sure that the resulting component values are not themselves tuples. At present, </span><span class="font2">((1, 2), (3, 4))</span><span class="font17">, which is illegal, is not diagnosed until later, when the malformed tuple participates in an arithmetic operation.</span></p>
<ul style="list-style:none;"><li>
<p class="font15">9.4 <span class="font2">linogram: </span><span class="font15" style="font-variant:small-caps;">a drawing system</span><span class="font20"> 559</span></p></li></ul>
<p><span class="font17">If the argument expression was neither a tuple, a variable, nor a constant, then it’s a compound expression. We start by evaluating the two operands:</span></p>
<p><span class="font2">my $e1 = expression_to_constraints($context, $s[0]);</span></p>
<p><span class="font2">my $e2 = expression_to_constraints($context, $s[1]);</span></p>
<p><span class="font17">We then dispatch an appropriate method to combine the two operands into a single expression. When the operator is </span><span class="font2">+</span><span class="font17">, we use the </span><span class="font2">add </span><span class="font17">method, and so on:</span></p>
<p><span class="font2">my %opmeth = ('+' =&gt; 'add',</span></p>
<p><span class="font2">'-' =&gt; 'sub',</span></p>
<p><span class="font2">'*' =&gt; 'mul',</span></p>
<p><span class="font2">'/' =&gt; 'div',</span></p>
<p><span class="font2">);</span></p>
<p><span class="font2">my $meth = $opmeth{$op};</span></p>
<p><span class="font2">if (defined $meth) {</span></p>
<p><span class="font2">return $e1-&gt;$meth($e2);</span></p>
<p><span class="font2">} else {</span></p>
<p><span class="font2">lino_error(&quot;Unknown operator '$op' in AST&quot;);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">This is what connects the parser with the arithmetic functions from class </span><span class="font2">Value</span><span class="font17">.</span></p>
<p><span class="font17">The one important function we haven’t seen is </span><span class="font2">convert_param_specs()</span><span class="font17">, which takes the parameter specifications in a declaration like </span><span class="font2">hline L(end=Q+R) </span><span class="font17">and converts them to constraints. The arguments are a context, the sub-feature type (</span><span class="font2">hline </span><span class="font17">in the example), and a parameter specification value, something like:</span></p>
<p><span class="font2">{ WHAT =&gt; 'PARAM_SPEC',</span></p>
<p><span class="font2">NAME =&gt; 'end',</span></p>
<p><span class="font2">VALUE =&gt; [ '+', ['VAR', 'Q'],</span></p>
<p><span class="font2">['VAR', 'R'],</span></p>
<p><span class="font2">],</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">The only fine point here is that parameter specifications are asymmetric. The name </span><span class="font2">end </span><span class="font17">on the left side is interpreted as a sub-feature of </span><span class="font2">L</span><span class="font17">, but the named </span><span class="font2">Q </span><span class="font17">and </span><span class="font2">R </span><span class="font17">on the right side are interpreted as sub-features of the outer context in which </span><span class="font2">L </span><span class="font17">is being defined. </span><span class="font2">convert_param_specs() </span><span class="font17">builds a new </span><span class="font2">Value::Feature </span><span class="font17">object for the left side by making two calls to </span><span class="font2">subfeature()</span><span class="font17">, one to find</span></p>
<div>
<p><span class="font20">560</span></p>
</div><br clear="all">
<p><span class="font15">CHAPTER 9 Declarative Programming</span></p>
<p><span class="font17">the type of the feature that’s being defined, </span><span class="font2">L </span><span class="font17">in the example, and then one more to find the type of the parameter name, </span><span class="font2">end </span><span class="font17">in the example. It uses the </span><span class="font2">expression_to_constraints() </span><span class="font17">function to convert the right-hand side, and then subtracts right from left to produce the final constraint:</span></p>
<p><span class="font2">sub convert_param_specs {</span></p>
<p><span class="font2">my (Scontext, Ssubobj, Spspec) = @_;</span></p>
<p><span class="font2">my ©constraints;</span></p>
<p><span class="font2">my Sleft = Value::Feature-&gt;new_from_var(&quot;Ssubobj.&quot; . Spspec-&gt;{NAME}, Scontext-&gt;subfeature(Ssubobj) -&gt;subfeature(Spspec-&gt;{NAME}) );</span></p>
<p><span class="font2">my Sright = expression_to_constraints(Scontext, Spspec-&gt;{VALUE}); return Sleft-&gt;sub(Sright);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">Our walk through the code is now complete.</span></p>
<ul style="list-style:none;"><li>
<h5><a name="bookmark211"></a><span class="font19">9.4.5 Missing Features</span></h5></li></ul>
<p><span class="font2">linogram </span><span class="font17">is missing a few valuable features. Some are easier to fix than others. It doesn’t support varying thickness lines, colored lines, or filled boxes. These are easy to add, and in fact an earlier version of </span><span class="font2">linogram </span><span class="font17">supports them; I took the feature out for pedagogical reasons. The technical support for the feature was to allow “parameter” declarations, like this:</span></p>
<p><span class="font2">define line {</span></p>
<p><span class="font2">point x, y;</span></p>
<p><span class="font2" style="font-weight:bold;">param number thickness = 1;</span></p>
<p><span class="font2" style="font-weight:bold;">param string color = &quot;black&quot;;</span></p>
<p><span class="font2">draw { &amp;draw_line; }</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">A parameter is just another sub-feature, except that it doesn’t participate in the system of linear equations. Like any other sub-feature, it may be constrained by the root feature or some other feature that includes it. The following root feature definition draws a vertical black line crossed by a horizontal red line:</span></p>
<p><span class="font2">vline v;</span></p>
<p><span class="font2">hline h(color=&quot;red&quot;);</span></p>
<p><span class="font2">constraints { v.center = h.center; }</span></p>
<ul style="list-style:none;"><li>
<p class="font15">9.4 <span class="font2">linogram: </span><span class="font15" style="font-variant:small-caps;">a drawing system</span></p>
<div>
<p><span class="font20">561</span></p>
</div><br clear="all"></li></ul>
<p><span class="font17">The </span><span class="font2">color=&quot;red&quot; </span><span class="font17">parameter specification overrides the default of </span><span class="font2">&quot;black&quot;</span><span class="font17">. The parameter values are then included in the environment hash that is passed to the drawing functions. When </span><span class="font2">draw_line </span><span class="font17">sees that the color is specified as </span><span class="font2">&quot;red&quot; </span><span class="font17">it is responsible for drawing a red line instead of a black one.</span></p>
<p><span class="font17">With the parameter feature, we can support the placement of objects that contain text:</span></p>
<p><span class="font2">define text extends box { param string text = &quot;&quot;; param number font_size = 9; param string font = &quot;courier&quot;; draw { &amp;draw_text }</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">and now we have something that has a top, bottom, left, northwest corner, and so forth, like a box, but whose four sides are invisible. Instead, the </span><span class="font2">draw_text </span><span class="font17">function is responsible for placing the text appropriately, or for issuing an error message if it doesn’t fit.</span></p>
<p><span class="font17">The value of a parameter must be completely determined before the constraint system is solved, either by a declaration like </span><span class="font2">hline h(color=&quot;red&quot;)</span><span class="font17">, or by a specified default. If neither is present, it is a fatal error.</span></p>
<p><span class="font17">Parameters can be used for other applications:</span></p>
<p><span class="font2">define marked_line extends vline {</span></p>
<p><span class="font2">hline mark;</span></p>
<p><span class="font2">param number markpos = 50;</span></p>
<p><span class="font2">constraints {</span></p>
<p><span class="font2">mark.length = 0.02;</span></p>
<p><span class="font2">mark.center = (center.x, start.y + markpos/100 * height);</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">This defines a feature that is a vertical line with a horizontal tick mark across it. By default, the tick mark is halfway up the line, but this depends on the value of </span><span class="font17" style="font-style:italic;">markpos,</span><span class="font17"> which can be between 0 and 100 to indicate a percentage of the way to the end of the </span><span class="font2">vline</span><span class="font17">. If </span><span class="font17" style="font-style:italic;">markpos</span><span class="font17"> is 100, the tick mark is at the end of the </span><span class="font2">vline</span><span class="font17">; if </span><span class="font17" style="font-style:italic;">markpos</span><span class="font17"> is 75, the tick mark is one-quarter of the way from the end.</span></p>
<p><span class="font17">If </span><span class="font17" style="font-style:italic;">markpos</span><span class="font17"> were not a </span><span class="font2">param</span><span class="font17">, the definition would be illegal, because the expression </span><span class="font2">markpos/100 * height </span><span class="font17">is nonlinear. But parameters do not participate in linear-equation solving. The rules for parameters say that </span><span class="font17" style="font-style:italic;">markpos</span><span class="font17"> must be specified somewhere before the equation solving begins. Suppose it has been</span></p>
<p><span class="font20">562 </span><span class="font15">CHAPTER 9 Declarative Programming</span></p>
<p><span class="font17">specified to be 75. Then the constraint is effectively:</span></p>
<p><span class="font2">mark.center = (center.x, start.y + 75/100 * height);</span></p>
<p><span class="font17">which </span><span class="font17" style="font-style:italic;">is</span><span class="font17"> linear. This feature lends a great deal of flexibility to the system.</span></p>
<p><span class="font17">One major feature that is missing is splines. A spline is a curved line whose path is determined by one or more control points. The spline wiggles along, starting at its first control point and heading towards the second, then veering off toward the third, and so on, until it ends at the last control point. The main impediment here is that unlike the other features we’ve seen, the number of control points of a spline isn’t known in advance. We could conceivably get around this by defining a series of spline types:</span></p>
<p><span class="font2">define spline2 { point p1, p2; draw { &amp;draw_spline; }</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">define spline3 extends spline2 { point p3;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">define spline4 extends spline3 { point p4;</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">but this is awfully clumsy. What </span><span class="font2">linogram </span><span class="font17">really needs to support features like splines and polygons is a way to specify a parametrizable array of features and their associated constraints, perhaps something like this:</span></p>
<p><span class="font2">define polygon(N) {</span></p>
<p><span class="font2">point v[N];</span></p>
<p><span class="font2">line s[N];</span></p>
<p><span class="font2">constraints {</span></p>
<p><span class="font2">when j is 1 .. N { s[j].start = v[j]; }</span></p>
<p><span class="font2">when j is 1 .. N-1 { s[j].end = v[j+1]; }</span></p>
<p><span class="font2">s[N].end = v[1];</span></p>
<p><span class="font2">}</span></p>
<p><span class="font2">}</span></p>
<p><span class="font17">There are a few missing syntactic features. A declaration like:</span></p>
<p><span class="font2">number hsize = 12;</span></p>
<p><span class="font17">would be convenient, as would equations with multiple equals signs:</span></p>
<p><span class="font2">A.sw = B.n = C.s;</span></p>
<ul style="list-style:none;"><li>
<h5><a name="bookmark212"></a><span class="font18">9.5 CONCLUSION</span></h5></li></ul>
<p><span class="font2">linogram </span><span class="font17">is a substantial application, one that might even be useful. I have been using the venerable </span><span class="font2">pic </span><span class="font17">system, developed at Bell Labs, for years, and it convinced me that defining diagrams by writing a text file of constraints is a good general strategy. But I’ve never been entirely happy with </span><span class="font2">pic</span><span class="font17">, and I wanted to see what else I could come up with.</span></p>
<p><span class="font17">I also wanted to finish the book with a serious example that would demonstrate how the techniques we’ve studied could be integrated into real Perl programs. </span><span class="font2">linogram </span><span class="font17">totals about 1,300 lines of code, counting the parsing system we developed in Chapter 8, but not counting comments, whitespace, curly braces, and the like. It would have been very difficult to build without the techniques of earlier chapters. The parsing system itself was essential; the clean design of the parsing system depends heavily on the earlier work on lazy streams and iterators. We used recursion and dispatch tables throughout to reduce and reorganize the code. Although the program doesn’t use any explicit currying or memoization, there are several places where the code would probably be improved by its introduction — the functions based on </span><span class="font2">apply()</span><span class="font17">, and the </span><span class="font2">subfeature() </span><span class="font17">function spring to mind.</span></p>
<h3><a name="bookmark213"></a><span class="font25">INDEX</span></h3>
<p><span class="font6" style="font-weight:bold;">Special Characters</span></p>
<p><span class="font1">&quot;&quot; </span><span class="font15">(stringification) pseudo-operator, 467</span></p>
<p><span class="font1">&quot;&quot; </span><span class="font15">key, 501</span></p>
<p><span class="font1">$&quot; </span><span class="font15">special variable, 261, 306</span></p>
<p><span class="font1">$$ </span><span class="font15">special variable, 155</span></p>
<p><span class="font1">$. </span><span class="font15">special variable, 353</span></p>
<p><span class="font1">$/ </span><span class="font15">special variable, 261, 361</span></p>
<p><span class="font1">$; </span><span class="font15">special variable, 84</span></p>
<p><span class="font1">$;$ </span><span class="font15">prototype, 338</span></p>
<p><span class="font1">$@ </span><span class="font15">special variable, 430</span></p>
<p><span class="font1">$_ </span><span class="font15">special variable, 142—43, 160</span></p>
<p><span class="font1">&amp; </span><span class="font15">notation in Linogram, 495</span></p>
<p><span class="font1">&amp;@ </span><span class="font15">prototype, 337</span></p>
<p><span class="font1">&amp;;@ </span><span class="font15">prototype, 338</span></p>
<p><span class="font1">&amp;&amp; @rest </span><span class="font15">condition, 211</span></p>
<p><span class="font1">(?!) </span><span class="font15">regex lookahead operator, 363</span></p>
<ul style="list-style:none;"><li>
<p><span class="font1">* </span><span class="font15">operator, 273,389, 558</span></p></li>
<li>
<p><span class="font1">* </span><span class="font15">quantifier, 436</span></p></li>
<li>
<p><span class="font1">* </span><span class="font15">token, 376</span></p></li></ul>
<p><span class="font1">** </span><span class="font15">operator, 426</span></p>
<p><span class="font1">+ </span><span class="font15">operator, 558</span></p>
<p><span class="font1">+ </span><span class="font15">quantifier, 436</span></p>
<p><span class="font1">+ </span><span class="font15">token, 376</span></p>
<p><span class="font1">-&gt; </span><span class="font15">operator, 176</span></p>
<p><span class="font1">. </span><span class="font15">operator, 176</span></p>
<p><span class="font1">; </span><span class="font15">symbol in prototypes, 179</span></p>
<p><span class="font1">&lt;...&gt; </span><span class="font15">operator, 187, 359, 360-65</span></p>
<p><span class="font15">as rudimentary parser, 359</span></p>
<p><span class="font1">&lt;=&gt; </span><span class="font15">operator, 102, 108</span></p>
<p><span class="font1">== </span><span class="font15">operator, 168, 177-78</span></p>
<p><span class="font15">for comparing objects, 477</span></p>
<p><span class="font1">? </span><span class="font15">quantifier, 436</span></p>
<p><span class="font1">@_</span><span class="font15">, modification of, 91-92</span></p>
<p><span class="font1">[...] </span><span class="font15">operator, 167</span></p>
<p><span class="font2">\ </span><span class="font15">(backslash) operator, 84-85, 87, 179, 439, 449</span></p>
<p><span class="font2">\</span><span class="font1">@$$ </span><span class="font15">prototype, 293</span></p>
<p><span class="font2">\</span><span class="font1">@</span><span class="font2">\</span><span class="font1">@ </span><span class="font15">prototype, 178</span></p>
<p><span class="font1">| </span><span class="font15">operator, 437</span></p>
<p><span class="font1">|| = </span><span class="font15">operator, 106, 106-7</span></p>
<p><span class="font1">|| </span><span class="font15">operator, 103</span></p>
<p><span class="font6" style="font-weight:bold;">A</span></p>
<p><span class="font1">-a </span><span class="font15">command-line option, 149</span></p>
<p><span class="font1">$a </span><span class="font15">and </span><span class="font1">$b </span><span class="font15">variables, 345</span></p>
<p><span class="font15">Abelson, Harold, xvii absolute zero, 475 abstract base class, 25, 478 abstract syntax tree (AST), 57-58, 393, 400, 408, 437, 553-54, 557 abstraction of functionality, 16, 41, 225, 412</span></p>
<p><span class="font15">accessor method, 29, 477 actions, 44, 49-50, 53, 446</span></p>
<p><span class="font15">Adler, David, 145</span></p>
<p><span class="font15">agenda, 207-12, 365, 370, 380-81 agenda method, universality of, 217 aggregation, 19-20</span></p>
<p><span class="font15">airplane, 109</span></p>
<p><span class="font15">algorithm, 10, 11, 287, 471 aliasing, 70-71, 81, 92, 112 alternate universe, 116-17 alternation of parsers, 387-88 ambiguity in arithmetic expressions, 54 amortization, 310-13</span></p>
<p><span class="font15">anchor component of URL, 189, 199 anonymous array, 31, 50, 81</span></p>
<p><span class="font15">anonymous functions, 19, 76, 79, 86, 123, 258-59, 300, 327, 371, 398, 421, 453, 478</span></p>
<p><span class="font15">debugger’s treatment of, 415-16 </span><span class="font1">argument isn’t numeric </span><span class="font15">warning, 108</span></p>
<p><span class="font15">argument normalizer, inlined cache manager with, 90-92</span></p>
<p><span class="font15">arithmetic expressions, 54, 376, 390-435 overview, 390-400</span></p>
<p><span class="font15">calculator, 400, 424-27 debugging, 415-24</span></p>
<p><span class="font15">generic-operator parsers, 412-15 grammar for, 376</span></p>
<p><span class="font15">left recursive, 400-8 arrays, 66, 179, 181</span></p>
<p><span class="font15">contrasted with iterators, 117-18 contrasted with linked lists, 257 looping over, 177-82</span></p>
<p><span class="font15">representation of database rows as, 165-66</span></p>
<p><span class="font15">repeated copying of, 129-30 </span><span class="font1">arrow</span><span class="font15">, definition in Linogram, 498 Ashton, Elaine, 145 assembly language, 314</span></p>
<p><span class="font15">associativity of operators, 257, 401-2, 426</span></p>
<p><span class="font15">AST (abstract syntax tree), 57-58, 393, 400, 408, 437, 553-54, 557 asymmetry, in Linogram parameter specifications, 559 atomic expression, 436 atomic features in Linogram, 494 atomic ray, 185 atoms in regexes, 436, 439 attribute-value pairs in HTML tags, 26 automatic profiling, 111-12 auxiliary parameter, 240</span></p>
<p><span class="font6" style="font-weight:bold;">B</span></p>
<p><span class="font2">\</span><span class="font1">b </span><span class="font15">regex metacharacter, 272, 439 backslash character, 84-85, 87, 179, 439, 449</span></p>
<p><span class="font15">backtracking, 207, 456-65 in regex engine, 364</span></p>
<p><span class="font15">backtracking parsers, 456-65 overview, 456 continuations, 457-61 parse streams, 461-65</span></p>
<p><span class="font15">backup program, 206 bacteriophage, 135 bad link detector, 191, 192, 194 bad luck, 168-69</span></p>
<p><span class="font15">balanced parentheses, 287-88 barbarian, 206-7</span></p>
<p><span class="font15">base case, 3, 5, 8, 35, 211, 534 bear, 359-60</span></p>
<p><span class="font1">BEGIN </span><span class="font15">block, 338-39, 346, 350-51, 353, 355-56, 502</span></p>
<p><span class="font15">beginner mode via alternative dispatch table, 49</span></p>
<p><span class="font15">behavior function in constraint system, 479, 480</span></p>
<p><span class="font15">Bell Labs, 563</span></p>
<p><span class="font15">BFS (breadth-first search), 189, 200, 213-15</span></p>
<p><span class="font15">binary, 1-3, 239-41</span></p>
<p><span class="font15">binary search, 292-93 binding, 71-72</span></p>
<p><span class="font15">bio-informatics, 135-39</span></p>
<p><span class="font15">Bird, Richard, xvii blessing, 356, 416, 466, 468-69 blocks, 72-73, 390</span></p>
<p><span class="font15">bare, 67-68</span></p>
<p><span class="font15">as arguments to </span><span class="font1">sort() </span><span class="font15">function, 102</span></p>
<p><span class="font1">BEGIN</span><span class="font15">, </span><span class="font14" style="font-style:italic;">see</span><span class="font1"> BEGIN </span><span class="font15">block disk, </span><span class="font14" style="font-style:italic;">see</span><span class="font15"> disk blocks labelled, parser for, 541-42 boolean “not” operator, 354 Borges, Jorge Luis, 417</span></p>
<p><span class="font15">Boss, the, 80</span></p>
<p><span class="font1">box</span><span class="font15">, definition in Linogram, 497 breadth-first search (BFS), 189, 200, 213-15</span></p>
<p><span class="font15">browsers, 68</span></p>
<p><span class="font15">buffer, 363</span></p>
<p><span class="font15">bullet symbol, 441</span></p>
<p><span class="font15">Bunce, Tim, 164</span></p>
<p><span class="font15">Burke, Sean, xvii-xviii, 29, 35 bytes, 19-20</span></p>
<p><span class="font6" style="font-weight:bold;">C</span></p>
<p><span class="font15">C programming language, xv-xvi, 67, 75, 79-80, 105, 108-9, 153, 166, 344, 362, 365, 424, 501 auto variables in, 6 </span><span class="font1">for </span><span class="font15">loop, 173 library of, 153, 155</span></p>
<p><span class="font15">C++ programming language, 25 </span><span class="font1">/c </span><span class="font15">regex modifier flag, 367 cache data, expiration of, 97-98 cache hit, 65, 90, 104, 107</span></p>
<p><span class="font15">false, 84, 93, 107</span></p>
<p><span class="font15">cache management overhead, 65, 87, 101, 109</span></p>
<p><span class="font15">cache memory, 68, 108 cache miss, 65, 91, 95, 107</span></p>
<p><span class="font15">caching and memoization, 63, 65, 83, 90, 101, 268</span></p>
<p><span class="font15">alternatives to, 101-8</span></p>
<p><span class="font15">benefits of speed, 109-13</span></p>
<p><span class="font15">caveats, 80-84</span></p>
<p><span class="font15">evangelism, 108-9</span></p>
<p><span class="font15">inline caching, 66-68</span></p>
<p><span class="font15">in object methods, 96-99</span></p>
<p><span class="font15">key generation, 84-95</span></p>
<p><span class="font1">Memoize </span><span class="font15">module, 70-80</span></p>
<p><span class="font15">persistent caches, 100-1</span></p>
<p><span class="font15">quantitative analysis of, 65, 83-84, 90, 101</span></p>
<p><span class="font15">and recursion, 65-66</span></p>
<p><span class="font15">calculator, 54-61, 365-69, 400, 424-27, 435, 469</span></p>
<p><span class="font15">calculus, 302, 305, 314, 319</span></p>
<p><span class="font15">call frame, 231-32</span></p>
<p><span class="font15">call tree, 215-17, 220</span></p>
<p><span class="font15">callbacks, 10, 20, 23, 119, 127, 143-44,</span></p>
<p><span class="font15">158, 160, 181, 187-88, 190,</span></p>
<p><span class="font15">225, 227, 326, 371, 386</span></p>
<p><span class="font1">caller() </span><span class="font15">function,420</span></p>
<p><span class="font15">canonical form, 218-19</span></p>
<p><span class="font15">canonical order, 349-50</span></p>
<p><span class="font15">cantankerous grandfather, 228 cardioid, 490</span></p>
<p><span class="font1">Carp </span><span class="font15">module, 186, 522, 532, 558</span></p>
<p><span class="font15">carriage return, 439</span></p>
<p><span class="font15">carrot, 162, 264, 275</span></p>
<p><span class="font15">CGI, 189, 197</span></p>
<p><span class="font1">CGI::Push </span><span class="font15">module, 155</span></p>
<p><span class="font15">chained lexers, 368-74</span></p>
<p><span class="font15">character classes, 273, 281</span></p>
<p><span class="font1">CHDIR </span><span class="font15">directive in configuration file, 42 </span><span class="font1">chdir() </span><span class="font15">function, 42 Christiansen, Tom, xv, 129 chromosome, 135</span></p>
<p><span class="font15">chronological order, 102-6, 149, 299-300</span></p>
<p><span class="font15">CIA, 184-85</span></p>
<p><span class="font1">circle</span><span class="font15">, definition in Linogram, 499</span></p>
<p><span class="font15">clauses in grammars, 376</span></p>
<p><span class="font15">cleverness, 211</span></p>
<p><span class="font15">clock, memoized, 82-83</span></p>
<p><span class="font1">clone </span><span class="font15">method in </span><span class="font1">URI::URL</span><span class="font15">, 199</span></p>
<p><span class="font1">closedir() </span><span class="font15">function, 15</span></p>
<p><span class="font15">closure, 76, 124, 326</span></p>
<p><span class="font15">closure property, 76-78</span></p>
<p><span class="font15">closure operator (</span><span class="font2">*</span><span class="font15">), 273, 286</span></p>
<p><span class="font1">cmp </span><span class="font15">operator, 105</span></p>
<p><span class="font15">CMYK, 63-64</span></p>
<p><span class="font15">code reference, 9-10, 41, 88, 159, </span><span class="font14" style="font-style:italic;">see also </span><span class="font15">closure, anonymous function</span></p>
<p><span class="font15">code value (CV), 75-77</span></p>
<p><span class="font15">coefficient, 317, 500, 508</span></p>
<p><span class="font15">college student, penurious, 206 comma-separated list, 542, 555 comparator function, 101-2, 291-92, 350</span></p>
<p><span class="font15">compiler, 57</span></p>
<p><span class="font1">comp.lang.perl.misc </span><span class="font15">newsgroup,</span></p>
<p><span class="font15">272</span></p>
<p><span class="font15">components, 27</span></p>
<p><span class="font15">compound interest, 310-13</span></p>
<p><span class="font15">compromise, 85</span></p>
<p><span class="font15">compulsive behavior, 453</span></p>
<p><span class="font1">concatenate^ </span><span class="font15">operator,397-98 concatenation, 3, 273, 386-87</span></p>
<p><span class="font15">of parsers, 386-87</span></p>
<p><span class="font15">of regexes, 273, 275-79, 283-84, 320-21, 438</span></p>
<p><span class="font15">configuration table, 41-42, 47</span></p>
<p><span class="font1">CONSTANT </span><span class="font15">object, 514-16</span></p>
<p><span class="font15">constant part of equation, 500-1, 503 constants, 483</span></p>
<p><span class="font15">constraint networks, 487</span></p>
<p><span class="font15">constraint systems, 472</span></p>
<p><span class="font1">Constraint </span><span class="font15">class, 512-13</span></p>
<p><span class="font1">constraints </span><span class="font15">section in Linogram specification, 549-50</span></p>
<p><span class="font1">Constraint_Set </span><span class="font15">class, 513-14</span></p>
<p><span class="font1">_content </span><span class="font15">key in </span><span class="font1">HTML::TreeBuilder</span><span class="font15">, 27</span></p>
<p><span class="font15">context, 104, 118-19, 159, 165, 182-83, 192, 193</span></p>
<p><span class="font15">Linogram evaluation environment, 557-60</span></p>
<p><span class="font15">continuation, 457-61</span></p>
<p><span class="font15">contradiction, 509-13</span></p>
<p><span class="font15">control-backslash character, 84 conversion, decimal to binary, 1-3 core dump, 75</span></p>
<p><span class="font1">cos() </span><span class="font15">function, 313-14,319</span></p>
<p><span class="font1">cosh() </span><span class="font15">function, 320</span></p>
<p><span class="font15">cost-benefit ratio, 110</span></p>
<p><span class="font15">counting process, 131-32</span></p>
<p><span class="font15">CPAN, 104-5, 152, 324, 500</span></p>
<p><span class="font15">CPU, 68</span></p>
<p><span class="font15">crab cakes, 82</span></p>
<p><span class="font15">current matching position of scalar, 366-67</span></p>
<p><span class="font15">Curry, Haskell B., 327</span></p>
<p><span class="font15">currying, 326-31, 340M3, 346, 350, 353, 484</span></p>
<p><span class="font15">custom key generation, 94—95 cutsorting, 288—300</span></p>
<p><span class="font15">log files, 293-300 cutting function, 290-91 CV (code value), 75-77 </span><span class="font1">cwd() </span><span class="font15">function, 46 </span><span class="font1">Cwd </span><span class="font15">module, 46</span></p>
<p><span class="font6" style="font-weight:bold;">D</span></p>
<p><span class="font1">-d </span><span class="font15">operator, 124</span></p>
<p><span class="font15">dangling symbolic link, 19, 23-24, 183, 325</span></p>
<p><span class="font15">database handle, 141</span></p>
<p><span class="font15">database query languages, 471 database-query parsing, 448-56</span></p>
<p><span class="font15">overview, 448</span></p>
<p><span class="font15">lexer, 448-51</span></p>
<p><span class="font15">parser, 451-56 databases, 351-57, 448-56</span></p>
<p><span class="font15">of cached values, 100-1, 111</span></p>
<p><span class="font15">flat, 140-53</span></p>
<p><span class="font15">SQL, 163-68</span></p>
<p><span class="font1">Data::Dumper </span><span class="font15">module, 392 data structure, 84, 542 date format, ISO, 105 </span><span class="font1">DB_File </span><span class="font15">module, 100</span></p>
<p><span class="font1">DBI </span><span class="font15">module, 163, 165-66, 168, 173 DBM, 101, 349 dead ends, 189 debugger, 154-55 debugging, 154-55, 415-17, 429, 475, 479, 551</span></p>
<p><span class="font15">decimal to binary conversion, 1-3 declarative programming, 471-563 overview, 471-72</span></p>
<p><span class="font15">linear equations, 488-90</span></p>
<p><span class="font15">local propagation networks, 472-88 overview, 472-75 implementing, 475-87 problems with, 487-88</span></p>
<p><span class="font15">declarator in Linogram, 545, 548 default action for dispatch table, 52-54 Defenestration of Prague, 204 </span><span class="font1">defined </span><span class="font15">operator, 167 depth-first search, </span><span class="font14" style="font-style:italic;">see</span><span class="font15"> DFS derivation of sentence, 377</span></p>
<p><span class="font15">derivative function, 305-6, 319, 320, 331 </span><span class="font1">DESTROY </span><span class="font15">method, 97</span></p>
<p><span class="font15">destructive function, 91, 262, 295 destructive method, 506, 511</span></p>
<p><span class="font15">DFS, 189, 200, 203, 212-15, 228-29, 383, 403 ambiguity of, 228 bound on size of agenda, 213 contraindications for, 213-14, 379, 403</span></p>
<p><span class="font15">recursion and, 126, 189, 203, 214, 217 web spiders and, 214, 379</span></p>
<p><span class="font15">diagnostic messages, 13, 42, 201, 260-61, 426, 476</span></p>
<p><span class="font1">diamond</span><span class="font15">, definition in Linogram, 499 </span><span class="font1">die()</span><span class="font15">, throwing exceptions with, 430 differential calculus, 305, 319 Dijkstra, Edsger Wybe, 219 directives, 45-46 directory tree, 123, 161 directory walking, applications and variations of, 16-25</span></p>
<p><span class="font15">dirhandles, 13-15, 118 disk blocks, 15 diskettes, 206</span></p>
<p><span class="font15">dispatch tables, 41-61, 182, 438, 515-16, 520,528, 551,559 overview, 41 advantages of, 45-49 calculator, 54-61</span></p>
<p><span class="font15">configuration file handling, 41-54 default actions, 52-54</span></p>
<p><span class="font15">division as inverse of multiplication, 482-83, 515-16</span></p>
<p><span class="font15">division by zero, 432, 481-82, 517 division of power series, 320-24 division of treasure, </span><span class="font14" style="font-style:italic;">see</span><span class="font15"> partition problem do-it-yourself, 126</span></p>
<p><span class="font1">do-while </span><span class="font15">loop, 243 domain name server, 68, 108 DONGS HLAGHAGHL, 386-87 doorbell, 386-87</span></p>
<p><span class="font1">drand48() </span><span class="font15">function, 153 </span><span class="font1">draw </span><span class="font15">section in Linogram specification, 550-51, 553-54</span></p>
<p><span class="font15">drawables, 536-39, 550-51, 553-54 drawables list, 554</span></p>
<p><span class="font15">drawing function, 494-95, 537, 561 drunken fraternity brothers, 156 </span><span class="font1">du </span><span class="font15">command in Unix, 16 duration (of value), 73-76</span></p>
<p><span class="font6" style="font-weight:bold;">E</span></p>
<p><span class="font1">-e </span><span class="font15">command line option, 149 </span><span class="font1">-e </span><span class="font15">operator, 19</span></p>
<p><span class="font15">INDEX </span><span class="font20">567</span></p>
<p><span class="font1">each() </span><span class="font15">operator, 182,349 </span><span class="font1">$elementfunc </span><span class="font15">argument, 29, 59-61 email, 293-94, 363-64</span></p>
<p><span class="font15">address, 53-54, 294</span></p>
<p><span class="font15">header of, 363</span></p>
<p><span class="font15">empty list, 24-25, 36, 166, 179, 346-47, 385</span></p>
<p><span class="font15">empty string, 273, 285, 372, 438, 511</span></p>
<p><span class="font15">end tag in HTML, 26</span></p>
<p><span class="font14" style="font-style:italic;">Engineering Mathematics Handbook</span><span class="font15" style="font-style:italic;">,</span><span class="font15"> 324 entropy, 156 environment, 76</span></p>
<p><span class="font1">Environment </span><span class="font15">class, 538-39</span></p>
<p><span class="font15">epoch format, 295</span></p>
<p><span class="font1">eq </span><span class="font15">operator, 169, 452</span></p>
<p><span class="font1">Equation </span><span class="font15">class, 500-11</span></p>
<p><span class="font1">Equation::System </span><span class="font15">class, 508-12 equations,</span></p>
<p><span class="font15">for Fibonacci numbers, 34 inconsistent, 509-10 linear, 488-513</span></p>
<p><span class="font15">redundant, 508</span></p>
<p><span class="font15">roots of, 301</span></p>
<p><span class="font15">solving, 301, 489</span></p>
<p><span class="font15">trivial (0=0), 502</span></p>
<p><span class="font15">equivalence classes, 218-19</span></p>
<p><span class="font15">error diagnosis and recovery in parsing, 427-35</span></p>
<p><span class="font15">escape sequence, 85</span></p>
<p><span class="font15">eta-conversion, 389-90, 391-92, 423,</span></p>
<p><span class="font15">437</span></p>
<p><span class="font15">Euclid’s algorithm, 231</span></p>
<p><span class="font1">eval </span><span class="font15">operator, 46, 86-88, 339, 340, 430,</span></p>
<p><span class="font15">543</span></p>
<p><span class="font15">exaggeration, 35</span></p>
<p><span class="font15">exceptions, 430-32</span></p>
<p><span class="font15">propagation of, 432</span></p>
<p><span class="font1">execute </span><span class="font15">method in DBI module, 168 </span><span class="font1">EXHAUSTED </span><span class="font15">operator, 172-73 exhaustion, 122, 163, 189, 207, 209, 292, 350, 365, 370, 428, 459</span></p>
<p><span class="font15">explicit function for, 171-73</span></p>
<p><span class="font15">synthetic representation of, 167-73</span></p>
<p><span class="font1">exists() </span><span class="font15">operator, 107</span></p>
<p><span class="font1">exp() </span><span class="font15">function, 320</span></p>
<p><span class="font15">expiration of cache data, 97-98, 101 explicit exhaustion function, 171-73 explicit specification of empty list value,</span></p>
<p><span class="font15">346</span></p>
<p><span class="font15">explicit stacks, 242-53</span></p>
<p><span class="font15">exponentiation operation, 425</span></p>
<p><span class="font1">Expression </span><span class="font15">class, 554</span></p>
<p><span class="font20">568 </span><span class="font15">INDEX</span></p>
<p><span class="font15">expression parser, 55—56, 376, 381—84, 391415</span></p>
<p><span class="font15">expressions, 376—77</span></p>
<p><span class="font15">in Linogram, 554—58</span></p>
<p><span class="font6" style="font-weight:bold;">F</span></p>
<p><span class="font1">-f </span><span class="font15">operator, 13</span></p>
<p><span class="font1">@F </span><span class="font15">special variable, 149</span></p>
<p><span class="font15">facade pattern, 170, 172—73</span></p>
<p><span class="font15">factor of arithmetic expression, 394 factorial function, 3—6, 241, 314—15, 324 fame and renown, 415</span></p>
<p><span class="font15">family tree, 489</span></p>
<p><span class="font1">Fcntl </span><span class="font15">module, 142</span></p>
<p class="font15">features in Linogram, 490, 491—98,</p>
<ul style="list-style:none;"><li>
<p><span class="font15">520-21, 528-37</span></p></li></ul>
<p><span class="font15">Fenchurch, 82</span></p>
<p><span class="font1">FETCH </span><span class="font15">method, 184, 184-85</span></p>
<p><span class="font1">fetchrow_arrayref </span><span class="font15">method in DBI module, 165, 168, 173, 174</span></p>
<p><span class="font15">Fibonacci numbers, 33-35, 65, 67, 243-53</span></p>
<p><span class="font15">eliminating recursion from calculation of, 243-53</span></p>
<p><span class="font15">fields in email message header, 363 fields in flat text database, 140, 148, 150</span></p>
<p><span class="font1">File::Basename </span><span class="font15">module, 191</span></p>
<p><span class="font1">File::Find </span><span class="font15">module, 126</span></p>
<p><span class="font1">File::ReadBackwards </span><span class="font15">module, 152 file system, 12, 26</span></p>
<p><span class="font15">filehandle, 115-16, 186</span></p>
<p><span class="font15">as iterator, 115-17</span></p>
<p><span class="font15">iterator interface to, 139-40</span></p>
<p><span class="font15">reading in </span><span class="font1">while </span><span class="font15">loop, 187</span></p>
<p><span class="font15">tied, 186-87, 299</span></p>
<p><span class="font15">files, 12-13, 18, 23-24, 82, 127, 142</span></p>
<p><span class="font15">configuration, 41-52</span></p>
<p><span class="font15">for persistent caching, 100-1</span></p>
<p><span class="font15">GIF, 64</span></p>
<p><span class="font15">INI, 117</span></p>
<p><span class="font15">log, 148-53, 294-95</span></p>
<p><span class="font15">with octopuses, 161</span></p>
<p><span class="font15">with plutonium, 116-17</span></p>
<p><span class="font15">filters and transforms, 157-63 fishing expedition, 109 flat databases, 148, 452</span></p>
<p><span class="font1">FlatDB </span><span class="font15">module, 140-53, 356, 448</span></p>
<p><span class="font1">FlatDB::Iterator </span><span class="font15">module, 150-52 flat-file database, 140, 140-48 floating-point numbers, 205-6 flow chart, 157 foolishness, 80, 88, 287 forcing the promise, 258, 269 </span><span class="font1">for </span><span class="font15">loop, C-style, 173 </span><span class="font1">foreach</span><span class="font15">, using to loop over more than one array, 177-82 </span><span class="font1">fork() </span><span class="font15">function, 80 Fortran, 6 four-dimensional beings, 518 fractions, 231 fragment of URL, </span><span class="font14" style="font-style:italic;">see</span><span class="font15"> anchor component </span><span class="font1">FreezeThaw </span><span class="font15">module, 85 Frege, Gottlob, 327 Frequently Asked Question, 1, 16, 129 fruit, 234 function calls, implementation of, 229 function factory, 70-71, 199, 259, 325, 385, 406-7</span></p>
<p><span class="font15">functional vs. object-oriented programming, 25-26 functions,</span></p>
<p><span class="font15">custom key generation, for impure functions, 94-95 higher-order, 325, 333 that return references, 81-82 very fast functions, 83-84 whose return values do not depend on their arguments, 80</span></p>
<p><span class="font15">with reference arguments, 93 with side effects, 80</span></p>
<p><span class="font15">Funes the Memorious, 417</span></p>
<p><span class="font6" style="font-weight:bold;">G</span></p>
<p><span class="font2">\</span><span class="font1">G </span><span class="font15">regex metacharacter, 366-67 </span><span class="font1">/g </span><span class="font15">regex modifier flag, 366 garbage collection, xv, 15, 73, 77, 79 Gaussian elimination, 500, 502-12 GCD (Greatest Common Divisor), 231 geeks, 310</span></p>
<p><span class="font15">General Electric, 69 generic-operator parsers, 412-15 Genomic sequence generator, 135-39 </span><span class="font1">getc() </span><span class="font15">function, 186 </span><span class="font1">get_links </span><span class="font15">method of</span></p>
<p><span class="font1">HTML::LinkExtor </span><span class="font15">module, 189-90</span></p>
<p><span class="font15">GIF file, 63-64 globs, 71, 186,330, 332 </span><span class="font1">glob() </span><span class="font15">operator, 119 global filehandle, 48 global variables, 5, 47, 49, 142-43, 264, 345, 420-21, 454 effect on recursion, 5-6, 13-14 filehandles as, 13-14, 15, 46 hashes instead of, 51</span></p>
<p><span class="font15">random number generator as, 156</span></p>
<p><span class="font15">Goff, Jeff, 217 golden ratio, 35 </span><span class="font1">golden_rectangle</span><span class="font15">, definition in</span></p>
<p><span class="font15">Linogram, 499 </span><span class="font1">goto</span><span class="font15">, 232, 243, 466 grammar, 376-80 Grasshopper, 188-201 greatest common divisor (GCD), 231-33 </span><span class="font1">grep() </span><span class="font15">function, 333-35 grocery bags, 35 Guttman, Uri, 152</span></p>
<p><span class="font6" style="font-weight:bold;">H</span></p>
<p><span class="font15">hack, 84</span></p>
<p><span class="font15">hairy code, 414</span></p>
<p><span class="font15">Hall, Joseph, 106</span></p>
<p><span class="font15">Hamming problem, 269-72</span></p>
<p><span class="font15">Hamming, Richard W, 269 hash, 20, 23, 27, 39, 51, 66-67, 83, 89, 112, 200, 235, 296, 479, 494-95, 512, 518, 561</span></p>
<p><span class="font15">cache, 64-67, 69, 71, 96, 101 as dispatch table, 44</span></p>
<p><span class="font15">for canonicalizing value, 218 iterator component of, 119, 182 power set of, 235-36 tied, 100, 416</span></p>
<p><span class="font15">hash key, 84, 93, 97</span></p>
<p><span class="font15">hash slice, 144</span></p>
<p><span class="font15">hash value computation, 83 head of linked list, 256, 375 header of email message, 363 header of flat-file database, 140 headers of HTML document, 30 hexadecimal, 96</span></p>
<p><span class="font15">hierarchical data, 12-15, 128, 203, 530 Hietaniemi, Jarkko, 234-35 high school, 300, 312, 489</span></p>
<p><span class="font15">higher-order functions, 325, 333 currying, 325-57</span></p>
<p><span class="font1">reduce() </span><span class="font15">and </span><span class="font1">combine()</span><span class="font15">, 343-51 </span><span class="font1">hline</span><span class="font15">, definition in Linogram, 496 hoax, 69</span></p>
<p><span class="font15">Hoefler, Jonathan, 204 Hoefler Type Foundry, 204 hook, 171, 188, 201, </span><span class="font14" style="font-style:italic;">see also</span><span class="font15"> callback</span></p>
<p><span class="font15">HTML, 26-33, 59-61, 179, 188-89, 326-27</span></p>
<p><span class="font1">HTML::LinkExtor </span><span class="font15">module, 188, 190 </span><span class="font1">HTML::TreeBuilder </span><span class="font15">module, 27, 27-29</span></p>
<p><span class="font15">HTTP, 150</span></p>
<p><span class="font1">httpd </span><span class="font15">log file, 148-49</span></p>
<p><span class="font15">Human Genome Project, 135 hyperlinks, 188-97, 200, 214</span></p>
<p><span class="font6" style="font-weight:bold;">I</span></p>
<p><span class="font1">if-else </span><span class="font15">tree, 42 44, 56, 59, 245 impure function, 94-95</span></p>
<p><span class="font1">INCLUDE </span><span class="font15">directive in configuration file, 48</span></p>
<p><span class="font15">incrementing numerals, 132</span></p>
<p><span class="font15">India, 299</span></p>
<p><span class="font15">infinite loop, 3, 117, 308, 403, 477, 506 infinite sequence of integers, 260</span></p>
<p><span class="font15">infinite streams, 255-324</span></p>
<p><span class="font15">overview, 255</span></p>
<p><span class="font15">hamming problem, 269-72</span></p>
<p><span class="font15">lazy linked lists, 257-63</span></p>
<p><span class="font15">Newton-Raphson method, 300-13</span></p>
<p><span class="font15">power series, 313-24</span></p>
<p><span class="font15">recursive streams, 263-69</span></p>
<p><span class="font15">regex string generation, 272-300</span></p>
<p><span class="font15">infix form of expression, 54</span></p>
<p><span class="font15">ingenuity, 48, 68, 124-26, 134, 179,</span></p>
<p><span class="font15">207, 323</span></p>
<p><span class="font15">INI file, 117</span></p>
<p><span class="font15">inline caching, 66-68</span></p>
<p><span class="font15">inlined cache manager, with argument normalizer, 90-92</span></p>
<p><span class="font15">inlining, 86-88, 90-92, 106</span></p>
<p><span class="font15">internal stack, 125</span></p>
<p><span class="font15">intrinsic constraints, 520-22, 534-35</span></p>
<p class="font1">Intrinsic_Constraint_Set <span class="font15">class,</span></p>
<ul style="list-style:none;"><li>
<p><span class="font15">521-22</span></p></li></ul>
<p><span class="font14" style="font-style:italic;">Introduction to Functional Programming</span><span class="font15" style="font-style:italic;">, </span><span class="font15">xvii</span></p>
<p><span class="font15">i-number, 294</span></p>
<p><span class="font15">investment banking, 96-98, 106-7</span></p>
<p><span class="font15">IOU, 259-60</span></p>
<p><span class="font15">IRC, 16, 272</span></p>
<p><span class="font1">is_in() </span><span class="font15">example, 93</span></p>
<p><span class="font1">isa </span><span class="font15">method, 88</span></p>
<p><span class="font15">ISO date format, 105</span></p>
<p><span class="font15">iteration, C model of, 173-74</span></p>
<p><span class="font15">iterators, 115-201</span></p>
<p><span class="font15">overview, 115 alternative interfaces to, 177-87 converting recursive functions to, 203-53</span></p>
<p><span class="font15">examples, 126-57</span></p>
<p><span class="font15">exhaustion of, 122</span></p>
<p><span class="font15">filehandle iterators, 139-40 filters and transforms of, 157-63 flat-file database, 140-48</span></p>
<p><span class="font15">genomic sequence generator, 135-39 homemade, 119-26</span></p>
<p><span class="font15">introduction, 115-19</span></p>
<p><span class="font15">kicking, 121, 157, 160, 185, 195 for permutations, 128-35</span></p>
<p><span class="font15">random number generators, 153-57 rewinding, 255</span></p>
<p><span class="font15">searching databases backwards, 148-53 semipredicate problem, 163-76 web spiders, 187-201</span></p>
<p><span class="font6" style="font-weight:bold;">J</span></p>
<p><span class="font15">jargon, 377</span></p>
<p><span class="font15">Junko, 82</span></p>
<p><span class="font6" style="font-weight:bold;">K</span></p>
<p><span class="font1">KEEPER </span><span class="font15">label for HTML elements, 30-31,326</span></p>
<p><span class="font15">key generation, 84-95</span></p>
<p><span class="font15">overview, 84-88</span></p>
<p><span class="font15">functions with reference arguments, 93 partitioning, 93-94</span></p>
<p><span class="font15">key-generation method, 85 </span><span class="font1">keys() </span><span class="font15">function, 119</span></p>
<p><span class="font15">kicking an iterator, 121, 157, 160, 185, 195</span></p>
<p><span class="font15">Kleene closure, 273</span></p>
<p><span class="font15">Knuth, Donald E., 154, 309</span></p>
<p><span class="font6" style="font-weight:bold;">L</span></p>
<p><span class="font1">-l </span><span class="font15">operator, 19</span></p>
<p><span class="font15">labeled block, 54142</span></p>
<p><span class="font15">Latin, 80, 207</span></p>
<p><span class="font15">laws of programming, 43 lazy linked lists, 257-63 left-associative operator, 426 left recursion, 400-8, 403 4, 409 left-recursive grammar rules, 403^ Leler, Wm, xviii</span></p>
<p><span class="font15">lemniscate, 490</span></p>
<p><span class="font15">Leonardo of Pisa (Fibonacci), 33</span></p>
<p><span class="font15">INDEX </span><span class="font20">569</span></p>
<p><span class="font15">lexer, Perl’s, 450-51</span></p>
<p><span class="font15">lexers, 365-75, 44142, 448-51, 540 overview, 359-60</span></p>
<p><span class="font15">chained, 368-74</span></p>
<p><span class="font15">emulating &lt;&gt;&nbsp;operator, 360-65</span></p>
<p><span class="font15">peeking, 374-75</span></p>
<p><span class="font15">lexical analysis, </span><span class="font14" style="font-style:italic;">see</span><span class="font15"> lexers</span></p>
<p><span class="font15">lexical closure, 76</span></p>
<p><span class="font15">lexical filehandle, 48</span></p>
<p><span class="font15">lexical variables, 5-6, 14, 67, 73, 92, 418</span></p>
<p><span class="font15">lexicality, 72-73, 79</span></p>
<p><span class="font15">lexing, </span><span class="font14" style="font-style:italic;">see</span><span class="font15"> lexers</span></p>
<p><span class="font1">line</span><span class="font15">, definition in Linogram, 494 linear equations, 488-90 linked lists, 255-57</span></p>
<p><span class="font15">head, 256</span></p>
<p><span class="font15">lazy, 257-63</span></p>
<p><span class="font15">splicing into, 257</span></p>
<p><span class="font15">tail, 256</span></p>
<p><span class="font15">linogram, 490-500</span></p>
<p><span class="font15">overview, 490-500</span></p>
<p><span class="font15">equations, 500-14 feature types, 530-39 missing features, 560-63 parser, 539-60</span></p>
<p><span class="font15">overview, 539-40</span></p>
<p><span class="font15">declarations, 545-54</span></p>
<p><span class="font15">definitions, 543-44</span></p>
<p><span class="font15">expressions, 554-60 required extensions, 541^2 programs, 543</span></p>
<p><span class="font15">scalar types, 531-32</span></p>
<p><span class="font1">%TYPES</span><span class="font15">, 542</span></p>
<p><span class="font15">values, 514-30</span></p>
<p><span class="font15">overview, 514-16</span></p>
<p><span class="font15">constant values, 516-18</span></p>
<p><span class="font15">feature values, 520-21 feature-value methods, 527-30 intrinsic constraints, 521-22 synthetic constraints, 522-27</span></p>
<p><span class="font15">tuple values, 518-20</span></p>
<p><span class="font15">Lisp programming language, xv-xvi, 107 list assignment as condition, 165-66 list context, 104, 119, 159, 165, 182-83, 192, 193</span></p>
<p><span class="font15">list expressions, 390</span></p>
<p><span class="font1">List::Util </span><span class="font15">module, 343-47</span></p>
<p><span class="font15">literal regexes, 274</span></p>
<p><span class="font1">local() </span><span class="font15">operator, 142-43, 160, 306 local propagation networks, 472-88 overview, 472-75</span></p>
<p><span class="font15">implementing, 475-87 problems with, 487-88</span></p>
<p><span class="font15">log files, 148-53, 293-300, 348-49 </span><span class="font1">log() </span><span class="font15">function, 320</span></p>
<p><span class="font1">LOGFILE </span><span class="font15">directive in configuration file, 42</span></p>
<p><span class="font15">lookahead assertions, 439</span></p>
<p><span class="font15">lookbehind assertions, 439</span></p>
<p><span class="font15">loop control operators, 243</span></p>
<p><span class="font15">love and admiration, 17</span></p>
<p><span class="font1">ls </span><span class="font15">command in Unix, 16</span></p>
<p><span class="font1">ls -R </span><span class="font15">command in Unix, 16</span></p>
<p><span class="font15">Lucas, Edouard, 6</span></p>
<p><span class="font15">Luke the Hermit, 107</span></p>
<p><span class="font1">LWP::Simple </span><span class="font15">module, 188-89, 201</span></p>
<p><span class="font6" style="font-weight:bold;">M</span></p>
<p><span class="font1">-M </span><span class="font15">operator, 82-83</span></p>
<p><span class="font1">m//g </span><span class="font15">operator, 119</span></p>
<p><span class="font15">Macdonald, John, 234</span></p>
<p><span class="font15">Machol, Richard Morris, 228</span></p>
<p><span class="font15">Macintosh, 206</span></p>
<p><span class="font15">magic variable, 184, 186</span></p>
<p><span class="font1">mailto </span><span class="font15">URL, 200</span></p>
<p><span class="font15">maintenance programmers, 87 </span><span class="font1">make_counter </span><span class="font15">example, 77-79 </span><span class="font1">malloc() </span><span class="font15">function, 166</span></p>
<p><span class="font1">map() </span><span class="font15">function, 124, 157-60, 262, 333-36, 345, 397, 521, 523</span></p>
<p><span class="font15">Marshall, Edward Waite, 69</span></p>
<p><span class="font15">marshalling, 69</span></p>
<p><span class="font15">mask function, 170, 172-73</span></p>
<p><span class="font14" style="font-style:italic;">Mastering Algorithms with Perl</span><span class="font15" style="font-style:italic;">,</span><span class="font15"> 234, 293</span></p>
<p><span class="font1">Math::BigFloat </span><span class="font15">(multiprecision floating-point library), 307, 435</span></p>
<p><span class="font1">Math::BigRat </span><span class="font15">module, 324</span></p>
<p><span class="font1">Math::Complex </span><span class="font15">module, 435</span></p>
<p><span class="font15">mathematics geeks, 310</span></p>
<p><span class="font15">matrix transformations, 500</span></p>
<p><span class="font1">max() </span><span class="font15">function in </span><span class="font1">Scalar::Util </span><span class="font15">module, 343-45</span></p>
<p><span class="font1">maxstr() </span><span class="font15">function in </span><span class="font1">Scalar::Util </span><span class="font15">module, 344</span></p>
<p><span class="font1">MAYBE </span><span class="font15">label for HTML elements, 30-31, 326</span></p>
<p><span class="font15">meaning of parsed input, 376, 384 meiosis, 261</span></p>
<p><span class="font1">Memoize </span><span class="font15">module, 69-80, 83, 105</span></p>
<p><span class="font15">memoization, </span><span class="font14" style="font-style:italic;">see</span><span class="font15"> caching and memoization</span></p>
<p><span class="font15">memoized clock, 82-83</span></p>
<p><span class="font15">merging streams, 270-71, 274-75</span></p>
<p><span class="font15">Michie, Donald, 69 </span><span class="font1">min() </span><span class="font15">function, 343-44 </span><span class="font1">minstr() </span><span class="font15">function, 344</span></p>
<p><span class="font14" style="font-style:italic;">ML for the Working Programmer</span><span class="font15" style="font-style:italic;">,</span><span class="font15"> xvii monster module, 70 morphology, 359-60 mortgage, 310-13</span></p>
<p><span class="font15">Mozilla, 198</span></p>
<p><span class="font15">MSIE, 198</span></p>
<p><span class="font15">multiple-list iterator, 179</span></p>
<p><span class="font1">my </span><span class="font15">declaration, 5, 13, 67, 72-73</span></p>
<p><span class="font15">oddity in semantics of, 264 </span><span class="font1">my </span><span class="font15">variable, </span><span class="font14" style="font-style:italic;">see</span><span class="font15"> lexical variables mystery, 185</span></p>
<p><span class="font6" style="font-weight:bold;">N</span></p>
<p><span class="font2">\</span><span class="font1">n </span><span class="font15">(newline) character, 362-63</span></p>
<p><span class="font1">-n </span><span class="font15">command-line option, 149</span></p>
<p><span class="font1">%N </span><span class="font15">hash for naming parsers, 416-23, 467 nasty regex, 287</span></p>
<p><span class="font15">nasty surprises, 142, 229, 335, 427</span></p>
<p><span class="font15">national security, 185</span></p>
<p><span class="font15">network server, 68, 94-95, 108, 148, 189 newline character, 261, 363, 441 newsgroups, 16, 272</span></p>
<p><span class="font15">Newton, Isaac, 301</span></p>
<p><span class="font15">Newton-Raphson method, 300-13 </span><span class="font1">nextval </span><span class="font15">method, 176</span></p>
<p><span class="font1">NEXTVAL </span><span class="font15">operation, 115-16, 120-21, 171-73</span></p>
<p><span class="font15">90-10 rule, 110</span></p>
<p><span class="font15">nodes, 212-13, 215-17, 225-28</span></p>
<p><span class="font15">in AST, 393, 400</span></p>
<p><span class="font15">in </span><span class="font1">HTML::TreeBuilder </span><span class="font15">object, 27-29</span></p>
<p><span class="font15">of linked list, 256-63</span></p>
<p><span class="font15">in local propagation network, 472-74 of notional tree of sentential forms, 377, 380, 382, 403</span></p>
<p><span class="font15">in outline structure, 442-44 non-reentrant, 6</span></p>
<p><span class="font15">nonterminal symbols, 377 normalization of equations, 511</span></p>
<p><span class="font15">Norvig, Peter, xv, xvii</span></p>
<p><span class="font15">null function, 24, 60</span></p>
<p><span class="font15">null pointer, 166</span></p>
<p><span class="font1">NULL </span><span class="font15">value in SQL databases, 163, 165 numerals, canonical form for, 219</span></p>
<p><span class="font6" style="font-weight:bold;">O</span></p>
<p><span class="font14" style="font-style:italic;">O</span><span class="font15" style="font-style:italic;">(</span><span class="font15">) notation, 103</span></p>
<p><span class="font15">object constructor methods, 75, 81, 184, 187, 501-2, 516, 518, 527 object identity, testing with ==, 477 object methods, caching in, 96-99 object-oriented (OO) programming, 25-26, 75, 96-98</span></p>
<p><span class="font15">octopuses, 81-82, 127-28, 161</span></p>
<p><span class="font15">oddity, 24, 264</span></p>
<p><span class="font15">odometer method, 132-34, 138</span></p>
<p><span class="font15">OO (object-oriented) programming, </span><span class="font14" style="font-style:italic;">see </span><span class="font15">object-oriented programming</span></p>
<p><span class="font1">open() </span><span class="font15">function, 116</span></p>
<p><span class="font1">opendir() </span><span class="font15">function, 13</span></p>
<p><span class="font15">operating system, 68, 82-83, 149-50 operator overloading, </span><span class="font14" style="font-style:italic;">see</span><span class="font15"> overloading operator precedence, 357, 372, 393-94, 414-15, 437, 465</span></p>
<p><span class="font15">optimization, 81, 110-11, 171, 204, 209-11, 230-31, 240-41, 253, 322, 332</span></p>
<p><span class="font15">option checking, 201</span></p>
<p><span class="font15">optional item, parser for, 541</span></p>
<p><span class="font15">orcish maneuver, 106</span></p>
<p><span class="font15">Orwant, Jon, 234</span></p>
<p><span class="font15">out of scope, 15, 71-75, 92, 264 outlines, 440-48</span></p>
<p><span class="font1">overload </span><span class="font15">module, 357, 467 overloading, 356, 416, 465-70 oxcart, 109</span></p>
<p><span class="font6" style="font-weight:bold;">P</span></p>
<p><span class="font15">pad, 73-77</span></p>
<p><span class="font1">Pair </span><span class="font15">objects, 468</span></p>
<p><span class="font15">palindromes, 214-15</span></p>
<p><span class="font15">parabola, 301-3</span></p>
<p><span class="font14" style="font-style:italic;">Paradigms of Artificial Intelligence</span></p>
<p><span class="font14" style="font-style:italic;">Programming</span><span class="font15">, xv, xvii</span></p>
<p><span class="font1">param </span><span class="font15">declaration in Linogram, 560-62 parameter specifications in Linogram, 545-49, 552, 559-60</span></p>
<p><span class="font15">parameters, 560-61</span></p>
<p><span class="font15">parentheses,</span></p>
<p><span class="font15">balanced, 287-88</span></p>
<p><span class="font15">disambiguating expressions, 54, 58, 437</span></p>
<p><span class="font15">in output of parser, 393-94, 398</span></p>
<p><span class="font15">in regex, 364</span></p>
<p><span class="font1">parse </span><span class="font15">method in </span><span class="font1">HTML::LinkExtor</span><span class="font15">, 190</span></p>
<p><span class="font15">parser function, 551</span></p>
<p><span class="font15">parser operator, 390</span></p>
<p><span class="font15">parser, Perl’s, 159, 360</span></p>
<p><span class="font1">Parser </span><span class="font15">module, 384</span></p>
<p><span class="font15">parsing, 43, 117-18, 198, 199, 351, 359-470</span></p>
<p><span class="font15">overview, 359</span></p>
<p><span class="font15">arithmetic expressions, 390^35 backtracking parsers, 456-65 database-query parsing, 448-56 HTML, 27, 188-90</span></p>
<p><span class="font15">in general, 376-84</span></p>
<p><span class="font15">lexers, 359-75</span></p>
<p><span class="font15">Linogram specifications, 539-57 overloaded operators for, 465-70 recursive-descent parsers, 384-90 regexes, 435-40</span></p>
<p><span class="font15">partial sums, 316</span></p>
<p><span class="font15">partition problem, 35-39, 93-94, 204-12</span></p>
<p><span class="font15">partitioning, 35-39, 93-94</span></p>
<p><span class="font15">partitions of an integer, 217-25, 225-26 comparing, 224</span></p>
<p><span class="font1">pathfinder.com</span><span class="font15">, 198</span></p>
<p><span class="font15">patterns, 131, 135, </span><span class="font14" style="font-style:italic;">see also</span><span class="font15"> regexes</span></p>
<p><span class="font15">Paulson, Lawrence, xvii</span></p>
<p><span class="font15">penurious college student, 206 performance, 63-64, 80, 93, 106, 110, 266-68, 332, 453</span></p>
<p><span class="font15">period of random-number generator, 154</span></p>
<p><span class="font15">Perl 6, 176</span></p>
<p><span class="font15">Perl interactive debugger, 415</span></p>
<p><span class="font1">perldoc </span><span class="font15">program, 112</span></p>
<p><span class="font15">permutations, 3-4, 128-35 persistent caches, 100-1</span></p>
<p><span class="font15">pi </span><span class="font15" style="font-style:italic;">(</span><span class="font2" style="font-style:italic;">n</span><span class="font15">),317-19, 426</span></p>
<p><span class="font1">pic </span><span class="font15">program, 563</span></p>
<p><span class="font15">pipe, 117</span></p>
<p><span class="font15">plain text, 26</span></p>
<p><span class="font15">plumber, 206-7</span></p>
<p><span class="font15">plutonium, 94-95, 116</span></p>
<p><span class="font1">point</span><span class="font15">, definition in Linogram, 494</span></p>
<p><span class="font15">polymorphism, 331</span></p>
<p><span class="font15">pop, 126, 223</span></p>
<p><span class="font1">POPDIR </span><span class="font15">directive in configuration file, 46-47</span></p>
<p><span class="font1">pos() </span><span class="font15">function, 366-67</span></p>
<p><span class="font15">postfix form, 54</span></p>
<p><span class="font15">postprocessing function, 544</span></p>
<p><span class="font15">PostScript, 494, 496</span></p>
<p><span class="font15">power series, 313-24 overview, 313-19</span></p>
<p><span class="font15">derivatives, 319</span></p>
<p><span class="font15">symbolic computation, 320-24</span></p>
<p><span class="font15">power series expansion, 313-24 power set, 234</span></p>
<p><span class="font15">powers of 2, 265-69</span></p>
<p><span class="font15">Prague, Defenestration of, 204 precedence, 357, 437, 465</span></p>
<p><span class="font15">in arithmetic expressions, 393, 415 predicate function, 107, 160-62, 194, 263, 333, 537</span></p>
<p><span class="font15">pre-emption, 223</span></p>
<p><span class="font15">preprocessor, 139</span></p>
<p><span class="font15">primitive features in Linogram, 491,</span></p>
<p><span class="font15">531-32</span></p>
<p><span class="font1">print()</span><span class="font15">, as expression, 424</span></p>
<p><span class="font1">print </span><span class="font15">statement, 9, 416</span></p>
<p><span class="font15">printer, 63</span></p>
<p><span class="font1">printf() </span><span class="font15">function, 19</span></p>
<p><span class="font15">priority queue, 225, 228</span></p>
<p><span class="font15">private variables, </span><span class="font14" style="font-style:italic;">see</span><span class="font15"> lexical variables</span></p>
<p><span class="font15">probability, 65</span></p>
<p><span class="font15">productions in grammars, 376</span></p>
<p><span class="font15">profiler, 110-11</span></p>
<p><span class="font15">profiling, 110-12</span></p>
<p><span class="font15">Prolog programming language, 471 promise, 257-58</span></p>
<p><span class="font15">forcing, 258, 269</span></p>
<p><span class="font15">propagation network, 485-86 prototypes, 123, 159, 178, 179, 236, 293, 304, 334, 337-43, 346</span></p>
<p><span class="font15">proxy server, 108</span></p>
<p><span class="font15">pruning, 213, 380, 382, 403</span></p>
<p><span class="font15">pseudo-random, 153</span></p>
<p><span class="font15">pun, 122, 374</span></p>
<p><span class="font15">punctuation, excessive, 144</span></p>
<p><span class="font15">pure functions, 82</span></p>
<p><span class="font15">pure virtual methods, 25</span></p>
<p><span class="font1">push() </span><span class="font15">function, 126</span></p>
<p><span class="font1">PUSHDIR </span><span class="font15">directive in configuration file, 46</span></p>
<p><span class="font6" style="font-weight:bold;">Q</span></p>
<p><span class="font1">q{...} </span><span class="font15">syntax, 87</span></p>
<p><span class="font1">qmail </span><span class="font15">mail system, 293-94, 299</span></p>
<p><span class="font15">quantification of regexes, 437</span></p>
<p><span class="font15">queue, 124-26, 127, 188, 192-93, 201 queue members, 193</span></p>
<p><span class="font1">qw(...) </span><span class="font15">syntax, 150</span></p>
<p><span class="font6" style="font-weight:bold;">R</span></p>
<p><span class="font15">rabbits, 33-34</span></p>
<p><span class="font1">rand() </span><span class="font15">function, 153</span></p>
<p><span class="font1">random() </span><span class="font15">function, 153</span></p>
<p><span class="font15">random number generation, 153-57</span></p>
<p><span class="font15">Raphson, Joseph, 301</span></p>
<p><span class="font1">readdir() </span><span class="font15">function, 118</span></p>
<p><span class="font1">READLINE </span><span class="font15">method, 187</span></p>
<p><span class="font15">reciprocal, 516-17</span></p>
<p><span class="font15">of power series, 323-24</span></p>
<p><span class="font15">recursion, 1</span></p>
<p><span class="font15">and caching, 65-66</span></p>
<p><span class="font15">as DFS, 215-17</span></p>
<p><span class="font15">elimination of, 229-53, 348</span></p>
<p><span class="font15">recursive-descent parsers, 384-90</span></p>
<p><span class="font15">overview, 384</span></p>
<p><span class="font15">compound operators, 388-90</span></p>
<p><span class="font15">parser operators, 386-88</span></p>
<p><span class="font15">very simple parsers, 384-86</span></p>
<p><span class="font15">recursive streams, 263-69, 280, 323</span></p>
<p><span class="font1">redo</span><span class="font15">, 243</span></p>
<p><span class="font15">re-entrancy, 6, 48-49</span></p>
<p><span class="font15">reentrant function, 49</span></p>
<p><span class="font1">ref() </span><span class="font15">function, 88, 501-2</span></p>
<p><span class="font1">ref($base) || $base </span><span class="font15">technique,</span></p>
<p><span class="font15">501-2</span></p>
<p><span class="font15">refactoring, 222-23, 234-39, 241, 249-53, 328</span></p>
<p><span class="font15">reference arguments, functions with, 93</span></p>
<p><span class="font15">references, 9-10, 19, 41, 61, 71, 73-76,</span></p>
<p><span class="font15">88, 164-65, 467, 502, 554</span></p>
<p><span class="font15">comparing with ==, 168-69, 178</span></p>
<p><span class="font15">from pad, 75, 76</span></p>
<p><span class="font15">functions returning, 81-82</span></p>
<p><span class="font15">functions accepting, 93</span></p>
<p><span class="font15">stringification of, 88, 93, 169, 415-16, 467</span></p>
<p><span class="font15">referrer, fake, 193</span></p>
<p><span class="font15">referring URL, 192</span></p>
<p><span class="font15">regex engine, 119, 471</span></p>
<p><span class="font15">regex string generation, 272-300</span></p>
<p><span class="font15">regexes, 119, 143, 272, 286, 361, 365-66, 368-69, 435-40, 471</span></p>
<p><span class="font15">as examples of declarative programming, 471</span></p>
<p><span class="font15">as lexers, 365</span></p>
<p><span class="font15">syntax of, 437</span></p>
<p><span class="font15">relaxation, 488</span></p>
<p><span class="font15">repetition of parser operation, 389-90</span></p>
<p><span class="font15">return-value parameter, 240</span></p>
<p><span class="font1">reverse^) </span><span class="font15">function, 135</span></p>
<p><span class="font15">RGB, 63-64</span></p>
<p><span class="font15">robot policy, 197</span></p>
<p><span class="font1">robots.txt </span><span class="font15">file, 197-98</span></p>
<p><span class="font15">Roode, Eric, xviii, 178, 178-79</span></p>
<p><span class="font15">root feature in linogram, 490</span></p>
<p><span class="font15">root of equation, 301</span></p>
<p><span class="font1">ROOT </span><span class="font15">type in Linogram, 542</span></p>
<p><span class="font15">round-off error, 305-6, 307-8, 322</span></p>
<p><span class="font15">RPN (reverse Polish notation), 54-55</span></p>
<p><span class="font6" style="font-weight:bold;">S</span></p>
<p><span class="font1">-s </span><span class="font15">operator, 12, 15</span></p>
<p><span class="font1">/s </span><span class="font15">regex modifier flag, 450 </span><span class="font1">s/// </span><span class="font15">operator, 87 scalar, 9, 183—84, 366</span></p>
<p><span class="font15">tied, 184-85</span></p>
<p><span class="font15">scalarcontext, 118-19, 159, 183, 192</span></p>
<p><span class="font1">Scalar::Util </span><span class="font15">module, 340 scaling operation, 271-72, 320-23, 329-30, 338-39, 503-5, 508, 511, 519-20, 523-24, 528-29 scanning, </span><span class="font14" style="font-style:italic;">see</span><span class="font15"> lexers schema, 140, 142, 150</span></p>
<p><span class="font15">Schonfinkel, Moses, 327</span></p>
<p><span class="font15">Schwartz, Randal, xv, xviii</span></p>
<p><span class="font15">Schwern, Michael, 145 scope, 20, 67-68, 71-76, 92, 98, 264, 454</span></p>
<p><span class="font15">vs. duration, 72-89</span></p>
<p><span class="font15">searching databases backwards, 148-53 secret weapon, 185</span></p>
<p><span class="font15">seed (of pseudo-random number generator), 153</span></p>
<p><span class="font1">seek() </span><span class="font15">function, 142, 148 self-referent stream definition, 263-69, 280, 323</span></p>
<p><span class="font15">semipredicate function, 107 semipredicate problem, 107, 124, 163, 170</span></p>
<p><span class="font15">sentences (in grammars), 377 sentential form, 377</span></p>
<p><span class="font15">serialization, 69</span></p>
<p><span class="font15">set difference, 354-56 </span><span class="font1">set_prototype() </span><span class="font15">function, 340 </span><span class="font1">shiftO </span><span class="font15">function, 126, 223</span></p>
<p><span class="font15">silly examples, 184-85, 346, 456-57 </span><span class="font1">sin() </span><span class="font15">function, 313-14, 319</span></p>
<p><span class="font1">sinh() </span><span class="font15">function, 320</span></p>
<p><span class="font15">Sitaker, Kragen, xviii, 453</span></p>
<p><span class="font15">Slashdot, 334 slope, 302, 302, 331 </span><span class="font1">sort() </span><span class="font15">function, 101, 299, 345 sorting, 82, 101-6</span></p>
<p><span class="font15">partitions, 224</span></p>
<p><span class="font15">comparator functions, 101-4, 291-92, 350, 353</span></p>
<p><span class="font15">tiebreakers in, 103</span></p>
<p><span class="font15">to obtain canonical form, 219 soup, fish-dog-and-carrot, 162, 275 spam, 363</span></p>
<p><span class="font15">special cases, 32, 110, 211, 236, 284, 345, 409, 455, 478, 505, 536, 556</span></p>
<p><span class="font15">splines, 562</span></p>
<p><span class="font1">split() </span><span class="font15">function, 137, 364-65 </span><span class="font1">sprintfQ </span><span class="font15">function, 1, 105-6 SQL, 163, 168, 471</span></p>
<p><span class="font1">sqrt() </span><span class="font15">function, 300, 307</span></p>
<p><span class="font1">square</span><span class="font15">, definition in Linogram, 498</span></p>
<p><span class="font1">square() </span><span class="font15">function, 83</span></p>
<p><span class="font1">srand() </span><span class="font15">function, 155</span></p>
<p><span class="font1">srand48() </span><span class="font15">function, 155</span></p>
<p><span class="font1">srandom() </span><span class="font15">function, 155 stack, 50, 55-56, 446-47</span></p>
<p><span class="font15">call stack, 125-26, 229-31</span></p>
<p><span class="font15">explicit simulation of, 38, 242-53 start symbol, 376-77 start tag in HTML, 26</span></p>
<p><span class="font1">stat() </span><span class="font15">function, 294</span></p>
<p><span class="font15">statements as expressions, 424-25 static variables, 67-68, 124</span></p>
<p><span class="font15">Stein, Lincoln, 135</span></p>
<p><span class="font1">Storable </span><span class="font15">module, 85, 89</span></p>
<p><span class="font1">STORE </span><span class="font15">method, 184-85</span></p>
<p><span class="font15">streams, 259, 261-62, 333, 375</span></p>
<p><span class="font15">merging, 270-71, 274-75 </span><span class="font1">strftime() </span><span class="font15">function, 297 </span><span class="font1">strict 'vars'</span><span class="font15">, 345</span></p>
<p><span class="font15">string, 96</span></p>
<p><span class="font15">string generator, 440</span></p>
<p><span class="font15">string literals, lexing, 449-50 stringification, 416, 467</span></p>
<p><span class="font14" style="font-style:italic;">Structure and Interpretation of Computer</span></p>
<p><span class="font14" style="font-style:italic;">Programs</span><span class="font15" style="font-style:italic;">,</span><span class="font15"> xvii</span></p>
<p><span class="font1">StrVal() </span><span class="font15">function in </span><span class="font1">overload </span><span class="font15">module, 467</span></p>
<p><span class="font15">stub functions, 71-72, 75-76, 99, 112 subclass, 25</span></p>
<p><span class="font15">subdirectories, 12</span></p>
<p><span class="font15">sub-parser, 374</span></p>
<p><span class="font1">substr()</span><span class="font15">, 34142</span></p>
<p><span class="font15">subtraction as inverse of addition, 482-83 subtype definitions, 543</span></p>
<p><span class="font1">sum() </span><span class="font15">function, 344-46</span></p>
<p><span class="font15">Sussman, Gerald Jay, xvii</span></p>
<p><span class="font15">Sybase, 145</span></p>
<p><span class="font15">symbolic links, 15, 19, 23-24, 183 dangling, 19, 23-24, 183,325</span></p>
<p><span class="font15">symbolic references, 51, 550</span></p>
<p><span class="font15">symbol table, xv, 70-71, 99, 112</span></p>
<p><span class="font15">symbols in grammars, 376-77</span></p>
<p><span class="font15">symbols, terminal vs. nonterminal, 377 syntactic equivalence of tokens, 436 syntactic sugar, 122, 123, 172, 259,374 syntax, 176, 397</span></p>
<p><span class="font15">bizarre, 180</span></p>
<p><span class="font15">irregularity of Perl’s, 453</span></p>
<p><span class="font15">obsession with, 176</span></p>
<p><span class="font15">synthetic constraints, 520-21, 522-27</span></p>
<p><span class="font1">Synthetic_Constraint_Set </span><span class="font15">class,</span></p>
<ul style="list-style:none;"><li>
<p><span class="font15">522-25</span></p></li></ul>
<p><span class="font15">system administrators, 149</span></p>
<p><span class="font15">systems programming, 152</span></p>
<p><span class="font6" style="font-weight:bold;">T</span></p>
<p><span class="font1">$~T </span><span class="font15">special variable, 82-83</span></p>
<p><span class="font2">\</span><span class="font1">t </span><span class="font15">(tab) character, 450</span></p>
<p><span class="font15">tab character, 450</span></p>
<p><span class="font1">tac </span><span class="font15">command in Unix, 152</span></p>
<p><span class="font1">_tag </span><span class="font15">key in </span><span class="font1">HTML::TreeBuilder</span><span class="font15">, 27</span></p>
<p><span class="font15">tags, 26,30-31, 44, 190</span></p>
<p><span class="font15">tai64n, 293, 295</span></p>
<p><span class="font15">tail of linked list, 256</span></p>
<p><span class="font15">tail-call elimination, 229</span></p>
<p><span class="font15">tangent function, 320</span></p>
<p><span class="font15">tangent line, 302</span></p>
<p><span class="font15">tautology, 508</span></p>
<p><span class="font1">tell() </span><span class="font15">function, 148</span></p>
<p><span class="font15">Tels, 307, 324, 435</span></p>
<p><span class="font15">temperature conversion, 472-75, 483, 485-87</span></p>
<p><span class="font15">terminals, 377</span></p>
<p><span class="font15">terminal symbol, 377</span></p>
<p><span class="font15">terminator pattern, 362-65</span></p>
<p><span class="font15">term of arithmetic expression, 394 terms, 394</span></p>
<p><span class="font1">$textfunc </span><span class="font15">argument, 29, 59-61</span></p>
<p><span class="font15">text object in Linogram, 561</span></p>
<p><span class="font15">thrashing, 129</span></p>
<p><span class="font15">three blind mice, 308</span></p>
<p><span class="font15">three-dimensional diagrams in Linogram, 518, 556</span></p>
<p><span class="font1">tie() </span><span class="font15">operator, 100, 173, 184-87</span></p>
<p><span class="font15">tied hashes, 100, 416</span></p>
<p><span class="font1">TIEHANDLE </span><span class="font15">method, 187</span></p>
<p><span class="font1">TIESCALAR </span><span class="font15">method, 184</span></p>
<p><span class="font1">timeO </span><span class="font15">function, 82-83, 112, 113</span></p>
<p><span class="font1">Time::HiRes </span><span class="font15">module, 112</span></p>
<p><span class="font1">times() </span><span class="font15">function, 113</span></p>
<p><span class="font15">to-do list, </span><span class="font14" style="font-style:italic;">see</span><span class="font15"> agenda</span></p>
<p><span class="font15">tokens, 55-57, 137, 359-60</span></p>
<p><span class="font15">syntactic equivalence of, 436 tokenization, </span><span class="font14" style="font-style:italic;">see</span><span class="font15"> lexers token-manufacturing function, 371-72,</span></p>
<p><span class="font15">451</span></p>
<p><span class="font15">Torkington, Nat, xviii, 129</span></p>
<p><span class="font15">tortoise and hare algorithm, 309</span></p>
<p><span class="font15">tourists, 76</span></p>
<p><span class="font15">Tower of Hanoi, 6—11 transcendental functions, 313, 409 transforms, </span><span class="font14" style="font-style:italic;">see</span><span class="font15"> filters and transforms treasure, 35—39, 206—11 trees, 12-14, 26-27, 58, 212, 217, 377-80, 402-3,440, 535 iterator for searching, 225-29 printing, 233-34, 242-43 recursion as search of, 215-17 traversal in various orders, 126 tricks, 86, 90, 107-8, 120, 137, 160, 179, 211, 312, 372, 416 trigonometry, 322, 489-90, 496 trivial equation (0=0), 502 trivial stream, 259 Tuma, Jan J., 324 tuples in Linogram, 491, 518-20, 525-30, 555-56, 558</span></p>
<p><span class="font1">Type </span><span class="font15">class, 530-39</span></p>
<p><span class="font1">Type::Scalar </span><span class="font15">class, 531-32 </span><span class="font1">%TYPES </span><span class="font15">hash in Linogram, 542-43 typesetting, 204 type specimen catalog, 204-5</span></p>
<p><span class="font6" style="font-weight:bold;">U</span></p>
<p><span class="font15">ugly code, 373 unary minus, 555 </span><span class="font1">undef</span><span class="font15">, 94, 160, 163-64, 167 undefined variables in calculator program, 426</span></p>
<p><span class="font15">union scale, 207</span></p>
<p><span class="font1">UNIVERSAL::isa() </span><span class="font15">function, 88, 181, 258</span></p>
<p><span class="font15">Unix, 15, 117, 150, 294 epoch time format, 295 untagged text, 27</span></p>
<p><span class="font1">until </span><span class="font15">loop, 233</span></p>
<p><span class="font1">upto()</span><span class="font15">, 121-23, 259-60</span></p>
<p><span class="font1">URI::URL </span><span class="font15">module, 199</span></p>
<p><span class="font15">URL, 188-93</span></p>
<p><span class="font15">bad, 191</span></p>
<p><span class="font15">fragment part, 199</span></p>
<p><span class="font1">mailto</span><span class="font15">, 200</span></p>
<p><span class="font15">referring, 149, 192-93</span></p>
<p><span class="font15">user-agent, 198</span></p>
<p><span class="font15">user parameter to callback function, 49, 51, 60-61, 371, 386, 454</span></p>
<p><span class="font15">user interfaces, 16</span></p>
<p><span class="font15">user-supplied key generators, applications of, 89-90</span></p>
<p><span class="font6" style="font-weight:bold;">V</span></p>
<p><span class="font1">Value </span><span class="font15">class, 515-16</span></p>
<p><span class="font1">Value::Constant </span><span class="font15">class, 516-18, 558</span></p>
<p><span class="font1">Value::Feature </span><span class="font15">class, 527-30, 535, 558-59</span></p>
<p><span class="font1">Value::Tuple </span><span class="font15">class, 518-20 value of parsed input, 376, 384-85 </span><span class="font1">values() </span><span class="font15">function, 119 variables, static, 67-68</span></p>
<p><span class="font1">VERBOSITY </span><span class="font15">directive, 42 virtual methods, 25 </span><span class="font1">vline</span><span class="font15">, definition in Linogram, 497</span></p>
<p><span class="font6" style="font-weight:bold;">W</span></p>
<p><span class="font15">Wadler, Philip, xvii</span></p>
<p><span class="font15">Wall, Larry, xv, xviii, 145, 176 waste of time, 64, 104, 110, 129-30, 190, 197, 230, 265-68, 304, 307, 461 web browsers, 68, 108</span></p>
<p><span class="font15">INDEX </span><span class="font20">573</span></p>
<p><span class="font15">web robots, </span><span class="font14" style="font-style:italic;">see</span><span class="font15"> web spiders</span></p>
<p><span class="font15">web server log, 148-50</span></p>
<p><span class="font15">web spiders, 187-201</span></p>
<p><span class="font15">overview, 187-90</span></p>
<p><span class="font15">DFS unsuitable for, 214</span></p>
<p><span class="font15">pursuing only interesting links, 190-92</span></p>
<p><span class="font15">referring URLs, 192-97</span></p>
<p><span class="font1">robots.txt</span><span class="font15">, 197-200</span></p>
<p><span class="font1">$whence </span><span class="font15">argument to </span><span class="font1">seek()</span><span class="font15">, 142</span></p>
<p><span class="font1">while (caller()) </span><span class="font15">loop, 420</span></p>
<p><span class="font1">while </span><span class="font15">loop, 13, 187, 209</span></p>
<p><span class="font15">reading filehandle in, 187</span></p>
<p><span class="font15">that executes only once, 222</span></p>
<p><span class="font15">whitespace, 27, 441</span></p>
<p><span class="font15">wildcard, 136-37, 136-38</span></p>
<p><span class="font15">Windows, 117</span></p>
<p><span class="font15">WIRED magazine, 228</span></p>
<p><span class="font15">“without” operator, 354-56</span></p>
<p><span class="font15">wizard, 206-7</span></p>
<p><span class="font15">Wolf Book, 234, 293</span></p>
<p><span class="font15">Wong, Meng, xviii</span></p>
<p><span class="font15">word boundary, 272, 439</span></p>
<p><span class="font15">Wrigley, Ave, 187</span></p>
<p><span class="font1">WWW::RobotRules </span><span class="font15">module, 198-99</span></p>
<p><span class="font1">WWW::SimpleRobot </span><span class="font15">module, 187-88, 200-1</span></p>
<p><span class="font15">WYSIWYG drawing system, 489</span></p>
<p><span class="font6" style="font-weight:bold;">Y</span></p>
<p><span class="font1">yes </span><span class="font15">command in Unix, 117</span></p>
<p><span class="font15">Yukon Territory, 179</span></p>
<p><span class="font6" style="font-weight:bold;">Z</span></p>
<p><span class="font1">0e0 </span><span class="font15">trick, 107-8</span></p>
<p><span class="font1">&quot;0 but true&quot;</span><span class="font15">, 108</span></p>
<p><sup><a href="#footnote1">1</a></sup><a name="bookmark215"></a></p>
<p class="font15"> This notation was introduced in Perl 5.004; users of 5.003 or earlier will have to use a much uglier notation instead: <span class="font1">&amp;{Scode_reference}(arguments...);</span><span class="font15">. When the </span><span class="font1">Scode_reference </span><span class="font15">expression is a simple variable, as in the example, the curly braces may be omitted.</span></p>
<p><sup><a href="#footnote2">2</a></sup><a name="bookmark217"></a></p>
<p class="font15"> This feature was introduced in Perl 5.6.0. Users of earlier Perl versions will have to use the <span class="font1">IO::Handle </span><span class="font15">module to explicitly manufacture a dirhandle: </span><span class="font1">my Sdir = IO::Handle-&gt;new; opendir Sdir, Stop;.</span></p>
<p><sup><a href="#footnote3">3</a></sup><a name="bookmark219"></a></p>
<p class="font15"> Some people find this unpersuasive, so perhaps I should point out that if we make ourselves useful to other people, they will love and admire us, and they might even pay us more.</p>
<p><sup><a href="#footnote4">4</a></sup><a name="bookmark223"></a></p>
<p><span class="font15"> &nbsp;One of the technical reviewers objected that this was an exaggeration, and it is. But I estimate that calculating </span><span class="font2">fib(100) </span><span class="font15">by this method would take about 2,241,937 billion billion years, which is close enough.</span></p>
<p><sup><a href="#footnote5">5</a></sup><a name="bookmark224"></a></p>
<p><span class="font15"> &nbsp;In fact, each increase of 2 in the argument increases the running time by a factor of about 2.62.</span></p>
<p><sup><a href="#footnote6">6</a></sup><a name="bookmark229"></a></p>
<p><span class="font15"> &nbsp;&nbsp;“K” is for “black”; the printers don’t use “B” because “B” is for “blue.”</span></p>
<p><sup><a href="#footnote7">7</a></sup><a name="bookmark231"></a></p>
<p><span class="font15"> &nbsp;Data marshalling is so named because it was first studied in 1962 by Edward Waite Marshall, then with the General Electric corporation.</span></p>
<p><sup><a href="#footnote8">8</a></sup><a name="bookmark232"></a></p>
<p><span class="font15"> &nbsp;The term </span><span class="font15" style="font-style:italic;">memoization</span><span class="font15"> was coined in 1968 by Donald Michie.</span></p>
<p><sup><a href="#footnote9">9</a></sup><a name="bookmark233"></a></p>
<p class="font15"> This is not precisely accurate. In imperative languages like Perl, a variable is an association between a name and the part of the computer’s memory <span class="font15" style="font-style:italic;">in which the value will be stored.</span><span class="font15"> For purposes of our discussion, this distinction is unimportant.</span></p>
<p><sup><a href="#footnote10">10</a></sup><a name="bookmark238"></a></p>
<p><span class="font15"> I sometimes enjoy the mind-bending exercise of imagining the result of memoizing the Unix </span><span class="font1">fork() </span><span class="font15">function.</span></p>
<p><sup><a href="#footnote11">11</a></sup><a name="bookmark239"></a></p>
<p><span class="font15"> To see this, just realize that there must be some difference in the way the two structures are represented in memory, and that the computer’s memory is itself nothing more than a very long string.</span></p>
<p><sup><a href="#footnote12">12</a></sup><a name="bookmark240"></a></p>
<p><span class="font15"> Most plutonium is ordered late at night in spite of the extra costs.</span></p>
<p><sup><a href="#footnote13">13</a></sup><a name="bookmark242"></a></p>
<p><span class="font15">Subtraction would work equally well here; </span><span class="font1">&lt;=&gt; </span><span class="font15">is used in comparators instead of plain subtraction because of its documentative value.</span></p>
<p><sup><a href="#footnote14">14</a></sup><a name="bookmark246"></a></p>
<p class="font15"> This comes as a surprise to many people, especially C programmers who expect <span class="font1">sprintf </span><span class="font15">to be slow. While </span><span class="font1">sprintf </span><span class="font15">is slow, so is Perl, so that dispatching a bunch of extra </span><span class="font1">&lt;=&gt; </span><span class="font15">and </span><span class="font2">|| </span><span class="font15">operations</span></p>
<p><sup><a href="#footnote15">15</a></sup><a name="bookmark247"></a></p>
<p><span class="font15"> &nbsp;&nbsp;</span><span class="font1">&quot;0e0&quot; </span><span class="font15">is hardly unique; </span><span class="font1">&quot;00&quot; </span><span class="font15">will also work, as will any string that begins with a 0 followed</span></p>
<p><span class="font15">by a non-numeral character, such as </span><span class="font1">&quot;0!!!!&quot;</span><span class="font15">. Strings like </span><span class="font1">&quot;0!!!!&quot;</span><span class="font15">, however, will generate an “Argument isn’t numeric” warning if warnings are enabled. One string commonly used when a zero-but-true value is desired is </span><span class="font1">&quot;0 but true&quot;</span><span class="font15">. Perl’s warning system has a special case in it that suppresses the usual “isn’t numeric” warning for this string.</span></p>
<p><sup><a href="#footnote16">16</a></sup><a name="bookmark253"></a></p>
<p><span class="font15"> The Perl Journal, Vol 1, #2 (Summer 1996) pp. 5-9.</span></p>
<p><sup><a href="#footnote17">17</a></sup><a name="bookmark259"></a></p>
<p><span class="font15"> The Art of Computer Programming, Volume II: Seminumerical Algorithms, Donald E. Knuth, Addison-Wesley.</span></p>
<p><sup><a href="#footnote18">18</a></sup><a name="bookmark274"></a></p>
<p><span class="font15"> There are, unfortunately, very few good robots.</span></p>
<p><sup><a href="#footnote19">19</a></sup><a name="bookmark275"></a></p>
<p><span class="font15"> Stay away from the windows if you’re ever in Prague; the city is famous for its defenestrations. Probably the most important was on 23 March, 1618, when Bohemian nobles flung two imperial governors out the window into a ditch, touching off the Thirty Years’ War. Other notable defenestrations have occurred in 1419 and 1948.</span></p>
<p><sup><a href="#footnote20">20</a></sup><a name="bookmark277"></a></p>
<p><span class="font15"> </span><span class="font15" style="font-style:italic;">Agenda</span><span class="font15"> is the Latin word for “to-do list.</span></p>
<p><sup><a href="#footnote21">21</a></sup><a name="bookmark278"></a></p>
<p><span class="font15"> If anyone complains about this abuse of terminology, I will just point out that Edsger Dijkstra, a computer scientist famous for precision, did the same thing. See page 3 of </span><span class="font15" style="font-style:italic;">An Introductory Example, </span><a href="http://www.cs.utexas.edu/users/EWD/ewd10xx/EWD1063.PDF"><span class="font15">http://www.cs.utexas.edu/users/EWD/ewd10xx/EWD1063.PDF</span></a><span class="font15">.</span></p>
<p><sup><a href="#footnote22">22</a></sup><a name="bookmark309"></a></p>
<p><span class="font15"> &nbsp;Named for Richard W. Hamming, who also invented Hamming codes.</span></p>
<p><sup><a href="#footnote23">23</a></sup><a name="bookmark320"></a></p>
<p><span class="font15"> The </span><span class="font1">* </span><span class="font15">operator is officially called the </span><span class="font15" style="font-style:italic;">closure operator,</span><span class="font15"> and the set of strings that match </span><span class="font1">/A*/ </span><span class="font15">is the </span><span class="font15" style="font-style:italic;">closure</span><span class="font15"> of the set of those that match </span><span class="font1">/A/</span><span class="font15">. This has nothing to do with anonymous function closures.</span></p>
<p><sup><a href="#footnote24">24</a></sup><a name="bookmark330"></a></p>
<p><span class="font15"> Perhaps I should have included a longer explanation of this point, since I seem to be the only person in the world who is bothered by the phrase “Your call will be answered in the order it was received.” It always seems to me that my call could not have an order.</span></p>
<p><sup><a href="#footnote25">25</a></sup><a name="bookmark333"></a></p>
<p><span class="font15"> &nbsp;</span><span class="font1">/-(?{local$d=0})(?:\((?{$d++})|\)(?{$d--})(?(?{$d&lt;0})(?!))|(?&gt;[-()]*))*(?(?{$d!=0})(?!))$/</span><span class="font15">.</span></p>
<p><sup><a href="#footnote26">26</a></sup><a name="bookmark339"></a></p>
<p><span class="font15"> Isaac Newton discovered and wrote about the method first, but his write-up wasn’t published until 1736. Joseph Raphson discovered the technique independently and published it in 1671.</span></p>
<p><sup><a href="#footnote27">27</a></sup><a name="bookmark340"></a></p>
<p class="font15"> It may not be obvious that the hare will necessarily catch the tortoise, but it is true. For details, see Donald Knuth, <span class="font15" style="font-style:italic;">The Art of Computer Programming: Volume 2, Seminumerical Algorithms, </span><span class="font15">exercise 3.1.6.</span></p>
<p><sup><a href="#footnote28">28</a></sup><a name="bookmark341"></a></p>
<p><span class="font15"> &nbsp;It also requires a bit of a trick. Say </span><span class="font15" style="font-style:italic;">S</span><span class="font18"> = </span><span class="font15">1 </span><span class="font18">+ </span><span class="font15" style="font-style:italic;">k</span><span class="font18"> + </span><span class="font15" style="font-style:italic;">k<sup>2</sup></span><span class="font18"> + ••• + </span><span class="font15" style="font-style:italic;">k<sup>n—</sup></span><span class="font15"><sup> 1</sup>. Multiplying both sides by </span><span class="font15" style="font-style:italic;">k</span><span class="font15"> gives </span><span class="font15" style="font-style:italic;">Sk = k</span><span class="font18"> + </span><span class="font15" style="font-style:italic;">k</span><span class="font15"><sup>2</sup> </span><span class="font18">+ • • • + </span><span class="font15" style="font-style:italic;">k<sup>n—</sup></span><span class="font15"><sup>1</sup> </span><span class="font18">+ </span><span class="font15" style="font-style:italic;">k<sup>n</sup></span><span class="font15"> . These two equations are almost the same, and if we subtract one from the other almost everything cancels out, leaving only </span><span class="font15" style="font-style:italic;">Sk — S = k<sup>n</sup> —</span><span class="font15"> 1 and so </span><span class="font15" style="font-style:italic;">S</span><span class="font18"> = </span><span class="font15" style="font-style:italic;">(k<sup>n</sup> — 1)/{k —</span><span class="font15"> 1).</span></p>
<p><sup><a href="#footnote29">29</a></sup><a name="bookmark342"></a></p>
<p><span class="font15"> &nbsp;&nbsp;I’m afraid I am out of tricks.</span></p>
<p><sup><a href="#footnote30">30</a></sup><a name="bookmark343"></a></p>
<p class="font15"> These series are often called <span class="font15" style="font-style:italic;">Taylor series</span><span class="font15"> or </span><span class="font15" style="font-style:italic;">Maclaurin series</span><span class="font15"> after English mathematicians Brook Taylor and Colin Maclaurin who popularized them. The general technique for constructing these series was discovered much earlier by several people, including James Gregory and Johann Bernoulli.</span></p>
<p><sup><a href="#footnote31">31</a></sup><a name="bookmark344"></a></p>
<p class="font15"> This shouldn’t be obvious, since there are an infinite number of terms in the rest of the stream, and in general the infinite tail of a stream may make a significant contribution to the total. However, in a power series, the additional terms <span class="font15" style="font-style:italic;">do</span><span class="font15"> get small so quickly that they can be disregarded, at least for sufficiently small values of </span><span class="font15" style="font-style:italic;">x</span><span class="font15">. For details, consult a textbook on numerical analysis or basic calculus.</span></p>
<p><sup><a href="#footnote32">32</a></sup><a name="bookmark350"></a></p>
<p><span class="font15"> Currying is so-named because it was popularized by Haskell B. Curry in 1930, although it had been discovered by Gottlob Frege in 1893 and rediscovered by Moses Schonfinkel in 1924.</span></p>
<p><sup><a href="#footnote33">33</a></sup><a name="bookmark395"></a></p>
<p><span class="font15">Someone looking for a fun project to garner fame and renown in the Perl world would do well to consider replacing the debugger.</span></p>
<p><sup><a href="#footnote34">34</a></sup><a name="bookmark412"></a></p>
<p><span class="font15"> In most modern languages, including Perl and C, statements may have a simpler structure, typically not much different than an expression. For example, in Perl, </span><span class="font1">print $x </span><span class="font15">and </span><span class="font1">$x = $y </span><span class="font15">are both</span></p>
<p><sup><a href="#footnote35">35</a></sup><a name="bookmark417"></a></p>
<p><span class="font2"> Parsing</span></p>
<ul style="list-style:none;"><li>
<p><span class="font2">* Lexers</span></p></li>
<li>
<p><span class="font2">* Emulating the </span><span class="font2" style="font-style:italic;">&lt;&gt;</span><span class="font2">&nbsp;operator</span></p></li>
<li>
<p><span class="font2">* Lexers more generally</span></p></li>
<li>
<p><span class="font2">* Chained Lexers</span></p></li>
<li>
<p><span class="font2">* Peeking</span></p></li>
<li>
<p><span class="font2">* Parsing in General</span></p></li>
<li>
<p><span class="font2">* Grammars</span></p></li>
<li>
<p><span class="font2">* Parsing Grammars</span></p></li>
<li>
<p><span class="font2">* Recursive-Descent Parsers</span></p></li>
<li>
<p><span class="font2">* Very Simple Parsers</span></p></li>
<li>
<p><span class="font2">* Parser Operators</span></p></li>
<li>
<p><span class="font2">* Compound Operators</span></p></li></ul>
<p><sup><a href="#footnote36">36</a></sup><a name="bookmark429"></a></p>
<p><span class="font15"> One of the technical reviewers ridiculed me extensively for this decision, since the performance difference is negligible. But it wasn’t for performance reasons that I disliked the idea of manufacturing six times as many functions as I needed. It was because I’m compulsive.</span></p>
<p><sup><a href="#footnote37">37</a></sup><a name="bookmark444"></a></p>
<p><span class="font15"> &nbsp;It would be nice to get rid of the parentheses as well, but we can’t, because </span><span class="font1">_ Sx - Sy </span><span class="font15">means </span><span class="font1">_(Sx -</span></p>
<p><span class="font1">Sy)</span><span class="font15">, rather than </span><span class="font1">_(Sx) - Sy </span><span class="font15">as we’d like.</span></p>
<p><sup><a href="#footnote38">38</a></sup><a name="bookmark471"></a></p>
<p><span class="font15"> &nbsp;&nbsp;In an earlier version of this program, the environment parameter was more interesting. Features</span></p>
<p><span class="font15">could contain local variables that didn’t participate in the constraint solving (and which therefore didn’t have to be linear) and parameters passed in from the containing feature. In the interests of clear exposition, I trimmed these features out.</span></p>
</body>
</html>